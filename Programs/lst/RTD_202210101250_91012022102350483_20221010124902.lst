GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


      *=====================================================================================
      Name:                 vSPDsolve.gms
      Function:             Establish base case and override data, prepare data, and
                            solve the model
      Developed by:         Electricity Authority, New Zealand
      Source:               https://github.com/ElectricityAuthority/vSPD
                            http://www.emi.ea.govt.nz/Tools/vSPD
      Contact:              Forum: http://www.emi.ea.govt.nz/forum/
                            Email: emi@ea.govt.nz
      Created on:           1st November 2022 for Real Time Pricing
       
      *=====================================================================================
       
      Directory of code sections in vSPDsolve.gms:
      1. Declare symbols and initialise some of them
      2. Load data from GDX file f
      3. Manage model and data compatability
      4. Input data overrides - declare and apply (include vSPDoverrides.gms)
      5. Initialise constraint violation penalties (CVPs)
      6. The vSPD solve loop
         a) Reset all sets, parameters and variables before proceeding with the next study trade period
         b) Initialise current trade period and model data for the current trade period
         c) Additional pre-processing on parameters and variables before model solve
         d) Solve the model
         e) Check if the LP results are valid
         f) Resolve the model if required
         g) Check for disconnected nodes and adjust prices accordingly
         h) Collect and store results from the current model solve in the output (o_xxx) parameters
         i) End of the solve vSPD loop
      7. vSPD scarcity pricing post-processing
      8. Write results to CSV report files and GDX files
2101   
2102  *=====================================================================================
2103  * 0. Initial setup
2104  *=====================================================================================
2105   
2106  * Include paths, settings and case name files
INCLUDE    C:\vSPD\ElectricityAuthority\Programs\vSPDsettings.inc
2108  *+++ vSPD settings +++
2111   
2112  *+++ Paths +++
2114   
2119   
2121   
2122   
2123  *+++ Model +++
2124  Scalar sequentialSolve                   / 1 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2125  Scalar disconnectedNodePriceCorrection   / 1 / ;
2126  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2127   
2128   
2129  *+++ Network +++
2130  Scalar useACLossModel                    / 1 / ;
2131  Scalar useHVDCLossModel                  / 1 / ;
2132  Scalar useACBranchLimits                 / 1 / ;
2133  Scalar useHVDCBranchLimits               / 1 / ;
2134  Scalar resolveCircularBranchFlows        / 1 / ;
2135  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2136  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2137  Scalar circularBranchFlowTolerance       / 0.0001 / ;
2138  Scalar nonPhysicalLossTolerance          / 1e-6 / ;
2139  Scalar useBranchFlowMIPTolerance         / 1e-6 / ;
2140   
2141   
2142  *+++ Constraints +++
2143  Scalar useReserveModel                   / 1 / ;
2144  Scalar suppressMixedConstraint           / 0 / ;   !  No longer used since Mixed MIP Constraints no longer exists
2145  Scalar mixedMIPtolerance                 / 1e-6 / ;
2146   
2147   
2148  *+++ Solver +++
2149  Scalar LPtimeLimit                       / 3600 / ;
2150  Scalar LPiterationLimit                  / 2000000000 / ;
2151  Scalar MIPtimeLimit                      / 3600 / ;
2152  Scalar MIPiterationLimit                 / 2000000000 / ;
2153  Scalar MIPoptimality                     / 0 / ;
2156   
2157   
2158  *+++ Various switches +++
INCLUDE    C:\vSPD\ElectricityAuthority\Programs\vSPDcase.inc
2162   
2163  * Update the ProgressReport.txt file
2164  File rep "Write to a report" /"ProgressReport.txt"/;  rep.lw = 0;  rep.ap = 1;
2165  putclose rep / 'Case "RTD_202210101250_91012022102350483_20221010124902" started at: ' system.date " " system.time /;
2166   
2167  if(sequentialSolve,
2168    putclose rep 'Vectorisation is switched OFF' /;
2169  else
2170    putclose rep 'Vectorisation is switched ON' /;
2171  ) ;
2172   
2173  * Set the solver for the LP and MIP
2174  option lp = Cplex ;
2175  option mip = Cplex ;
2176   
2177  * Set profile status
2178  option profile = 0 ;
2179   
2180  * Set the solution print status in the lst file
2181  option solprint = off;
2182   
2183  * Set the column (variable) and row (equation) listing in the lst file
2184  option limcol = 0 ;
2185  option limrow = 0 ;
2186   
2187  * Declare a temporary file
2188  File temp ;
2189   
2190  * Allow empty data set declaration
2192   
2193  *=====================================================================================
2194  * 1. Declare symbols and initialise some of them
2195  *=====================================================================================
2196   
2197  Sets
2198    unsolvedDT(dt)                                  'Set of datetime that are not solved yet'
2199    SOS1_solve(dt)                                  'Flag period that is resolved using SOS1'
2200   
2201  * Unmmaped bus defificit temporary sets
2202    unmappedDeficitBus(dt,b)                        'List of buses that have deficit generation (price) and are not mapped to any pnode - revisit'
2203    changedDeficitBus(dt,b)                         'List of buses that have deficit generation added from unmapped deficit bus - revisit'
2204    ;
2205   
2206  Parameters
2207  * Flag to apply corresponding vSPD model
2208    VSPDModel(dt)                                       '0=VSPD, 1=vSPD_BranchFlowMIP, 2=VSPD (last solve)'
2209   
2210  * MIP logic
2211    circularBranchFlowExist(dt,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2212    poleCircularBranchFlowExist(dt,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2213   
2214  * Calculated parameter used to check if non-physical loss occurs on HVDC
2215    northHVDC(dt)                                       'HVDC MW sent from from SI to NI'
2216    southHVDC(dt)                                       'HVDC MW sent from from NI to SI'
2217    nonPhysicalLossExist(dt,br)                         'Flag to indicate if non-physical losses exist on branch (applied to HVDC only): 1 = Yes'
2218    manualBranchSegmentMWFlow(dt,br,los,fd)             'Manual calculation of the branch loss segment MW flow --> used to manually calculate hvdc branch losses'
2219    manualLossCalculation(dt,br)                        'MW losses calculated manually from the solution for each loss branch'
2220   
2221  * Calculated parameter used to check if circular branch flow exists on each HVDC pole
2222    TotalHVDCpoleFlow(dt,pole)                          'Total flow on an HVDC pole'
2223    MaxHVDCpoleFlow(dt,pole)                            'Maximum flow on an HVDC pole'
2224   
2225  * Disconnected bus post-processing
2226    busGeneration(dt,b)                                 'MW generation at each bus for the study trade periods'
2227    busLoad(dt,b)                                       'MW load at each bus for the study trade periods'
2228    busPrice(dt,b)                                      '$/MW price at each bus for the study trade periods'
2229    busDisconnected(dt,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2230  * Unmmaped bus defificit temporary parameters
2231    temp_busDeficit_TP(dt,b)                             'Bus deficit violation for each trade period'
2232  * TN - Replacing invalid prices after SOS1
2233    busSOSinvalid(dt,b)                                 'Buses with invalid bus prices after SOS1 solve'
2234    numberofbusSOSinvalid(dt)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration)'
2235  * System loss calculated by SPD for RTD run
2236    SPDLoadCalcLosses(dt,isl)                           'Island losses calculated by SPD in the first solve to adjust demand'
2237   ;
2238   
2239  Parameters
2240  * Dispatch results for reporting - Trade period level - Island output
2241    o_islandGen_TP(dt,isl)                              'Island MW generation for the different time periods'
2242    o_islandLoad_TP(dt,isl)                             'Island MW fixed load for the different time periods'
2243    o_islandClrBid_TP(dt,isl)                           'Island cleared MW bid for the different time periods'
2244    o_islandBranchLoss_TP(dt,isl)                       'Intra-island branch losses for the different time periods (MW)'
2245    o_islandRefPrice_TP(dt,isl)                         'Reference prices in each island ($/MWh)'
2246   
2247    o_HVDCflow_TP(dt,isl)                               'HVDC flow from each island (MW)'
2248    o_HVDCloss_TP(dt,isl)                               'HVDC losses (MW)'
2249    o_HVDCpoleFixedLoss_TP(dt,isl)                      'Fixed loss on inter-island HVDC (MW)'
2250    o_HVDCreceived(dt,isl)                              'Energy Recevied from HVDC into an island'
2251    o_HVDCRiskSubtractor(dt,isl,resC,riskC)             'OutPut HVDC risk subtractor'
2252   
2253    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
2254    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
2255    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
2256    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
2257    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
2258   
2259    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
2260    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
2261    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
2262    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
2263    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
2264    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
2265    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
2266    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
2267    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
2268   
2269    o_ACbranchTotalRentals(dt)                          'FTR rental - Total AC rental by trading period'
2270    o_ACbranchLossMW(dt,br,los)                         'FTR rental - MW element of the loss segment curve in MW'
2271    o_ACbranchLossFactor(dt,br,los)                     'FTR rental Loss factor element of the loss segment curve applied to'
2272   
2273    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
2274    o_offerRes_TP(dt,o,resC)                            'Output MW cleared for each reserve offer for each trade period'
2275    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
2276    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
2277   
2278    o_groupEnergy_TP(dt,rg,riskC)                       'Output MW cleared for risk group for each trade period'
2279    o_groupFKband_TP(dt,rg,riskC)                       'Output FK band MW applied for risk group for each trade period'
2280    o_groupRes_TP(dt,rg,resC,riskC)                     'Output reserve MW cleared for risk group for each trade period'
2281   
2282    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
2283    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
2284   
2285    o_ReserveReqd_TP(dt,isl,resC)                       'Output MW required for each reserve class in each trade period'
2286    o_FIRreqd_TP(dt,isl)                                'Output MW required FIR for each trade period'
2287    o_SIRreqd_TP(dt,isl)                                'Output MW required SIR for each trade period'
2288    o_ResCleared_TP(dt,isl,resC)                        'Reserve cleared from an island for each trade period'
2289    o_FIRcleared_TP(dt,isl)                             'Output - total FIR cleared by island'
2290    o_SIRcleared_TP(dt,isl)                             'Output - total SIR cleared by island'
2291    o_ResPrice_TP(dt,isl,resC)                          'Output $/MW price for each reserve classes for each trade period'
2292    o_FIRprice_TP(dt,isl)                               'Output $/MW price for FIR reserve classes for each trade period'
2293    o_SIRprice_TP(dt,isl)                               'Output $/MW price for SIR reserve classes for each trade period'
2294   
2295    o_GenRiskPrice_TP(dt,isl,o,resC,riskC)              'Output Gen risk marginal prices'
2296    o_HVDCSecRiskPrice_TP(dt,isl,o,resC,riskC)          'Output HVDC risk marginal prices'
2297    o_GenRiskGroupPrice_TP(dt,isl,rg,resC,riskC)        'Output risk group marginal prices'
2298    o_HVDCRiskPrice_TP(dt,isl,resC,riskC)               'Output HVDC risk marginal prices'
2299    o_ManualRiskPrice_TP(dt,isl,resC,riskC)             'Output Manual risk marginal prices'
2300    o_HVDCSecManualRiskPrice_TP(dt,isl,resC,riskC)      'Output HVDC risk marginal prices'
2301   
2302    o_GenRiskShortfall_TP(dt,isl,o,resC,riskC)          'Output Gen risk shortfall'
2303    o_HVDCSecRiskShortfall_TP(dt,isl,o,resC,riskC)      'Output HVDC risk shortfall'
2304    o_GenRiskGroupShortfall_TP(dt,isl,rg,resC,riskC)    'Output risk group shortfall'
2305    o_HVDCRiskShortfall_TP(dt,isl,resC,riskC)           'Output HVDC risk shortfall'
2306    o_ManualRiskShortfall_TP(dt,isl,resC,riskC)         'Output Manual risk shortfall'
2307    o_HVDCSecManualRiskShortfall_TP(dt,isl,resC,riskC)  'Output HVDC risk shortfall'
2308   
2309    o_ResViolation_TP(dt,isl,resC)                      'Violation MW for each reserve classes for each trade period'
2310    o_FIRviolation_TP(dt,isl)                           'Violation MW for FIR reserve classes for each trade period'
2311    o_SIRviolation_TP(dt,isl)                           'Violation MW for SIR reserve classes for each trade period'
2312   
2313    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
2314    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
2315    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
2316    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
2317    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
2318    o_nodeDead_TP(dt,n)                                 'Define if a Node  (Pnode) is dead'
2319    o_nodeDeadPrice_TP(dt,n)                            'Flag to check if a dead Node has valid price'
2320    o_nodeDeadPriceFrom_TP(dt,n,n1)                     'Flag to show which price node the price of the dead node come from'
2321  * Security constraint data
2322    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
2323    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
2324    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
2325    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
2326  * Mnode constraint data
2327    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
2328    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
2329    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
2330    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
2331  * TradePeriod summary report
2332    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
2333    o_systemCost_TP(dt)                                 'System cost for summary report'
2334    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
2335    o_ofv_TP(dt)                                        'Objective function value for summary report'
2336    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
2337    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
2338    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
2339    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
2340    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
2341    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
2342    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
2343    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
2344    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
2345    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
2346    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
2347   
2348  * Factor to prorate the deficit and surplus at the nodal level
2349    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
2350    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
2351   
2352  * Audit - extra output declaration
2353    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
2354    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
2355    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
2356    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
2357   
2358    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
2359    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
2360    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
2361    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
2362    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
2363    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
2364    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
2365    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
2366   
2367    o_generationRiskLevel(dt,isl,o,resC,riskC)                    'Audit - generation risk'
2368   
2369    o_HVDCriskLevel(dt,isl,resC,riskC)                            'Audit - DCCE and DCECE risk'
2370   
2371    o_manuRiskLevel(dt,isl,resC,riskC)                            'Audit - manual risk'
2372   
2373    o_genHVDCriskLevel(dt,isl,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
2374   
2375    o_manuHVDCriskLevel(dt,isl,resC,riskC)                        'Audit - manual + HVDC secondary'
2376   
2377    o_generationRiskGroupLevel(dt,isl,rg,resC,riskC)              'Audit - generation group risk'
2378   
2379   
2380  * TN - output parameters added for NMIR project --------------------------------
2381    o_FirSent_TP(dt,isl)                        'FIR export from an island for each trade period'
2382    o_SirSent_TP(dt,isl)                        'SIR export from an island for each trade period'
2383    o_FirReceived_TP(dt,isl)                    'FIR received at an island for each trade period'
2384    o_SirReceived_TP(dt,isl)                    'SIR received at an island for each trade period'
2385    o_FirEffReport_TP(dt,isl)                   'Effective FIR share for reporting to an island for each trade period'
2386    o_SirEffReport_TP(dt,isl)                   'Effective FIR share for reporting to an island for each trade period'
2387    o_EffectiveRes_TP(dt,isl,resC,riskC)        'Effective reserve share to an island for each trade period'
2388    o_FirEffectiveCE_TP(dt,isl)                 'Effective FIR share to an island for each trade period'
2389    o_SirEffectiveCE_TP(dt,isl)                 'Effective FIR share to an island for each trade period'
2390    o_FirEffectiveECE_TP(dt,isl)                'Effective FIR share to an island for each trade period'
2391    o_SirEffectiveECE_TP(dt,isl)                'Effective FIR share to an island for each trade period'
2392   
2393    o_TotalIslandReserve(dt,isl,resC,riskC)     'Total Reserve cleared in a island including shared Reserve'
2394  * TN - output parameters added for NMIR project end ----------------------------
2395    ;
2396   
2397  Scalars
2398    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
2399    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
2400    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
2401    ;
2402   
2403   
2404   
2405  *=====================================================================================
2406  * 2. Load data from GDX file
2407  *=====================================================================================
2408   
2409  * If input file does not exist then go to the next input file
2411   
2412  * Load trading period to be solved
GDXIN   C:\vSPD\ElectricityAuthority\Programs\vSPDPeriod.gdx
--- LOAD  tp = 1:i_TradePeriod
--- LOAD  dt = 2:i_DateTime
--- LOAD  dt2tp = 3:i_DateTimeTradePeriod
2417   
2418  * Call the GDX routine and load the input data:
GDXIN   C:\vSPD\ElectricityAuthority\Input\RTD_202210101250_91012022102350483_20221010124902.gdx
2420  * Sets
--- LOAD  caseName = 1:caseName
--- LOAD  rundt = 3:i_runDateTime
--- LOAD  b = 10:i_bus
--- LOAD  n = 9:i_node
--- LOAD  o = 36:i_Offer
--- LOAD  bd = 48:i_bid
--- LOAD  trdr = 35:i_Trader
--- LOAD  br = 19:i_branch
--- LOAD  brCstr = 26:i_branchConstraint
--- LOAD  MnodeCstr = 29:i_MnodeConstraint
--- LOAD  node = 11:i_dateTimeNode
--- LOAD  bus = 12:i_dateTimeBus
--- LOAD  node2node = 18:i_dateTimeNodeToNode
--- LOAD  offerTrader = 37:i_dateTimeOfferTrader
--- LOAD  offerNode = 38:i_dateTimeOfferNode
--- LOAD  bidTrader = 49:i_dateTimeBidTrader
--- LOAD  bidNode = 50:i_dateTimeBidNode
--- LOAD  nodeBus = 14:i_dateTimeNodeBus
--- LOAD  busIsland = 16:i_dateTimeBusIsland
--- LOAD  branchDefn = 20:i_dateTimeBranchDefn
--- LOAD  riskGenerator = 54:i_dateTimeRiskGenerator
--- LOAD  primarySecondaryOffer = 47:i_dateTimePrimarySecondaryOffer
--- LOAD  dispatchableBid = 52:i_dateTimeDispatchableBid
--- LOAD  rg = 73:i_riskGroup
--- LOAD  riskGroupOffer = 74:i_dateTimeRiskGroup
2438   
2439  * Parameters
--- LOAD  gdxDate = 2:gdxDate
--- MERGE intervalDuration = 7:i_intervalLength
--- LOAD  offerParameter = 39:i_dateTimeOfferParameter
--- LOAD  energyOffer = 40:i_dateTimeEnergyOffer
--- LOAD  fastPLSRoffer = 42:i_dateTimeFastPLSRoffer
--- LOAD  sustainedPLSRoffer = 41:i_dateTimeSustainedPLSRoffer
--- LOAD  fastTWDRoffer = 44:i_dateTimeFastTWDRoffer
--- LOAD  sustainedTWDRoffer = 43:i_dateTimeSustainedTWDRoffer
--- LOAD  fastILRoffer = 46:i_dateTimeFastILRoffer
--- LOAD  sustainedILRoffer = 45:i_dateTimeSustainedILRoffer
2449   
--- LOAD  energyBid = 51:i_dateTimeEnergyBid
--- LOAD  nodeDemand = 53:i_dateTimeNodeDemand
2452   
--- LOAD  refNode = 13:i_dateTimeReferenceNode
--- LOAD  HVDCBranch = 21:i_dateTimeHVDCBranch
--- LOAD  branchParameter = 22:i_dateTimeBranchParameter
--- LOAD  branchCapacity = 23:i_dateTimeBranchCapacity
--- LOAD  branchOpenStatus = 24:i_dateTimeBranchOpenStatus
--- LOAD  nodeBusAllocationFactor = 15:i_dateTimeNodeBusAllocationFactor
--- LOAD  busElectricalIsland = 17:i_dateTimeBusElectricalIsland
2460   
--- LOAD  riskParameter = 55:i_dateTimeRiskParameter
--- LOAD  islandMinimumRisk = 56:i_dateTimeManualRisk
--- LOAD  HVDCSecRiskEnabled = 57:i_dateTimeHVDCSecRiskEnabled
--- LOAD  HVDCSecRiskSubtractor = 58:i_dateTimeHVDCSecRiskSubtractor
--- LOAD  reserveMaximumFactor = 59:i_dateTimeReserveMaximumFactor
2466   
--- LOAD  branchCstrFactors = 27:i_dateTimeBranchConstraintFactors
--- LOAD  branchCstrRHS = 28:i_dateTimeBranchConstraintRHS
--- LOAD  mnCstrEnrgFactors = 30:i_dateTimeMNCnstrEnrgFactors
--- LOAD  mnCnstrResrvFactors = 31:i_dateTimeMNCnstrResrvFactors
--- LOAD  mnCnstrEnrgBidFactors = 32:i_dateTimeMNCnstrEnrgBidFactors
--- LOAD  mnCnstrResrvBidFactors = 33:i_dateTimeMNCnstrResrvBidFactors
--- LOAD  mnCnstrRHS = 34:i_dateTimeMNCnstrRHS
2474   
2475  * National market for IR effective date 20 Oct 2016
--- LOAD  reserveRoundPower = 60:i_dateTimeReserveRoundPower
--- LOAD  reserveShareEnabled = 61:i_dateTimeReserveSharing
--- LOAD  modulationRiskClass = 62:i_dateTimeModulationRisk
--- LOAD  roundPower2MonoLevel = 63:i_dateTimeRoundPower2Mono
--- LOAD  bipole2MonoLevel = 64:i_dateTimeBipole2Mono
--- LOAD  MonopoleMinimum = 65:i_dateTimeReserveSharingPoleMin
--- LOAD  HVDCControlBand = 66:i_dateTimeHVDCcontrolBand
--- LOAD  HVDClossScalingFactor = 67:i_dateTimeHVDClossScalingFactor
--- LOAD  sharedNFRFactor = 68:i_dateTimeSharedNFRfactor
--- LOAD  sharedNFRLoadOffset = 70:i_dateTimeSharedNFRLoadOffset
--- LOAD  effectiveFactor = 69:i_dateTimeReserveEffectiveFactor
--- LOAD  RMTReserveLimitTo = 71:i_dateTimeRMTreserveLimit
--- LOAD  rampingConstraint = 72:i_dateTimeRampingConstraint
2489   
2490  *Real Time Pricing Project
--- MERGE studyMode = 75:i_studyMode
--- LOAD  useGenInitialMW = 76:i_dateTimeUseGenInitialMW
--- LOAD  runEnrgShortfallTransfer = 77:i_dateTimeRunEnrgShortfallTransfer
--- LOAD  runPriceTransfer = 78:i_dateTimeRunPriceTransfer
--- LOAD  replaceSurplusPrice = 79:i_dateTimeReplaceSurplusPrice
--- LOAD  rtdIgIncreaseLimit = 80:i_dateTimeRtdIgIncreaseLimit
--- LOAD  useActualLoad = 81:i_dateTimeUseActualLoad
--- LOAD  dontScaleNegativeLoad = 82:i_dateTimeDontScaleNegativeLoad
--- LOAD  inputInitialLoad = 83:i_dateTimeInputInitialLoad
--- LOAD  conformingFactor = 84:i_dateTimeConformingFactor
--- LOAD  nonConformingLoad = 85:i_dateTimeNonConformingLoad
--- LOAD  loadIsOverride = 86:i_dateTimeLoadIsOverride
--- LOAD  loadIsBad = 87:i_dateTimeLoadIsBad
--- LOAD  loadIsNCL = 88:i_dateTimeLoadIsNCL
--- LOAD  maxLoad = 89:i_dateTimeMaxLoad
--- LOAD  instructedloadshed = 90:i_dateTimeInstructedLoadShed
--- LOAD  instructedshedactive = 91:i_dateTimeInstructedShedActive
--- LOAD  islandMWIPS = 92:i_dateTimeIslandMWIPS
--- LOAD  islandPDS = 93:i_dateTimeIslandPDS
--- LOAD  islandLosses = 94:i_dateTimeIslandLosses
2511   
--- LOAD  energyScarcityEnabled = 96:i_dateTimeEnergyScarcityEnabled
--- LOAD  reserveScarcityEnabled = 97:i_dateTimeReserveScarcityEnabled
--- LOAD  scarcityEnrgNationalFactor = 98:i_dateTimeScarcityEnrgNationalFactor
--- LOAD  scarcityEnrgNationalPrice = 99:i_dateTimeScarcityEnrgNationalPrice
--- LOAD  scarcityEnrgNodeFactor = 100:i_dateTimeScarcityEnrgNodeFactor
--- LOAD  scarcityEnrgNodeFactorPrice = 101:i_dateTimeScarcityEnrgNodeFactorPrice
--- LOAD  scarcityEnrgNodeLimit = 102:i_dateTimeScarcityEnrgNodeLimit
--- LOAD  scarcityEnrgNodeLimitPrice = 103:i_dateTimeScarcityEnrgNodeLimitPrice
--- LOAD  scarcityResrvIslandLimit = 104:i_dateTimeScarcityResrvIslandLimit
--- LOAD  scarcityResrvIslandPrice = 105:i_dateTimeScarcityResrvIslandPrice
2523   
2524  *===============================================================================
2525  * 3. Manage model and data compatability
2526  *===============================================================================
2527  * This section manages the changes to model flags to ensure backward
2528  * compatibility given changes in the SPD model formulation over time:
2529  * Ex: some data (sets) only starting to exist at certain time and we need to use
2530  * GDX time to check if we can load that data (set) from gdx.
2531   
2532  * Gregorian date of when symbols have been included into the GDX files
2533  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
2534  inputGDXGDate = jdate(gdxDate('year'),gdxDate('month'),gdxDate('day'));
2535   
2536  * The code below is for example and not currently used
      put_utility temp 'gdxin' / '%inputPath%\%GDXname%.gdx' ;
      if (inputGDXGDate >= jdate(2022,11,1) or sum[sameas(caseName,testCases),1] ,
          execute_load
          energyScarcityEnabled       = i_energyScarcityEnabled
          ;
      ) ;
      $oftext
       
       
      *=====================================================================================
      * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
      *=====================================================================================
       
      $ontext
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
2564   
2566   
2567   
2568  *===============================================================================
2569  * 5. Initialise model mapping and inputs
2570  *===============================================================================
2572   
2573  * Check if NMIR is enabled
2574  UseShareReserve = 1 $ sum[ (dt,resC), reserveShareEnabled(dt,resC)] ;
2575   
2576  * Pre-dispatch schedule is solved sequentially
2577  sequentialSolve $ { (studyMode >= 130) and (studyMode <= 133) } = 1 ;
2578  sequentialSolve $ sum[dt, useGenInitialMW(dt)] = 1;
2579  sequentialSolve $ UseShareReserve = 1;
2580   
2581   
2582   
2583  * Initialise genrating offer parameters ----------------------------------------
2584  GenerationStart(dt,o) = offerParameter(dt,o,'initialMW')
2585                        + sum[ o1 $ primarySecondaryOffer(dt,o,o1)
2586                                  , offerParameter(dt,o1,'initialMW') ] ;
2587  * if useGenIntitialMW = 1 --> sequential solve like PRSS, NRSS
2588  GenerationStart(dt,o) $ { (useGenInitialMW(dt) = 1) and (ord(dt) > 1) } = 0;
2589   
2590  RampRateUp(dt,o)               = offerParameter(dt,o,'rampUpRate')      ;
2591  RampRateDn(dt,o)               = offerParameter(dt,o,'rampDnRate')      ;
2592  ReserveGenerationMaximum(dt,o) = offerParameter(dt,o,'resrvGenMax')      ;
2593  WindOffer(dt,o)                = offerParameter(dt,o,'isIG')            ;
2594  FKband(dt,o)                   = offerParameter(dt,o,'FKbandMW')        ;
2595  PriceResponsive(dt,o)          = offerParameter(dt,o,'isPriceResponse') ;
2596  PotentialMW(dt,o)              = offerParameter(dt,o,'potentialMW')     ;
2597   
2598  * This is based on the 4.6.2.1 calculation
      For generators in the PRICERESPONSIVEIG subset, if the PotentialMWg value is
      less than ReserveGenerationMaximumg,c  then pre-processing sets the
      ReserveGenerationMaximumg,c parameter to the PotentialMWg value, otherwise if
      the PotentialMWg value is greater than or equal to the
      ReserveGenerationMaximumg,c  then the ReserveGenerationMaximumg,c
      value is unchanged
      Tuong note: this does not seems to make saense and be used.
2608  reserveMaximumFactor(dt,o,resC)
2609      $ { windOffer(dt,o) and priceResponsive(dt,o) and( potentialMW(dt,o) > 0)
2610      and (potentialMW(dt,o) < ReserveGenerationMaximum(dt,o)) }
2611      = ReserveGenerationMaximum(dt,o) / potentialMW(dt,o) ;
2612  *-------------------------------------------------------------------------------
2613   
2614   
2615  * Initialise offer limits and prices -------------------------------------------
2616   
2617  * Initialise energy offer data for the current trade period start
2618  EnrgOfrMW(dt,o,blk) = energyOffer(dt,o,blk,'limitMW') ;
2619  EnrgOfrPrice(dt,o,blk) = energyOffer(dt,o,blk,'price') ;
2620   
2621  * Initialise reserve offer data for the current trade period start
2622  PLRO(resT) $ (ord(resT) = 1) = yes ;
2623  TWRO(resT) $ (ord(resT) = 2) = yes ;
2624  ILRO(resT) $ (ord(resT) = 3) = yes ;
2625   
2626  ResOfrPct(dt,o,blk,resC)
2627      = (fastPLSRoffer(dt,o,blk,'plsrPct')      / 100) $ ( ord(resC) = 1 )
2628      + (sustainedPLSRoffer(dt,o,blk,'plsrPct') / 100) $ ( ord(resC) = 2 );
2629   
2630  ResOfrMW(dt,o,blk,resC,PLRO)
2631      = fastPLSRoffer(dt,o,blk,'limitMW')     $(ord(resC)=1)
2632      + sustainedPLSRoffer(dt,o,blk,'limitMW')$(ord(resC)=2) ;
2633   
2634  ResOfrMW(dt,o,blk,resC,TWRO)
2635      = fastTWDRoffer(dt,o,blk,'limitMW')     $(ord(resC)=1)
2636      + sustainedTWDRoffer(dt,o,blk,'limitMW')$(ord(resC)=2) ;
2637   
2638  ResOfrMW(dt,o,blk,resC,ILRO)
2639      = fastILRoffer(dt,o,blk,'limitMW')     $(ord(resC)=1)
2640      + sustainedILRoffer(dt,o,blk,'limitMW')$(ord(resC)=2) ;
2641   
2642  ResOfrPrice(dt,o,blk,resC,PLRO)
2643      = fastPLSRoffer(dt,o,blk,'price')     $(ord(resC)=1)
2644      + sustainedPLSRoffer(dt,o,blk,'price')$(ord(resC)=2) ;
2645   
2646  ResOfrPrice(dt,o,blk,resC,TWRO)
2647      = fastTWDRoffer(dt,o,blk,'price')     $(ord(resC)=1)
2648      + sustainedTWDRoffer(dt,o,blk,'price')$(ord(resC)=2) ;
2649   
2650  ResOfrPrice(dt,o,blk,resC,ILRO)
2651      = fastILRoffer(dt,o,blk,'price')     $(ord(resC)=1)
2652      + sustainedILRoffer(dt,o,blk,'price')$(ord(resC)=2)  ;
2653  *-------------------------------------------------------------------------------
2654   
2655   
2656  * Define valid offers and valid offer block ------------------------------------
2657   
2658  * Valid offer must be mapped to a bus with electrical island <> 0
2659  offer(dt,o) $ sum[ (n,b) $ { offerNode(dt,o,n) and nodeBus(dt,n,b)
2660                             }, busElectricalIsland(dt,b) ] = yes ;
2661   
2662  * IL offer with non zero total limit is always valid
2663  offer(dt,o) $ sum[ (blk,resC,ILRO), ResOfrMW(dt,o,blk,resC,ILRO)] = yes ;
2664   
2665  * Valid energy offer blocks are defined as those with a positive block limit
2666  genOfrBlk(dt,o,blk) $ ( EnrgOfrMW(dt,o,blk) > 0 ) = yes ;
2667   
2668  * Define set of positive (valid) energy offers
2669  posEnrgOfr(dt,o) $ sum[ blk $ genOfrBlk(dt,o,blk), 1 ] = yes ;
2670   
2671  * Only reserve offer block with a positive block limit is valid
2672  resOfrBlk(dt,o,blk,resC,resT) $ (ResOfrMW(dt,o,blk,resC,resT) > 0) = yes ;
2673  *-------------------------------------------------------------------------------
2674   
2675   
2676  * Initialise bid limits and prices ---------------------------------------------
2677   
2678  * Valid bid must be mapped to a bus with electrical island <> 0
2679  bid(dt,bd) $ sum[ (n,b) $ { bidNode(dt,bd,n) and nodeBus(dt,n,b)
2680                            }, busElectricalIsland(dt,b) ] = yes ;
2681  * Bid energy data
2682  DemBidMW(bid,blk)    $ dispatchableBid(bid) = energyBid(bid,blk,'limitMW') ;
2683  DemBidPrice(bid,blk) $ dispatchableBid(bid) = energyBid(bid,blk,'price')   ;
2684  * Valid Demand Bid Block
2685  DemBidBlk(bid,blk)   $ ( DemBidMW(bid,blk) <> 0 ) = yes ;
2686  *-------------------------------------------------------------------------------
2687   
2688   
2689  * Initialise mappings to use in later stage ------------------------------------
2690   
2691  nodeIsland(dt,n,isl) $ sum[ b $ { bus(dt,b) and node(dt,n)
2692                                and nodeBus(dt,n,b) and busIsland(dt,b,isl) }, 1
2693                            ] = yes ;
2694  offerIsland(offer(dt,o),isl)
2695      $ sum[ n $ { offerNode(dt,o,n) and nodeIsland(dt,n,isl) }, 1 ] = yes ;
2696   
2697  bidIsland(bid(dt,bd),isl)
2698      $ sum[ n $ { bidNode(dt,bd,n) and nodeIsland(dt,n,isl) }, 1 ] = yes ;
2699   
2700  islandRiskGenerator(dt,isl,o)
2701      $ { offerIsland(dt,o,isl) and riskGenerator(dt,o) } = yes ;
2702   
2703   
2704  * Identification of primary and secondary units
2705  PrimaryOffer(dt,o) = 1 ;
2706  SecondaryOffer(dt,o) = 1 $ sum[ o1 $ primarySecondaryOffer(dt,o1,o), 1 ] ;
2707  PrimaryOffer(dt,o) $ SecondaryOffer(dt,o) = 0 ;
2708  *-------------------------------------------------------------------------------
2709   
2710   
2711  * Initialise demand/bid data ---------------------------------------------------
2712  RequiredLoad(node) = nodeDemand(node) ;
2713   
2714  * 4.9.2 Dispatchable Pnodes
      If the Pnode associated with a Dispatchable Demand Bid is not a dead Pnode then
      PnodeRequiredLoadpn is set to zero. The Pnode load will be determined by
      clearing the Pnode's Dispatchable Demand Bid when the LP Model is solved.
2720  RequiredLoad(node(dt,n))
2721      $ { Sum[ (bd,blk) $ bidNode(dt,bd,n), DemBidMW(dt,bd,blk) ] > 0 } = 0;
2722   
2723   
2724   
2725  * 4.10 Real Time Pricing - First RTD load calculation
2726  if studyMode = 101 or studyMode = 201 then
2727   
2728  *   Calculate first target total load [4.10.6.5]
2729  *   Island-level MW load forecast. For the fist loop:
2730  *   replace LoadCalcLosses(dt,isl) = islandLosses(dt,isl);
2731      TargetTotalLoad(dt,isl) = islandMWIPS(dt,isl)
2732                              + islandPDS(dt,isl)
2733                              - islandLosses(dt,isl);
2734   
2735  *   Flag if estimate load is scalable [4.10.6.7]
2736  *   Binary value. If True then ConformingFactor load MW will be scaled in order
2737  *   to calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
2738  *   assigned directly to EstimatedInitialLoad
2739      EstLoadIsScalable(dt,n) =  1 $ { (LoadIsNCL(dt,n) = 0)
2740                                   and (ConformingFactor(dt,n) > 0) } ;
2741   
2742  *   Calculate estimate non-scalable load [4.10.6.8]
2743  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for
2744  *   a conforming Pnode this will be the ConformingFactor MW input if that value
2745  *   is negative, otherwise it will be zero
2746      EstNonScalableLoad(dt,n) $ ( LoadIsNCL(dt,n) = 1 ) = NonConformingLoad(dt,n);
2747      EstNonScalableLoad(dt,n) $ ( LoadIsNCL(dt,n) = 0 ) = ConformingFactor(dt,n);
2748      EstNonScalableLoad(dt,n) $ ( EstLoadIsScalable(dt,n) = 1 ) = 0;
2749   
2750  *   Calculate estimate scalable load [4.10.6.10]
2751  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
2752  *   this value will be the ConformingFactor if it is non-negative, otherwise
2753  *   this value will be zero'
2754      EstScalableLoad(dt,n) $ ( EstLoadIsScalable(dt,n) = 1 ) = ConformingFactor(dt,n);
2755   
2756   
2757  *   Calculate Scaling applied to ConformingFactor load MW [4.10.6.9]
2758  *   in order to calculate EstimatedInitialLoad
2759      EstScalingFactor(dt,isl)
2760          = (islandMWIPS(dt,isl) - islandLosses(dt,isl)
2761            - Sum[ n $ nodeIsland(dt,n,isl), EstNonScalableLoad(dt,n) ]
2762            ) / Sum[ n $ nodeIsland(dt,n,isl), EstScalableLoad(dt,n) ]
2763   
2764          ;
2765   
2766  *   Calculate estimate initial load [4.10.6.6]
2767  *   Calculated estimate of initial MW load, available to be used as an
2768  *   alternative to InputInitialLoad
2769      EstimatedInitialLoad(dt,n) $ ( EstLoadIsScalable(dt,n) = 1 )
2770          = ConformingFactor(dt,n) * Sum[ isl $ nodeisland(dt,n,isl)
2771                                        , EstScalingFactor(dt,isl)] ;
2772      EstimatedInitialLoad(dt,n) $ ( EstLoadIsScalable(dt,n) = 0 )
2773          = EstNonScalableLoad(dt,n);
2774   
2775  *   Calculate initial load [4.10.6.2]
2776  *   Value that represents the Pnode load MW at the start of the solution
2777  *   interval. Depending on the inputs this value will be either actual load,
2778  *   an operator applied override or an estimated initial load
2779      InitialLoad(dt,n) = InputInitialLoad(dt,n);
2780      InitialLoad(dt,n) $ { (LoadIsOverride(dt,n) = 0)
2781                        and ( (useActualLoad(dt) = 0) or (LoadIsBad(dt,n) = 1) )
2782                          } = EstimatedInitialLoad(dt,n) ;
2783      InitialLoad(dt,n) $ { (LoadIsOverride(dt,n) = 1)
2784                        and (useActualLoad(dt) = 1)
2785                        and (InitialLoad(dt,n) > MaxLoad(dt,n))
2786                          } = MaxLoad(dt,n) ;
2787   
2788  *   Flag if load is scalable [4.10.6.4]
2789  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
2790  *   calculate RequiredLoad, if False then Pnode InitialLoad will be directly
2791  *   assigned to RequiredLoad
2792      LoadIsScalable(dt,n) = 1 $ { (LoadIsNCL(dt,n) = 0)
2793                               and (LoadIsOverride(dt,n) = 0)
2794                               and (InitialLoad(dt,n) >= 0) } ;
2795   
2796  *   Calculate Island-level scaling factor [4.10.6.3]
2797  *   --> applied to InitialLoad in order to calculate RequiredLoad
2798      LoadScalingFactor(dt,isl)
2799          = ( TargetTotalLoad(dt,isl)
2800            - Sum[ n $ { nodeIsland(dt,n,isl)
2801                     and (LoadIsScalable(dt,n) = 0) }, InitialLoad(dt,n) ]
2802            ) / Sum[ n $ { nodeIsland(dt,n,isl)
2803                       and (LoadIsScalable(dt,n) = 1) }, InitialLoad(dt,n) ]
2804          ;
2805   
2806  *   Calculate RequiredLoad [4.10.6.1]
2807      RequiredLoad(dt,n) $ LoadIsScalable(dt,n)
2808          = InitialLoad(dt,n) * sum[ isl $ nodeisland(dt,n,isl)
2809                                   , LoadScalingFactor(dt,isl) ];
2810   
2811      RequiredLoad(dt,n) $ (LoadIsScalable(dt,n) = 0) = InitialLoad(dt,n);
2812   
2813      RequiredLoad(dt,n) = RequiredLoad(dt,n)
2814                         + [instructedloadshed(dt,n) $ instructedshedactive(dt,n)];
2815   
2816  Endif;
2817  *-------------------------------------------------------------------------------
2818   
2819   
2820  * Initialize energy scarcity limits and prices ---------------------------------
2821   
2822  ScarcityEnrgLimit(dt,n,blk)
2823      $ { energyScarcityEnabled(dt) and scarcityEnrgNodeLimit(dt,n,blk) }
2824      = scarcityEnrgNodeLimit(dt,n,blk);
2825  ScarcityEnrgPrice(dt,n,blk)
2826      $ { energyScarcityEnabled(dt) and scarcityEnrgNodeLimit(dt,n,blk) }
2827      = scarcityEnrgNodeLimitPrice(dt,n,blk) ;
2828   
2829   
2830  ScarcityEnrgLimit(dt,n,blk)
2831      $ { energyScarcityEnabled(dt)
2832      and (sum[blk1, ScarcityEnrgLimit(dt,n,blk1)] = 0 )
2833      and scarcityEnrgNodeFactor(dt,n,blk)
2834      and (RequiredLoad(dt,n) > 0)
2835        }
2836      = scarcityEnrgNodeFactor(dt,n,blk) * RequiredLoad(dt,n);
2837  ScarcityEnrgPrice(dt,n,blk)
2838      $ { energyScarcityEnabled(dt)
2839      and (sum[blk1, ScarcityEnrgLimit(dt,n,blk1)] > 0 )
2840      and scarcityEnrgNodeFactor(dt,n,blk)
2841        }
2842      = scarcityEnrgNodeFactorPrice(dt,n,blk) ;
2843   
2844   
2845  ScarcityEnrgLimit(dt,n,blk)
2846      $ { energyScarcityEnabled(dt)
2847      and (sum[blk1, ScarcityEnrgLimit(dt,n,blk1)] = 0 )
2848      and (RequiredLoad(dt,n) > 0)
2849        }
2850      = scarcityEnrgNationalFactor(dt,blk) * RequiredLoad(dt,n);
2851  ScarcityEnrgPrice(dt,n,blk)
2852      $ { energyScarcityEnabled(dt)
2853      and (sum[blk1, ScarcityEnrgLimit(dt,n,blk1)] > 0 )
2854        }
2855      = scarcityEnrgNationalPrice(dt,blk) ;
2856   
2857   
2858  *-------------------------------------------------------------------------------
2859   
2860   
2861  * Initialize AC and DC branches ------------------------------------------------
2862   
2863  * Branch is defined if there is a defined terminal bus, it has a non-zero
2864  * capacity and is closed for that trade period
2865  * Update the pre-processing code that removes branches which have a limit of zero
2866  * so that it removes a branch if either direction has a limit of zero.
2867  branch(dt,br) $ { (not branchOpenStatus(dt,br)) and
2868                    (not HVDCBranch(dt,br)) and
2869                    sum[ fd $ (ord(fd)=1), branchCapacity(dt,br,fd)] and
2870                    sum[ fd $ (ord(fd)=2), branchCapacity(dt,br,fd)] and
2871                    sum[ (b,b1) $ { bus(dt,b) and bus(dt,b1) and
2872                                    branchDefn(dt,br,b,b1) }, 1 ]
2873                  } = yes ;
2874   
2875  branch(dt,br) $ { (not branchOpenStatus(dt,br)) and
2876                    (HVDCBranch(dt,br)) and
2877                    sum[ fd, branchCapacity(dt,br,fd)] and
2878                    sum[ (b,b1) $ { bus(dt,b) and bus(dt,b1) and
2879                                    branchDefn(dt,br,b,b1) }, 1 ]
2880                  } = yes ;
2881   
2882   
2883  branchBusDefn(branch,b,b1) $ branchDefn(branch,b,b1)    = yes ;
2884  branchFrBus(branch,frB) $ sum[ toB $ branchBusDefn(branch,frB,toB), 1 ] = yes ;
2885  branchToBus(branch,toB) $ sum[ frB $ branchBusDefn(branch,frB,toB), 1 ] = yes ;
2886  branchBusConnect(branch,b) $ branchFrBus(branch,b) = yes ;
2887  branchBusConnect(branch,b) $ branchToBus(branch,b) = yes ;
2888   
2889   
2890  * HVDC link and AC branch definition
2891  HVDClink(branch) = yes $ HVDCBranch(branch) ;
2892  ACbranch(branch) = yes $ [not HVDCBranch(branch)];
2893   
2894   
2895  * Determine sending and receiving bus for each branch flow direction
2896  loop (frB,toB) do
2897      ACbranchSendingBus(ACbranch,frB,fd)
2898          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
2899   
2900      ACbranchReceivingBus(ACbranch,toB,fd)
2901          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
2902   
2903      ACbranchSendingBus(ACbranch,toB,fd)
2904          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
2905   
2906      ACbranchReceivingBus(ACbranch,frB,fd)
2907          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
2908  endloop;
2909   
2910  HVDClinkSendingBus(HVDClink,frB)
2911      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
2912   
2913  HVDClinkReceivingBus(HVDClink,toB)
2914      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
2915   
2916  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
2917  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
2918   
2919  * Determine the HVDC inter-island pole in the northward and southward direction
2920   
2921  HVDCpoleDirection(dt,br,fd) $ { (ord(fd) = 1) and HVDClink(dt,br) }
2922      = yes $ sum[ (isl,NodeBus(dt,n,b)) $ { (ord(isl) = 2)
2923                                         and nodeIsland(dt,n,isl)
2924                                         and HVDClinkSendingBus(dt,br,b) }, 1 ] ;
2925   
2926  HVDCpoleDirection(dt,br,fd) $ { (ord(fd) = 2) and HVDClink(dt,br) }
2927      = yes $ sum[ (isl,NodeBus(dt,n,b)) $ { (ord(isl) = 1)
2928                                         and nodeIsland(dt,n,isl)
2929                                         and HVDClinkSendingBus(dt,br,b) }, 1 ] ;
2930   
2931  * Mapping HVDC branch to pole to account for name changes to Pole 3
2932  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
2933  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
2934  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
2935  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
2936  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
2937  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
2938   
2939  * Initialise network data for the current trade period start
2940  branchResistance(branch)    = branchParameter(branch,'resistance') ;
2941  branchSusceptance(ACbranch) = -100 * branchParameter(ACbranch,'susceptance');
2942  branchLossBlocks(branch)    = branchParameter(branch,'numLossTranches') ;
2943   
2944  * Ensure fixed losses for no loss AC branches are not included
2945  branchFixedLoss(ACbranch) = branchParameter(ACbranch,'fixedLosses')
2946                            $ (branchLossBlocks(ACbranch) > 1) ;
2947   
2948  branchFixedLoss(HVDClink) = branchParameter(HVDClink,'fixedLosses') ;
2949   
2950  * Set resistance and fixed loss to zero if do not want to use the loss model
2951  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
2952  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
2953  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
2954  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
2955   
2956  * Initialise loss tranches data for the current trade period start
2957  * The loss factor coefficients assume that the branch capacity is in MW
2958  * and the resistance is in p.u.
2959   
2960  * Loss branches with 0 loss blocks
2961  lossSegmentMW(branch,los,fd)
2962      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
2963      = branchCapacity(branch,fd) ;
2964   
2965  LossSegmentFactor(branch,los,fd)
2966      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
2967      = 0 ;
2968   
2969  * Loss branches with 1 loss blocks
2970  LossSegmentMW(branch,los,fd)
2971      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
2972      = maxFlowSegment ;
2973   
2974  LossSegmentFactor(branch,los,fd)
2975      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
2976      = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
2977   
2978  * Loss branches with 3 loss blocks
2979  loop branch $ (branchLossBlocks(branch) = 3) do
2980  *   Segment 1
2981      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
2982          = lossCoeff_A * branchCapacity(branch,fd) ;
2983   
2984      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
2985          = 0.01 * 0.75 * lossCoeff_A
2986          * branchResistance(branch) * branchCapacity(branch,fd) ;
2987   
2988  *   Segment 2
2989      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
2990          = (1-lossCoeff_A) * branchCapacity(branch,fd) ;
2991   
2992      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
2993          = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
2994   
2995  *   Segment 3
2996      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
2997          = maxFlowSegment ;
2998   
2999      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
3000          = 0.01 * (2 - (0.75*lossCoeff_A))
3001          * branchResistance(branch) * branchCapacity(branch,fd) ;
3002  endloop;
3003   
3004  * Loss branches with 6 loss blocks
3005  loop branch $ (branchLossBlocks(branch) = 6) do
3006  *   Segment 1
3007      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3008          = lossCoeff_C  * branchCapacity(branch,fd) ;
3009   
3010      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3011          = 0.01 * 0.75 * lossCoeff_C
3012          * branchResistance(branch) * branchCapacity(branch,fd) ;
3013   
3014  *   Segment 2
3015      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
3016          = lossCoeff_D * branchCapacity(branch,fd) ;
3017   
3018      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
3019          = 0.01 * lossCoeff_E
3020          * branchResistance(branch) * branchCapacity(branch,fd) ;
3021   
3022  *   Segment 3
3023      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
3024          = 0.5 * branchCapacity(branch,fd) ;
3025   
3026      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
3027          = 0.01 * lossCoeff_F
3028          * branchResistance(branch) * branchCapacity(branch,fd) ;
3029   
3030  *   Segment 4
3031      LossSegmentMW(branch,los,fd) $ (ord(los) = 4)
3032          = (1 - lossCoeff_D) * branchCapacity(branch,fd) ;
3033   
3034      LossSegmentFactor(branch,los,fd) $ (ord(los) = 4)
3035          = 0.01 * (2 - lossCoeff_F)
3036          * branchResistance(branch) * branchCapacity(branch,fd) ;
3037   
3038  *   Segment 5
3039      LossSegmentMW(branch,los,fd) $ (ord(los) = 5)
3040          = (1 - lossCoeff_C) * branchCapacity(branch,fd) ;
3041   
3042      LossSegmentFactor(branch,los,fd) $ (ord(los) = 5)
3043          = 0.01 * (2 - lossCoeff_E)
3044          * branchResistance(branch) * branchCapacity(branch,fd) ;
3045   
3046  *   Segment 6
3047      LossSegmentMW(branch,los,fd) $ (ord(los) = 6)
3048          = maxFlowSegment ;
3049   
3050      LossSegmentFactor(branch,los,fd) $ (ord(los) = 6)
3051          = 0.01 * (2 - (0.75*lossCoeff_C))
3052          * branchResistance(branch) * branchCapacity(branch,fd) ;
3053  endloop ;
3054   
3055  * HVDC does not have backward flow --> No loss segment for backward flow
3056  LossSegmentMW(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
3057  LossSegmentFactor(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
3058   
3059   
3060  * Valid loss segment for a branch is defined as a loss segment that
3061  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
3062  validLossSegment(branch,los,fd) = yes $ { (ord(los) = 1) or
3063                                            LossSegmentMW(branch,los,fd) or
3064                                            LossSegmentFactor(branch,los,fd) } ;
3065   
3066  * HVDC loss model requires at least two loss segments and
3067  * an additional loss block due to cumulative loss formulation
3068  validLossSegment(HVDClink,los,fd)
3069      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
3070   
3071  validLossSegment(HVDClink,los,fd)
3072      $ { (branchLossBlocks(HVDClink) > 1) and
3073          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
3074          (sum[ los1, LossSegmentMW(HVDClink,los1,fd)
3075                    + LossSegmentFactor(HVDClink,los1,fd) ] > 0)
3076        } = yes ;
3077   
3078  * branches that have non-zero loss factors
3079  LossBranch(branch) $ sum[ (los,fd), LossSegmentFactor(branch,los,fd) ] = yes ;
3080   
3081  * Create AC branch loss segments
3082  ACbranchLossMW(ACbranch,los,fd)
3083      $ { validLossSegment(ACbranch,los,fd) and (ord(los) = 1) }
3084      = LossSegmentMW(ACbranch,los,fd) ;
3085   
3086  ACbranchLossMW(ACbranch,los,fd)
3087      $ { validLossSegment(ACbranch,los,fd) and (ord(los) > 1) }
3088      = LossSegmentMW(ACbranch,los,fd) - LossSegmentMW(ACbranch,los-1,fd) ;
3089   
3090  ACbranchLossFactor(ACbranch,los,fd)
3091      $ validLossSegment(ACbranch,los,fd) = LossSegmentFactor(ACbranch,los,fd) ;
3092   
3093  * Create HVDC loss break points
3094  HVDCBreakPointMWFlow(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
3095  HVDCBreakPointMWLoss(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
3096   
3097  HVDCBreakPointMWFlow(HVDClink,bp,fd)
3098      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) > 1) }
3099      = LossSegmentMW(HVDClink,bp-1,fd) ;
3100   
3101  HVDCBreakPointMWLoss(HVDClink,bp,fd)
3102      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) = 2) }
3103      =  LossSegmentMW(HVDClink,bp-1,fd) * LossSegmentFactor(HVDClink,bp-1,fd) ;
3104   
3105  loop (HVDClink(branch),bp) $ (ord(bp) > 2) do
3106      HVDCBreakPointMWLoss(branch,bp,fd) $ validLossSegment(branch,bp,fd)
3107          = LossSegmentFactor(branch,bp-1,fd)
3108          * [ LossSegmentMW(branch,bp-1,fd) - LossSegmentMW(branch,bp-2,fd) ]
3109          + HVDCBreakPointMWLoss(branch,bp-1,fd) ;
3110  endloop ;
3111  *-------------------------------------------------------------------------------
3112   
3113   
3114  * Initialise branch constraint data --------------------------------------------
3115  branchConstraint(dt,brCstr)
3116      $ sum[ branch(dt,br) $ branchCstrFactors(dt,brCstr,br), 1 ] = yes ;
3117   
3118  branchConstraintSense(branchConstraint)
3119      = branchCstrRHS(branchConstraint,'cnstrSense') ;
3120   
3121  branchConstraintLimit(branchConstraint)
3122      = branchCstrRHS(branchConstraint,'cnstrLimit') ;
3123  *-------------------------------------------------------------------------------
3124   
3125   
3126  * Calculate parameters for NMIR project ----------------------------------------
3127  islandRiskGroup(dt,isl,rg,riskC)
3128      = yes $ sum[ o $ { offerIsland(dt,o,isl)
3129                     and riskGroupOffer(dt,rg,o,riskC) }, 1 ] ;
3130   
3131  modulationRisk(dt) = smax[ riskC, modulationRiskClass(dt,RiskC) ];
3132   
3133  reserveShareEnabledOverall(dt) = smax[ resC, reserveShareEnabled(dt,resC) ];
3134   
3135  roPwrZoneExit(dt,resC)
3136      = [ roundPower2MonoLevel(dt) - modulationRisk(dt) ]$(ord(resC)=1)
3137      + bipole2MonoLevel(dt)$(ord(resC)=2) ;
3138   
3139  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are
         now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition
            by SPD pre-processing (same as for SIR). A change from the existing where
            the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition
            by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone
            for FIR will be removed by SPD pre-processing (same as for SIR). A change
            from the existing where the InNoReverseZone for FIR is never removed by
            SPD pre-processing.
3152   
3153  if inputGDXGDate >= jdate(2019,03,28) then
3154      roPwrZoneExit(dt,resC) = bipole2MonoLevel(dt) ;
3155  endif ;
3156   
3157  * National market refinement end
3158   
3159   
3160  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (4.5.2.1)
3161  sharedNFRLoad(dt,isl)
3162      = sum[ nodeIsland(dt,n,isl), RequiredLoad(dt,n)]
3163      + sum[ (bd,blk) $ bidIsland(dt,bd,isl), DemBidMW(dt,bd,blk) ]
3164      - sharedNFRLoadOffset(dt,isl) ;
3165   
3166  sharedNFRMax(dt,isl) = Min{ RMTReserveLimitTo(dt,isl,'FIR'),
3167                              sharedNFRFactor(dt)*sharedNFRLoad(dt,isl) } ;
3168   
3169  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
       TN on 22 May 2017:
      Usually a branch group constraint that limits the HVDC flow only involves the
      HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017,
      the constraint HAY_BEN_High_Frequency_limit involved all four branches in the
      form: HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
      This method of formulating the constraint prevented the previous formulation of
      monopoleConstraint and bipoleConstraintfrom working properly. Those constraints
      have been reformulated (see below) in order to cope with the formulation
      observed on 18 May 2017.
3181  monopoleConstraint(dt,isl,brCstr,br)
3182      $ { HVDClink(dt,br)
3183      and ( not rampingConstraint(dt,brCstr) )
3184      and ( branchConstraintSense(dt,brCstr) = -1 )
3185      and (Sum[ (br1,b) $ {HVDClinkSendingBus(dt,br1,b) and busIsland(dt,b,isl)}
3186                        , branchCstrFactors(dt,brCstr,br1)    ] = 1)
3187      and (Sum[ b $ {HVDClinkSendingBus(dt,br,b) and busIsland(dt,b,isl)}
3188                   , branchCstrFactors(dt,brCstr,br)      ] = 1)
3189         } = yes ;
3190   
3191  bipoleConstraint(dt,isl,brCstr)
3192      $ { ( not rampingConstraint(dt,brCstr) )
3193      and ( branchConstraintSense(dt,brCstr) = -1 )
3194      and (Sum[ (br,b) $ { HVDClink(dt,br)
3195                       and HVDClinkSendingBus(dt,br,b)
3196                       and busIsland(dt,b,isl) }
3197                      , branchCstrFactors(dt,brCstr,br)  ] = 2)
3198                         } = yes ;
3199   
3200  monoPoleCapacity(dt,isl,br)
3201      = Sum[ (b,fd) $ { BusIsland(dt,b,isl)
3202                    and HVDClink(dt,br)
3203                    and HVDClinkSendingBus(dt,br,b)
3204                    and ( ord(fd) = 1 )
3205                      }, branchCapacity(dt,br,fd) ] ;
3206   
3207  monoPoleCapacity(dt,isl,br)
3208      $ Sum[ brCstr $ monopoleConstraint(dt,isl,brCstr,br), 1]
3209      = Smin[ brCstr $ monopoleConstraint(dt,isl,brCstr,br)
3210            , branchConstraintLimit(dt,brCstr) ];
3211   
3212  monoPoleCapacity(dt,isl,br)
3213      = Min( monoPoleCapacity(dt,isl,br),
3214             sum[ fd $ ( ord(fd) = 1 ), branchCapacity(dt,br,fd) ] );
3215   
3216  biPoleCapacity(dt,isl)
3217      $ Sum[ brCstr $ bipoleConstraint(dt,isl,brCstr), 1]
3218      = Smin[ brCstr $ bipoleConstraint(dt,isl,brCstr)
3219            , branchConstraintLimit(dt,brCstr) ];
3220   
3221  biPoleCapacity(dt,isl)
3222      $ { Sum[ brCstr $ bipoleConstraint(dt,isl,brCstr), 1] = 0 }
3223      = Sum[ (b,br,fd) $ { BusIsland(dt,b,isl) and HVDClink(dt,br)
3224                       and HVDClinkSendingBus(dt,br,b)
3225                       and ( ord(fd) = 1 )
3226                         }, branchCapacity(dt,br,fd) ] ;
3227   
3228  HVDCMax(dt,isl)
3229      = Min( biPoleCapacity(dt,isl), Sum[ br, monoPoleCapacity(dt,isl,br) ] ) ;
3230   
3231   
3232  * Calculate HVDC HVDC Loss segment applied for NMIR ----------------------------
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
3238  if inputGDXGDate >= jdate(2016,11,22) then
3239        HVDCCapacity(dt,isl)
3240            = Sum[ (b,br,fd) $ { BusIsland(dt,b,isl) and HVDClink(dt,br)
3241                             and HVDClinkSendingBus(dt,br,b)
3242                             and ( ord(fd) = 1 )
3243                               }, branchCapacity(dt,br,fd) ] ;
3244   
3245        numberOfPoles(dt,isl)
3246            = Sum[ (b,br) $ { BusIsland(dt,b,isl) and HVDClink(dt,br)
3247                          and HVDClinkSendingBus(dt,br,b) }, 1 ] ;
3248   
3249        HVDCResistance(dt,isl) $ (numberOfPoles(dt,isl) = 2)
3250            = Prod[ (b,br) $ { BusIsland(dt,b,isl) and HVDClink(dt,br)
3251                           and HVDClinkSendingBus(dt,br,b)
3252                             }, branchResistance(dt,br) ]
3253            / Sum[ (b,br) $ { BusIsland(dt,b,isl) and HVDClink(dt,br)
3254                          and HVDClinkSendingBus(dt,br,b)
3255                            }, branchResistance(dt,br) ] ;
3256   
3257        HVDCResistance(dt,isl) $ (numberOfPoles(dt,isl) = 1)
3258            = Sum[ br $ monoPoleCapacity(dt,isl,br), branchResistance(dt,br) ] ;
3259  else
3260      HVDCCapacity(dt,isl)
3261          = Sum[ (br,b,b1,fd) $ { (HVDCBranch(dt,br) = 1)
3262                              and busIsland(dt,b,isl)
3263                              and branchDefn(dt,br,b,b1)
3264                              and ( ord(fd) = 1 )
3265                                }, branchCapacity(dt,br,fd) ] ;
3266   
3267      numberOfPoles(dt,isl)
3268          =Sum[ (br,b,b1) $ { (HVDCBranch(dt,br) = 1)
3269                        and busIsland(dt,b,isl)
3270                        and branchDefn(dt,br,b,b1)
3271                        and sum[ fd $ ( ord(fd) = 1 )
3272                               , branchCapacity(dt,br,fd) ]
3273                          }, 1 ] ;
3274   
3275      HVDCResistance(dt,isl)
3276          =  Sum[ (br,b,b1,brPar)
3277                $ { (HVDCBranch(dt,br) = 1)
3278                and busIsland(dt,b,isl)
3279                and branchDefn(dt,br,b,b1)
3280                and (ord(brPar) = 1)
3281                  }, branchParameter(dt,br,brPar) ] ;
3282   
3283      HVDCResistance(dt,isl) $ (numberOfPoles(dt,isl) = 2)
3284          = Prod[ (br,b,b1,brPar)
3285                $ { (HVDCBranch(dt,br) = 1)
3286                and busIsland(dt,b,isl)
3287                and branchDefn(dt,br,b,b1)
3288                and sum[ fd $ ( ord(fd) = 1 )
3289                               , branchCapacity(dt,br,fd) ]
3290                and (ord(brPar) = 1)
3291                  }, branchParameter(dt,br,brPar)
3292                ] / HVDCResistance(dt,isl) ;
3293  endif ;
3294   
3295  * Segment 1
3296  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 1)
3297      = HVDCCapacity(dt,isl) * lossCoeff_C ;
3298   
3299  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 1)
3300      = 0.01 * 0.75 * lossCoeff_C
3301      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3302   
3303  * Segment 2
3304  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 2)
3305      = HVDCCapacity(dt,isl) * lossCoeff_D ;
3306   
3307  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 2)
3308      = 0.01 * lossCoeff_E
3309      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3310   
3311  * Segment 3
3312  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 3)
3313      = HVDCCapacity(dt,isl) * 0.5 ;
3314   
3315  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 3)
3316      = 0.01 * lossCoeff_F
3317      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3318   
3319  * Segment 4
3320  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 4)
3321      = HVDCCapacity(dt,isl) * (1 - lossCoeff_D) ;
3322   
3323  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 4)
3324      = 0.01 * (2 - lossCoeff_F)
3325      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3326   
3327  * Segment 5
3328  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 5)
3329      = HVDCCapacity(dt,isl) * (1 - lossCoeff_C) ;
3330   
3331  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 5)
3332      = 0.01 * (2 - lossCoeff_E)
3333      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3334   
3335  * Segment 6
3336  HVDCLossSegmentMW(dt,isl,los) $ (ord(los) = 6)
3337      = HVDCCapacity(dt,isl) ;
3338   
3339  HVDCLossSegmentFactor(dt,isl,los) $ (ord(los) = 6)
3340      = 0.01 * (2 - (0.75*lossCoeff_C))
3341      * HVDCResistance(dt,isl) * HVDCCapacity(dt,isl) ;
3342   
3343  * Parameter for energy lambda loss model
3344  HVDCSentBreakPointMWFlow(dt,isl,bp) $ (ord(bp) = 1) = 0 ;
3345  HVDCSentBreakPointMWLoss(dt,isl,bp) $ (ord(bp) = 1) = 0 ;
3346   
3347  HVDCSentBreakPointMWFlow(dt,isl,bp) $ (ord(bp) > 1)
3348      = HVDCLossSegmentMW(dt,isl,bp-1) ;
3349   
3350  loop (dt,isl,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)} do
3351      HVDCSentBreakPointMWLoss(dt,isl,bp)
3352          = HVDClossScalingFactor(dt)
3353          * HVDCLossSegmentFactor(dt,isl,bp-1)
3354          * [ HVDCLossSegmentMW(dt,isl,bp-1)
3355            - HVDCSentBreakPointMWFlow(dt,isl,bp-1) ]
3356          + HVDCSentBreakPointMWLoss(dt,isl,bp-1) ;
3357  endloop ;
3358   
3359  * Parameter for energy+reserve lambda loss model
3360   
3361  * Ideally SO should use asymmetric loss curve
3362  HVDCReserveBreakPointMWFlow(dt,isl,rsbp) $ (ord(rsbp) <= 7)
3363      = Sum[ (isl1,rsbp1) $ { ( not sameas(isl1,isl) )
3364                          and ( ord(rsbp) + ord(rsbp1) = 8)}
3365           , -HVDCSentBreakPointMWFlow(dt,isl1,rsbp1) ];
3366   
3367  * SO decide to use symmetric loss curve instead
3368  HVDCReserveBreakPointMWFlow(dt,isl,rsbp) $ (ord(rsbp) <= 7)
3369      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
3370           , -HVDCSentBreakPointMWFlow(dt,isl,rsbp1) ];
3371   
3372  HVDCReserveBreakPointMWFlow(dt,isl,rsbp)
3373      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
3374      = HVDCSentBreakPointMWFlow(dt,isl,rsbp-6) ;
3375   
3376   
3377  * Ideally SO should use asymmetric loss curve
3378  HVDCReserveBreakPointMWLoss(dt,isl,rsbp) $ (ord(rsbp) <= 7)
3379      = Sum[ (isl1,rsbp1) $ { ( not sameas(isl1,isl) )
3380                          and ( ord(rsbp) + ord(rsbp1) = 8)}
3381           , HVDCSentBreakPointMWLoss(dt,isl1,rsbp1) ];
3382   
3383  * SO decide to use symmetric loss curve instead
3384  HVDCReserveBreakPointMWLoss(dt,isl,rsbp) $ (ord(rsbp) <= 7)
3385      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
3386           , HVDCSentBreakPointMWLoss(dt,isl,rsbp1) ];
3387   
3388  HVDCReserveBreakPointMWLoss(dt,isl,rsbp)
3389      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
3390      = HVDCSentBreakPointMWLoss(dt,isl,rsbp-6);
3391   
3392  * Parameter for lambda loss model  end
3393   
3394  * Initialze parameters for NMIR project end ----------------------------------
3395   
3396   
3397  * Initialise risk/reserve data for the current trade period start
3398   
3399  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
3400  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
3401  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
3402  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
3403  GenRisk(riskC)     $ (ord(riskC) = 5) = yes ;
3404  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes ;
3405  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes ;
3406  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes ;
3407   
3408  * Define the CE and ECE risk class set to support the different CE and ECE CVP
3409  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
3410  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
3411  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
3412  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
3413  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes ;
3414  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes ;
3415  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes ;
3416  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes ;
3417   
3418  * Risk parameters
3419  FreeReserve(dt,isl,resC,riskC)
3420      = riskParameter(dt,isl,resC,riskC,'freeReserve')
3421  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
3422      - sum[ isl1 $ (not sameas(isl,isl1)),sharedNFRMax(dt,isl1)
3423           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
3424             and (inputGDXGDate >= jdate(2016,10,20)) }
3425      ;
3426   
3427  IslandRiskAdjustmentFactor(dt,isl,resC,riskC) $ useReserveModel
3428      = riskParameter(dt,isl,resC,riskC,'adjustFactor') ;
3429   
3430  * HVDC rampup max - (6.5.1.2) - SPD version 12
3431  HVDCpoleRampUp(dt,isl,resC,riskC)
3432      = riskParameter(dt,isl,resC,riskC,'HVDCRampUp') ;
3433   
3434   
3435   
3436  * Initialise market node constraint data for the current trading period
3437  MnodeConstraint(dt,MnodeCstr)
3438      $ { sum[ (offer(dt,o),resT,resC)
3439             $ { mnCstrEnrgFactors(dt,MnodeCstr,o) or
3440                 mnCnstrResrvFactors(dt,MnodeCstr,o,resC,resT)
3441               }, 1
3442             ]
3443        or
3444          sum[ (bid(dt,bd),resC)
3445             $ { mnCnstrEnrgBidFactors(dt,MnodeCstr,bd) or
3446                 mnCnstrResrvBidFactors(dt,MnodeCstr,bd,resC)
3447               }, 1
3448             ]
3449        } = yes ;
3450   
3451  MnodeConstraintSense(MnodeConstraint)
3452      = mnCnstrRHS(MnodeConstraint,'cnstrSense') ;
3453   
3454  MnodeConstraintLimit(MnodeConstraint)
3455      = mnCnstrRHS(MnodeConstraint,'cnstrLimit') ;
3456   
3457   
3458  * Generation Ramp Pre_processing -----------------------------------------------
3459   
3460  * For PRICERESPONSIVEIG generators, The RTD RampRateUp is capped: (4.7.2.2)
3461  if studyMode = 101 or studyMode = 201 then
3462      RampRateUp(offer(dt,o)) $ { windOffer(offer) and priceResponsive(offer) }
3463          = Min[ RampRateUp(offer), rtdIgIncreaseLimit(dt)*60/intervalDuration ];
3464  endif;
3465   
3466  * Need to initiate value for this parameters before it is used
3467  o_offerEnergy_TP(dt,o) = 0;
3468   
3469   
3470  * TN - Pivot or demand analysis begin
3473  * TN - Pivot or demand analysis begin end
3474   
3476  *=====================================================================================
3477  * 7. The vSPD solve loop
3478  *=====================================================================================
3479  if (studyMode = 101 or studyMode = 201,
INCLUDE    C:\vSPD\ElectricityAuthority\Programs\vSPDsolve_RTP.gms
3481  *=====================================================================================
3482  * Name:                 vSPDsolve_RTP.gms
3483  * Function:             First RTD solve to update island loss in order to
3484  *                       adjust node demand
3485  *                       A new development for Rea
3486  * Developed by:         Electricity Authority, New Zealand
3487  * Source:               https://github.com/ElectricityAuthority/vSPD
3488  *                       http://www.emi.ea.govt.nz/Tools/vSPD
3489  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
3490  *                       Email: emi@ea.govt.nz
3491  * Created on:           14 Jan 2022
3492   
3493  *=====================================================================================
3494   
3495  *   7d. Solve Models First Time For Real Time Pricing
3496  *=====================================================================================
3497  * 7. The vSPD solve loop
3498  *=====================================================================================
3499  put_utility temp 'gdxin' / 'C:\vSPD\ElectricityAuthority\Programs\..\Input\\RTD_202210101250_91012022102350483_20221010124902.gdx' ;
3500  execute_load SPDLoadCalcLosses = i_dateTimeSPDLoadCalcLosses  ;
3501  put_utility temp 'gdxin' ;
3502   
3503  unsolvedDT(dt) = yes;
3504  VSPDModel(dt) = 0 ;
3505  option clear = useBranchFlowMIP ;
3506   
3507  While ( Sum[ dt $ unsolvedDT(dt), 1 ],
3508    exitLoop = 0;
3509    loop[ dt $ {unsolvedDT(dt) and (exitLoop = 0)},
3510   
3511  *   7a. Reset all sets, parameters and variables -------------------------------
3512      option clear = t ;
3513  *   Generation variables
3514      option clear = GENERATION ;
3515      option clear = GENERATIONBLOCK ;
3516      option clear = GENERATIONUPDELTA ;
3517      option clear = GENERATIONDNDELTA ;
3518  *   Purchase variables
3519      option clear = PURCHASE ;
3520      option clear = PURCHASEBLOCK ;
3521  *   Network variables
3522      option clear = ACNODENETINJECTION ;
3523      option clear = ACNODEANGLE ;
3524      option clear = ACBRANCHFLOW ;
3525      option clear = ACBRANCHFLOWDIRECTED ;
3526      option clear = ACBRANCHLOSSESDIRECTED ;
3527      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
3528      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
3529      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
3530      option clear = HVDCLINKFLOW ;
3531      option clear = HVDCLINKLOSSES ;
3532      option clear = LAMBDA ;
3533      option clear = LAMBDAINTEGER ;
3534      option clear = HVDCLINKFLOWDIRECTED_INTEGER ;
3535      option clear = HVDCPOLEFLOW_INTEGER ;
3536  *   Risk/Reserve variables
3537      option clear = RISKOFFSET ;
3538      option clear = HVDCREC ;
3539      option clear = ISLANDRISK ;
3540      option clear = RESERVEBLOCK ;
3541      option clear = RESERVE ;
3542      option clear = ISLANDRESERVE;
3543  *   NMIR variables
3544      option clear = SHAREDNFR ;
3545      option clear = SHAREDRESERVE ;
3546      option clear = HVDCSENT ;
3547      option clear = RESERVESHAREEFFECTIVE ;
3548      option clear = RESERVESHARERECEIVED ;
3549      option clear = RESERVESHARESENT ;
3550      option clear = HVDCSENDING ;
3551      option clear = INZONE ;
3552      option clear = HVDCSENTINSEGMENT ;
3553      option clear = HVDCRESERVESENT ;
3554      option clear = HVDCSENTLOSS ;
3555      option clear = HVDCRESERVELOSS ;
3556      option clear = LAMBDAHVDCENERGY ;
3557      option clear = LAMBDAHVDCRESERVE ;
3558      option clear = RESERVESHAREPENALTY ;
3559  *   Objective
3560      option clear = NETBENEFIT ;
3561  *   Violation variables
3562      option clear = TOTALPENALTYCOST ;
3563      option clear = DEFICITBUSGENERATION ;
3564      option clear = SURPLUSBUSGENERATION ;
3565      option clear = DEFICITRESERVE_CE ;
3566      option clear = DEFICITRESERVE_ECE ;
3567      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
3568      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
3569      option clear = DEFICITRAMPRATE ;
3570      option clear = SURPLUSRAMPRATE ;
3571      option clear = DEFICITBRANCHFLOW ;
3572      option clear = SURPLUSBRANCHFLOW ;
3573      option clear = DEFICITMNODECONSTRAINT ;
3574      option clear = SURPLUSMNODECONSTRAINT ;
3575   
3576      option clear = SCARCITYCOST;
3577      option clear = ENERGYSCARCITYBLK ;
3578      option clear = ENERGYSCARCITYNODE;
3579   
3580  *   Clear the pole circular branch flow flag
3581      option clear = circularBranchFlowExist ;
3582      option clear = poleCircularBranchFlowExist ;
3583      option clear = northHVDC ;
3584      option clear = southHVDC ;
3585      option clear = manualBranchSegmentMWFlow ;
3586      option clear = manualLossCalculation ;
3587      option clear = nonPhysicalLossExist ;
3588      option clear = modelSolved ;
3589      option clear = LPmodelSolved ;
3590  *   Disconnected bus post-processing
3591      option clear = busGeneration ;
3592      option clear = busLoad ;
3593      option clear = busDisconnected ;
3594      option clear = busPrice ;
3595   
3596   
3597  *   End reset
3598   
3599   
3600  *   7b. Initialise current trade period and model data -------------------------
3601      t(dt)  $ sequentialSolve       = yes;
3602      t(dt1) $ (not sequentialSolve) = yes;
3603   
3604  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
3605      generationStart(offer(t(dt),o))
3606          $ (sum[ o1, generationStart(dt,o1)] = 0)
3607          = sum[ dt1 $ (ord(dt1) = ord(dt)-1), o_offerEnergy_TP(dt1,o) ] ;
3608   
      these are not used anymore
      *   Calculation of generation upper limits due to ramp rate limits
      *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
      *   initial MW and ramp rate is used - Reference: Transpower Market Services
          rampTimeUp(offer(t(tp),o))
              $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
              = Min[ intervalDuration , ( generationMaximum(offer)
                                             - generationStart(offer)
                                             ) / rampRateUp(offer)
                   ] ;
       
      *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
      *   initial MW and ramp rate is used - Reference: Transpower Market Services
          generationEndUp(offer(t(tp),o)) $ (not hasPrimaryOffer(offer))
              = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
       
       
      *   Calculation of generation lower limits due to ramp rate limits
       
      *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
      *   initial MW and ramp rate is used - Reference: Transpower Market Services
          rampTimeDown(offer(t(tp),o))
              $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
              = Min[ intervalDuration, ( generationStart(offer)
                                            - generationMinimum(offer)
                                            ) / rampRateDown(offer)
                   ] ;
       
      *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
      *   initial MW and ramp rate is used - Reference: Transpower Market Services
          generationEndDown(offer(t(tp),o)) $ (not hasPrimaryOffer(offer))
              = Max[ 0, generationStart(offer)
                      - rampRateDown(offer)*rampTimeDown(offer) ] ;
3644  *   Additional pre-processing on parameters end
3645   
3646   
3647  *   7c. Updating the variable bounds before model solve ------------------------
3648   
3649  * TN - Pivot or Demand Analysis - revise input data
3652  * TN - Pivot or Demand Analysis - revise input data end
3653   
3654  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
3655   
3656  *   Offer blocks - Constraint 6.1.1.1
3657      GENERATIONBLOCK.up(genOfrBlk(t,o,blk))
3658          = EnrgOfrMW(genOfrBlk) ;
3659   
3660      GENERATIONBLOCK.fx(t,o,blk)
3661          $ (not genOfrBlk(t,o,blk)) = 0 ;
3662   
3663  *   Constraint 6.1.1.2 - Fix the invalid generation to Zero
3664      GENERATION.fx(offer(t,o)) $ (not posEnrgOfr(offer)) = 0 ;
3665   
3666  *   Constraint 6.1.1.3 - Set Upper Bound for intermittent generation
3667      GENERATION.up(offer(t,o))
3668          $ { windOffer(offer) and priceResponsive(offer) }
3669          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
3670   
3671  *   Constraint 6.1.1.4 - Set Upper/Lower Bound for Positive Demand Bid
3672      PURCHASEBLOCK.up(demBidBlk(t,bd,blk))
3673          = DemBidMW(t,bd,blk) $ [DemBidMW(t,bd,blk)>0];
3674   
3675      PURCHASEBLOCK.lo(demBidBlk(t,bd,blk))
3676          = 0 $ [DemBidMW(t,bd,blk)>0];
3677   
3678  *   Constraint 6.1.1.5 - Set Upper/Lower Bound for Negativetive Demand Bid
3679      PURCHASEBLOCK.up(demBidBlk(t,bd,blk))
3680          = 0 $ [DemBidMW(t,bd,blk)<0];
3681   
3682      PURCHASEBLOCK.lo(demBidBlk(t,bd,blk))
3683          = DemBidMW(t,bd,blk) $ [DemBidMW(t,bd,blk)<0];
3684   
3685      PURCHASEBLOCK.fx(t,bd,blk)
3686          $ (not demBidBlk(t,bd,blk))
3687          = 0 ;
3688   
3689      PURCHASE.fx(t,bd) $ (sum[blk $ demBidBlk(t,bd,blk), 1] = 0) = 0 ;
3690   
3691  *   Constraint 6.1.1.7 - Set Upper Bound for Energy Scaricty Block
3692      ENERGYSCARCITYBLK.up(t,n,blk) = ScarcityEnrgLimit(t,n,blk) ;
3693      ENERGYSCARCITYBLK.fx(t,n,blk) $ (not EnergyScarcityEnabled(t)) = 0;
3694      ENERGYSCARCITYNODE.fx(t,n) $ (not EnergyScarcityEnabled(t)) = 0;
3695   
3696  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
3697   
3698   
3699  *======= HVDC TRANSMISSION EQUATIONS ===========================================
3700   
3701  *   Ensure that variables used to specify flow and losses on HVDC link are
3702  *   zero for AC branches and for open HVDC links.
3703      HVDCLINKFLOW.fx(t,br)   $ (not HVDClink(t,br)) = 0 ;
3704      HVDCLINKLOSSES.fx(t,br) $ (not HVDClink(t,br)) = 0 ;
3705   
3706  *   Apply an upper bound on the weighting parameter based on its definition
3707      LAMBDA.up(branch,bp) = 1 ;
3708   
3709  *   Ensure that the weighting factor value is zero for AC branches and for
3710  *   invalid loss segments on HVDC links
3711      LAMBDA.fx(HVDClink,bp)
3712          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
3713      LAMBDA.fx(t,br,bp) $ (not HVDClink(t,br)) = 0 ;
3714   
3715  *======= HVDC TRANSMISSION EQUATIONS END =======================================
3716   
3717   
3718  *======= AC TRANSMISSION EQUATIONS =============================================
3719   
3720  *   Ensure that variables used to specify flow and losses on AC branches are
3721  *   zero for HVDC links branches and for open AC branches
3722      ACBRANCHFLOW.fx(t,br)              $ (not ACbranch(t,br)) = 0 ;
3723      ACBRANCHFLOWDIRECTED.fx(t,br,fd)   $ (not ACbranch(t,br)) = 0 ;
3724      ACBRANCHLOSSESDIRECTED.fx(t,br,fd) $ (not ACbranch(t,br)) = 0 ;
3725   
3726  *   Ensure directed block flow and loss block variables are zero for
3727  *   non-AC branches and invalid loss segments on AC branches
3728     ACBRANCHFLOWBLOCKDIRECTED.fx(t,br,los,fd)
3729         $ { not(ACbranch(t,br) and validLossSegment(t,br,los,fd)) } = 0 ;
3730   
3731     ACBRANCHLOSSESBLOCKDIRECTED.fx(t,br,los,fd)
3732         $ { not(ACbranch(t,br) and validLossSegment(t,br,los,fd)) } = 0 ;
3733   
3734   
3735  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
3736  *   corresponding to the reference nodes and the HVDC nodes are set to zero
3737      ACNODEANGLE.fx(t,b)
3738         $ sum[ n $ { NodeBus(t,n,b) and refNode(t,n) }, 1 ] = 0 ;
3739   
3740  *======= AC TRANSMISSION EQUATIONS END =========================================
3741   
3742   
3743  *======= RISK & RESERVE EQUATIONS ==============================================
3744   
3745  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
3746      RESERVEBLOCK.fx(offer(t,o),blk,resC,resT)
3747          $ (not resOfrBlk(offer,blk,resC,resT)) = 0 ;
3748   
3749  *   Reserve block maximum for offers and purchasers - Constraint 6.5.3.2.
3750      RESERVEBLOCK.up(resOfrBlk(t,o,blk,resC,resT))
3751          = ResOfrMW(resOfrBlk) ;
3752   
3753  *   Fix the reserve variable for invalid reserve offers. These are offers that
3754  *   are either not connected to the grid or have no reserve quantity offered.
3755      RESERVE.fx(t,o,resC,resT)
3756          $ (not sum[ blk $ resOfrBlk(t,o,blk,resC,resT), 1 ] ) = 0 ;
3757   
3758  *   NMIR project variables
3759      HVDCSENT.fx(t,isl) $ (HVDCCapacity(t,isl) = 0) = 0 ;
3760      HVDCSENTLOSS.fx(t,isl) $ (HVDCCapacity(t,isl) = 0) = 0 ;
3761   
3762  *   (3.4.2.3) - SPD version 11.0
3763      SHAREDNFR.up(t,isl) = Max[0,sharedNFRMax(t,isl)] ;
3764   
3765  *   No forward reserve sharing if HVDC capacity is zero
3766      RESERVESHARESENT.fx(t,isl,resC,rd)
3767          $ { (HVDCCapacity(t,isl) = 0) and (ord(rd) = 1) } = 0 ;
3768   
3769  *   No forward reserve sharing if reserve sharing is disabled
3770      RESERVESHARESENT.fx(t,isl,resC,rd)
3771          $ (reserveShareEnabled(t,resC)=0) = 0;
3772   
3773  *   No reserve sharing to cover HVDC risk
3774      RESERVESHAREEFFECTIVE.fx(t,isl,resC,HVDCrisk) = 0;
3775      RESERVESHAREEFFECTIVE.fx(t,isl,resC,HVDCsecRisk) = 0;
3776   
3777  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
3778      INZONE.fx(t,isl,resC,z)
3779          $ {(ord(z) = 1) and (not reserveRoundPower(t,resC))} = 0;
3780   
3781  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
3782      INZONE.fx(t,isl,resC,z)
3783          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(t,resC)} = 0;
3784   
3785  *   Fixing Lambda integer variable for energy sent
3786      LAMBDAHVDCENERGY.fx(t,isl,bp) $ { (HVDCCapacity(t,isl) = 0)
3787                                          and (ord(bp) = 1) } = 1 ;
3788   
3789      LAMBDAHVDCENERGY.fx(t,isl,bp) $ (ord(bp) > 7) = 0 ;
3790   
3791  * To be reviewed NMIR
3792      LAMBDAHVDCRESERVE.fx(t,isl,resC,rd,rsbp)
3793          $ { (HVDCCapacity(t,isl) = 0)
3794          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
3795   
3796      LAMBDAHVDCRESERVE.fx(t,isl1,resC,rd,rsbp)
3797          $ { (sum[ isl $ (not sameas(isl,isl1)), HVDCCapacity(t,isl) ] = 0)
3798          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
3799   
3800  *   Contraint 6.5.4.2 - Set Upper Bound for reserve shortfall
3801      RESERVESHORTFALLBLK.up(t,isl,resC,riskC,blk)
3802          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
3803      RESERVESHORTFALLBLK.fx(t,isl,resC,riskC,blk)
3804          $ (not reserveScarcityEnabled(t)) = 0;
3805      RESERVESHORTFALL.fx(t,isl,resC,riskC)
3806          $ (not reserveScarcityEnabled(t)) = 0;
3807   
3808      RESERVESHORTFALLUNITBLK.up(t,isl,o,resC,riskC,blk)
3809          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
3810      RESERVESHORTFALLUNITBLK.fx(t,isl,o,resC,riskC,blk)
3811          $ (not reserveScarcityEnabled(t)) = 0;
3812      RESERVESHORTFALLUNIT.fx(t,isl,o,resC,riskC)
3813          $ (not reserveScarcityEnabled(t)) = 0;
3814   
3815      RESERVESHORTFALLGROUPBLK.up(t,isl,rg,resC,riskC,blk)
3816          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
3817      RESERVESHORTFALLGROUPBLK.fx(t,isl,rg,resC,riskC,blk)
3818          $ (not reserveScarcityEnabled(t)) = 0;
3819      RESERVESHORTFALLGROUP.fx(t,isl,rg,resC,riskC)
3820          $ (not reserveScarcityEnabled(t)) = 0;
3821  ;
3822   
3823   
3824  *======= RISK & RESERVE EQUATIONS END ==========================================
3825   
3826   
3827  *   Updating the variable bounds before model solve end
3828   
3829   
3830  *   7d. Solve Models
3831  *   Solve the LP model ---------------------------------------------------------
3832      if( (Sum[t, VSPDModel(t)] = 0),
3833   
3834          if( UseShareReserve,
3835              option bratio = 1 ;
3836              vSPD_NMIR.Optfile = 1 ;
3837              vSPD_NMIR.optcr = MIPOptimality ;
3838              vSPD_NMIR.reslim = MIPTimeLimit ;
3839              vSPD_NMIR.iterlim = MIPIterationLimit ;
3840              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
3841  *           Set the model solve status
3842              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
3843                                 or (vSPD_NMIR.modelstat = 8) )
3844                              and ( vSPD_NMIR.solvestat = 1 ) } ;
3845          else
3846              option bratio = 1 ;
3847              vSPD.reslim = LPTimeLimit ;
3848              vSPD.iterlim = LPIterationLimit ;
3849              solve vSPD using lp maximizing NETBENEFIT ;
3850  *           Set the model solve status
3851              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
3852          )
3853   
3854  *       Post a progress message to the console and for use by EMI.
3855          if((ModelSolved = 1) and (sequentialSolve = 0),
3856              putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 '
3857                           'is 1st solved successfully.'/
3858                           'Objective function value: '
3859                           NETBENEFIT.l:<15:4 /
3860                           'Violation Cost          : '
3861                           TOTALPENALTYCOST.l:<15:4 /
3862          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
3863              putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 '
3864                           'is 1st solved unsuccessfully.'/
3865          ) ;
3866   
3867          if((ModelSolved = 1) and (sequentialSolve = 1),
3868              loop(t,
3869                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
3870                               'is 1st solved successfully.'/
3871                               'Objective function value: '
3872                               NETBENEFIT.l:<15:4 /
3873                               'Violations cost         : '
3874                               TOTALPENALTYCOST.l:<15:4 /
3875              ) ;
3876          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
3877              loop(t,
3878                  unsolvedDT(t) = no;
3879                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
3880                               'is 1st solved unsuccessfully.'/
3881              ) ;
3882   
3883          ) ;
3884  *   Solve the LP model end -----------------------------------------------------
3885   
3886  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
3887      elseif (Sum[t, VSPDModel(t)] = 1),
3888  *       Fix the values of these integer variables that are not needed
3889          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(t,br),fd)
3890              $ { (not ACbranch(t,br)) or (not LossBranch(branch)) } = 0 ;
3891   
3892  *       Fix the integer AC branch flow variable to zero for invalid branches
3893          ACBRANCHFLOWDIRECTED_INTEGER.fx(t,br,fd)
3894              $ (not branch(t,br)) = 0 ;
3895   
3896  *       Apply an upper bound on the integer weighting parameter
3897          LAMBDAINTEGER.up(branch(t,br),bp) = 1 ;
3898   
3899  *       Ensure that the weighting factor value is zero for AC branches
3900  *       and for invalid loss segments on HVDC links
3901          LAMBDAINTEGER.fx(branch(t,br),bp)
3902              $ { ACbranch(branch)
3903              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
3904                } = 0 ;
3905   
3906  *       Fix the lambda integer variable to zero for invalid branches
3907          LAMBDAINTEGER.fx(t,br,bp) $ (not branch(t,br)) = 0 ;
3908   
3909          option bratio = 1 ;
3910          vSPD_BranchFlowMIP.Optfile = 1 ;
3911          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
3912          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
3913          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
3914          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
3915  *       Set the model solve status
3916          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
3917                                (vSPD_BranchFlowMIP.modelstat = 8)
3918                              ]
3919                              and
3920                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
3921                            } ;
3922   
3923  *       Post a progress message for use by EMI.
3924          if(ModelSolved = 1,
3925   
3926  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
3927              SOS1_solve(t)  = yes;
3928   
3929              loop(t,
3930                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
3931                               'is 1st solved successfully for branch integer.'/
3932                               'Objective function value: '
3933                               NETBENEFIT.l:<15:4 /
3934                               'Violations cost         : '
3935                               TOTALPENALTYCOST.l:<15:4 /
3936              ) ;
3937          else
3938              loop(t,
3939                  unsolvedDT(t) = yes;
3940                  VSPDModel(t) = 2;
3941                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
3942                               'is 1st solved unsuccessfully for branch integer.'/
3943              ) ;
3944          ) ;
3945  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
3946   
3947   
3948   
3949  *   Solve the LP model and stop ------------------------------------------------
3950      elseif (Sum[t, VSPDModel(t)] = 2),
3951   
3952          if( UseShareReserve,
3953              option bratio = 1 ;
3954              vSPD_NMIR.Optfile = 1 ;
3955              vSPD_NMIR.optcr = MIPOptimality ;
3956              vSPD_NMIR.reslim = MIPTimeLimit ;
3957              vSPD_NMIR.iterlim = MIPIterationLimit ;
3958              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
3959  *           Set the model solve status
3960              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
3961                                 or (vSPD_NMIR.modelstat = 8) )
3962                              and ( vSPD_NMIR.solvestat = 1 ) } ;
3963          else
3964              option bratio = 1 ;
3965              vSPD.reslim = LPTimeLimit ;
3966              vSPD.iterlim = LPIterationLimit ;
3967              solve vSPD using lp maximizing NETBENEFIT ;
3968  *           Set the model solve status
3969              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
3970          )
3971   
3972  *       Post a progress message for use by EMI.
3973          if( ModelSolved = 1,
3974              loop(t,
3975                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ')'
3976                                  ' integer resolve was unsuccessful.' /
3977                                  'Reverting back to linear solve and '
3978                                  'solve successfully. ' /
3979                                  'Objective function value: '
3980                                  NETBENEFIT.l:<15:4 /
3981                                  'Violations cost         : '
3982                                  TOTALPENALTYCOST.l:<15:4 /
3983                                  'Solution may have circulating flows '
3984                                  'and/or non-physical losses.' /
3985              ) ;
3986          else
3987              loop(t,
3988                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl
3989                                  ') integer solve was unsuccessful. '
3990                                  'Reverting back to linear solve. '
3991                                  'Linear solve unsuccessful.' /
3992              ) ;
3993          ) ;
3994   
3995          unsolvedDT(t) = no;
3996   
3997  *   Solve the LP model and stop end --------------------------------------------
3998   
3999      ) ;
4000  *   Solve the models end
4001   
4002   
4003   
4004  *   6e. Check if the LP results are valid --------------------------------------
4005      if((ModelSolved = 1),
4006          useBranchFlowMIP(t) = 0 ;
4007  *       Check if there is no branch circular flow and non-physical losses
4008          Loop( t $ (VSPDModel(t)=0) ,
4009   
4010  *           Check if there are circulating branch flows on loss AC branches
4011              circularBranchFlowExist(ACbranch(t,br))
4012                  $ { LossBranch(ACbranch) and
4013                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
4014                        - abs(ACBRANCHFLOW.l(ACbranch))
4015                        ) > circularBranchFlowTolerance
4016                      ]
4017                    } = 1 ;
4018   
4019  *           Determine the circular branch flow flag on each HVDC pole
4020              TotalHVDCpoleFlow(t,pole)
4021                  = sum[ br $ HVDCpoleBranchMap(pole,br)
4022                       , HVDCLINKFLOW.l(t,br) ] ;
4023   
4024              MaxHVDCpoleFlow(t,pole)
4025                  = smax[ br $ HVDCpoleBranchMap(pole,br)
4026                        , HVDCLINKFLOW.l(t,br) ] ;
4027   
4028              poleCircularBranchFlowExist(t,pole)
4029                  $ { ( TotalHVDCpoleFlow(t,pole)
4030                      - MaxHVDCpoleFlow(t,pole)
4031                      ) > circularBranchFlowTolerance
4032                    } = 1 ;
4033   
4034  *           Check if there are circulating branch flows on HVDC
4035              NorthHVDC(t)
4036                  = sum[ (isl,b,br) $ { (ord(isl) = 2) and
4037                                        busIsland(t,b,isl) and
4038                                        HVDClinkSendingBus(t,br,b) and
4039                                        HVDClink(t,br)
4040                                      }, HVDCLINKFLOW.l(t,br)
4041                       ] ;
4042   
4043              SouthHVDC(t)
4044                  = sum[ (isl,b,br) $ { (ord(isl) = 1) and
4045                                        busIsland(t,b,isl) and
4046                                        HVDClinkSendingBus(t,br,b) and
4047                                        HVDClink(t,br)
4048                                      }, HVDCLINKFLOW.l(t,br)
4049                       ] ;
4050   
4051              circularBranchFlowExist(t,br)
4052                  $ { HVDClink(t,br) and LossBranch(t,br) and
4053                     (NorthHVDC(t) > circularBranchFlowTolerance) and
4054                     (SouthHVDC(t) > circularBranchFlowTolerance)
4055                    } = 1 ;
4056   
4057  *           Check if there are non-physical losses on HVDC links
4058              ManualBranchSegmentMWFlow(LossBranch(HVDClink(t,br)),los,fd)
4059                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
4060                  and validLossSegment(t,br,los,fd) }
4061                  = Min[ Max( 0,
4062                              [ abs(HVDCLINKFLOW.l(HVDClink))
4063                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
4064                              ]
4065                            ),
4066                         ( LossSegmentMW(HVDClink,los,fd)
4067                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
4068                         )
4069                       ] ;
4070   
4071              ManualLossCalculation(LossBranch(HVDClink(t,br)))
4072                  = sum[ (los,fd) $ validLossSegment(t,br,los,fd)
4073                                  , LossSegmentFactor(HVDClink,los,fd)
4074                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
4075                       ] ;
4076   
4077              NonPhysicalLossExist(LossBranch(HVDClink(t,br)))
4078                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
4079                         - ManualLossCalculation(HVDClink)
4080                         ) > NonPhysicalLossTolerance
4081                    } = 1 ;
4082   
4083  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
4084  *           and non-physical loss branches exceeds the specified tolerance
4085              useBranchFlowMIP(t)
4086                  $ { ( sum[ br $ { ACbranch(t,br) and LossBranch(t,br) }
4087                                , resolveCircularBranchFlows
4088                                * circularBranchFlowExist(t,br)
4089                           ]
4090                      + sum[ br $ { HVDClink(t,br) and LossBranch(t,br) }
4091                                , resolveCircularBranchFlows
4092                                * circularBranchFlowExist(t,br)
4093                                + resolveHVDCnonPhysicalLosses
4094                                * NonPhysicalLossExist(t,br)
4095                           ]
4096                      + sum[ pole, resolveCircularBranchFlows
4097                                 * poleCircularBranchFlowExist(t,pole)
4098                           ]
4099                       ) > UseBranchFlowMIPTolerance
4100                    } = 1 ;
4101   
4102  *       Check if there is no branch circular flow and non-physical losses end
4103          );
4104   
4105  *       A period is unsolved if MILP model is required
4106          unsolvedDT(t) = yes $ UseBranchFlowMIP(t) ;
4107   
4108  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
4109          loop( unsolvedDT(t),
4110              if( UseBranchFlowMIP(t) >= 1,
4111                  VSPDModel(t) = 1;
4112                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 requires a '
4113                               'vSPD_BranchFlowMIP resolve for period '
4114                               t.tl '. Switching Vectorisation OFF.'/
4115              ) ;
4116   
4117          ) ;
4118   
4119          sequentialSolve $ Sum[ unsolvedDT(t), 1 ] = 1 ;
4120          exitLoop = 1 $ Sum[ unsolvedDT(t), 1 ];
4121   
4122  *   Check if the LP results are valid end
4123      ) ;
4124   
4125  * End of the solve vSPD loop
4126    ] ;
4127  * End of the While loop
4128  );
4129   
4130   
4131  * Real Time Pricing - Second RTD load calculation
4132   
4133  *   Calculate Island-level MW losses used to calculate the Island-level load
4134  *   forecast from the InputIPS and the IslandPSD.
4135  *   2nd solve loop --> SystemLosses as calculated in section 8.1'
4136      LoadCalcLosses(t,isl)
4137          = Sum[ (br,frB,toB)
4138               $ { ACbranch(t,br) and busIsland(t,toB,isl)
4139               and branchBusDefn(t,br,frB,toB)
4140                 }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(t,br,fd) ]
4141                  + branchFixedLoss(t,br)
4142               ]
4143   
4144          + Sum[ (br,frB,toB) $ { HVDClink(t,br) and
4145                                  branchBusDefn(t,br,frB,toB) and
4146                                  ( busIsland(t,toB,isl) or
4147                                    busIsland(t,frB,isl)
4148                                  )
4149                                }, 0.5 * branchFixedLoss(t,br)
4150               ]
4151          + Sum[ (br,frB,toB) $ { HVDClink(t,br) and
4152                                  branchBusDefn(t,br,frB,toB) and
4153                                  busIsland(t,toB,isl) and
4154                                  (not (busIsland(t,frB,isl)))
4155                                }, HVDCLINKLOSSES.l(t,br)
4156               ]
4157            ;
4158   
4159  *   Check if vSPD LoadCalcLosses = SPD LoadCalcLosses
4160  *   if not, let's just use SPD LoadCalcLosses
4161      loop ( (t,isl),
4162          if ( ( SPDLoadCalcLosses(t,isl) > 0 )
4163           and ( abs( SPDLoadCalcLosses(t,isl)-LoadCalcLosses(t,isl) )>0.001 ) ,
4164   
4165              putclose rep 'Recalulated losses for ' isl.tl ' are different '
4166                           'between vSPD (' LoadCalcLosses(t,isl):<7:4
4167                           ') and SPD (' SPDLoadCalcLosses(t,isl):<7:4
4168                           '). We use SPD number instead' / ;
4169             LoadCalcLosses(t,isl) = SPDLoadCalcLosses(t,isl) ;
4170   
4171          );
4172      );
4173   
4174   
4175  *   Calculate first target total load [4.10.6.5]
4176  *   Island-level MW load forecast. For the second loop:
4177  *   replace LoadCalcLosses(tp,isl) = islandLosses(tp,isl);
4178      TargetTotalLoad(t,isl) = islandMWIPS(t,isl)
4179                             + islandPDS(t,isl)
4180                             - LoadCalcLosses(t,isl) ;
4181   
4182  *   Flag if estimate load is scalable [4.10.6.7]
4183  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
4184  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
4185  *   assigned directly to EstimatedInitialLoad
4186      EstLoadIsScalable(t,n) =  1 $ { (LoadIsNCL(t,n) = 0)
4187                                       and (ConformingFactor(t,n) > 0) } ;
4188   
4189  *   Calculate estimate non-scalable load 4.10.6.8]
4190  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
4191  *   conforming Pnode this will be the ConformingFactor MW input if that value is
4192  *   negative, otherwise it will be zero
4193      EstNonScalableLoad(t,n) $ ( LoadIsNCL(t,n) = 1 ) = NonConformingLoad(t,n);
4194      EstNonScalableLoad(t,n) $ ( LoadIsNCL(t,n) = 0 ) = ConformingFactor(t,n);
4195      EstNonScalableLoad(t,n) $ ( EstLoadIsScalable(t,n) = 1 ) = 0;
4196   
4197  *   Calculate estimate scalable load [4.10.6.10]
4198  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
4199  *   this value will be the ConformingFactor if it is non-negative, otherwise this
4200  *   value will be zero'
4201      EstScalableLoad(t,n) $ ( EstLoadIsScalable(t,n) = 1 ) = ConformingFactor(t,n);
4202   
4203   
4204  *   Calculate Scaling applied to ConformingFactor load MW [4.10.6.9]
4205  *   in order to calculate EstimatedInitialLoad
4206      EstScalingFactor(t,isl)
4207          = (islandMWIPS(t,isl) - LoadCalcLosses(t,isl)
4208            - Sum[ n $ nodeIsland(t,n,isl), EstNonScalableLoad(t,n) ]
4209            ) / Sum[ n $ nodeIsland(t,n,isl), EstScalableLoad(t,n) ]
4210   
4211          ;
4212   
4213  *   Calculate estimate initial load [4.10.6.6]
4214  *   Calculated estimate of initial MW load, available to be used as an
4215  *   alternative to InputInitialLoad
4216      EstimatedInitialLoad(t,n) $ ( EstLoadIsScalable(t,n) = 1 )
4217          = ConformingFactor(t,n) * Sum[ isl $ nodeisland(t,n,isl)
4218                                            , EstScalingFactor(t,isl)] ;
4219  * TN- There is a bug in this equarion
4220      EstimatedInitialLoad(t,n) $ ( EstLoadIsScalable(t,n) = 0 )
4221  *        = NonConformingLoad(t,n);
4222          = EstNonScalableLoad(t,n);
4223   
4224  *   Calculate initial load [4.10.6.2]
4225  *   Value that represents the Pnode load MW at the start of the solution
4226  *   interval. Depending on the inputs this value will be either actual load,
4227  *   an operator applied override or an estimated initial load
4228      InitialLoad(t,n) = InputInitialLoad(t,n);
4229      InitialLoad(t,n) $ { (LoadIsOverride(t,n) = 0)
4230                            and ( (useActualLoad(t) = 0)
4231                               or (LoadIsBad(t,n) = 1) )
4232                              } = EstimatedInitialLoad(t,n) ;
4233   
4234  *   Flag if load is scalable [4.10.6.4]
4235  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
4236  *   calculate RequiredLoad, if False then Pnode InitialLoad will be directly
4237  *   assigned to RequiredLoad
4238      LoadIsScalable(t,n) = 1 $ { (LoadIsNCL(t,n) = 0)
4239                                   and (LoadIsOverride(t,n) = 0)
4240                                   and (InitialLoad(t,n) >= 0) } ;
4241   
4242  *   Calculate Island-level scaling factor [4.10.6.3]
4243  *   --> applied to InitialLoad in order to calculate RequiredLoad
4244      LoadScalingFactor(t,isl)
4245          = ( TargetTotalLoad(t,isl)
4246            - Sum[ n $ { nodeIsland(t,n,isl)
4247                     and (LoadIsScalable(t,n) = 0) }, InitialLoad(t,n) ]
4248            ) / Sum[ n $ { nodeIsland(t,n,isl)
4249                       and (LoadIsScalable(t,n) = 1) }, InitialLoad(t,n) ]
4250          ;
4251   
4252  *   Calculate RequiredLoad [4.10.6.1]
4253      RequiredLoad(t,n) $ LoadIsScalable(t,n)
4254          = InitialLoad(t,n) * sum[ isl $ nodeisland(t,n,isl)
4255                                   , LoadScalingFactor(t,isl) ];
4256   
4257      RequiredLoad(t,n) $ (LoadIsScalable(t,n) = 0) = InitialLoad(t,n);
4258   
4259      RequiredLoad(t,n) = RequiredLoad(t,n)
4260                       + [instructedloadshed(t,n) $ instructedshedactive(t,n)] ;
4261   
4262   
4263  * Recalculate energy scarcity limits -------------------------------------------
4264  ScarcityEnrgLimit(t,n,blk) = 0 ;
4265   
4266  ScarcityEnrgLimit(t,n,blk) $ energyScarcityEnabled(t)
4267      = scarcityEnrgNodeLimit(t,n,blk);
4268   
4269  ScarcityEnrgLimit(t,n,blk)
4270      $ { energyScarcityEnabled(t)
4271      and (sum[blk1, ScarcityEnrgLimit(t,n,blk1)] = 0 )
4272      and (RequiredLoad(t,n) > 0)
4273        }
4274      = scarcityEnrgNodeFactor(t,n,blk) * RequiredLoad(t,n);
4275   
4276  ScarcityEnrgLimit(t,n,blk)
4277      $ { energyScarcityEnabled(t)
4278      and (sum[blk1, ScarcityEnrgLimit(t,n,blk1)] = 0 )
4279      and (RequiredLoad(t,n) > 0)
4280        }
4281      = scarcityEnrgNationalFactor(t,blk) * RequiredLoad(t,n);
4282  *-------------------------------------------------------------------------------
4283   
4284   
4285   
4286  *   Update Free Reserve and SharedNFRmax
4287  *   Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (4.5.1.2)
4288      sharedNFRLoad(t,isl)
4289          = sum[ nodeIsland(t,n,isl), RequiredLoad(t,n)]
4290          + sum[ (bd,blk) $ bidIsland(t,bd,isl), DemBidMW(t,bd,blk) ]
4291          - sharedNFRLoadOffset(t,isl) ;
4292   
4293      sharedNFRMax(t,isl) = Min{ RMTReserveLimitTo(t,isl,'FIR'),
4294                                 sharedNFRFactor(t)*sharedNFRLoad(t,isl) } ;
4295   
4296  *   Risk parameters
4297      FreeReserve(t,isl,resC,riskC)
4298          = riskParameter(t,isl,resC,riskC,'freeReserve')
4299  *   NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4300          - sum[ isl1 $ (not sameas(isl,isl1)),sharedNFRMax(t,isl1)
4301               ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4302                 and (inputGDXGDate >= jdate(2016,10,20)) }
4303      ;
4304   
4305  *   6.5.2.3 Total shared NFR is capped by shared NFR max
4306      SHAREDNFR.up(t,isl) = Max[0,sharedNFRMax(t,isl)] ;
4307   
4308  *);
4309   
4310   
4311   
4312  ) ;
4313   
4314   
4315  unsolvedDT(dt) = yes;
4316  VSPDModel(dt) = 0 ;
4317  option clear = useBranchFlowMIP ;
4318   
4319  While ( Sum[ dt $ unsolvedDT(dt), 1 ],
4320    exitLoop = 0;
4321    loop[ dt $ {unsolvedDT(dt) and (exitLoop = 0)},
4322   
4323  *   7a. Reset all sets, parameters and variables -------------------------------
4324      option clear = t ;
4325  *   Generation variables
4326      option clear = GENERATION ;
4327      option clear = GENERATIONBLOCK ;
4328      option clear = GENERATIONUPDELTA ;
4329      option clear = GENERATIONDNDELTA ;
4330  *   Purchase variables
4331      option clear = PURCHASE ;
4332      option clear = PURCHASEBLOCK ;
4333  *   Network variables
4334      option clear = ACNODENETINJECTION ;
4335      option clear = ACNODEANGLE ;
4336      option clear = ACBRANCHFLOW ;
4337      option clear = ACBRANCHFLOWDIRECTED ;
4338      option clear = ACBRANCHLOSSESDIRECTED ;
4339      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4340      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4341      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4342      option clear = HVDCLINKFLOW ;
4343      option clear = HVDCLINKLOSSES ;
4344      option clear = LAMBDA ;
4345      option clear = LAMBDAINTEGER ;
4346      option clear = HVDCLINKFLOWDIRECTED_INTEGER ;
4347      option clear = HVDCPOLEFLOW_INTEGER ;
4348  *   Risk/Reserve variables
4349      option clear = RISKOFFSET ;
4350      option clear = HVDCREC ;
4351      option clear = ISLANDRISK ;
4352      option clear = RESERVEBLOCK ;
4353      option clear = RESERVE ;
4354      option clear = ISLANDRESERVE;
4355  *   NMIR variables
4356      option clear = SHAREDNFR ;
4357      option clear = SHAREDRESERVE ;
4358      option clear = HVDCSENT ;
4359      option clear = RESERVESHAREEFFECTIVE ;
4360      option clear = RESERVESHARERECEIVED ;
4361      option clear = RESERVESHARESENT ;
4362      option clear = HVDCSENDING ;
4363      option clear = INZONE ;
4364      option clear = HVDCSENTINSEGMENT ;
4365      option clear = HVDCRESERVESENT ;
4366      option clear = HVDCSENTLOSS ;
4367      option clear = HVDCRESERVELOSS ;
4368      option clear = LAMBDAHVDCENERGY ;
4369      option clear = LAMBDAHVDCRESERVE ;
4370      option clear = RESERVESHAREPENALTY ;
4371  *   Objective
4372      option clear = NETBENEFIT ;
4373  *   Violation variables
4374      option clear = TOTALPENALTYCOST ;
4375      option clear = DEFICITBUSGENERATION ;
4376      option clear = SURPLUSBUSGENERATION ;
4377      option clear = DEFICITRESERVE_CE ;
4378      option clear = DEFICITRESERVE_ECE ;
4379      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4380      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4381      option clear = DEFICITRAMPRATE ;
4382      option clear = SURPLUSRAMPRATE ;
4383      option clear = DEFICITBRANCHFLOW ;
4384      option clear = SURPLUSBRANCHFLOW ;
4385      option clear = DEFICITMNODECONSTRAINT ;
4386      option clear = SURPLUSMNODECONSTRAINT ;
4387   
4388      option clear = SCARCITYCOST;
4389      option clear = ENERGYSCARCITYBLK ;
4390      option clear = ENERGYSCARCITYNODE;
4391   
4392      option clear = RESERVESHORTFALLBLK;
4393      option clear = RESERVESHORTFALL;
4394      option clear = RESERVESHORTFALLUNITBLK;
4395      option clear = RESERVESHORTFALLUNIT;
4396      option clear = RESERVESHORTFALLGROUPBLK;
4397      option clear = RESERVESHORTFALLGROUP;
4398   
4399  *   Clear the pole circular branch flow flag
4400      option clear = circularBranchFlowExist ;
4401      option clear = poleCircularBranchFlowExist ;
4402      option clear = northHVDC ;
4403      option clear = southHVDC ;
4404      option clear = manualBranchSegmentMWFlow ;
4405      option clear = manualLossCalculation ;
4406      option clear = nonPhysicalLossExist ;
4407      option clear = modelSolved ;
4408      option clear = LPmodelSolved ;
4409  *   Disconnected bus post-processing
4410      option clear = busGeneration ;
4411      option clear = busLoad ;
4412      option clear = busDisconnected ;
4413      option clear = busPrice ;
4414   
4415   
4416  *   End reset
4417   
4418   
4419  *   7b. Initialise current trade period and model data -------------------------
4420      t(dt)  $ sequentialSolve       = yes;
4421      t(dt1) $ (not sequentialSolve) = yes;
4422   
4423  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4424      generationStart(offer(t(dt),o))
4425          $ (sum[ o1, generationStart(dt,o1)] = 0)
4426          = sum[ dt1 $ (ord(dt1) = ord(dt)-1), o_offerEnergy_TP(dt1,o) ] ;
4427   
4428  *   Additional pre-processing on parameters end
4429   
4430   
4431  *   7c. Updating the variable bounds before model solve ------------------------
4432   
4433  * TN - Pivot or Demand Analysis - revise input data
4436  * TN - Pivot or Demand Analysis - revise input data end
4437   
4438  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4439   
4440  *   Offer blocks - Constraint 6.1.1.1
4441      GENERATIONBLOCK.up(genOfrBlk(t,o,blk))
4442          = EnrgOfrMW(genOfrBlk) ;
4443   
4444      GENERATIONBLOCK.fx(t,o,blk)
4445          $ (not genOfrBlk(t,o,blk)) = 0 ;
4446   
4447  *   Constraint 6.1.1.2 - Fix the invalid generation to Zero
4448      GENERATION.fx(offer(t,o)) $ (not posEnrgOfr(offer)) = 0 ;
4449   
4450  *   Constraint 6.1.1.3 - Set Upper Bound for intermittent generation
4451      GENERATION.up(offer(t,o))
4452          $ { windOffer(offer) and priceResponsive(offer) }
4453          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4454   
4455  *   Constraint 6.1.1.4 - Set Upper/Lower Bound for Positive Demand Bid
4456      PURCHASEBLOCK.up(demBidBlk(t,bd,blk))
4457          = DemBidMW(t,bd,blk) $ [DemBidMW(t,bd,blk)>0];
4458   
4459      PURCHASEBLOCK.lo(demBidBlk(t,bd,blk))
4460          = 0 $ [DemBidMW(t,bd,blk)>0];
4461   
4462  *   Constraint 6.1.1.5 - Set Upper/Lower Bound for Negativetive Demand Bid
4463      PURCHASEBLOCK.up(demBidBlk(t,bd,blk)) $ [DemBidMW(t,bd,blk)<0] = 0;
4464   
4465      PURCHASEBLOCK.lo(demBidBlk(t,bd,blk))
4466          = DemBidMW(t,bd,blk) $ [DemBidMW(t,bd,blk)<0];
4467   
4468      PURCHASEBLOCK.fx(t,bd,blk)
4469          $ (not demBidBlk(t,bd,blk))
4470          = 0 ;
4471   
4472      PURCHASE.fx(t,bd) $ (sum[blk $ demBidBlk(t,bd,blk), 1] = 0) = 0 ;
4473   
4474  *   Constraint 6.1.1.7 - Set Upper Bound for Energy Scaricty Block
4475      ENERGYSCARCITYBLK.up(t,n,blk) = ScarcityEnrgLimit(t,n,blk) ;
4476      ENERGYSCARCITYBLK.fx(t,n,blk) $ (not EnergyScarcityEnabled(t)) = 0;
4477      ENERGYSCARCITYNODE.fx(t,n) $ (not EnergyScarcityEnabled(t)) = 0;
4478   
4479  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4480   
4481   
4482  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4483   
4484  *   Ensure that variables used to specify flow and losses on HVDC link are
4485  *   zero for AC branches and for open HVDC links.
4486      HVDCLINKFLOW.fx(t,br)   $ (not HVDClink(t,br)) = 0 ;
4487      HVDCLINKLOSSES.fx(t,br) $ (not HVDClink(t,br)) = 0 ;
4488   
4489  *   Apply an upper bound on the weighting parameter based on its definition
4490      LAMBDA.up(branch,bp) = 1 ;
4491   
4492  *   Ensure that the weighting factor value is zero for AC branches and for
4493  *   invalid loss segments on HVDC links
4494      LAMBDA.fx(HVDClink,bp)
4495          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
4496      LAMBDA.fx(t,br,bp) $ (not HVDClink(t,br)) = 0 ;
4497   
4498  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4499   
4500   
4501  *======= AC TRANSMISSION EQUATIONS =============================================
4502   
4503  *   Ensure that variables used to specify flow and losses on AC branches are
4504  *   zero for HVDC links branches and for open AC branches
4505      ACBRANCHFLOW.fx(t,br)              $ (not ACbranch(t,br)) = 0 ;
4506      ACBRANCHFLOWDIRECTED.fx(t,br,fd)   $ (not ACbranch(t,br)) = 0 ;
4507      ACBRANCHLOSSESDIRECTED.fx(t,br,fd) $ (not ACbranch(t,br)) = 0 ;
4508   
4509  *   Ensure directed block flow and loss block variables are zero for
4510  *   non-AC branches and invalid loss segments on AC branches
4511     ACBRANCHFLOWBLOCKDIRECTED.fx(t,br,los,fd)
4512         $ { not(ACbranch(t,br) and validLossSegment(t,br,los,fd)) } = 0 ;
4513   
4514     ACBRANCHLOSSESBLOCKDIRECTED.fx(t,br,los,fd)
4515         $ { not(ACbranch(t,br) and validLossSegment(t,br,los,fd)) } = 0 ;
4516   
4517   
4518  *   Constraint 6.4.1.10 - Ensure that the bus voltage angle for the buses
4519  *   corresponding to the reference nodes are set to zero
4520      ACNODEANGLE.fx(t,b)
4521         $ sum[ n $ { NodeBus(t,n,b) and  refNode(t,n) }, 1 ] = 0 ;
4522   
4523  *======= AC TRANSMISSION EQUATIONS END =========================================
4524   
4525   
4526  *======= RISK & RESERVE EQUATIONS ==============================================
4527   
4528  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4529      RESERVEBLOCK.fx(offer(t,o),blk,resC,resT)
4530          $ (not resOfrBlk(offer,blk,resC,resT)) = 0 ;
4531   
4532  *   Reserve block maximum for offers and purchasers - Constraint 6.5.3.2.
4533      RESERVEBLOCK.up(resOfrBlk(t,o,blk,resC,resT))
4534          = ResOfrMW(resOfrBlk) ;
4535   
4536  *   Fix the reserve variable for invalid reserve offers. These are offers that
4537  *   are either not connected to the grid or have no reserve quantity offered.
4538      RESERVE.fx(t,o,resC,resT)
4539          $ (not sum[ blk $ resOfrBlk(t,o,blk,resC,resT), 1 ] ) = 0 ;
4540   
4541  *   NMIR project variables
4542      HVDCSENT.fx(t,isl) $ (HVDCCapacity(t,isl) = 0) = 0 ;
4543      HVDCSENTLOSS.fx(t,isl) $ (HVDCCapacity(t,isl) = 0) = 0 ;
4544   
4545  *   Total shared NFR is capped by shared NFR max(6.5.2.3)
4546      SHAREDNFR.up(t,isl) = Max[0,sharedNFRMax(t,isl)] ;
4547   
4548  *   No forward reserve sharing if HVDC capacity is zero
4549      RESERVESHARESENT.fx(t,isl,resC,rd)
4550          $ { (HVDCCapacity(t,isl) = 0) and (ord(rd) = 1) } = 0 ;
4551   
4552  *   No forward reserve sharing if reserve sharing is disabled
4553      RESERVESHARESENT.fx(t,isl,resC,rd)
4554          $ (reserveShareEnabled(t,resC)=0) = 0;
4555   
4556  *   No reserve sharing to cover HVDC risk
4557      RESERVESHAREEFFECTIVE.fx(t,isl,resC,HVDCrisk) = 0;
4558      RESERVESHAREEFFECTIVE.fx(t,isl,resC,HVDCsecRisk) = 0;
4559   
4560  *   (6.5.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4561      INZONE.fx(t,isl,resC,z)
4562          $ {(ord(z) = 1) and (not reserveRoundPower(t,resC))} = 0;
4563   
4564  *   (6.5.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
4565      INZONE.fx(t,isl,resC,z)
4566          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(t,resC)} = 0;
4567   
4568  *   Fixing Lambda integer variable for energy sent
4569      LAMBDAHVDCENERGY.fx(t,isl,bp) $ { (HVDCCapacity(t,isl) = 0)
4570                                          and (ord(bp) = 1) } = 1 ;
4571   
4572      LAMBDAHVDCENERGY.fx(t,isl,bp) $ (ord(bp) > 7) = 0 ;
4573   
4574  * To be reviewed NMIR
4575      LAMBDAHVDCRESERVE.fx(t,isl,resC,rd,rsbp)
4576          $ { (HVDCCapacity(t,isl) = 0)
4577          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
4578   
4579      LAMBDAHVDCRESERVE.fx(t,isl1,resC,rd,rsbp)
4580          $ { (sum[ isl $ (not sameas(isl,isl1)), HVDCCapacity(t,isl) ] = 0)
4581          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
4582   
4583  *   Contraint 6.5.4.2 - Set Upper Bound for reserve shortfall
4584      RESERVESHORTFALLBLK.up(t,isl,resC,riskC,blk)
4585          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
4586      RESERVESHORTFALLBLK.fx(t,isl,resC,riskC,blk)
4587          $ (not reserveScarcityEnabled(t)) = 0;
4588      RESERVESHORTFALL.fx(t,isl,resC,riskC)
4589          $ (not reserveScarcityEnabled(t)) = 0;
4590   
4591      RESERVESHORTFALLUNITBLK.up(t,isl,o,resC,riskC,blk)
4592          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
4593      RESERVESHORTFALLUNITBLK.fx(t,isl,o,resC,riskC,blk)
4594          $ (not reserveScarcityEnabled(t)) = 0;
4595      RESERVESHORTFALLUNIT.fx(t,isl,o,resC,riskC)
4596          $ (not reserveScarcityEnabled(t)) = 0;
4597   
4598      RESERVESHORTFALLGROUPBLK.up(t,isl,rg,resC,riskC,blk)
4599          = scarcityResrvIslandLimit(t,isl,resC,blk) $ reserveScarcityEnabled(t);
4600      RESERVESHORTFALLGROUPBLK.fx(t,isl,rg,resC,riskC,blk)
4601          $ (not reserveScarcityEnabled(t)) = 0;
4602      RESERVESHORTFALLGROUP.fx(t,isl,rg,resC,riskC)
4603          $ (not reserveScarcityEnabled(t)) = 0;
4604  ;
4605   
4606   
4607  *======= RISK & RESERVE EQUATIONS END ==========================================
4608   
4609   
4610  *   Updating the variable bounds before model solve end
4611   
4612   
4613  *   7d. Solve Models
4614   
4615  *   Solve the LP model ---------------------------------------------------------
4616      if( (Sum[t, VSPDModel(t)] = 0),
4617   
4618          if( UseShareReserve,
4619              option bratio = 1 ;
4620              vSPD_NMIR.Optfile = 1 ;
4621              vSPD_NMIR.optcr = MIPOptimality ;
4622              vSPD_NMIR.reslim = MIPTimeLimit ;
4623              vSPD_NMIR.iterlim = MIPIterationLimit ;
4624              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
4625  *           Set the model solve status
4626              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
4627                                 or (vSPD_NMIR.modelstat = 8) )
4628                              and ( vSPD_NMIR.solvestat = 1 ) } ;
4629          else
4630              option bratio = 1 ;
4631              vSPD.reslim = LPTimeLimit ;
4632              vSPD.iterlim = LPIterationLimit ;
4633              solve vSPD using lp maximizing NETBENEFIT ;
4634  *           Set the model solve status
4635              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
4636          )
4637   
4638  *       Post a progress message to the console and for use by EMI.
4639          if((ModelSolved = 1) and (sequentialSolve = 0),
4640              putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 '
4641                           'is solved successfully.'/
4642                           'Objective function value: '
4643                           NETBENEFIT.l:<15:4 /
4644                           'Violation Cost          : '
4645                           TOTALPENALTYCOST.l:<15:4 /
4646          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
4647              putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 '
4648                           'is solved unsuccessfully.'/
4649          ) ;
4650   
4651          if((ModelSolved = 1) and (sequentialSolve = 1),
4652              loop(t,
4653                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
4654                               'is solved successfully.'/
4655                               'Objective function value: '
4656                               NETBENEFIT.l:<15:4 /
4657                               'Violations cost         : '
4658                               TOTALPENALTYCOST.l:<15:4 /
4659              ) ;
4660          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
4661              loop(t,
4662                  unsolvedDT(t) = no;
4663                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
4664                               'is solved unsuccessfully.'/
4665              ) ;
4666   
4667          ) ;
4668  *   Solve the LP model end -----------------------------------------------------
4669   
4670   
4671  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
4672      elseif (Sum[t, VSPDModel(t)] = 1),
4673  *       Fix the values of these integer variables that are not needed
4674          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(t,br),fd)
4675              $ { (not ACbranch(t,br)) or (not LossBranch(branch)) } = 0 ;
4676   
4677  *       Fix the integer AC branch flow variable to zero for invalid branches
4678          ACBRANCHFLOWDIRECTED_INTEGER.fx(t,br,fd)
4679              $ (not branch(t,br)) = 0 ;
4680   
4681  *       Apply an upper bound on the integer weighting parameter
4682          LAMBDAINTEGER.up(branch(t,br),bp) = 1 ;
4683   
4684  *       Ensure that the weighting factor value is zero for AC branches
4685  *       and for invalid loss segments on HVDC links
4686          LAMBDAINTEGER.fx(branch(t,br),bp)
4687              $ { ACbranch(branch)
4688              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
4689                } = 0 ;
4690   
4691  *       Fix the lambda integer variable to zero for invalid branches
4692          LAMBDAINTEGER.fx(t,br,bp) $ (not branch(t,br)) = 0 ;
4693   
4694          option bratio = 1 ;
4695          vSPD_BranchFlowMIP.Optfile = 1 ;
4696          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
4697          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
4698          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
4699          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
4700  *       Set the model solve status
4701          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
4702                                (vSPD_BranchFlowMIP.modelstat = 8)
4703                              ]
4704                              and
4705                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
4706                            } ;
4707   
4708  *       Post a progress message for use by EMI.
4709          if(ModelSolved = 1,
4710   
4711  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
4712              SOS1_solve(t)  = yes;
4713   
4714              loop(t,
4715                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
4716                               'is solved successfully for branch integer.'/
4717                               'Objective function value: '
4718                               NETBENEFIT.l:<15:4 /
4719                               'Violations cost         : '
4720                               TOTALPENALTYCOST.l:<15:4 /
4721              ) ;
4722          else
4723              loop(t,
4724                  unsolvedDT(t) = yes;
4725                  VSPDModel(t) = 2;
4726                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ') '
4727                               'is solved unsuccessfully for branch integer.'/
4728              ) ;
4729          ) ;
4730  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
4731   
4732   
4733  *   Solve the LP model and stop ------------------------------------------------
4734      elseif (Sum[t, VSPDModel(t)] = 2),
4735   
4736          if( UseShareReserve,
4737              option bratio = 1 ;
4738              vSPD_NMIR.Optfile = 1 ;
4739              vSPD_NMIR.optcr = MIPOptimality ;
4740              vSPD_NMIR.reslim = MIPTimeLimit ;
4741              vSPD_NMIR.iterlim = MIPIterationLimit ;
4742              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
4743  *           Set the model solve status
4744              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
4745                                 or (vSPD_NMIR.modelstat = 8) )
4746                              and ( vSPD_NMIR.solvestat = 1 ) } ;
4747          else
4748              option bratio = 1 ;
4749              vSPD.reslim = LPTimeLimit ;
4750              vSPD.iterlim = LPIterationLimit ;
4751              solve vSPD using lp maximizing NETBENEFIT ;
4752  *           Set the model solve status
4753              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
4754          )
4755   
4756  *       Post a progress message for use by EMI.
4757          if( ModelSolved = 1,
4758              loop(t,
4759                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl ')'
4760                                  ' integer resolve was unsuccessful.' /
4761                                  'Reverting back to linear solve and '
4762                                  'solve successfully. ' /
4763                                  'Objective function value: '
4764                                  NETBENEFIT.l:<15:4 /
4765                                  'Violations cost         : '
4766                                  TOTALPENALTYCOST.l:<15:4 /
4767                                  'Solution may have circulating flows '
4768                                  'and/or non-physical losses.' /
4769              ) ;
4770          else
4771              loop(t,
4772                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 (' t.tl
4773                                  ') integer solve was unsuccessful. '
4774                                  'Reverting back to linear solve. '
4775                                  'Linear solve unsuccessful.' /
4776              ) ;
4777          ) ;
4778   
4779          unsolvedDT(t) = no;
4780   
4781  *   Solve the LP model and stop end --------------------------------------------
4782   
4783      ) ;
4784  *   Solve the models end
4785   
4786   
4787   
4788  *   6e. Check if the LP results are valid --------------------------------------
4789      if((ModelSolved = 1),
4790          useBranchFlowMIP(t) = 0 ;
4791  *       Check if there is no branch circular flow and non-physical losses
4792          Loop( t $ (VSPDModel(t)=0) ,
4793   
4794  *           Check if there are circulating branch flows on loss AC branches
4795              circularBranchFlowExist(ACbranch(t,br))
4796                  $ { LossBranch(ACbranch) and
4797                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
4798                        - abs(ACBRANCHFLOW.l(ACbranch))
4799                        ) > circularBranchFlowTolerance
4800                      ]
4801                    } = 1 ;
4802   
4803  *           Determine the circular branch flow flag on each HVDC pole
4804              TotalHVDCpoleFlow(t,pole)
4805                  = sum[ br $ HVDCpoleBranchMap(pole,br)
4806                       , HVDCLINKFLOW.l(t,br) ] ;
4807   
4808              MaxHVDCpoleFlow(t,pole)
4809                  = smax[ br $ HVDCpoleBranchMap(pole,br)
4810                        , HVDCLINKFLOW.l(t,br) ] ;
4811   
4812              poleCircularBranchFlowExist(t,pole)
4813                  $ { ( TotalHVDCpoleFlow(t,pole)
4814                      - MaxHVDCpoleFlow(t,pole)
4815                      ) > circularBranchFlowTolerance
4816                    } = 1 ;
4817   
4818  *           Check if there are circulating branch flows on HVDC
4819              NorthHVDC(t)
4820                  = sum[ (isl,b,br) $ { (ord(isl) = 2) and
4821                                        busIsland(t,b,isl) and
4822                                        HVDClinkSendingBus(t,br,b) and
4823                                        HVDClink(t,br)
4824                                      }, HVDCLINKFLOW.l(t,br)
4825                       ] ;
4826   
4827              SouthHVDC(t)
4828                  = sum[ (isl,b,br) $ { (ord(isl) = 1) and
4829                                        busIsland(t,b,isl) and
4830                                        HVDClinkSendingBus(t,br,b) and
4831                                        HVDClink(t,br)
4832                                      }, HVDCLINKFLOW.l(t,br)
4833                       ] ;
4834   
4835              circularBranchFlowExist(t,br)
4836                  $ { HVDClink(t,br) and LossBranch(t,br) and
4837                     (NorthHVDC(t) > circularBranchFlowTolerance) and
4838                     (SouthHVDC(t) > circularBranchFlowTolerance)
4839                    } = 1 ;
4840   
4841  *           Check if there are non-physical losses on HVDC links
4842              ManualBranchSegmentMWFlow(LossBranch(HVDClink(t,br)),los,fd)
4843                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
4844                  and validLossSegment(t,br,los,fd) }
4845                  = Min[ Max( 0,
4846                              [ abs(HVDCLINKFLOW.l(HVDClink))
4847                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
4848                              ]
4849                            ),
4850                         ( LossSegmentMW(HVDClink,los,fd)
4851                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
4852                         )
4853                       ] ;
4854   
4855              ManualLossCalculation(LossBranch(HVDClink(t,br)))
4856                  = sum[ (los,fd) $ validLossSegment(t,br,los,fd)
4857                                  , LossSegmentFactor(HVDClink,los,fd)
4858                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
4859                       ] ;
4860   
4861              NonPhysicalLossExist(LossBranch(HVDClink(t,br)))
4862                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
4863                         - ManualLossCalculation(HVDClink)
4864                         ) > NonPhysicalLossTolerance
4865                    } = 1 ;
4866   
4867  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
4868  *           and non-physical loss branches exceeds the specified tolerance
4869              useBranchFlowMIP(t)
4870                  $ { ( sum[ br $ { ACbranch(t,br) and LossBranch(t,br) }
4871                                , resolveCircularBranchFlows
4872                                * circularBranchFlowExist(t,br)
4873                           ]
4874                      + sum[ br $ { HVDClink(t,br) and LossBranch(t,br) }
4875                                , resolveCircularBranchFlows
4876                                * circularBranchFlowExist(t,br)
4877                                + resolveHVDCnonPhysicalLosses
4878                                * NonPhysicalLossExist(t,br)
4879                           ]
4880                      + sum[ pole, resolveCircularBranchFlows
4881                                 * poleCircularBranchFlowExist(t,pole)
4882                           ]
4883                       ) > UseBranchFlowMIPTolerance
4884                    } = 1 ;
4885   
4886  *       Check if there is no branch circular flow and non-physical losses end
4887          );
4888   
4889  *       A period is unsolved if MILP model is required
4890          unsolvedDT(t) = yes $ UseBranchFlowMIP(t) ;
4891   
4892  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
4893          loop( unsolvedDT(t),
4894              if( UseBranchFlowMIP(t) >= 1,
4895                  VSPDModel(t) = 1;
4896                  putclose rep 'The case: RTD_202210101250_91012022102350483_20221010124902 requires a '
4897                                      'vSPD_BranchFlowMIP resolve for period '
4898                                      t.tl '. Switching Vectorisation OFF.'/
4899              ) ;
4900   
4901          ) ;
4902   
4903          sequentialSolve $ Sum[ unsolvedDT(t), 1 ] = 1 ;
4904          exitLoop = 1 $ Sum[ unsolvedDT(t), 1 ];
4905   
4906  *   Check if the LP results are valid end
4907      ) ;
4908   
4909   
4910   
4911  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
4912   
4913  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
4914  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
4935   
4936      busGeneration(bus(t,b))
4937          = sum[ (o,n) $ { offerNode(t,o,n) and NodeBus(t,n,b) }
4938               , NodeBusAllocationFactor(t,n,b) * GENERATION.l(t,o)
4939               ] ;
4940   
4941      busLoad(bus(t,b))
4942          = sum[ NodeBus(t,n,b)
4943               , NodeBusAllocationFactor(t,n,b) * RequiredLoad(t,n)
4944               ] ;
4945   
4946      busPrice(bus(t,b)) = ACnodeNetInjectionDefinition2.m(t,b) ;
4947   
4948      if((disconnectedNodePriceCorrection = 1),
4949  *       Post-MSP cases
4950  *       Scenario C/F/G/H/I:
4951          busDisconnected(bus(t,b)) $ { (busLoad(bus) = 0)
4952                                        and (busElectricalIsland(bus) = 0)
4953                                      } = 1 ;
4954  *       Scenario E:
4955          busDisconnected(bus(t,b))
4956              $ { ( sum[ b1 $ { busElectricalIsland(t,b1)
4957                              = busElectricalIsland(bus) }
4958                       , busLoad(t,b1) ] = 0
4959                  ) and
4960                  ( busElectricalIsland(bus) > 0 )
4961                } = 1 ;
4962  *       Set prices at dead buses with non-zero load
4963          busPrice(bus(t,b)) $ { (busLoad(bus) > 0) and
4964                                 (busElectricalIsland(bus)= 0)
4965                               } = DeficitBusGenerationPenalty ;
4966   
4967          busPrice(bus(t,b)) $ { (busLoad(bus) < 0) and
4968                                 (busElectricalIsland(bus)= 0)
4969                               } = -SurplusBusGenerationPenalty ;
4970   
4971  *       Set price at identified disconnected buses to 0
4972          busPrice(bus)$busDisconnected(bus) = 0 ;
4973      ) ;
4974   
4975  * End Check for disconnected nodes and adjust prices accordingly
4976   
4977  * TN - Replacing invalid prices after SOS1
4978  *   6f0. Replacing invalid prices after SOS1 (7.1.3)----------------------------
4979      if ( SOS1_solve(dt),
4980           busSOSinvalid(dt,b)
4981             = 1 $ { [ ( busPrice(dt,b) = 0 )
4982                      or ( busPrice(dt,b) > 0.9 * deficitBusGenerationPenalty )
4983                      or ( busPrice(dt,b) < -0.9 * surplusBusGenerationPenalty )
4984                       ]
4985                   and bus(dt,b)
4986                   and [ not busDisconnected(dt,b) ]
4987                   and [ busLoad(dt,b) = busGeneration(dt,b) ]
4988                   and [ sum[(br,fd)
4989                            $ { BranchBusConnect(dt,br,b) and branch(dt,br) }
4990                            , ACBRANCHFLOWDIRECTED.l(dt,br,fd)
4991                            ] = 0
4992                       ]
4993                   and [ sum[ br
4994                            $ { BranchBusConnect(dt,br,b) and branch(dt,br) }
4995                            , 1
4996                            ] > 0
4997                       ]
4998                     };
4999          numberofbusSOSinvalid(dt) = 2*sum[b, busSOSinvalid(dt,b)];
5000          While ( sum[b, busSOSinvalid(dt,b)] < numberofbusSOSinvalid(dt) ,
5001              numberofbusSOSinvalid(dt) = sum[b, busSOSinvalid(dt,b)];
5002              busPrice(dt,b)
5003                $ { busSOSinvalid(dt,b)
5004                and ( sum[ b1 $ { [ not busSOSinvalid(dt,b1) ]
5005                              and sum[ br $ { branch(dt,br)
5006                                          and BranchBusConnect(dt,br,b)
5007                                          and BranchBusConnect(dt,br,b1)
5008                                            }, 1
5009                                     ]
5010                               }, 1
5011                         ] > 0
5012                    )
5013                  }
5014                = sum[ b1 $ { [ not busSOSinvalid(dt,b1) ]
5015                          and sum[ br $ { branch(dt,br)
5016                                      and BranchBusConnect(dt,br,b)
5017                                      and BranchBusConnect(dt,br,b1)
5018                                        }, 1 ]
5019                            }, busPrice(dt,b1)
5020                     ]
5021                / sum[ b1 $ { [ not busSOSinvalid(dt,b1) ]
5022                          and sum[ br $ { branch(dt,br)
5023                                      and BranchBusConnect(dt,br,b)
5024                                      and BranchBusConnect(dt,br,b1)
5025                                        }, 1 ]
5026                            }, 1
5027                     ];
5028   
5029              busSOSinvalid(dt,b)
5030                = 1 $ { [ ( busPrice(dt,b) = 0 )
5031                       or ( busPrice(dt,b) > 0.9 * deficitBusGenerationPenalty )
5032                       or ( busPrice(dt,b) < -0.9 * surplusBusGenerationPenalty )
5033                        ]
5034                    and bus(dt,b)
5035                    and [ not busDisconnected(dt,b) ]
5036                    and [ busLoad(dt,b) = busGeneration(dt,b) ]
5037                    and [ sum[(br,fd)
5038                            $ { BranchBusConnect(dt,br,b) and branch(dt,br) }
5039                            , ACBRANCHFLOWDIRECTED.l(dt,br,fd)
5040                             ] = 0
5041                        ]
5042                    and [ sum[ br
5043                             $ { BranchBusConnect(dt,br,b) and branch(dt,br) }
5044                             , 1
5045                             ] > 0
5046                        ]
5047                      };
5048           );
5049      );
5050  *   End Replacing invalid prices after SOS1 (7.1.3) ----------------------------
5051   
5052   
5053  *   6g. Collect and store results of solved periods into output parameters -----
5054  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
5055   
5058  *   Normal vSPD run - write results out for for reporting
5059      Loop t $ (not unsolvedDT(t)) do
5060  *   Reporting at trading period start
5061  *       Node level output
5062          o_nodeGeneration_TP(t,n) $ Node(t,n)
5063              = sum[ o $ offerNode(t,o,n), GENERATION.l(t,o) ] ;
5064   
5065          o_nodeLoad_TP(t,n) $ Node(t,n)
5066             = RequiredLoad(t,n)
5067             + Sum[ bd $ bidNode(t,bd,n), PURCHASE.l(t,bd) ];
5068   
5069          o_nodePrice_TP(t,n) $ Node(t,n)
5070              = sum[ b $ NodeBus(t,n,b)
5071                   , NodeBusAllocationFactor(t,n,b) * busPrice(t,b)
5072                    ] ;
5073   
5074          if { runPriceTransfer(t)
5075          and ( (studyMode = 101) or (studyMode = 201) or (studyMode = 130))
5076             }   then
5077              o_nodeDead_TP(t,n)
5078                  = 1 $ ( sum[b $ {NodeBus(t,n,b) and (not busDisconnected(t,b))
5079                                  }, NodeBusAllocationFactor(t,n,b) ] = 0 ) ;
5080   
5081              o_nodeDeadPriceFrom_TP(t,n,n1)
5082                  = 1 $ {o_nodeDead_TP(t,n) and node2node(t,n,n1)};
5083   
5084              o_nodeDeadPrice_TP(t,n) $ o_nodeDead_TP(t,n) = 1;
5085   
5086              While sum[ n $ o_nodeDead_TP(t,n), o_nodeDeadPrice_TP(t,n) ] do
5087                  o_nodePrice_TP(t,n)
5088                      $ { o_nodeDead_TP(t,n) and o_nodeDeadPrice_TP(t,n) }
5089                      = sum[n1 $ o_nodeDeadPriceFrom_TP(t,n,n1)
5090                               , o_nodePrice_TP(t,n1) ] ;
5091   
5092                  o_nodeDeadPrice_TP(t,n)
5093                      = 1 $ sum[n1 $ o_nodeDead_TP(t,n1)
5094                                   , o_nodeDeadPriceFrom_TP(t,n,n1) ];
5095   
5096                  o_nodeDeadPriceFrom_TP(t,n,n2) $ o_nodeDeadPrice_TP(t,n)
5097                      = 1 $ { sum[ n1 $ { node2node(t,n1,n2)
5098                                      and o_nodeDeadPriceFrom_TP(t,n,n1) }, 1 ]
5099                            } ;
5100   
5101                  o_nodeDeadPriceFrom_TP(t,n,n1) $ o_nodeDead_TP(t,n1) = 0 ;
5102   
5103              endwhile
5104          endif;
5105   
5106  *       Offer output
5107          o_offerEnergy_TP(t,o) $ offer(t,o) = GENERATION.l(t,o) ;
5108   
5109          o_offerRes_TP(t,o,resC) $ offer(t,o)
5110              = sum[ resT, RESERVE.l(t,o,resC,resT) ] ;
5111   
5112          o_offerFIR_TP(t,o) $ offer(t,o)
5113              = sum[ resC $ (ord(resC) = 1),o_offerRes_TP(t,o,resC) ] ;
5114   
5115          o_offerSIR_TP(t,o) $ offer(t,o)
5116              = sum[ resC $ (ord(resC) = 2),o_offerRes_TP(t,o,resC) ] ;
5117   
5118  *       Risk group output
5119          o_groupEnergy_TP(t,rg,GenRisk)
5120              = sum[ o $ riskGroupOffer(t,rg,o,GenRisk), o_offerEnergy_TP(t,o) ];
5121   
5122          o_groupFKband_TP(t,rg,GenRisk)
5123              = sum[ o $ riskGroupOffer(t,rg,o,GenRisk), FKBand(t,o) ];
5124   
5125          o_groupRes_TP(t,rg,resC,GenRisk)
5126              = sum[ o $ riskGroupOffer(t,rg,o,GenRisk), o_offerRes_TP(t,o,resC)];
5127   
5128  *       Bus level output
5129          o_busGeneration_TP(t,b) $ bus(t,b) = busGeneration(t,b) ;
5130   
5131          o_busLoad_TP(t,b) $ bus(t,b)
5132              = busLoad(t,b)
5133              + Sum[ (bd,n) $ { bidNode(t,bd,n) and NodeBus(t,n,b) }
5134                   , PURCHASE.l(t,bd) ];
5135   
5136          o_busPrice_TP(t,b) $ bus(t,b) = busPrice(t,b) ;
5137   
5138          o_busDeficit_TP(t,b) $ bus(t,b)
5139              = DEFICITBUSGENERATION.l(t,b)
5140              + sum[n, NodeBusAllocationFactor(t,n,b)*ENERGYSCARCITYNODE.l(t,n)];
5141   
5142          o_busSurplus_TP(t,b)$bus(t,b) = SURPLUSBUSGENERATION.l(t,b) ;
5143   
5144  *       Node level output
5145   
5146          totalBusAllocation(t,b) $ bus(t,b)
5147              = sum[ n $ Node(t,n), NodeBusAllocationFactor(t,n,b)];
5148   
5149          busNodeAllocationFactor(t,b,n) $ (totalBusAllocation(t,b) > 0)
5150              = NodeBusAllocationFactor(t,n,b) / totalBusAllocation(t,b) ;
5151   
5152  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
5166          unmappedDeficitBus(t,b) $ o_busDeficit_TP(t,b)
5167              = yes $ (Sum[ n, busNodeAllocationFactor(t,b,n)] = 0);
5168   
5169          changedDeficitBus(t,b) = no;
5170   
5171          If Sum[b $ unmappedDeficitBus(t,b), 1] then
5172   
5173              temp_busDeficit_TP(t,b) = o_busDeficit_TP(t,b);
5174   
5175              Loop b $ unmappedDeficitBus(t,b) do
5176                  o_busDeficit_TP(t,b1)
5177                    $ { Sum[ br $ { ( branchLossBlocks(t,br)=0 )
5178                                and ( branchBusDefn(t,br,b1,b)
5179                                   or branchBusDefn(t,br,b,b1) )
5180                                  }, 1 ]
5181                      } = o_busDeficit_TP(t,b1) + o_busDeficit_TP(t,b) ;
5182   
5183                  changedDeficitBus(t,b1)
5184                    $ Sum[ br $ { ( branchLossBlocks(t,br)=0 )
5185                              and ( branchBusDefn(t,br,b1,b)
5186                                 or branchBusDefn(t,br,b,b1) )
5187                                }, 1 ] = yes;
5188   
5189                  unmappedDeficitBus(t,b) = no;
5190                  changedDeficitBus(t,b) = no;
5191                  o_busDeficit_TP(t,b) = 0;
5192              EndLoop;
5193   
5194              Loop n $ sum[ b $ changedDeficitBus(t,b)
5195                          , busNodeAllocationFactor(t,b,n)] do
5196                  o_nodePrice_TP(t,n) = deficitBusGenerationPenalty ;
5197                  o_nodeDeficit_TP(t,n) = sum[ b $ busNodeAllocationFactor(t,b,n),
5198                                                    busNodeAllocationFactor(t,b,n)
5199                                                  * o_busDeficit_TP(t,b) ] ;
5200              EndLoop;
5201   
5202              o_busDeficit_TP(t,b) = temp_busDeficit_TP(t,b);
5203          Endif;
5204  * TN - post processing unmapped generation deficit buses end
5205   
5206          o_nodeDeficit_TP(t,n) $ Node(t,n)
5207              = sum[ b $ NodeBus(t,n,b), busNodeAllocationFactor(t,b,n)
5208                                            * DEFICITBUSGENERATION.l(t,b) ] ;
5209   
5210          o_nodeSurplus_TP(t,n) $ Node(t,n)
5211              = sum[ b $ NodeBus(t,n,b), busNodeAllocationFactor(t,b,n)
5212                                            * SURPLUSBUSGENERATION.l(t,b) ] ;
5213   
5214  *       branch output
5215          o_branchFlow_TP(t,br) $ ACbranch(t,br) = ACBRANCHFLOW.l(t,br);
5216   
5217          o_branchFlow_TP(t,br) $ HVDClink(t,br) = HVDCLINKFLOW.l(t,br);
5218   
5219          o_branchDynamicLoss_TP(t,br) $  ACbranch(t,br)
5220              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(t,br,fd) ] ;
5221   
5222          o_branchDynamicLoss_TP(t,br) $ HVDClink(t,br)
5223              = HVDCLINKLOSSES.l(t,br) ;
5224   
5225          o_branchFixedLoss_TP(t,br) $ branch(t,br)
5226              = branchFixedLoss(t,br) ;
5227   
5228          o_branchTotalLoss_TP(t,br) $ branch(t,br)
5229              = o_branchDynamicLoss_TP(t,br) + o_branchFixedLoss_TP(t,br) ;
5230   
5231          o_branchMarginalPrice_TP(t,br) $ ACbranch(t,br)
5232              = sum[ fd, ACbranchMaximumFlow.m(t,br,fd) ] ;
5233   
5234          o_branchMarginalPrice_TP(t,br) $ HVDClink(t,br)
5235              = HVDClinkMaximumFlow.m(t,br) ;
5236   
5237          o_branchCapacity_TP(t,br) $ branch(t,br)
5238              = sum[ fd $ ( ord(fd) = 1 )
5239                        , branchCapacity(t,br,fd)
5240                   ] $  { o_branchFlow_TP(t,br) >= 0 }
5241              + sum[ fd $ ( ord(fd) = 2 )
5242                        , branchCapacity(t,br,fd)
5243                   ] $  { o_branchFlow_TP(t,br) < 0 } ;
5244   
5245  *       bid output
5246          o_bidEnergy_TP(t,bd) $ bid(t,bd) = PURCHASE.l(t,bd) ;
5247   
5248          o_bidTotalMW_TP(t,bd) $ bid(t,bd)
5249              = sum[ blk, DemBidMW(t,bd,blk) ] ;
5250   
5251  *       Violation reporting based on the CE and ECE
5252          o_ResViolation_TP(t,isl,resC)
5253              = DEFICITRESERVE_CE.l(t,isl,resC)
5254              + DEFICITRESERVE_ECE.l(t,isl,resC)  ;
5255   
5256          o_FIRviolation_TP(t,isl)
5257              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(t,isl,resC) ] ;
5258   
5259          o_SIRviolation_TP(t,isl)
5260              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(t,isl,resC) ] ;
5261   
5262  *       Risk marginal prices and shortfall outputs
5263          o_GenRiskPrice_TP(t,isl,o,resC,GenRisk)
5264              = -GenIslandRiskCalculation_1.m(t,isl,o,resC,GenRisk) ;
5265   
5266          o_GenRiskShortfall_TP(t,isl,o,resC,GenRisk)
5267              = RESERVESHORTFALLUNIT.l(t,isl,o,resC,GenRisk) ;
5268   
5269          o_HVDCSecRiskPrice_TP(t,isl,o,resC,HVDCSecRisk)
5270              = -HVDCIslandSecRiskCalculation_GEN_1.m(t,isl,o,resC,HVDCSecRisk) ;
5271   
5272          o_HVDCSecRiskShortfall_TP(t,isl,o,resC,HVDCSecRisk)
5273              = RESERVESHORTFALLUNIT.l(t,isl,o,resC,HVDCSecRisk) ;
5274   
5275          o_GenRiskGroupPrice_TP(t,isl,rg,resC,GenRisk)
5276              = -GenIslandRiskGroupCalculation_1.m(t,isl,rg,resC,GenRisk) ;
5277   
5278          o_GenRiskGroupShortfall_TP(t,isl,rg,resC,GenRisk)
5279              = RESERVESHORTFALLGROUP.l(t,isl,rg,resC,GenRisk) ;
5280   
5281          o_HVDCRiskPrice_TP(t,isl,resC,HVDCrisk)
5282              = -HVDCIslandRiskCalculation.m(t,isl,resC,HVDCrisk);
5283   
5284          o_HVDCRiskShortfall_TP(t,isl,resC,HVDCrisk)
5285              = RESERVESHORTFALL.l(t,isl,resC,HVDCrisk);
5286   
5287   
5288          o_ManualRiskPrice_TP(t,isl,resC,ManualRisk)
5289              = -ManualIslandRiskCalculation.m(t,isl,resC,ManualRisk) ;
5290   
5291          o_ManualRiskShortfall_TP(t,isl,resC,ManualRisk)
5292              = RESERVESHORTFALL.l(t,isl,resC,ManualRisk) ;
5293   
5294          o_HVDCSecManualRiskPrice_TP(t,isl,resC,HVDCSecRisk)
5295              = -HVDCIslandSecRiskCalculation_Manu_1.m(t,isl,resC,HVDCSecRisk);
5296   
5297          o_HVDCSecManualRiskShortfall_TP(t,isl,resC,HVDCSecRisk)
5298              = RESERVESHORTFALL.l(t,isl,resC,HVDCSecRisk) ;
5299   
5300  *       Security constraint data
5301   
5302          o_brConstraintSense_TP(t,brCstr) $ branchConstraint(t,brCstr)
5303              = branchConstraintSense(t,brCstr) ;
5304   
5305          o_brConstraintLHS_TP(t,brCstr) $ branchConstraint(t,brCstr)
5306              = [ branchSecurityConstraintLE.l(t,brCstr)
5307                $ (branchConstraintSense(t,brCstr) = -1) ] ;
5308   
5309          o_brConstraintRHS_TP(t,brCstr) $ branchConstraint(t,brCstr)
5310              = branchConstraintLimit(t,brCstr) ;
5311   
5312          o_brConstraintPrice_TP(t,brCstr) $ branchConstraint(t,brCstr)
5313              = [ branchSecurityConstraintLE.m(t,brCstr)
5314                $ (branchConstraintSense(t,brCstr) = -1) ] ;
5315   
5316  *       Mnode constraint data
5317          o_MnodeConstraintSense_TP(t,MnodeCstr)
5318              $ MnodeConstraint(t,MnodeCstr)
5319              = MnodeConstraintSense(t,MnodeCstr) ;
5320   
5321          o_MnodeConstraintLHS_TP(t,MnodeCstr)
5322              $ MnodeConstraint(t,MnodeCstr)
5323              = [ MnodeSecurityConstraintLE.l(t,MnodeCstr)
5324                $ (MnodeConstraintSense(t,MnodeCstr) = -1) ]
5325              + [ MnodeSecurityConstraintGE.l(t,MnodeCstr)
5326                $ (MnodeConstraintSense(t,MnodeCstr) = 1)  ]
5327              + [ MnodeSecurityConstraintEQ.l(t,MnodeCstr)
5328                $ (MnodeConstraintSense(t,MnodeCstr) = 0)  ] ;
5329   
5330          o_MnodeConstraintRHS_TP(t,MnodeCstr)
5331              $ MnodeConstraint(t,MnodeCstr)
5332              = MnodeConstraintLimit(t,MnodeCstr) ;
5333   
5334          o_MnodeConstraintPrice_TP(t,MnodeCstr)
5335              $ MnodeConstraint(t,MnodeCstr)
5336              = [ MnodeSecurityConstraintLE.m(t,MnodeCstr)
5337                $ (MnodeConstraintSense(t,MnodeCstr) = -1) ]
5338              + [ MnodeSecurityConstraintGE.m(t,MnodeCstr)
5339                $ (MnodeConstraintSense(t,MnodeCstr) = 1)  ]
5340              + [ MnodeSecurityConstraintEQ.m(t,MnodeCstr)
5341                $ (MnodeConstraintSense(t,MnodeCstr) = 0)  ] ;
5342   
5343  *       Island output
5344          o_ResPrice_TP(t,isl,resC)= IslandReserveCalculation.m(t,isl,resC);
5345   
5346          o_FIRprice_TP(t,isl) = sum[ resC $ (ord(resC) = 1)
5347                                            , o_ResPrice_TP(t,isl,resC) ];
5348   
5349          o_SIRprice_TP(t,isl) = sum[ resC $ (ord(resC) = 2)
5350                                            , o_ResPrice_TP(t,isl,resC) ];
5351   
5352          o_islandGen_TP(t,isl)
5353              = sum[ b $ busIsland(t,b,isl), busGeneration(t,b) ] ;
5354   
5355          o_islandClrBid_TP(t,isl)
5356              = sum[ bd $ bidIsland(t,bd,isl), PURCHASE.l(t,bd) ] ;
5357   
5358          o_islandLoad_TP(t,isl)
5359              = sum[ b $ busIsland(t,b,isl), busLoad(t,b) ]
5360              + o_islandClrBid_TP(t,isl) ;
5361   
5362          o_ResCleared_TP(t,isl,resC) = ISLANDRESERVE.l(t,isl,resC);
5363   
5364          o_FirCleared_TP(t,isl) = Sum[ resC $ (ord(resC) = 1)
5365                                              , o_ResCleared_TP(t,isl,resC) ];
5366   
5367          o_SirCleared_TP(t,isl) = Sum[ resC $ (ord(resC) = 2)
5368                                              , o_ResCleared_TP(t,isl,resC) ];
5369   
5370          o_islandBranchLoss_TP(t,isl)
5371              = sum[ (br,frB,toB)
5372                   $ { ACbranch(t,br) and busIsland(t,toB,isl)
5373                   and branchBusDefn(t,br,frB,toB)
5374                     }, o_branchTotalLoss_TP(t,br) ] ;
5375   
5376          o_HVDCflow_TP(t,isl)
5377              = sum[ (br,frB,toB)
5378                   $ { HVDClink(t,br) and busIsland(t,frB,isl)
5379                   and branchBusDefn(t,br,frB,toB)
5380                     }, o_branchFlow_TP(t,br) ] ;
5381   
5382   
5383          o_HVDCpoleFixedLoss_TP(t,isl)
5384              = sum[ (br,frB,toB) $ { HVDClink(t,br) and
5385                                      branchBusDefn(t,br,frB,toB) and
5386                                      ( busIsland(t,toB,isl) or
5387                                        busIsland(t,frB,isl)
5388                                      )
5389                                    }, 0.5 * o_branchFixedLoss_TP(t,br)
5390                   ] ;
5391   
5392          o_HVDCloss_TP(t,isl)
5393              = o_HVDCpoleFixedLoss_TP(t,isl)
5394              + sum[ (br,frB,toB) $ { HVDClink(t,br) and
5395                                      branchBusDefn(t,br,frB,toB) and
5396                                      busIsland(t,toB,isl) and
5397                                      (not (busIsland(t,frB,isl)))
5398                                    }, o_branchDynamicLoss_TP(t,br)
5399                   ] ;
5400   
5401          o_HVDCreceived(t,isl) = HVDCREC.l(t,isl);
5402   
5403          o_HVDCRiskSubtractor(t,isl,resC,HVDCrisk)
5404              = RISKOFFSET.l(t,isl,resC,HVDCrisk) ;
5405   
5406  * TN - The code below is added for NMIR project ================================
5407          o_EffectiveRes_TP(t,isl,resC,riskC) $ reserveShareEnabled(t,resC)
5408              = RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ;
5409   
5410          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(t,resC)] then
5411   
5412              o_FirSent_TP(t,isl)
5413                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5414                       , RESERVESHARESENT.l(t,isl,resC,rd)];
5415   
5416              o_FirReceived_TP(t,isl)
5417                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5418                       , RESERVESHARERECEIVED.l(t,isl,resC,rd) ];
5419   
5420              o_FirEffectiveCE_TP(t,isl)
5421                  = Smax[ (resC,riskC)
5422                        $ { (ord(resC) = 1) and ContingentEvents(riskC) }
5423                        , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5424   
5425              o_FirEffectiveECE_TP(t,isl)
5426                  = Smax[ (resC,riskC)
5427                        $ { (ord(resC) = 1) and ExtendedContingentEvent(riskC) }
5428                        , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5429   
5430              o_FirEffReport_TP(t,isl)
5431                  = Smax[ (resC,riskC) $ (ord(resC)=1)
5432                       , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5433   
5434          Endif;
5435   
5436          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(t,resC)] then
5437   
5438              o_SirSent_TP(t,isl)
5439                  = Sum[ (rd,resC) $ (ord(resC) = 2),
5440                         RESERVESHARESENT.l(t,isl,resC,rd) ];
5441   
5442              o_SirReceived_TP(t,isl)
5443                  = Sum[ (fd,resC) $ (ord(resC) = 2),
5444                         RESERVESHARERECEIVED.l(t,isl,resC,fd) ];
5445   
5446              o_SirEffectiveCE_TP(t,isl)
5447                  = Smax[ (resC,riskC)
5448                        $ { (ord(resC) = 2) and ContingentEvents(riskC) }
5449                        , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5450   
5451              o_SirEffectiveECE_TP(t,isl)
5452                  = Smax[ (resC,riskC)
5453                        $ { (ord(resC) = 2) and ExtendedContingentEvent(riskC) }
5454                        , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5455   
5456              o_SirEffReport_TP(t,isl)
5457                  = Smax[ (resC,riskC) $ (ord(resC)=2)
5458                       , RESERVESHAREEFFECTIVE.l(t,isl,resC,riskC) ];
5459          Endif;
5460   
5461          o_TotalIslandReserve(t,isl,resC,riskC)
5462              = o_ResCleared_TP(t,isl,resC) + o_EffectiveRes_TP(t,isl,resC,riskC);
5463   
5464   
5465  * TN - The code for NMIR project end ===========================================
5466   
5467  *       Additional output for audit reporting
5468          o_ACbusAngle(t,b) = ACNODEANGLE.l(t,b) ;
5469   
5470  *       Check if there are non-physical losses on AC branches
5471          ManualBranchSegmentMWFlow(LossBranch(ACbranch(t,br)),los,fd)
5472                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
5473                  and validLossSegment(ACbranch,los,fd)
5474                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
5475                    }
5476                  = Min[ Max( 0,
5477                              [ abs(o_branchFlow_TP(t,br))
5478                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
5479                              ]
5480                            ),
5481                         ( LossSegmentMW(ACbranch,los,fd)
5482                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
5483                         )
5484                       ] ;
5485   
5486          ManualBranchSegmentMWFlow(LossBranch(HVDClink(t,br)),los,fd)
5487                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5488                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
5489                    }
5490                  = Min[ Max( 0,
5491                              [ abs(o_branchFlow_TP(t,br))
5492                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5493                              ]
5494                            ),
5495                         ( LossSegmentMW(HVDClink,los,fd)
5496                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5497                         )
5498                       ] ;
5499   
5500          ManualLossCalculation(LossBranch(branch(t,br)))
5501              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
5502                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
5503   
5504          o_nonPhysicalLoss(t,br) = o_branchDynamicLoss_TP(t,br)
5505                                   - ManualLossCalculation(t,br) ;
5506   
5507          o_lossSegmentBreakPoint(t,br,los)
5508              = sum [ fd $ { validLossSegment(t,br,los,fd)
5509                         and (ord(fd) = 1)
5510                           }, LossSegmentMW(t,br,los,fd) ] $ { o_branchFlow_TP(t,br) >= 0 }
5511              + sum [ fd $ { validLossSegment(t,br,los,fd)
5512                         and (ord(fd) = 2)
5513                           }, LossSegmentMW(t,br,los,fd) ] $ { o_branchFlow_TP(t,br) < 0 }
5514          ;
5515   
5516          o_lossSegmentFactor(t,br,los)
5517              = sum [ fd $ { validLossSegment(t,br,los,fd)
5518                         and (ord(fd) = 1)
5519                           }, LossSegmentFactor(t,br,los,fd) ] $ { o_branchFlow_TP(t,br) >= 0 }
5520              + sum [ fd $ { validLossSegment(t,br,los,fd)
5521                         and (ord(fd) = 2)
5522                           }, LossSegmentFactor(t,br,los,fd) ] $ { o_branchFlow_TP(t,br) < 0 }
5523          ;
5524   
5525          o_PLRO_FIR_TP(t,o) $ offer(t,o)
5526              = sum[(resC,PLRO) $ (ord(resC)=1)
5527                   , RESERVE.l(t,o,resC,PLRO) ] ;
5528   
5529          o_PLRO_SIR_TP(t,o) $ offer(t,o)
5530              = sum[(resC,PLRO) $ (ord(resC)=2)
5531                   , RESERVE.l(t,o,resC,PLRO)] ;
5532   
5533          o_TWRO_FIR_TP(t,o) $ offer(t,o)
5534              = sum[(resC,TWRO) $ (ord(resC)=1)
5535                   , RESERVE.l(t,o,resC,TWRO)] ;
5536   
5537          o_TWRO_SIR_TP(t,o) $ offer(t,o)
5538              = sum[(resC,TWRO) $ (ord(resC)=2)
5539                   , RESERVE.l(t,o,resC,TWRO)] ;
5540   
5541          o_ILRO_FIR_TP(t,o) $ offer(t,o)
5542              = sum[ (resC,ILRO) $ (ord(resC)=1)
5543                   , RESERVE.l(t,o,resC,ILRO)] ;
5544   
5545          o_ILRO_SIR_TP(t,o) $ offer(t,o)
5546              = sum[ (resC,ILRO) $ (ord(resC)=2)
5547                   , RESERVE.l(t,o,resC,ILRO)] ;
5548   
5549          o_ILbus_FIR_TP(t,b) = sum[ (o,n) $ { NodeBus(t,n,b) and
5550                                                offerNode(t,o,n)
5551                                              }, o_ILRO_FIR_TP(t,o) ] ;
5552   
5553          o_ILbus_SIR_TP(t,b) = sum[ (o,n) $ { NodeBus(t,n,b) and
5554                                                offerNode(t,o,n)
5555                                              }, o_ILRO_SIR_TP(t,o) ] ;
5556   
5557          o_generationRiskLevel(t,isl,o,resC,GenRisk)
5558              = GENISLANDRISK.l(t,isl,o,resC,GenRisk)
5559              + RESERVESHAREEFFECTIVE.l(t,isl,resC,GenRisk)
5560              ;
5561   
5562          o_HVDCriskLevel(t,isl,resC,HVDCrisk)
5563              = ISLANDRISK.l(t,isl,resC,HVDCrisk) ;
5564   
5565          o_manuRiskLevel(t,isl,resC,ManualRisk)
5566              = ISLANDRISK.l(t,isl,resC,ManualRisk)
5567              + RESERVESHAREEFFECTIVE.l(t,isl,resC,ManualRisk)
5568              ;
5569   
5570          o_genHVDCriskLevel(t,isl,o,resC,HVDCsecRisk)
5571              = HVDCGENISLANDRISK.l(t,isl,o,resC,HVDCsecRisk) ;
5572   
5573          o_manuHVDCriskLevel(t,isl,resC,HVDCsecRisk)
5574              = HVDCMANISLANDRISK.l(t,isl,resC,HVDCsecRisk);
5575   
5576          o_generationRiskGroupLevel(t,isl,rg,resC,GenRisk)
5577              $ islandRiskGroup(t,isl,rg,GenRisk)
5578              = GENISLANDRISKGROUP.l(t,isl,rg,resC,GenRisk)
5579              + RESERVESHAREEFFECTIVE.l(t,isl,resC,GenRisk)
5580              ;
5581   
5582  *       FIR and SIR required based on calculations of the island risk to
5583  *       overcome reporting issues of the risk setter under degenerate
5584  *       conditions when reserve price = 0 - See below
5585   
5586          o_ReserveReqd_TP(t,isl,resC)
5587              = Max[ 0,
5588                     smax[(o,GenRisk)     , o_generationRiskLevel(t,isl,o,resC,GenRisk)],
5589                     smax[ HVDCrisk       , o_HVDCriskLevel(t,isl,resC,HVDCrisk) ] ,
5590                     smax[ ManualRisk     , o_manuRiskLevel(t,isl,resC,ManualRisk) ] ,
5591                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(t,isl,o,resC,HVDCsecRisk) ] ,
5592                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(t,isl,resC,HVDCsecRisk)  ] ,
5593                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(t,isl,rg,resC,GenRisk)  ]
5594                   ] ;
5595   
5596          o_FIRreqd_TP(t,isl) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(t,isl,resC) ] ;
5597          o_SIRreqd_TP(t,isl) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(t,isl,resC) ] ;
5598   
5599  *       Summary reporting by trading period
5600          o_solveOK_TP(t) = ModelSolved ;
5601   
5602          o_systemCost_TP(t) = SYSTEMCOST.l(t) ;
5603   
5604          o_systemBenefit_TP(t) = SYSTEMBENEFIT.l(t) ;
5605   
5606          o_penaltyCost_TP(t) = SYSTEMPENALTYCOST.l(t) ;
5607   
5608          o_ofv_TP(t) = o_systemBenefit_TP(t)
5609                       - o_systemCost_TP(t)
5610                       - o_penaltyCost_TP(t);
5611   
5612   
5613  *       Separete violation reporting at trade period level
5614          o_defGenViolation_TP(t) = sum[ b, o_busDeficit_TP(t,b) ] ;
5615   
5616          o_surpGenViolation_TP(t) = sum[ b, o_busSurplus_TP(t,b) ] ;
5617   
5618          o_surpBranchFlow_TP(t)
5619              = sum[ br$branch(t,br), SURPLUSBRANCHFLOW.l(t,br) ] ;
5620   
5621          o_defRampRate_TP(t)
5622              = sum[ o $ offer(t,o), DEFICITRAMPRATE.l(t,o) ] ;
5623   
5624          o_surpRampRate_TP(t)
5625              = sum[ o $ offer(t,o), SURPLUSRAMPRATE.l(t,o) ] ;
5626   
5627          o_surpBranchGroupConst_TP(t)
5628              = sum[ brCstr $ branchConstraint(t,brCstr)
5629                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(t,brCstr) ] ;
5630   
5631          o_defBranchGroupConst_TP(t)
5632              = sum[ brCstr $ branchConstraint(t,brCstr)
5633                   , DEFICITBRANCHSECURITYCONSTRAINT.l(t,brCstr) ] ;
5634   
5635          o_defMnodeConst_TP(t)
5636              = sum[ MnodeCstr $ MnodeConstraint(t,MnodeCstr)
5637                   , DEFICITMnodeCONSTRAINT.l(t,MnodeCstr) ] ;
5638   
5639          o_surpMnodeConst_TP(t)
5640              = sum[ MnodeCstr $ MnodeConstraint(t,MnodeCstr)
5641                   , SURPLUSMnodeCONSTRAINT.l(t,MnodeCstr) ] ;
5642   
5643          o_defResv_TP(t)
5644              = sum[ (isl,resC) , o_ResViolation_TP(t,isl,resC) ] ;
5645   
5646  *   Reporting at trading period end
5647      EndLoop;
5649   
5651   
5652  * End of the solve vSPD loop
5653    ] ;
5654  * End of the While loop
5655  );
5656   
5657   
5658  *   Summary reports - only applied for normal and audit vSPD run.
5660   
5661  *   System level
5662   
5663   
5664  *   Offer level - This does not include revenue from wind generators for
5665  *   final pricing because the wind generation is netted off against load
5666  *   at the particular bus for the final pricing solves
5667   
5669   
5670   
5671  * 8b. Calculating price-relating outputs --------------------------------------
5672   
5674  loop (dt,
5675   
5676  *   branch output update
5677      o_branchFromBusPrice_TP(dt,br) $ branch(dt,br)
5678          = sum[ b $ branchFrBus(dt,br,b), o_busPrice_TP(dt,b) ] ;
5679   
5680      o_branchToBusPrice_TP(dt,br) $ branch(dt,br)
5681          = sum[ b $ branchToBus(dt,br,b), o_busPrice_TP(dt,b) ] ;
5682   
5683      o_branchTotalRentals_TP(dt,br)
5684          $ { branch(dt,br) and (o_branchFlow_TP(dt,br) >= 0) }
5685          = (intervalDuration/60)
5686          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5687            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
5688            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5689            ] ;
5690   
5691      o_branchTotalRentals_TP(dt,br)
5692          $ { branch(dt,br) and (o_branchFlow_TP(dt,br) < 0) }
5693          = (intervalDuration/60)
5694          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5695            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5696            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
5697            ] ;
5698   
5699  *   Island output
5700      o_islandRefPrice_TP(dt,isl)
5701          = sum[ n $ { refNode(dt,n)
5702                   and nodeIsland(dt,n,isl) } , o_nodePrice_TP(dt,n) ] ;
5703  ) ;
5704   
5706  *   Calculating price-relating outputs end -------------------------------------
5707   
5708  *=====================================================================================
5709  * 9. Write results to CSV report files and GDX files
5710  *=====================================================================================
5711  * TN - Pivot analysis end
INCLUDE    C:\vSPD\ElectricityAuthority\Programs\vSPDreport.gms
5713  *=====================================================================================
5714  * Name:                 vSPDreport.gms
5715  * Function:             Creates the detailed reports for normal SPD mode
5716  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
5717  * Source:               https://github.com/ElectricityAuthority/vSPD
5718  *                       https://www.emi.ea.govt.nz/Tools/vSPD
5719  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
5720  *                       Email: emi@ea.govt.nz
5721  * Last modified on:     1 Oct 2019
5722  *
5723  *=====================================================================================
5724   
5725  * Normal vSPD run output
5726  *=====================================================================================
5727  * Writing data in to CSV result files
5728  *=====================================================================================
5729   
5730  * Trading period level report
5732   
5733  * Trading period summary result
5734  File
5735  SummaryResults_TP / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_SummaryResults_TP.csv" / ;
5736  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
5737  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
5738  SummaryResults_TP.nd = 5 ;    SummaryResults_TP.nw = 20 ;
5739  put SummaryResults_TP ;
5740  loop( (dt,rundt),
5741      put dt.tl,rundt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
5742          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
5743          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
5744          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
5745          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
5746          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
5747          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt) / ;
5748  ) ;
5749   
5750  * Trading period island result
5751  File IslandResults_TP /"C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_IslandResults_TP.csv"/;
5752  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
5753  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
5754  IslandResults_TP.nd = 5 ;
5755  put IslandResults_TP ;
5756  loop( (dt,rundt,isl),
5757      put dt.tl,rundt.tl, isl.tl, o_islandGen_TP(dt,isl), o_islandLoad_TP(dt,isl)
5758          o_islandClrBid_TP(dt,isl), o_islandBranchLoss_TP(dt,isl)
5759          o_HVDCFlow_TP(dt,isl), o_HVDCLoss_TP(dt,isl)
5760          o_islandRefPrice_TP(dt,isl), o_FIRReqd_TP(dt,isl)
5761          o_SIRReqd_TP(dt,isl), o_FIRPrice_TP(dt,isl)o_SIRPrice_TP(dt,isl)
5762  * NIRM output
5763      o_FirCleared_TP(dt,isl), o_SirCleared_TP(dt,isl)
5764      o_FirSent_TP(dt,isl), o_SirSent_TP(dt,isl)
5765      o_FirReceived_TP(dt,isl), o_SirReceived_TP(dt,isl)
5766      o_FirEffectiveCE_TP(dt,isl), o_SirEffectiveCE_TP(dt,isl)
5767      o_FirEffectiveECE_TP(dt,isl), o_SirEffectiveECE_TP(dt,isl)
5768  *NIRM output end
5769      / ;
5770  ) ;
5771   
5772   
5773  * Trading period bus result
5774  File BusResults_TP   / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_BusResults_TP.csv" / ;
5775  BusResults_TP.pc = 5 ;
5776  BusResults_TP.lw = 0 ;
5777  BusResults_TP.pw = 9999 ;
5778  BusResults_TP.ap = 1 ;
5779  BusResults_TP.nd = 3
5780  put BusResults_TP ;
5781  loop( (dt,rundt,b) $ bus(dt,b),
5782      put dt.tl,rundt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
5783          o_busPrice_TP(dt,b), o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
5784  ) ;
5785   
5786  * Trading period node result
5787  File NodeResults_TP  /"C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_NodeResults_TP.csv" / ;
5788  NodeResults_TP.pc = 5 ;
5789  NodeResults_TP.lw = 0 ;
5790  NodeResults_TP.pw = 9999 ;
5791  NodeResults_TP.ap = 1 ;
5792  NodeResults_TP.nd = 4 ;
5793  put NodeResults_TP ;
5794  loop( (dt,rundt,n) $ node(dt,n),
5795      put dt.tl,rundt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
5796          o_nodePrice_TP(dt,n), o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
5797  ) ;
5798   
5799  * Trading period offer result
5800  File OfferResults_TP  /"C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_OfferResults_TP.csv"/ ;
5801  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
5802  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
5803  OfferResults_TP.nd = 4 ;
5804  put OfferResults_TP ;
5805  loop( (dt,rundt,o,trdr) $ { offer(dt,o) and OfferTrader(dt,o,trdr) },
5806      put dt.tl, rundt.tl, o.tl, trdr.tl
5807          o_offerEnergy_TP(dt,o), o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
5808  ) ;
5809   
5810  * Trading period bid result
5811  File BidResults_TP    / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_BidResults_TP.csv" / ;
5812  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
5813  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
5814  BidResults_TP.nd = 4 ;
5815  put BidResults_TP ;
5816  loop( (dt,rundt,bd,trdr) $ { bid(dt,bd) and BidTrader(dt,bd,trdr) },
5817      put dt.tl,rundt.tl, bd.tl, trdr.tl
5818          o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd) / ;
5819  ) ;
5820   
5821  * Trading period reserve result
5822  File
5823  ReserveResults_TP /"C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_ReserveResults_TP.csv" / ;
5824  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
5825  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
5826  ReserveResults_TP.nd = 3 ;
5827  put ReserveResults_TP ;
5828  loop( (dt,rundt,isl),
5829      put dt.tl,rundt.tl, isl.tl, o_FIRReqd_TP(dt,isl), o_SIRReqd_TP(dt,isl)
5830          o_FIRPrice_TP(dt,isl), o_SIRPrice_TP(dt,isl)
5831          o_FIRViolation_TP(dt,isl), o_SIRViolation_TP(dt,isl) / ;
5832  ) ;
5833   
5834   
5835  * Trading period risk result
5836  File riskResults_TP / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_RiskResults_TP.csv" /;
5837  riskResults_TP.pc = 5;        riskResults_TP.lw = 0;
5838  riskResults_TP.pw = 9999;     riskResults_TP.ap = 1 ;
5839  riskResults_TP.nd = 4 ;
5840  put riskResults_TP ;
5841  loop( (dt,rundt,isl,o,resC,GenRisk)
5842      $ (o_GenRiskPrice_TP(dt,isl,o,resC,GenRisk) <> 0),
5843      put dt.tl,rundt.tl, isl.tl, resC.tl ;
5844      if (ContingentEvents(GenRisk),
5845           put 'CE', 'GEN' ;
5846      else
5847           put 'ECE','GEN' ;
5848      );
5849   
5850      put o.tl, o_offerEnergy_TP(dt,o), o_offerRes_TP(dt,o,resC), FKband(dt,o)
5851          FreeReserve(dt,isl,resC,GenRisk)
5852          o_TotalIslandReserve(dt,isl,resC,GenRisk)
5853          o_GenRiskShortfall_TP(dt,isl,o,resC,GenRisk)
5854          o_ResViolation_TP(dt,isl,resC), o_ResPrice_TP(dt,isl,resC)
5855          o_GenRiskPrice_TP(dt,isl,o,resC,GenRisk)  / ;
5856  );
5857   
5858  loop( (dt,rundt,isl,resC,HVDCRisk)
5859      $ (o_HVDCRiskPrice_TP(dt,isl,resC,HVDCrisk)  <> 0),
5860      put dt.tl,rundt.tl, isl.tl, resC.tl ;
5861      if (ContingentEvents(HVDCRisk),
5862           put 'CE', 'HVDC', 'HVDC';
5863      else
5864           put 'ECE','HVDC', 'HVDC';
5865      );
5866      put o_HVDCreceived(dt,isl), 0, modulationRiskClass(dt,HVDCrisk)
5867          o_HVDCRiskSubtractor(dt,isl,resC,HVDCrisk)
5868          o_TotalIslandReserve(dt,isl,resC,HVDCrisk)
5869          o_HVDCRiskShortfall_TP(dt,isl,resC,HVDCrisk)
5870          o_ResViolation_TP(dt,isl,resC), o_ResPrice_TP(dt,isl,resC)
5871          o_HVDCRiskPrice_TP(dt,isl,resC,HVDCrisk)  / ;
5872  );
5873   
5874  loop( (dt,rundt,isl,resC,ManualRisk)
5875      $ (o_ManualRiskPrice_TP(dt,isl,resC,ManualRisk)  <> 0),
5876      put dt.tl,rundt.tl, isl.tl, resC.tl ;
5877      if (ContingentEvents(ManualRisk),
5878           put 'CE', 'MANUAL', 'MANUAL';
5879      else
5880           put 'ECE','MANUAL', 'MANUAL';
5881      );
5882      put IslandMinimumRisk(dt,isl,resC,ManualRisk) , 0, 0
5883          FreeReserve(dt,isl,resC,ManualRisk)
5884          o_TotalIslandReserve(dt,isl,resC,ManualRisk)
5885          o_ManualRiskShortfall_TP(dt,isl,resC,ManualRisk)
5886          o_ResViolation_TP(dt,isl,resC), o_ResPrice_TP(dt,isl,resC)
5887          o_ManualRiskPrice_TP(dt,isl,resC,ManualRisk)    / ;
5888  );
5889   
5890  loop( (dt,rundt,isl,rg,resC,GenRisk)
5891      $ (o_GenRiskGroupPrice_TP(dt,isl,rg,resC,GenRisk) <> 0),
5892      put dt.tl,rundt.tl, isl.tl, resC.tl ;
5893      if (ContingentEvents(GenRisk),
5894           put 'CE', 'RISKGROUP';
5895      else
5896           put 'ECE','RISKGROUP';
5897      );
5898      put rg.tl, o_groupEnergy_TP(dt,rg,GenRisk),o_groupRes_TP(dt,rg,resC,GenRisk)
5899          o_groupFKband_TP(dt,rg,GenRisk), FreeReserve(dt,isl,resC,GenRisk)
5900          o_TotalIslandReserve(dt,isl,resC,GenRisk)
5901          o_GenRiskGroupShortfall_TP(dt,isl,rg,resC,GenRisk)
5902          o_ResViolation_TP(dt,isl,resC), o_ResPrice_TP(dt,isl,resC)
5903          o_GenRiskGroupPrice_TP(dt,isl,rg,resC,GenRisk)  / ;
5904  );
5905   
5906  * Trading period branch result
5907  File
5908  BranchResults_TP  / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_BranchResults_TP.csv" / ;
5909  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
5910  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
5911  BranchResults_TP.nd = 5 ;
5912  put BranchResults_TP ;
5913  loop( (dt,rundt,br,frB,toB) $ branchDefn(dt,br,frB,toB),
5914      put dt.tl, rundt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
5915          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
5916          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
5917          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
5918          o_branchTotalRentals_TP(dt,br) / ;
5919  ) ;
5920   
5921   
5922  * Trading period branch constraint result
5923  File BrCstrResults_TP
5924  / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_BrConstraintResults_TP.csv" / ;
5925  BrCstrResults_TP.pc = 5 ;      BrCstrResults_TP.lw = 0 ;
5926  BrCstrResults_TP.pw = 9999 ;   BrCstrResults_TP.ap = 1 ;
5927  BrCstrResults_TP.nd = 5 ;
5928  put BrCstrResults_TP ;
5929  loop( (dt,rundt,brCstr) $ branchConstraint(dt,brCstr),
5930      put dt.tl,rundt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
5931          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
5932          o_brConstraintPrice_TP(dt,brCstr) / ;
5933  ) ;
5934   
5935   
5936  * Trading period market node constraint result
5937  File MnodeCstrResults_TP
5938  / "C:\vSPD\ElectricityAuthority\Programs\..\Output\\Run_All_Cases\Run_All_Cases_MnodeConstraintResults_TP.csv" / ;
5939  MnodeCstrResults_TP.pc = 5 ;    MnodeCstrResults_TP.lw = 0 ;
5940  MnodeCstrResults_TP.pw = 9999 ; MnodeCstrResults_TP.ap = 1 ;
5941  MnodeCstrResults_TP.nd = 5 ;
5942  put MnodeCstrResults_TP ;
5943  loop( (dt,rundt,MnodeCstr) $ MnodeConstraint(dt,MnodeCstr),
5944      put dt.tl,rundt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
5945          o_MnodeConstraintSense_TP(dt,MnodeCstr)
5946          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
5947          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
5948  ) ;
5949   
5951  *===============================================================================
5952   
5953   
5954   
5955  *===============================================================================
5956  * Audit mode reporting process
5957  *===============================================================================
5959  *===============================================================================
5960  *execute_unload '%outputPath%\%runName%\%GDXname%_AllData.gdx' ;
5961   
5962   
5963   
5964   
5966   
5967   
5968  * Post a progress message for use by EMI.
5969  putclose rep 'Case: RTD_202210101250_91012022102350483_20221010124902 is complete in ',timeExec,'(secs)'/ ;
5970  putclose rep 'Case: RTD_202210101250_91012022102350483_20221010124902 is finished in ',timeElapsed,'(secs)'/ ;
5971   
5972  * Go to the next input file
5974   
5975  * Post a progress message for use by EMI.
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\vSPD\ElectricityAuthority\Programs\vSPDsolve.gms
     2     2107 INCLUDE        1      40  .C:\vSPD\ElectricityAuthority\Programs\vSPDsettings.inc
     3     2160 INCLUDE        1      41  .C:\vSPD\ElectricityAuthority\Programs\vSPDcase.inc
     4     2410 IF EXIST       1     290  C:\vSPD\ElectricityAuthority\Input\RTD_202210101250_91012022102350483_20221010124902.gdx
     5     2414 GDXIN          1     294  C:\vSPD\ElectricityAuthority\Programs\vSPDPeriod.gdx
     6     2419 GDXIN          1     299  C:\vSPD\ElectricityAuthority\Input\RTD_202210101250_91012022102350483_20221010124902.gdx
     7     2565 IF EXIST       1     445  C:\vSPD\ElectricityAuthority\Override\.gdx
     8     3480 INCLUDE        1    1360  .C:\vSPD\ElectricityAuthority\Programs\vSPDsolve_RTP.gms
     9     5712 INCLUDE        1    2776  .C:\vSPD\ElectricityAuthority\Programs\vSPDreport.gms
    10     5731 IF EXIST       9      19  .C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_BusResults_TP.csv
    11     5976 IF EXIST       1    2788  C:\vSPD\ElectricityAuthority\Input\RTD_202210101250_91012022102350483_20221010124902.gdx


COMPILATION TIME     =        0.032 SECONDS      4 MB  36.2.0 r433180e WEX-WEI
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 3840


LOOPS                            FOR/WHILE   1
                                        dt   10-OCT-2022 12:50


MODEL STATISTICS

BLOCKS OF EQUATIONS          84     SINGLE EQUATIONS       32,027
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       56,483
NON ZERO ELEMENTS       108,310     DISCRETE VARIABLES         14


GENERATION TIME      =        0.094 SECONDS     30 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         dt 10-OCT-2022 12:50

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 3840


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  3840

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE         93065245.4487

 RESOURCE USAGE, LIMIT          0.891      3600.000
 ITERATION COUNT, LIMIT      6158    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\ElectricityAuthority\Programs\cplex.opt"
>>  epint = 1e-9
>>  epopt = 1e-9
>>  sos1reform = -1
>>  sos2reform = -1
Finished reading from "C:\vSPD\ElectricityAuthority\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 6.07 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 15.22 Mb (peak 15.65 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.44 Mb (peak 9.92 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.53sec (det. 637.54 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 289.42 ticks)


Proven optimal solution
MIP Solution:     93065245.448700    (6158 iterations, 4 nodes)
Final Solve:      93065245.448700    (3718 iterations)

Best possible:    93065245.448700
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 4624


LOOPS                            FOR/WHILE   1
                                        dt   10-OCT-2022 12:50


MODEL STATISTICS

BLOCKS OF EQUATIONS          84     SINGLE EQUATIONS       32,027
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       56,483
NON ZERO ELEMENTS       108,310     DISCRETE VARIABLES         14


GENERATION TIME      =        0.125 SECONDS     33 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         dt 10-OCT-2022 12:50

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 8
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 4624


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  4624

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE         93105897.7142

 RESOURCE USAGE, LIMIT          0.860      3600.000
 ITERATION COUNT, LIMIT      5847    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\ElectricityAuthority\Programs\cplex.opt"
>>  epint = 1e-9
>>  epopt = 1e-9
>>  sos1reform = -1
>>  sos2reform = -1
Finished reading from "C:\vSPD\ElectricityAuthority\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 6.07 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 15.22 Mb (peak 15.65 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.44 Mb (peak 9.92 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.50sec (det. 621.26 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 285.90 ticks)


Proven optimal solution
MIP Solution:     93105897.714216    (5847 iterations, 4 nodes)
Final Solve:      93105897.714216    (3547 iterations)

Best possible:    93105897.714216
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/18/22 16:54:31 Page 9
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

rep C:\vSPD\ElectricityAuthority\Programs\ProgressReport.txt
temp C:\vSPD\ElectricityAuthority\Programs\temp.put
SummaryResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_SummaryResults_TP.csv
IslandResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_IslandResults_TP.csv
BusResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_BusResults_TP.csv
NodeResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_NodeResults_TP.csv
OfferResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_OfferResults_TP.csv
BidResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_BidResults_TP.csv
ReserveResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_ReserveResults_TP.csv
riskResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_RiskResults_TP.csv
BranchResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_BranchResults_TP.csv
BrCstrResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_BrConstraintResults_TP.csv
MnodeCstrResults_TP C:\vSPD\ElectricityAuthority\Output\Run_All_Cases\Run_All_Cases_MnodeConstraintResults_TP.csv


EXECUTION TIME       =        2.703 SECONDS     35 MB  36.2.0 r433180e WEX-WEI


USER: Single User License                            G210922|0002CO-GEN
      Electricity Authority - Te Mana Hiko,                   DC5643-S4


**** FILE SUMMARY

Restart    C:\vSPD\ElectricityAuthority\Programs\vSPDmodel.g00
Input      C:\vSPD\ElectricityAuthority\Programs\vSPDsolve.gms
Output     C:\vSPD\ElectricityAuthority\Programs\vSPDsolve.lst
