GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


2594  *=====================================================================================
2595  * Name:                 vSPDsolve.gms
2596  * Function:             Establish base case and override data, prepare data, and solve
2597  *                       the model
2598  * Developed by:         Electricity Authority, New Zealand
2599  * Source:               https://github.com/ElectricityAuthority/vSPD
2600  *                       https://www.emi.ea.govt.nz/Tools/vSPD
2601  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
2602  *                       Email: emi@ea.govt.nz
2603  * Modified on:          1 Oct 2019
2604  *                       New feature added: new wind offer arrangements
2605  * Last modified on:     11 Nov 2020
2606  *                       Replacing invalid bus prices after SOS1 (6.1.3)
2607  *
2608  *=====================================================================================
2609   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file f
        3. Manage model and data compatability
        4. Input data overrides - declare and apply (include vSPDoverrides.gms)
        5. Initialise constraint violation penalties (CVPs)
        6. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        7. vSPD scarcity pricing post-processing
        8. Write results to CSV report files and GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr            i_scarcityArea = sarea
        i_reserveType = resT                      i_reserveClass = resC
        i_riskClass = riskC                       i_constraintRHS = CstrRHS
        i_riskParameter = riskPar                 i_offerParam = offerPar
        i_dczone = z,z1,rrz,rrz1                  i_riskGroup = rg,rg1)
2648   
2649   
2650  * Include paths, settings and case name files
INCLUDE    A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDsettings.inc
2652  *+++ vSPD settings +++
2655   
2656  *+++ Paths +++
2662   
2664   
2665   
2666  *+++ Model +++
2667  Scalar sequentialSolve                   / 0 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2668  Scalar disconnectedNodePriceCorrection   / 1 / ;
2669  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2670   
2671   
2672  *+++ Network +++
2673  Scalar useACLossModel                    / 1 / ;
2674  Scalar useHVDCLossModel                  / 1 / ;
2675  Scalar useACBranchLimits                 / 1 / ;
2676  Scalar useHVDCBranchLimits               / 1 / ;
2677  Scalar resolveCircularBranchFlows        / 1 / ;
2678  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2679  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2680  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2681  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2682  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2683   
2684   
2685  *+++ Constraints +++
2686  Scalar useReserveModel                   / 1 / ;
2687  Scalar suppressMixedConstraint           / 0 / ;
2688  Scalar mixedMIPtolerance                 / 0.000001 / ;
2689   
2690   
2691  *+++ Solver +++
2692  Scalar LPtimeLimit                       / 3600 / ;
2693  Scalar LPiterationLimit                  / 2000000000 / ;
2694  Scalar MIPtimeLimit                      / 3600 / ;
2695  Scalar MIPiterationLimit                 / 2000000000 / ;
2696  Scalar MIPoptimality                     / 0 / ;
2699   
2700   
2701  *+++ Various switches +++
2704   
INCLUDE    A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDcase.inc
2709  tradePeriodReports = 1 ;
2710   
2711   
2712  * Update the runlog file
2713  File runlog "Write to a report"  / "ProgressReport.txt" /;
2714  runlog.lw = 0 ; runlog.ap = 1 ;
2715  putclose runlog / 'Case "RTD_20201028_0105_301" started at: '
2716                    system.date " " system.time /;
2717  if(sequentialSolve,
2718    putclose runlog 'Vectorisation is switched OFF' /;
2719  else
2720    putclose runlog 'Vectorisation is switched ON' /;
2721  ) ;
2722   
2723  * Set the solver for the LP and MIP
2724  option lp = Cplex ;
2725  option mip = Cplex ;
2726   
2727  * Set profile status
2728  option profile = 0 ;
2729   
2730  * Set the solution print status in the lst file
2731  option solprint = off;
2732   
2733  * Set the column (variable) and row (equation) listing in the lst file
2734  option limcol = 0 ;
2735  option limrow = 0 ;
2736   
2737  * Allow empty data set declaration
2739   
2740  * Declare a temporary file
2741  File temp ;
2742   
2743  *=====================================================================================
2744  * 1. Declare symbols and initialise some of them
2745  *=====================================================================================
2746   
2747  Sets
2748  * Initialise fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2749    i_island                    / NI, SI /
2750    i_reserveClass              / FIR, SIR /
2751   
       Scarcity pricing updates --> i_reserveType
       Rather than include an additional reserve type element an additional virutal
       reserve paramter and associated variable is created. This is more efficient
       implementation in terms of the problem size as all other reserve providers
       are indexed on i_reserveType which would include an additional index on all
       these variables thus increasing the problem size. This increase would then
       need additional pre-processing to fix variables to zero. To avoid this and
       keep the problem size small the additional virtual reserve variable is included.
2762    i_reserveType               / PLSR, TWDR, ILR /
2763   
2764    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2765                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2766    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2767    i_offerType                 / energy, PLSR, TWDR, ILR /
2768    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2769                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW,
2770                                  i_IsPriceResponse, i_PotentialMW  /
2771    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2772    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2773    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2774    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2775    i_energyBidComponent        / i_bidMW, i_bidPrice /
2776    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2777    i_tradeBlock                / t1*t20 /
2778    i_lossSegment               / ls1*ls13 /
2779    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2780    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2781    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2782    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2783    i_flowDirection             / forward, backward /
2784    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2785                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2786                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2787                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2788                                  i_deficitRampRate, i_surplusRampRate
2789                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2790                                  i_deficitBranchFlow, i_surplusBranchFlow
2791                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2792                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2793                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2794   
2795  * Initialise the set called pole
2796    pole  'HVDC poles'          / pole1, pole2 /
2797   
2798  * Scarcity pricing updates
2799    i_scarcityArea              /NI, SI, National/
2800   
2801  * NMIR - HVDC flow zones for reverse reserve sharing
2802    i_dczone                    /RP, NR, RZ/
2803   
2804    ;
2805   
2806   
2807   
2808  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2809  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2810   
2811  Sets
2812    scarcityAreaIslandMap(sarea,ild)                    'Mapping of scarcity area to island'
2813    unsolvedPeriod(tp)                                  'Set of periods that are not solved yet'
2814  * Unmmaped bus defificit temporary sets
2815    unmappedDeficitBus(dt,b)                            'List of buses that have deficit generation (price) and are not mapped to any pnode'
2816    changedDeficitBus(dt,b)                             'List of buses that have deficit generation added from unmapped deficit bus'
2817  * TN - Replacing invalid prices after SOS1
2818    vSPD_SOS1_Solve(tp)                                'Flag period that is resolved using SOS1'
2819    ;
2820   
2821  Parameters
2822  * Flag to apply corresponding vSPD model
2823    VSPDModel(tp)                                       '0=VSPD, 1=VSPD_MIP, 2=vSPD_BranchFlowMIP, 3=vSPD_MixedConstraintMIP, 4=VSPD (last solve)'
2824  * Main iteration counter
2825    iterationCount                                      'Iteration counter for the solve'
2826  * MIP logic
2827    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2828  * Introduce flag to detect circular branch flows on each HVDC pole
2829    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2830    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2831    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2832    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2833    manualBranchSegmentMWFlow(tp,br,los)                'Manual calculation of the branch loss segment MW flow'
2834    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2835    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2836    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2837  * Parameters to calculate circular branch flow on each HVDC pole
2838    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2839    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2840  * Disconnected bus post-processing
2841    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2842    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2843    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2844    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2845  * Scarcity pricing processing parameters
2846    scarcitySituation(tp,sarea)                         'Flag to indicate that a scarcity situation exists (1 = Yes)'
2847    GWAPFloor(tp,sarea)                                 'Floor price for the scarcity situation in scarcity area'
2848    GWAPCeiling(tp,sarea)                               'Ceiling price for the scarcity situation in scarcity area'
2849    GWAPPastDaysAvg(tp,ild)                             'Average GWAP over past days - number of periods in GWAP count'
2850    GWAPCountForAvg(tp,ild)                             'Number of periods used for the i_gwapPastDaysAvg'
2851    GWAPThreshold(tp,ild)                               'Threshold on previous 336 trading period GWAP - cumulative price threshold'
2852    islandGWAP(tp,ild)                                  'Island GWAP calculation used to update GWAPPastDaysAvg'
2853    scarcityAreaGWAP(tp,sarea)                          'Scarcity area GWAP used to calculate the scaling factor'
2854    pastGWAPsumforCPT(tp,ild)
2855    pastTPcntforCPT(tp,ild)
2856    currentDayGWAPsumforCPT(ild)
2857    currentDayTPsumforCPT(ild)
2858    avgPriorGWAP(tp,ild)
2859    cptIslandPassed(tp,sarea)
2860    cptPassed(tp,sarea)
2861    cptIslandReq(sarea)
2862    scarcityScalingFactor(tp,sarea)
2863    scaledbusPrice(tp,b)
2864    scalednodePrice(tp,n)
2865    scaledFIRprice(tp,ild)
2866    scaledSIRprice(tp,ild)
2867    scaledislandGWAP(tp,ild)
2868    scaledscarcityAreaGWAP(tp,sarea)
2869  * Unmmaped bus defificit temporary parameters
2870    temp_busDeficit_TP(dt,b)                            'Bus deficit violation for each trade period'
2871  * TN - Replacing invalid prices after SOS1
2872    busSOSinvalid(tp,b)                                 'Buses with invalid bus prices after SOS1 solve'
2873    numberofbusSOSinvalid(tp)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration) '
2874    ;
2875   
2876  Sets
2877  * Dispatch results reporting
2878    o_fromDateTime(dt)                                  'Start period for summary reports'
2879    o_dateTime(dt)                                      'Date and time for reporting'
2880    o_bus(dt,b)                                         'Set of buses for output report'
2881    o_offer(dt,o)                                       'Set of offers for output report'
2882    o_bid(dt,bd)                                        'Set of bids for output report'
2883    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2884    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2885    o_trader(trdr)                                      'Set of traders for trader summary output report'
2886    o_node(dt,n)                                        'Set of nodes for output report'
2887    o_branch(dt,br)                                     'Set of branches for output report'
2888    o_HVDClink(dt,br)                                   'HVDC links (branches) defined for the current trading period'
2889    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2890    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2891    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2892    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2893  * Audit - extra output declaration
2894    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2895    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2896    ;
2897   
2898  Parameters
2899  * Dispatch results for reporting - Trade period level - Island output
2900    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2901    o_islandLoad_TP(dt,ild)                             'Island MW fixed load for the different time periods'
2902    o_islandClrBid_TP(dt,ild)                           'Island cleared MW bid for the different time periods'
2903    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2904    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2905    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2906    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
2907    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
2908    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
2909    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
2910    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
2911    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
2912    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
2913    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
2914    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
2915    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
2916    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
2917    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
2918    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
2919    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
2920    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
2921    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
2922    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
2923    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
2924    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
2925    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
2926    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
2927    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
2928    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
2929    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
2930    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
2931    o_ACbranchTotalRentals(dt)                          'Total AC rental by trading period for reporting'
2932    o_ACbranchLossMW(dt,br,los)                         'MW element of the loss segment curve in MW'
2933    o_ACbranchLossFactor(dt,br,los)                     'Loss factor element of the loss segment curve'
2934    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
2935    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
2936    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
2937    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
2938    o_offerEnergyBlock_TP(dt,o,trdBlk)                  'Output MW cleared for each energy offer for each trade period'
2939    o_offerFIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for FIR for each trade period'
2940    o_offerSIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for SIR for each trade period'
2941    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
2942    o_bidFIR_TP(dt,bd)                                  'Output MW cleared for FIR for each trade period'
2943    o_bidSIR_TP(dt,bd)                                  'Output MW cleared for SIR for each trade period'
2944    o_ReserveReqd_TP(dt,ild,resC)                       'Output MW required for each reserve class in each trade period'
2945    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
2946    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
2947    o_ResCleared_TP(dt,ild,resC)                        'Reserve cleared from an island for each trade period'
2948    o_FIRcleared_TP(dt,ild)                             'Output - total FIR cleared by island'
2949    o_SIRcleared_TP(dt,ild)                             'Output - total SIR cleared by island'
2950    o_ResPrice_TP(dt,ild,resC)                          'Output $/MW price for each reserve classes for each trade period'
2951    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
2952    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
2953    o_ResViolation_TP(dt,ild,resC)                      'Violation MW for each reserve classes for each trade period'
2954    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
2955    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
2956    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
2957    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
2958    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
2959    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
2960    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
2961    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
2962    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
2963  * Security constraint data
2964    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
2965    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
2966    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
2967    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
2968  * Mnode constraint data
2969    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
2970    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
2971    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
2972    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
2973  * TradePeriod summary report
2974    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
2975    o_systemCost_TP(dt)                                 'System cost for summary report'
2976    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
2977    o_ofv_TP(dt)                                        'Objective function value for summary report'
2978    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
2979    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
2980    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
2981    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
2982    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
2983    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
2984    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
2985    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
2986    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
2987    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
2988    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
2989    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
2990    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
2991    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
2992    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
2993    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
2994    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
2995    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
2996  * System level
2997    o_numTradePeriods                                   'Output number of trade periods in summary'
2998    o_systemOFV                                         'System objective function value'
2999    o_systemGen                                         'Output system MWh generation'
3000    o_systemLoad                                        'Output system MWh load'
3001    o_systemLoss                                        'Output system MWh loss'
3002    o_systemViolation                                   'Output system MWh violation'
3003    o_systemFIR                                         'Output system FIR MWh reserve'
3004    o_systemSIR                                         'Output system SIR MWh reserve'
3005    o_systemEnergyRevenue                               'Output offer energy revenue $'
3006    o_systemReserveRevenue                              'Output reserve revenue $'
3007    o_systemLoadCost                                    'Output system load cost $'
3008    o_systemLoadRevenue                                 'Output system load revenue $'
3009    o_systemSurplus                                     'Output system surplus $'
3010  * Offer level
3011    o_offerGen(o)                                       'Output offer generation (MWh)'
3012    o_offerFIR(o)                                       'Output offer FIR (MWh)'
3013    o_offerSIR(o)                                       'Output offer SIR (MWh)'
3014    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
3015    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
3016    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
3017  * Trader level
3018    o_traderGen(trdr)                                   'Output trader generation (MWh)'
3019    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
3020    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
3021    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
3022    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
3023    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
3024  * Factor to prorate the deficit and surplus at the nodal level
3025    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
3026    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
3027  * Introduce i_useBusNetworkModel to account for MSP change-over date.
3028    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
3029  * Virtual reserve output
3030    o_vrResMW_TP(dt,ild,resC)                           'MW scheduled from virtual reserve resource'
3031    o_FIRvrMW_TP(dt,ild)                                'MW scheduled from virtual FIR resource'
3032    o_SIRvrMW_TP(dt,ild)                                'MW scheduled from virtual SIR resource'
3033  * Scarcity pricing output
3034    o_scarcityExists_TP(dt,ild)
3035    o_cptPassed_TP(dt,ild)
3036    o_avgPriorGWAP_TP(dt,ild)
3037    o_islandGWAPbefore_TP(dt,ild)
3038    o_islandGWAPafter_TP(dt,ild)
3039    o_scarcityGWAPbefore_TP(dt,ild)
3040    o_scarcityGWAPafter_TP(dt,ild)
3041    o_scarcityScalingFactor_TP(dt,ild)
3042    o_GWAPthreshold_TP(dt,ild)
3043    o_GWAPfloor_TP(dt,ild)
3044    o_GWAPceiling_TP(dt,ild)
3045  * Audit - extra output declaration
3046    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
3047    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
3048    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
3049    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
3050    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
3051    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
3052    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
3053    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
3054    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
3055    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
3056    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
3057    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
3058    o_generationRiskLevel(dt,ild,o,resC,riskC)                    'Audit - generation risk'
3059    o_generationRiskPrice(dt,ild,o,resC,riskC)                    'Audit - generation risk shadow price'
3060    o_HVDCriskLevel(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk'
3061    o_HVDCriskPrice(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk shadow price'
3062    o_manuRiskLevel(dt,ild,resC,riskC)                            'Audit - manual risk'
3063    o_manuRiskPrice(dt,ild,resC,riskC)                            'Audit - manual risk shadow price'
3064    o_genHVDCriskLevel(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
3065    o_genHVDCriskPrice(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk shadow price'
3066    o_manuHVDCriskLevel(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary'
3067    o_manuHVDCriskPrice(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary shadow price'
3068    o_generationRiskGroupLevel(dt,ild,rg,resC,riskC)                 'Audit - generation group risk'
3069    o_generationRiskGroupPrice(dt,ild,rg,resC,riskC)                 'Audit - generation group risk shadow price'
3070  * TN - output parameters added for NMIR project --------------------------------
3071    o_FirSent_TP(dt,ild)                        'FIR export from an island for each trade period'
3072    o_SirSent_TP(dt,ild)                        'SIR export from an island for each trade period'
3073    o_FirReceived_TP(dt,ild)                    'FIR received at an island for each trade period'
3074    o_SirReceived_TP(dt,ild)                    'SIR received at an island for each trade period'
3075    o_FirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3076    o_SirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3077    o_EffectiveRes_TP(dt,ild,resC,riskC)        'Effective reserve share to an island for each trade period'
3078    o_FirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3079    o_SirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3080  * TN - output parameters added for NMIR project end ----------------------------
3081    ;
3082   
3083  Scalars
3084    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
3085    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
3086  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
3087    useExtendedRiskClass          'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
3088  * Scarcity pricing
3089    scarcityExists                'Flag to indicate that a scarcity situation exists for at least 1 trading period in the solve'
3090    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
3091    ;
3092   
3093   
3094   
3095  *=====================================================================================
3096  * 2. Load data from GDX file
3097  *=====================================================================================
3098   
3099  * If input file does not exist then go to the next input file
3101   
3102  * Load trading period to be solved
3103  * If scarcity pricing situation exists --> load and solve all trading periods
GDXIN   A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDPeriod.gdx
--- LOAD  i_tradePeriod = 1:i_TradePeriod
--- LOAD  i_dateTime = 2:i_DateTime
3109   
3110   
3111  * Call the GDX routine and load the input data:
GDXIN   A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx
3113  * Sets
--- LOAD  i_offer = 82:i_Offer
--- LOAD  i_trader = 81:i_Trader
--- LOAD  i_bid = 100:i_bid
--- LOAD  i_node = 15:i_node
--- LOAD  i_bus = 16:i_bus
--- LOAD  i_branch = 32:i_branch
--- LOAD  i_branchConstraint = 40:i_branchConstraint
--- LOAD  i_ACnodeConstraint = 43:i_ACnodeConstraint
--- LOAD  i_MnodeConstraint = 46:i_MnodeConstraint
--- LOAD  i_genericConstraint = 52:i_genericConstraint
--- LOAD  i_type1MixedConstraint = 61:i_type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 76:i_type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 7:i_dateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 89:i_tradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 90:i_tradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 103:i_tradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 104:i_tradePeriodBidNode
--- LOAD  i_tradePeriodNode = 17:i_tradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 19:i_tradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 18:i_tradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 20:i_tradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 33:i_tradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 114:i_tradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 62:i_type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 63:i_tradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 77:i_tradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 64:i_type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 53:i_tradePeriodGenericConstraint
3120  * Parameters
--- LOAD  i_day = 2:i_day
--- LOAD  i_month = 3:i_month
--- LOAD  i_year = 4:i_year
--- LOAD  i_tradingPeriodLength = 10:i_tradingPeriodLength
--- LOAD  i_AClineUnit = 9:i_AClineUnit
--- MERGE i_branchReceivingEndLossProportion = 11:i_branchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 8:i_studyTradePeriod
--- LOAD  i_CVPvalues = 13:i_CVPvalues
--- LOAD  i_tradePeriodOfferParameter = 91:i_tradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 92:i_tradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 93:i_tradePeriodSustainedPLSRoffer
--- LOAD  i_tradePeriodFastPLSRoffer = 94:i_tradePeriodFastPLSRoffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 95:i_tradePeriodSustainedTWDRoffer
--- LOAD  i_tradePeriodFastTWDRoffer = 96:i_tradePeriodFastTWDRoffer
--- LOAD  i_tradePeriodSustainedILRoffer = 97:i_tradePeriodSustainedILRoffer
--- LOAD  i_tradePeriodFastILRoffer = 98:i_tradePeriodFastILRoffer
--- LOAD  i_tradePeriodNodeDemand = 109:i_tradePeriodNodeDemand
--- LOAD  i_tradePeriodEnergyBid = 105:i_tradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 106:i_tradePeriodSustainedILRbid
--- LOAD  i_tradePeriodFastILRbid = 107:i_tradePeriodFastILRbid
--- LOAD  i_tradePeriodHVDCNode = 23:i_tradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 24:i_tradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 34:i_tradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 35:i_tradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 36:i_tradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 37:i_tradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 27:i_noLossBranch
--- LOAD  i_AClossBranch = 28:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 29:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 21:i_tradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 22:i_tradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 115:i_tradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 116:i_tradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 41:i_tradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 42:i_tradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 44:i_tradePeriodACnodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 45:i_tradePeriodACnodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 47:i_tradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 48:i_tradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 49:i_tradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 50:i_tradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 51:i_tradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 65:i_type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 67:i_type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 68:i_type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 69:i_type1MixedConstraintHVDClineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 70:i_tradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 78:i_type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 79:i_tradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 54:i_tradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 55:i_tradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 56:i_tradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 57:i_tradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 58:i_tradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 59:i_tradePeriodGenericConstraintRHS
3134   
3135  * New risk group sets
GDXIN   A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx
--- LOAD  i_riskGroup = 146:i_riskGroup
--- LOAD  riskGroupOffer = 144:i_tradePeriodRiskGroup
3141   
3142   
3143  *=====================================================================================
3144  * 3. Manage model and data compatability
3145  *=====================================================================================
3146   
3147  * This section manages the changes to model flags to ensure backward compatibility
3148  * given changes in the SPD model formulation over time:
3149  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
3150  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
3151   
3152  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
3153  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
3154   
3155  * Calculate the Gregorian date of the input data
3156  inputGDXGDate = jdate(i_year,i_month,i_day) ;
3157   
3158  * Introduce i_useBusNetworkModel to account for MSP change-over date when for
3159  * half of the day the old market node model and the other half the bus network
3160  * model was used. The old model does not have the i_tradePeriodBusElectrical
3161  * island paramter specified since it uses the market node network model.
3162  * This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter
3163  * to be used in the post-MSP solves to indentify 'dead' electrical buses.
3164  * MSP change over from mid-day on 21 Jul 2009
3165  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= jdate(2009,7,21) ) and
3166                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
3167                                 } ;
3168   
3169  * Switch off the mixed constraint based risk offset calculation after 17 October 2011
3170  useMixedConstraintRiskOffset = 1 $ { inputGDXGDate < jdate(2011,10,17) } ;
3171   
3172  * Switch off mixed constraint formulation if no data coming through
3173  * or mixed constraint is suppressed manually in vSPDsetting.inc
3174  useMixedConstraint(tp)
3175      = 1 $ { sum[t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1]
3176          and (suppressMixedConstraint = 0) } ;
3177   
3178  put_utility temp 'gdxin' / 'A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Input\\RTD_20201028_0105_301.gdx' ;
3179   
3180  * Primary secondary offer in use from 01 May 2012'
3181  if(inputGDXGDate >= jdate(2012,05,01),
3182      execute_load i_tradePeriodPrimarySecondaryOffer ;
3183  else
3184      i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
3185  ) ;
3186   
3187  * Change to demand bid on 28 Jun 2012
3188  useDSBFDemandBidModel = 1 $ { inputGDXGDate >= jdate(2012,6,28) } ;
3189   
3190  * Manual ECE risk parameters in use from 20 Sep 2012
3191  if(inputGDXGDate >= jdate(2012,9,20),
3192      execute_load i_tradePeriodManualRisk_ECE ;
3193  else
3194      i_tradePeriodManualRisk_ECE(tp,ild,resC) = 0 ;
3195  ) ;
3196   
3197  * HVDC secondary risk parameters in use from 20 Sep 2012
3198  if(inputGDXGDate >= jdate(2012,9,20),
3199      execute_load i_tradePeriodHVDCsecRiskEnabled
3200                   i_tradePeriodHVDCsecRiskSubtractor ;
3201  else
3202      i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC) = 0 ;
3203      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
3204  ) ;
3205   
3206  * Do not use the extended risk class if no data coming through
3207  useExtendedRiskClass
3208      = 1 $ { sum[ (tp,ild,resC,riskC,riskPar) $ (ord(riskC) > 4)
3209                 , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] };
3210   
3211  * HVDC round power mode in use from 20 Sep 2012
3212  if(inputGDXGDate >= jdate(2012,9,20),
3213      execute_load i_tradePeriodAllowHVDCroundpower ;
3214  else
3215      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
3216  ) ;
3217   
3218  * Additional mixed constraint parameters exist from 24 Feb 2013
3219   
3220  if(inputGDXGDate >= jdate(2013,2,24),
3221      execute_load i_type1MixedConstraintAClineWeight
3222                   i_type1MixedConstraintAClineLossWeight
3223                   i_type1MixedConstraintAClineFixedLossWeight
3224                   i_type1MixedConstraintHVDClineLossWeight
3225                   i_type1MixedConstraintHVDClineFixedLossWeight
3226                   i_type1MixedConstraintPurWeight ;
3227  else
3228      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
3229      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
3230      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
3231      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
3232      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
3233      i_type1MixedConstraintPurWeight(t1MixCstr,bd) = 0 ;
3234  ) ;
3235   
3236  *  Reserve class generation parameter in use from 24 Feb 2013
3237  if(inputGDXGDate >= jdate(2013,2,24),
3238      execute_load i_tradePeriodReserveClassGenerationMaximum ;
3239  else
3240      i_tradePeriodReserveClassGenerationMaximum(tp,o,resC) = 0 ;
3241  ) ;
3242   
3243  * Primary secondary risk model in use from 24 Feb 2013
3244  usePrimSecGenRiskModel = 1 $ { inputGDXGDate >= jdate(2013,2,24) } ;
3245   
3246  * Dispatchable Demand effective date 20 May 2014
3247  if(inputGDXGDate >= jdate(2014,5,20),
3248      execute_load i_tradePeriodDispatchableBid;
3249  else
3250      i_tradePeriodDispatchableBid(tp,bd) =  Yes $ useDSBFDemandBidModel ;
3251  ) ;
3252  * MODD modification end
3253   
3254  * Scarcity pricing scheme for reserve available from 27 May 2014
3255  if(inputGDXGDate >= jdate(2014,5,27),
3256    execute_load i_tradePeriodVROfferMax, i_tradePeriodVROfferPrice ;
3257  else
3258    i_tradePeriodVROfferMax(tp,ild,resC) = 0 ;
3259    i_tradePeriodVROfferPrice(tp,ild,resC) = 0 ;
3260  ) ;
3261   
3262   
3263  * National market for IR effective date 20 Oct 2016
3264  if (inputGDXGDate >= jdate(2016,10,20),
3265    execute_load
3266    reserveRoundPower     = i_tradePeriodReserveRoundPower
3267    reserveShareEnabled   = i_tradePeriodReserveSharing
3268    modulationRiskClass   = i_tradePeriodModulationRisk
3269    roundPower2MonoLevel  = i_tradePeriodRoundPower2Mono
3270    bipole2MonoLevel      = i_tradePeriodBipole2Mono
3271    monopoleMinimum       = i_tradePeriodReserveSharingPoleMin
3272    HVDCControlBand       = i_tradePeriodHVDCcontrolBand
3273    HVDClossScalingFactor = i_tradePeriodHVDClossScalingFactor
3274    sharedNFRfactor       = i_tradePeriodSharedNFRfactor
3275    sharedNFRLoadOffset   = i_tradePeriodSharedNFRLoadOffset
3276    effectiveFactor       = i_tradePeriodReserveEffectiveFactor
3277    RMTreserveLimitTo     = i_tradePeriodRMTreserveLimit
3278    rampingConstraint     = i_tradePeriodRampingConstraint
3279    ;
3280  else
3281    reserveRoundPower(tp,resC)         = 0    ;
3282    reserveShareEnabled(tp,resC)       = 0    ;
3283    modulationRiskClass(tp,riskC)      = 0    ;
3284    roundPower2MonoLevel(tp)           = 0    ;
3285    bipole2MonoLevel(tp)               = 0    ;
3286    MonopoleMinimum(tp)                = 0    ;
3287    HVDCControlBand(tp,fd)             = 0    ;
3288    HVDClossScalingFactor(tp)          = 0    ;
3289    sharedNFRfactor(tp)                = 0    ;
3290    sharedNFRloadOffset(tp,ild)        = 0    ;
3291    effectiveFactor(tp,ild,resC,riskC) = 0    ;
3292    RMTreserveLimitTo(tp,ild,resC)     = 0    ;
3293    rampingConstraint(tp,brCstr)       = no   ;
3294  ) ;
3295   
3296  UseShareReserve = 1 $ sum[ (tp,resC), reserveShareEnabled(tp,resC)] ;
3297   
3298  *=====================================================================================
3299  * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
3300  *=====================================================================================
3301   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
3315   
3317   
3318   
3319  *=====================================================================================
3320  * 5. Initialise constraint violation penalties (CVPs)
3321  *=====================================================================================
3322   
3323  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
3324  * Calculate the Gregorian date of the CE and ECE change
3325  * Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
3326  CVPchangeGDate = jdate(2010,06,24) ;
3327   
3328  * Set the flag for the application of the different CVPs for CE and ECE
3329  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
3330  diffCeECeCVP = 0 ;
3331  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
3332  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
3333  * If the user selects Yes (1), set the diffCeECeCVP flag
3334  diffCeECeCVP $ (-1 = 1) = 1 ;
3335   
3336  deficitBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
3337  surplusBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
3338  deficitReservePenalty(resC) $ (ord(resC) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3339  deficitReservePenalty(resC) $ (ord(resC) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3340  deficitBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
3341  surplusBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
3342  deficitGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
3343  surplusGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
3344  deficitRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
3345  surplusRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
3346  deficitACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
3347  surplusACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
3348  deficitBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
3349  surplusBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
3350  deficitMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
3351  surplusMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
3352  deficitT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
3353  surplusT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
3354  * Different CVPs defined for CE and ECE
3355  deficitReservePenalty_CE(resC) $ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3356  deficitReservePenalty_CE(resC) $ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3357  deficitReservePenalty_ECE(resC)$ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
3358  deficitReservePenalty_ECE(resC)$ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
3359   
3360  *=====================================================================================
3361  * 6. Initialise model mapping and inputs
3362  *=====================================================================================
3363   
3364  * Pre-dispatch schedule is solved sequentially
3365  sequentialSolve
3366      $ ( sum[ (tp,o,offerPar) $ {(ord(tp) = 2) and (ord(offerPar) = 1)}
3367                               , i_tradePeriodOfferParameter(tp,o,offerPar) ] = 0
3368        ) = 1 ;
3369   
3370  sequentialSolve $ UseShareReserve = 1;
3371   
3372  * Initialise bus, node, offer, bid for the current trade period start
3373  bus(tp,b)  $ i_tradePeriodBus(tp,b)  = yes  ;
3374  node(tp,n) $ i_tradePeriodNode(tp,n) = yes  ;
3375   
3376  * Initialise network sets for the current trade period start
3377  nodeBus(node,b)     $ i_tradePeriodNodeBus(node,b)        = yes ;
3378  HVDCnode(node)      $ i_tradePeriodHVDCnode(node)         = yes ;
3379  ACnode(node)        $ ( not HVDCnode(node))               = yes ;
3380  referenceNode(node) $ i_tradePeriodReferenceNode(node)    = yes ;
3381  DCbus(tp,b)         $ sum[ nodeBus(HVDCnode(tp,n),b), 1 ] = yes ;
3382  ACbus(tp,b)         $ ( not DCbus(tp,b) )                 = yes ;
3383   
3384  * Bus live island status
3385  busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3386   
3387  * Offer initialisation - offer must be mapped to a node that is mapped to a
3388  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3389  offer(tp,o) $ sum[ (n,b) $ { i_tradePeriodOfferNode(tp,o,n) and
3390                               nodeBus(tp,n,b) and
3391                               ( (not i_useBusNetworkModel(tp)) or
3392                                 busElectricalIsland(tp,b))
3393                             }, 1 ] = yes ;
3394   
3395  * IL offer mapped to a node that is mapped to a bus always valid
3396  * (updated on 23 July 2015 based on an email from SO Bennet Tucker on 21 July 2015))
3397  offer(tp,o)
3398      $ sum[ (n,b)
3399           $ { i_tradePeriodOfferNode(tp,o,n) and nodeBus(tp,n,b)
3400           and sum[ (trdBlk,ILofrCmpnt)
3401                  , i_tradePeriodFastILRoffer(tp,o,trdBlk,ILofrCmpnt)
3402                  + i_tradePeriodSustainedILRoffer(tp,o,trdBlk,ILofrCmpnt) ]
3403             }, 1 ] = yes ;
3404   
3405  * Bid initialisation - bid must be mapped to a node that is mapped to a bus
3406  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3407  bid(tp,bd) $ sum[ (n,b) $ { i_tradePeriodBidNode(tp,bd,n) and
3408                              nodeBus(tp,n,b) and
3409                              ( (not i_useBusNetworkModel(tp)) or
3410                                busElectricalIsland(tp,b) )
3411                            }, 1 ] = yes ;
3412   
3413  * Initialise Risk/Reserve data for the current trading period
3414  RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3415   
3416  * Mapping bus, node, offer, bid and island start for the current trade period
3417  offerNode(offer,n)   $ i_tradePeriodOfferNode(offer,n)                 = yes ;
3418  bidNode(bid,n)       $ i_tradePeriodBidNode(bid,n)                     = yes ;
3419  busIsland(bus,ild)   $ i_tradePeriodBusIsland(bus,ild)                 = yes ;
3420  nodeIsland(tp,n,ild) $ sum[ b $ { bus(tp,b) and node(tp,n)
3421                                and nodeBus(tp,n,b)
3422                                and busIsland(tp,b,ild) }, 1 ]           = yes ;
3423  offerIsland(offer(tp,o),ild)
3424      $ sum[ n $ { offerNode(tp,o,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3425  bidIsland(bid(tp,bd),ild)
3426      $ sum[ n $ { bidNode(tp,bd,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3427   
3428  IslandRiskGenerator(tp,ild,o)
3429      $ { offerIsland(tp,o,ild) and RiskGenerator(tp,o) } = yes ;
3430   
3431  * Set the primary-secondary offer combinations
3432  primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3433   
3434  * Identification of primary and secondary units
3435  hasSecondaryOffer(tp,o) = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o,o1), 1 ] ;
3436  hasPrimaryOffer(tp,o)   = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o1,o), 1 ];
3437   
3438  * Initialise offer parameters for the current trade period start
3439  generationStart(offer(tp,o))
3440      = sum[ offerPar $ ( ord(offerPar) = 1 )
3441                      , i_tradePeriodOfferParameter(tp,o,offerPar)
3442                      + sum[ o1 $ primarySecondaryOffer(tp,o,o1)
3443                                ,i_tradePeriodOfferParameter(tp,o1,offerPar) ]
3444           ];
3445   
3446  rampRateUp(offer)
3447      = sum[ offerPar $ ( ord(offerPar) = 2 )
3448                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3449  rampRateDown(offer)
3450      = sum[ offerPar $ ( ord(offerPar) = 3 )
3451                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3452  reserveGenerationMaximum(offer)
3453      = sum[ offerPar $ ( ord(offerPar) = 4 )
3454                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3455  windOffer(offer)
3456      = sum[ offerPar $ ( ord(offerPar) = 5 )
3457                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3458  FKband(offer)
3459      = sum[ offerPar $ ( ord(offerPar) = 6 )
3460                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3461   
3462  priceResponsive(offer)
3463      = sum[ offerPar $ ( ord(offerPar) = 7 )
3464                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3465   
3466  potentialMW(offer)
3467      = sum[ offerPar $ ( ord(offerPar) = 8 )
3468                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3469   
3470   
3471  * Initialise energy offer data for the current trade period start
3472  generationOfferMW(offer,trdBlk)
3473      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3474                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3475  generationOfferPrice(offer,trdBlk)
3476      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3477                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3478   
3479  * Valid generation offer blocks are defined as those with a positive block limit
3480  validGenerationOfferBlock(offer,trdBlk)
3481      $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3482   
3483  * Define set of positive energy offers
3484  positiveEnergyOffer(offer)
3485      $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3486   
3487  * Initialise reserve offer data for the current trade period start
3488  PLSRReserveType(resT) $ (ord(resT) = 1) = yes ;
3489  TWDRReserveType(resT) $ (ord(resT) = 2) = yes ;
3490  ILReserveType(resT)   $ (ord(resT) = 3) = yes ;
3491   
3492  reserveOfferProportion(offer,trdBlk,resC)
3493      $ ( ord(resC) = 1 )
3494      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3495           , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3496   
3497  reserveOfferProportion(offer,trdBlk,resC)
3498      $ ( ord(resC) = 2 )
3499      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3500           , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3501   
3502  reserveOfferMaximum(offer(tp,o),trdBlk,resC,PLSRReserveType)
3503      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3504      , i_tradePeriodFastPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3505      + i_tradePeriodSustainedPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3506   
3507  reserveOfferMaximum(offer(tp,o),trdBlk,resC,TWDRReserveType)
3508      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3509      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3510      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3511   
3512  reserveOfferMaximum(offer,trdBlk,resC,ILReserveType)
3513      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3514      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3515      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ];
3516   
3517  reserveOfferPrice(offer,trdBlk,resC,PLSRReserveType)
3518      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3519      , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3520      + i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3521   
3522   
3523  reserveOfferPrice(offer,trdBlk,resC,TWDRReserveType)
3524      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3525      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3526      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3527   
3528  reserveOfferPrice(offer,trdBlk,resC,ILReserveType)
3529      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3530      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3531      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ] ;
3532   
3533  * Only reserve offer block with a positive block limit is valid
3534  validReserveOfferBlock(offer,trdBlk,resC,resT)
3535      $ (reserveOfferMaximum(offer,trdBlk,resC,resT) > 0) = yes ;
3536   
3537  * Bid energy data
3538  purchaseBidMW(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3539      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3540           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3541   
3542  purchaseBidPrice(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3543      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3544           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3545   
3546  validPurchaseBidBlock(bid,trdBlk)
3547      $ { ( purchaseBidMW(bid,trdBlk) > 0 ) or
3548          ( useDSBFDemandBidModel * purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3549   
3550  * Bid IL data
3551  purchaseBidILRMW(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3552      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3553           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3554           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3555   
3556  purchaseBidILRPrice(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3557      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3558           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3559           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3560   
3561  validPurchaseBidILRBlock(bid,trdBlk,resC)
3562      $ ( purchaseBidILRMW(bid,trdBlk,resC) > 0 ) = yes ;
3563   
3564   
3565  * Initialise demand/bid data for the current trade period start
3566  nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3567   
3568  * If a bid is valid --> ignore the demand at the node connected to the bid
3569  * (PA suggested during v1.4 Audit)
3570  nodeDemand(node(tp,n))
3571      $ { useDSBFDemandBidModel and
3572          Sum[ bd $ { bidNode(tp,bd,n) and i_tradePeriodDispatchableBid(tp,bd) }
3573             , 1 ]
3574        } = 0;
3575   
3576  * Branch is defined if there is a defined terminal bus, it has a non-zero
3577  * capacity and is closed for that trade period
3578  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3579                    i_tradePeriodBranchCapacity(tp,br)         and
3580                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3581                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3582                  } = yes ;
3583   
3584  branchBusDefn(branch,b,b1) $ i_tradePeriodBranchDefn(branch,b,b1)    = yes ;
3585  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b,b1), 1] = yes ;
3586  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b1,b), 1] = yes ;
3587   
3588  * HVDC link and AC branch definition
3589  HVDClink(branch)      $ i_tradePeriodHVDCBranch(branch)         = yes ;
3590  HVDCpoles(branch)     $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3591  HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3592  ACbranch(branch)      $ ( not HVDClink(branch) )                = yes ;
3593   
3594  * Determine sending and receiving bus sets
3595  loop((frB,toB),
3596      ACbranchSendingBus(ACbranch,frB,fd)
3597          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3598   
3599      ACbranchReceivingBus(ACbranch,toB,fd)
3600          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3601   
3602      ACbranchSendingBus(ACbranch,toB,fd)
3603          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3604   
3605      ACbranchReceivingBus(ACbranch,frB,fd)
3606          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3607  );
3608   
3609  HVDClinkSendingBus(HVDClink,frB)
3610      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3611   
3612  HVDClinkReceivingBus(HVDClink,toB)
3613      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3614   
3615  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
3616  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
3617   
3618  * Determine the HVDC inter-island pole in the northward and southward direction
3619   
3620  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 1) and HVDClink(tp,br) }
3621      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 2)
3622                                         and nodeIsland(tp,n,ild)
3623                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3624   
3625  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 2) and HVDClink(tp,br) }
3626      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 1)
3627                                         and nodeIsland(tp,n,ild)
3628                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3629   
3630  * Mapping HVDC branch to pole to account for name changes to Pole 3
3631  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3632  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3633  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3634  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3635  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3636  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3637   
3638  * Initialise network data for the current trade period start
3639  * Node-bus allocation factor
3640  nodeBusAllocationFactor(tp,n,b) $ { node(tp,n) and bus(tp,b) }
3641      = i_tradePeriodNodeBusAllocationFactor(tp,n,b) ;
3642   
3643  * Flag to allow roundpower on the HVDC link
3644  allowHVDCroundpower(tp) = i_tradePeriodAllowHVDCroundpower(tp) ;
3645   
3646  * Allocate the input branch parameters to the defined model parameters
3647  branchCapacity(branch) = i_tradePeriodBranchCapacity(branch) ;
3648   
3649  branchResistance(branch)
3650      = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3651           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3652   
3653  * Convert susceptance from -Bpu to B% for data post-MSP
3654  branchSusceptance(ACbranch(tp,br))
3655      = sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3656           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ]
3657      * [ 100$(not i_useBusNetworkModel(tp)) - 100$i_useBusNetworkModel(tp) ];
3658   
3659  branchLossBlocks(branch)
3660      = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3661           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3662   
3663  * Ensure fixed losses for no loss AC branches are not included
3664  branchFixedLoss(ACbranch)
3665      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3666           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3667           ] $ (branchLossBlocks(ACbranch) > 1) ;
3668   
3669  branchFixedLoss(HVDClink)
3670      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3671           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3672   
3673  * Set resistance and fixed loss to zero if do not want to use the loss model
3674  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3675  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
3676   
3677  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3678  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
3679   
3680  * Initialise loss tranches data for the current trade period start
3681  * The loss factor coefficients assume that the branch capacity is in MW
3682  * and the resistance is in p.u.
3683   
3684  * Loss branches with 0 loss blocks
3685  LossSegmentMW(branch,los)
3686      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3687      = branchCapacity(branch) ;
3688   
3689  LossSegmentFactor(branch,los)
3690      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3691      = 0 ;
3692   
3693  * Loss branches with 1 loss blocks
3694  LossSegmentMW(branch,los)
3695      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3696      = maxFlowSegment ;
3697   
3698  LossSegmentFactor(branch,los)
3699      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3700      = 0.01 * branchResistance(branch) * branchCapacity(branch) ;
3701   
3702  * Loss branches with 3 loss blocks
3703  loop( branch $ (branchLossBlocks(branch) = 3),
3704  *   Segment 1
3705      LossSegmentMW(branch,los) $ (ord(los) = 1)
3706          = lossCoeff_A * branchCapacity(branch) ;
3707   
3708      LossSegmentFactor(branch,los) $ (ord(los) = 1)
3709          = 0.01 * 0.75 * lossCoeff_A
3710          * branchResistance(branch) * branchCapacity(branch) ;
3711   
3712  *   Segment 2
3713      LossSegmentMW(branch,los) $ (ord(los) = 2)
3714          = (1-lossCoeff_A) * branchCapacity(branch) ;
3715   
3716      LossSegmentFactor(branch,los) $ (ord(los) = 2)
3717          = 0.01 * branchResistance(branch) * branchCapacity(branch) ;
3718   
3719  *   Segment 3
3720      LossSegmentMW(branch,los) $ (ord(los) = 3)
3721          = maxFlowSegment ;
3722   
3723      LossSegmentFactor(branch,los) $ (ord(los) = 3)
3724          = 0.01 * (2 - (0.75*lossCoeff_A))
3725          * branchResistance(branch) * branchCapacity(branch) ;
3726  );
3727   
3728  * Loss branches with 6 loss blocks
3729  loop( branch $ (branchLossBlocks(branch) = 6),
3730  *   Segment 1
3731      LossSegmentMW(branch,los) $ (ord(los) = 1)
3732          = lossCoeff_C  * branchCapacity(branch) ;
3733   
3734      LossSegmentFactor(branch,los) $ (ord(los) = 1)
3735          = 0.01 * 0.75 * lossCoeff_C
3736          * branchResistance(branch) * branchCapacity(branch) ;
3737   
3738  *   Segment 2
3739      LossSegmentMW(branch,los) $ (ord(los) = 2)
3740          = lossCoeff_D * branchCapacity(branch) ;
3741   
3742      LossSegmentFactor(branch,los) $ (ord(los) = 2)
3743          = 0.01 * lossCoeff_E
3744          * branchResistance(branch) * branchCapacity(branch) ;
3745   
3746  *   Segment 3
3747      LossSegmentMW(branch,los) $ (ord(los) = 3)
3748          = 0.5 * branchCapacity(branch) ;
3749   
3750      LossSegmentFactor(branch,los) $ (ord(los) = 3)
3751          = 0.01 * lossCoeff_F
3752          * branchResistance(branch) * branchCapacity(branch) ;
3753   
3754  *   Segment 4
3755      LossSegmentMW(branch,los) $ (ord(los) = 4)
3756          = (1 - lossCoeff_D) * branchCapacity(branch) ;
3757   
3758      LossSegmentFactor(branch,los) $ (ord(los) = 4)
3759          = 0.01 * (2 - lossCoeff_F)
3760          * branchResistance(branch) * branchCapacity(branch) ;
3761   
3762  *   Segment 5
3763      LossSegmentMW(branch,los) $ (ord(los) = 5)
3764          = (1 - lossCoeff_C) * branchCapacity(branch) ;
3765   
3766      LossSegmentFactor(branch,los) $ (ord(los) = 5)
3767          = 0.01 * (2 - lossCoeff_E)
3768          * branchResistance(branch) * branchCapacity(branch) ;
3769   
3770  *   Segment 6
3771      LossSegmentMW(branch,los) $ (ord(los) = 6)
3772          = maxFlowSegment ;
3773   
3774      LossSegmentFactor(branch,los) $ (ord(los) = 6)
3775          = 0.01 * (2 - (0.75*lossCoeff_C))
3776          * branchResistance(branch) * branchCapacity(branch) ;
3777  ) ;
3778   
3779  * Valid loss segment for a branch is defined as a loss segment that
3780  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
3781  validLossSegment(branch,los) = yes $ { (ord(los) = 1) or
3782                                         LossSegmentMW(branch,los) or
3783                                         LossSegmentFactor(branch,los) } ;
3784   
3785  * HVDC loss model requires at least two loss segments and
3786  * an additional loss block due to cumulative loss formulation
3787  validLossSegment(HVDClink,los)
3788      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
3789   
3790  validLossSegment(HVDClink,los)
3791      $ { (branchLossBlocks(HVDClink) > 1) and
3792          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
3793          (sum[ los1, LossSegmentMW(HVDClink,los1)
3794                    + LossSegmentFactor(HVDClink,los1) ] > 0)
3795        } = yes ;
3796   
3797  * branches that have non-zero loss factors
3798  LossBranch(branch) $ sum[ los, LossSegmentFactor(branch,los) ] = yes ;
3799   
3800  * Create AC branch loss segments
3801  ACbranchLossMW(ACbranch,los)
3802      $ { validLossSegment(ACbranch,los) and (ord(los) = 1) }
3803      = LossSegmentMW(ACbranch,los) ;
3804   
3805  ACbranchLossMW(ACbranch,los)
3806      $ { validLossSegment(ACbranch,los) and (ord(los) > 1) }
3807      = LossSegmentMW(ACbranch,los) - LossSegmentMW(ACbranch,los-1) ;
3808   
3809  ACbranchLossFactor(ACbranch,los)
3810      $ validLossSegment(ACbranch,los) = LossSegmentFactor(ACbranch,los) ;
3811   
3812  * Create HVDC loss break points
3813  HVDCBreakPointMWFlow(HVDClink,bp) $ (ord(bp) = 1) = 0 ;
3814  HVDCBreakPointMWLoss(HVDClink,bp) $ (ord(bp) = 1) = 0 ;
3815   
3816  HVDCBreakPointMWFlow(HVDClink,bp)
3817      $ { validLossSegment(HVDClink,bp) and (ord(bp) > 1) }
3818      = LossSegmentMW(HVDClink,bp-1) ;
3819   
3820  HVDCBreakPointMWLoss(HVDClink,bp)
3821      $ { validLossSegment(HVDClink,bp) and (ord(bp) = 2) }
3822      =  LossSegmentMW(HVDClink,bp-1) * LossSegmentFactor(HVDClink,bp-1)  ;
3823   
3824  loop( (HVDClink(branch),bp) $ (ord(bp) > 2),
3825      HVDCBreakPointMWLoss(branch,bp) $ validLossSegment(branch,bp)
3826          = LossSegmentFactor(branch,bp-1)
3827          * [ LossSegmentMW(branch,bp-1) - LossSegmentMW(branch,bp-2) ]
3828          + HVDCBreakPointMWLoss(branch,bp-1) ;
3829  ) ;
3830   
3831  * Initialise branch constraint data for the current trading period
3832  branchConstraint(tp,brCstr)
3833      $ sum[ branch(tp,br)
3834           $ i_tradePeriodBranchConstraintFactors(tp,brCstr,br), 1 ] = yes ;
3835   
3836  branchConstraintFactors(branchConstraint,br)
3837      = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
3838   
3839  branchConstraintSense(branchConstraint)
3840      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
3841           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
3842   
3843  branchConstraintLimit(branchConstraint)
3844      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
3845           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
3846   
3847  * Calculate parameters for NMIR project ----------------------------------------
3848  islandRiskGroup(tp,ild,rg,riskC)
3849      = yes $ sum[ o $ { offerIsland(tp,o,ild)
3850                     and riskGroupOffer(tp,rg,o,riskC) }, 1 ] ;
3851   
3852  modulationRisk(tp) = smax[ riskC, modulationRiskClass(tp,RiskC) ];
3853   
3854  reserveShareEnabledOverall(tp) = smax[ resC, reserveShareEnabled(tp,resC) ];
3855   
3856  roPwrZoneExit(tp,resC)
3857      = [ roundPower2MonoLevel(tp) - modulationRisk(tp) ]$(ord(resC)=1)
3858      + bipole2MonoLevel(tp)$(ord(resC)=2) ;
3859   
3860  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition by SPD pre-processing (same as for SIR),
            a change from the existing where the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone for FIR will be removed by SPD pre-processing (same as for SIR),
            a change from the existing where the InNoReverseZone for FIR is never removed by SPD pre-processing.
3868   
3869  if (inputGDXGDate >= jdate(2019,03,28),
3870      roPwrZoneExit(tp,resC) = bipole2MonoLevel(tp) ;
3871  ) ;
3872   
3873  * National market refinement end
3874   
3875   
3876  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
3877  sharedNFRLoad(tp,ild)
3878      = sum[ nodeIsland(tp,n,ild), nodeDemand(tp,n)]
3879      + sum[ (bd,trdBlk) $ bidIsland(tp,bd,ild), purchaseBidMW(tp,bd,trdBlk) ]
3880      - sharedNFRLoadOffset(tp,ild) ;
3881   
3882  sharedNFRMax(tp,ild) = Min{ RMTReserveLimitTo(tp,ild,'FIR'),
3883                              sharedNFRFactor(tp)*sharedNFRLoad(tp,ild) } ;
3884   
3885  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
3886  * TN on 22 May 2017: Usually a branch group constraint that limits the HVDC flow only involves
3887  * the HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017, the
3888  * constraint HAY_BEN_High_Frequency_limit involved all four branches in the form:
3889  *   HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
3890  * This method of formulating the constraint prevented the previous formulation of monopoleConstraint
3891  * and bipoleConstraintfrom working properly. Those constraints have been reformulated (see below)
3892  * in order to cope with the formulation observed on 18 May 2017.
3893  monopoleConstraint(tp,ild,brCstr,br)
3894      $ { HVDCpoles(tp,br)
3895      and ( not rampingConstraint(tp,brCstr) )
3896      and ( branchConstraintSense(tp,brCstr) = -1 )
3897      and (Sum[ (br1,b) $ {HVDClinkSendingBus(tp,br1,b) and busIsland(tp,b,ild)}
3898                        , branchConstraintFactors(tp,brCstr,br1)    ] = 1)
3899      and (Sum[ b $ {HVDClinkSendingBus(tp,br,b) and busIsland(tp,b,ild)}
3900                   , branchConstraintFactors(tp,brCstr,br)      ] = 1)
3901         } = yes ;
3902   
3903  bipoleConstraint(tp,ild,brCstr)
3904      $ { ( not rampingConstraint(tp,brCstr) )
3905      and ( branchConstraintSense(tp,brCstr) = -1 )
3906      and (Sum[ (br,b) $ { HVDCpoles(tp,br)
3907                       and HVDClinkSendingBus(tp,br,b)
3908                       and busIsland(tp,b,ild) }
3909                      , branchConstraintFactors(tp,brCstr,br)  ] = 2)
3910                         } = yes ;
3911   
3912  monoPoleCapacity(tp,ild,br)
3913      = Sum[ b $ { BusIsland(tp,b,ild)
3914               and HVDCPoles(tp,br)
3915               and HVDClinkSendingBus(tp,br,b)
3916                 }, branchCapacity(tp,br) ] ;
3917   
3918  monoPoleCapacity(tp,ild,br)
3919      $ Sum[ brCstr $ monopoleConstraint(tp,ild,brCstr,br), 1]
3920      = Smin[ brCstr $ monopoleConstraint(tp,ild,brCstr,br)
3921            , branchConstraintLimit(tp,brCstr) ];
3922   
3923  monoPoleCapacity(tp,ild,br)
3924      = Min( monoPoleCapacity(tp,ild,br), branchCapacity(tp,br) );
3925   
3926  biPoleCapacity(tp,ild)
3927      $ Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1]
3928      = Smin[ brCstr $ bipoleConstraint(tp,ild,brCstr)
3929            , branchConstraintLimit(tp,brCstr) ];
3930   
3931  biPoleCapacity(tp,ild)
3932      $ { Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1] = 0 }
3933      = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
3934                    and HVDClinkSendingBus(tp,br,b) }, branchCapacity(tp,br) ] ;
3935   
3936  HVDCMax(tp,ild)
3937      = Min( biPoleCapacity(tp,ild), Sum[ br, monoPoleCapacity(tp,ild,br) ] ) ;
3938   
3939  * Calculate HVDC HVDC Loss segment applied for NMIR
3940   
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
3946  if (inputGDXGDate >= jdate(2016,11,22),
3947        HVDCCapacity(tp,ild)
3948            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
3949                          and HVDClinkSendingBus(tp,br,b)
3950                            }, branchCapacity(tp,br) ] ;
3951   
3952        numberOfPoles(tp,ild)
3953            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
3954                          and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3955   
3956        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
3957            = Prod[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
3958                           and HVDClinkSendingBus(tp,br,b)
3959                             }, branchResistance(tp,br) ]
3960            / Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
3961                          and HVDClinkSendingBus(tp,br,b)
3962                            }, branchResistance(tp,br) ] ;
3963   
3964        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 1)
3965            = Sum[ br $ monoPoleCapacity(tp,ild,br), branchResistance(tp,br) ] ;
3966  else
3967      HVDCCapacity(tp,ild)
3968          = Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
3969                        and i_tradePeriodBusIsland(tp,b,ild)
3970                        and i_tradePeriodBranchDefn(tp,br,b,b1)
3971                          }, i_tradePeriodBranchCapacity(tp,br) ] ;
3972   
3973      numberOfPoles(tp,ild)
3974          =Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
3975                        and i_tradePeriodBusIsland(tp,b,ild)
3976                        and i_tradePeriodBranchDefn(tp,br,b,b1)
3977                        and i_tradePeriodBranchCapacity(tp,br)
3978                          }, 1 ] ;
3979   
3980      HVDCResistance(tp,ild)
3981          =  Sum[ (br,b,b1,i_branchParameter)
3982                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
3983                and i_tradePeriodBusIsland(tp,b,ild)
3984                and i_tradePeriodBranchDefn(tp,br,b,b1)
3985                and (ord(i_branchParameter) = 1)
3986                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter) ] ;
3987   
3988      HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
3989          = Prod[ (br,b,b1,i_branchParameter)
3990                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
3991                and i_tradePeriodBusIsland(tp,b,ild)
3992                and i_tradePeriodBranchDefn(tp,br,b,b1)
3993                and i_tradePeriodBranchCapacity(tp,br)
3994                and (ord(i_branchParameter) = 1)
3995                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter)
3996                ] / HVDCResistance(tp,ild) ;
3997  ) ;
3998   
3999  * Segment 1
4000  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 1)
4001      = HVDCCapacity(tp,ild) * lossCoeff_C ;
4002   
4003  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 1)
4004      = 0.01 * 0.75 * lossCoeff_C
4005      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4006   
4007  * Segment 2
4008  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 2)
4009      = HVDCCapacity(tp,ild) * lossCoeff_D ;
4010   
4011  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 2)
4012      = 0.01 * lossCoeff_E
4013      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4014   
4015  * Segment 3
4016  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 3)
4017      = HVDCCapacity(tp,ild) * 0.5 ;
4018   
4019  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 3)
4020      = 0.01 * lossCoeff_F
4021      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4022   
4023  * Segment 4
4024  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 4)
4025      = HVDCCapacity(tp,ild) * (1 - lossCoeff_D) ;
4026   
4027  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 4)
4028      = 0.01 * (2 - lossCoeff_F)
4029      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4030   
4031  * Segment 5
4032  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 5)
4033      = HVDCCapacity(tp,ild) * (1 - lossCoeff_C) ;
4034   
4035  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 5)
4036      = 0.01 * (2 - lossCoeff_E)
4037      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4038   
4039  * Segment 6
4040  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 6)
4041      = HVDCCapacity(tp,ild) ;
4042   
4043  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 6)
4044      = 0.01 * (2 - (0.75*lossCoeff_C))
4045      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4046   
4047  * Parameter for energy lambda loss model
4048  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4049  HVDCSentBreakPointMWLoss(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4050   
4051  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) > 1)
4052      = HVDCLossSegmentMW(tp,ild,bp-1) ;
4053   
4054  loop( (tp,ild,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)},
4055      HVDCSentBreakPointMWLoss(tp,ild,bp)
4056          = HVDClossScalingFactor(tp)
4057          * HVDCLossSegmentFactor(tp,ild,bp-1)
4058          * [ HVDCLossSegmentMW(tp,ild,bp-1)
4059            - HVDCSentBreakPointMWFlow(tp,ild,bp-1) ]
4060          + HVDCSentBreakPointMWLoss(tp,ild,bp-1) ;
4061  ) ;
4062   
4063  * Parameter for energy+reserve lambda loss model
4064   
4065  * Ideally SO should use asymmetric loss curve
4066  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4067      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4068                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4069           , -HVDCSentBreakPointMWFlow(tp,ild1,rsbp1) ];
4070   
4071  * SO decide to use symmetric loss curve instead
4072  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4073      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4074           , -HVDCSentBreakPointMWFlow(tp,ild,rsbp1) ];
4075   
4076  HVDCReserveBreakPointMWFlow(tp,ild,rsbp)
4077      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4078      = HVDCSentBreakPointMWFlow(tp,ild,rsbp-6) ;
4079   
4080   
4081  * Ideally SO should use asymmetric loss curve
4082  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4083      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4084                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4085           , HVDCSentBreakPointMWLoss(tp,ild1,rsbp1) ];
4086   
4087  * SO decide to use symmetric loss curve instead
4088  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4089      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4090           , HVDCSentBreakPointMWLoss(tp,ild,rsbp1) ];
4091   
4092  HVDCReserveBreakPointMWLoss(tp,ild,rsbp)
4093      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4094      = HVDCSentBreakPointMWLoss(tp,ild,rsbp-6);
4095   
4096  * Parameter for lambda loss model  end
4097   
4098  * Initialze parameters for NMIR project end ----------------------------------
4099   
4100   
4101  * Initialise risk/reserve data for the current trade period start
4102   
4103  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
4104  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
4105  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
4106  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
4107  GenRisk(riskC)     $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4108  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4109  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4110  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4111   
4112  * Define the CE and ECE risk class set to support the different CE and ECE CVP
4113  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
4114  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
4115  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
4116  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
4117  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4118  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4119  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4120  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4121   
4122  * Risk parameters
4123  FreeReserve(tp,ild,resC,riskC)
4124      = sum[ riskPar $ (ord(riskPar) = 1)
4125                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ]
4126  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4127      - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(tp,ild1)
4128           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4129             and (inputGDXGDate >= jdate(2016,10,20)) }
4130      ;
4131   
4132  IslandRiskAdjustmentFactor(tp,ild,resC,riskC) $ useReserveModel
4133      = sum[ riskPar $ (ord(riskPar) = 2)
4134                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4135   
4136  * HVDC rampup max - (3.4.1.3) - SPD version 11
4137  HVDCpoleRampUp(tp,ild,resC,riskC)
4138      = sum[ riskPar $ (ord(riskPar) = 3)
4139                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4140   
4141  * Index IslandMinimumRisk to cater for CE and ECE minimum risk
4142  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 4)
4143      = i_tradePeriodManualRisk(tp,ild,resC) ;
4144   
4145  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 6)
4146      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4147   
4148  * HVDC secondary risk parameters
4149  HVDCsecRiskEnabled(tp,ild,riskC)= i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC);
4150  HVDCsecRiskSubtractor(tp,ild)   = i_tradePeriodHVDCsecRiskSubtractor(tp,ild) ;
4151   
4152  * Min risks for the HVDC secondary risk are the same as the island min risk
4153  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 7)
4154      = i_tradePeriodManualRisk(tp,ild,resC) ;
4155   
4156  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 8)
4157      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4158   
4159  * The MW combined maximum capability for generation and reserve of class.
4160  reserveClassGenerationMaximum(offer,resC) = ReserveGenerationMaximum(offer) ;
4161   
4162  reserveClassGenerationMaximum(offer,resC)
4163      $ i_tradePeriodReserveClassGenerationMaximum(offer,resC)
4164      = i_tradePeriodReserveClassGenerationMaximum(offer,resC) ;
4165   
4166  * Calculation of reserve maximum factor - 5.2.1.1
4167  ReserveMaximumFactor(offer,resC) = 1 ;
4168  ReserveMaximumFactor(offer,resC)
4169      $ (ReserveClassGenerationMaximum(offer,resC)>0)
4170      = ReserveGenerationMaximum(offer)
4171      / reserveClassGenerationMaximum(offer,resC) ;
4172   
4173  * Virtual reserve
4174  virtualReserveMax(tp,ild,resC) = i_tradePeriodVROfferMax(tp,ild,resC) ;
4175  virtualReservePrice(tp,ild,resC) = i_tradePeriodVROfferPrice(tp,ild,resC) ;
4176   
4177  * Initialise AC node constraint data for the current trading period
4178  ACnodeConstraint(tp,ACnodeCstr)
4179      $ sum[ ACnode(tp,n)
4180           $ i_tradePeriodACnodeConstraintFactors(tp,ACnodeCstr,n), 1 ] = yes ;
4181   
4182  ACnodeConstraintFactors(ACnodeConstraint,n)
4183      = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
4184   
4185  ACnodeConstraintSense(ACnodeConstraint)
4186      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4187           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4188   
4189  ACnodeConstraintLimit(ACnodeConstraint)
4190      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4191           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4192   
4193  * Initialise market node constraint data for the current trading period
4194  MnodeConstraint(tp,MnodeCstr)
4195      $ { sum[ (offer(tp,o),resT,resC)
4196             $ { i_tradePeriodMnodeEnergyOfferConstraintFactors(tp,MnodeCstr,o) or
4197                 i_tradePeriodMnodeReserveOfferConstraintFactors(tp,MnodeCstr,o,resC,resT)
4198               }, 1
4199             ]
4200        or
4201          sum[ (bid(tp,bd),resC)
4202             $ { i_tradePeriodMnodeEnergyBidConstraintFactors(tp,MnodeCstr,bd) or
4203                 i_tradePeriodMnodeILReserveBidConstraintFactors(tp,MnodeCstr,bd,resC)
4204               }, 1
4205             ]
4206        } = yes ;
4207   
4208  MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
4209      = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
4210   
4211  MnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT)
4212      = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT) ;
4213   
4214  MnodeEnergyBidConstraintFactors(MnodeConstraint,bd)
4215      = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,bd) ;
4216   
4217  MnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC)
4218      = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC) ;
4219   
4220  MnodeConstraintSense(MnodeConstraint)
4221      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4222           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4223   
4224  MnodeConstraintLimit(MnodeConstraint)
4225      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4226           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4227   
4228  * Initialise mixed constraint data for the current trading period
4229  Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC)
4230      = i_type1MixedConstraintReserveMap(t1MixCstr,ild,resC,riskC) ;
4231   
4232  Type1MixedConstraint(tp,t1MixCstr)
4233      = i_tradePeriodType1MixedConstraint(tp,t1MixCstr) ;
4234   
4235  Type2MixedConstraint(tp,t2MixCstr)
4236      = i_tradePeriodType2MixedConstraint(tp,t2MixCstr) ;
4237   
4238  Type1MixedConstraintSense(tp,t1MixCstr)
4239      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
4240           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4241   
4242  Type1MixedConstraintLimit1(tp,t1MixCstr)
4243      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
4244           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4245   
4246  Type1MixedConstraintLimit2(tp,t1MixCstr)
4247      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
4248           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4249   
4250  Type2MixedConstraintSense(tp,t2MixCstr)
4251      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4252           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4253   
4254  Type2MixedConstraintLimit(tp,t2MixCstr)
4255      = sum[ CstrRHS$(ord(CstrRHS) = 2)
4256           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4257   
4258  Type1MixedConstraintCondition(tp,t1MixCstr)
4259      $ sum[ br $ { HVDChalfPoles(tp,br) and
4260                    i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4261                  }, 1
4262           ] = yes ;
4263   
4264  * Initialise generic constraint data for the current trading period
4265  GenericConstraint(tp,gnrcCstr) = i_tradePeriodGenericConstraint(tp,gnrcCstr) ;
4266   
4267  GenericEnergyOfferConstraintFactors(GenericConstraint,o)
4268      = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
4269   
4270  GenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT)
4271      = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT) ;
4272   
4273  GenericEnergyBidConstraintFactors(GenericConstraint,bd)
4274      = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,bd) ;
4275   
4276  GenericILReserveBidConstraintFactors(GenericConstraint,bd,resC)
4277      = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,bd,resC) ;
4278   
4279  GenericBranchConstraintFactors(GenericConstraint,br)
4280      = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
4281   
4282  GenericConstraintSense(GenericConstraint)
4283      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4284           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4285   
4286  GenericConstraintLimit(GenericConstraint)
4287      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4288           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4289   
4290   
4291  * Additional pre-processing on parameters --------------------------------------
4292   
4293  * Calculation of generation upper limits due to ramp rate limits
4294   
4295  * Only primary offers are considered (5.3.1.1)
4296  generationMaximum(tp,o) $ (not hasPrimaryOffer(tp,o))
4297      = sum[ validGenerationOfferBlock(tp,o,trdBlk)
4298           , generationOfferMW(tp,o,trdBlk) ]
4299      + sum[ (o1,trdBlk) $ { primarySecondaryOffer(tp,o,o1) and
4300                             validGenerationOfferBlock(tp,o1,trdBlk) }
4301           , generationOfferMW(tp,o1,trdBlk)
4302           ] ;
4303   
4304  * Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4305  * initial MW and ramp rate is used - Reference: Transpower Market Services
4306  rampTimeUp(offer) $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4307      = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4308                                     - generationStart(offer)
4309                                     ) / rampRateUp(offer)
4310           ] ;
4311   
4312  * Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4313  * initial MW and ramp rate is used - Reference: Transpower Market Services
4314  generationEndUp(offer) $ (not hasPrimaryOffer(offer))
4315      = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4316   
4317   
4318  * Calculation of generation lower limits due to ramp rate limits
4319   
4320  * Only primary offers are considered (5.3.2.1)
4321  * Negative prices for generation offers are not allowed? (5.3.2.1)
4322  generationMinimum(offer) = 0;
4323   
4324  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4325  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4326  rampTimeDown(offer) $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4327      = Min[ i_tradingPeriodLength, ( generationStart(offer)
4328                                    - generationMinimum(offer)
4329                                    ) / rampRateDown(offer)
4330           ] ;
4331   
4332  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4333  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4334  generationEndDown(offer) $ (not hasPrimaryOffer(offer))
4335      = Max[ 0, generationStart(offer) - rampRateDown(offer)*rampTimeDown(offer) ] ;
4336   
4337  o_offerEnergy_TP(dt,o) = 0;
4338  *   Additional pre-processing on parameters end
4339   
4340   
4341   
4342  * TN - Pivot or demand analysis begin
4345  * TN - Pivot or demand analysis begin end
4346   
4347  *=====================================================================================
4348  * 7. The vSPD solve loop
4349  *=====================================================================================
4350   
4351  unsolvedPeriod(tp) = yes;
4352  VSPDModel(tp) = 0 ;
4353  option clear = useBranchFlowMIP ;
4354  option clear = useMixedConstraintMIP ;
4355   
4356  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
4357    exitLoop = 0;
4358    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
4359   
4360  *   7a. Reset all sets, parameters and variables -------------------------------
4361      option clear = currTP ;
4362  *   Generation variables
4363      option clear = GENERATION ;
4364      option clear = GENERATIONBLOCK ;
4365  *   Purchase variables
4366      option clear = PURCHASE ;
4367      option clear = PURCHASEBLOCK ;
4368      option clear = PURCHASEILR ;
4369      option clear = PURCHASEILRBLOCK ;
4370  *   Network variables
4371      option clear = ACNODENETINJECTION ;
4372      option clear = ACNODEANGLE ;
4373      option clear = ACBRANCHFLOW ;
4374      option clear = ACBRANCHFLOWDIRECTED ;
4375      option clear = ACBRANCHLOSSESDIRECTED ;
4376      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4377      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4378      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4379      option clear = HVDCLINKFLOW ;
4380      option clear = HVDCLINKLOSSES ;
4381      option clear = LAMBDA ;
4382      option clear = LAMBDAINTEGER ;
4383      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
4384      option clear = HVDCPOLEFLOW_INTEGER ;
4385  *   Risk/Reserve variables
4386      option clear = RISKOFFSET ;
4387      option clear = HVDCREC ;
4388      option clear = ISLANDRISK ;
4389      option clear = RESERVEBLOCK ;
4390      option clear = RESERVE ;
4391      option clear = ISLANDRESERVE;
4392  *   NMIR variables
4393      option clear = SHAREDNFR ;
4394      option clear = SHAREDRESERVE ;
4395      option clear = HVDCSENT ;
4396      option clear = RESERVESHAREEFFECTIVE ;
4397      option clear = RESERVESHARERECEIVED ;
4398      option clear = RESERVESHARESENT ;
4399      option clear = HVDCSENDING ;
4400      option clear = INZONE ;
4401      option clear = HVDCSENTINSEGMENT ;
4402      option clear = HVDCRESERVESENT ;
4403      option clear = HVDCSENTLOSS ;
4404      option clear = HVDCRESERVELOSS ;
4405      option clear = LAMBDAHVDCENERGY ;
4406      option clear = LAMBDAHVDCRESERVE ;
4407      option clear = RESERVESHAREPENALTY ;
4408  *   Mixed constraint variables
4409      option clear = MIXEDCONSTRAINTVARIABLE ;
4410      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
4411  *   Objective
4412      option clear = NETBENEFIT ;
4413  *   Violation variables
4414      option clear = TOTALPENALTYCOST ;
4415      option clear = DEFICITBUSGENERATION ;
4416      option clear = SURPLUSBUSGENERATION ;
4417      option clear = DEFICITRESERVE ;
4418      option clear = DEFICITRESERVE_CE ;
4419      option clear = DEFICITRESERVE_ECE ;
4420      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4421      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4422      option clear = DEFICITRAMPRATE ;
4423      option clear = SURPLUSRAMPRATE ;
4424      option clear = DEFICITACnodeCONSTRAINT ;
4425      option clear = SURPLUSACnodeCONSTRAINT ;
4426      option clear = DEFICITBRANCHFLOW ;
4427      option clear = SURPLUSBRANCHFLOW ;
4428      option clear = DEFICITMNODECONSTRAINT ;
4429      option clear = SURPLUSMNODECONSTRAINT ;
4430      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
4431      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
4432      option clear = DEFICITGENERICCONSTRAINT ;
4433      option clear = SURPLUSGENERICCONSTRAINT ;
4434   
4435  *   Clear the pole circular branch flow flag
4436      option clear = circularBranchFlowExist ;
4437      option clear = poleCircularBranchFlowExist ;
4438      option clear = northHVDC ;
4439      option clear = southHVDC ;
4440      option clear = manualBranchSegmentMWFlow ;
4441      option clear = manualLossCalculation ;
4442      option clear = nonPhysicalLossExist ;
4443      option clear = modelSolved ;
4444      option clear = LPmodelSolved ;
4445  *   Disconnected bus post-processing
4446      option clear = busGeneration ;
4447      option clear = busLoad ;
4448      option clear = busDisconnected ;
4449      option clear = busPrice ;
4450   
4451   
4452  *   End reset
4453   
4454   
4455  *   7b. Initialise current trade period and model data -------------------------
4456      currTP(tp)  $ sequentialSolve       = yes;
4457      currTP(tp1) $ (not sequentialSolve) = yes;
4458   
4459  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4460      generationStart(offer(currTP(tp),o))
4461          $ (sum[ o1, generationStart(currTP,o1)] = 0)
4462          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
4463  *   Calculation of generation upper limits due to ramp rate limits
4464  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4465  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4466      rampTimeUp(offer(currTP(tp),o))
4467          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4468          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4469                                         - generationStart(offer)
4470                                         ) / rampRateUp(offer)
4471               ] ;
4472   
4473  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4474  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4475      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4476          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4477   
4478   
4479  *   Calculation of generation lower limits due to ramp rate limits
4480   
4481  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4482  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4483      rampTimeDown(offer(currTP(tp),o))
4484          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4485          = Min[ i_tradingPeriodLength, ( generationStart(offer)
4486                                        - generationMinimum(offer)
4487                                        ) / rampRateDown(offer)
4488               ] ;
4489   
4490  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4491  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4492      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4493          = Max[ 0, generationStart(offer)
4494                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
4495   
4496  *   Additional pre-processing on parameters end
4497   
4498   
4499  *   7c. Updating the variable bounds before model solve ------------------------
4500   
4501  * TN - Pivot or Demand Analysis - revise input data
4504  * TN - Pivot or Demand Analysis - revise input data end
4505   
4506  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4507   
4508  *   Offer blocks - Constraint 3.1.1.1
4509      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
4510          = generationOfferMW(validGenerationOfferBlock) ;
4511   
4512      GENERATIONBLOCK.fx(currTP,o,trdBlk)
4513          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
4514   
4515  *   Constraint 3.1.1.2 - Fix the generation variable for generators
4516  *   that are not connected or do not have a non-zero energy offer
4517      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
4518   
4519  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
4520      GENERATION.up(offer(currTP,o))
4521          $ { windOffer(offer) and priceResponsive(offer) }
4522          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4523   
4524  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
4525      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4526          $ (not UseDSBFDemandBidModel)
4527          = purchaseBidMW(validPurchaseBidBlock) ;
4528   
4529      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4530          $ (not UseDSBFDemandBidModel)
4531          = 0 ;
4532   
4533      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4534          $ UseDSBFDemandBidModel
4535          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
4536   
4537      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4538          $ UseDSBFDemandBidModel
4539          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
4540   
4541      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
4542          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
4543          = 0 ;
4544   
4545  *   Fix the purchase variable for purchasers that are not connected
4546  *   or do not have a non-zero purchase bid
4547      PURCHASE.fx(currTP,bd)
4548          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
4549   
4550  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4551   
4552   
4553  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4554   
4555  *   Ensure that variables used to specify flow and losses on HVDC link are
4556  *   zero for AC branches and for open HVDC links.
4557      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
4558      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
4559   
4560  *   Apply an upper bound on the weighting parameter based on its definition
4561      LAMBDA.up(branch,bp) = 1 ;
4562   
4563  *   Ensure that the weighting factor value is zero for AC branches and for
4564  *   invalid loss segments on HVDC links
4565      LAMBDA.fx(HVDClink,bp)  $ (not validLossSegment(HVDClink,bp)) = 0 ;
4566      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
4567   
4568  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4569   
4570   
4571  *======= AC TRANSMISSION EQUATIONS =============================================
4572   
4573  *   Ensure that variables used to specify flow and losses on AC branches are
4574  *   zero for HVDC links branches and for open AC branches
4575      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
4576      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
4577      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
4578   
4579  *   Ensure directed block flow and loss block variables are zero for
4580  *   non-AC branches and invalid loss segments on AC branches
4581     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
4582         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los)) } = 0 ;
4583   
4584     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
4585         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los)) } = 0 ;
4586   
4587   
4588  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
4589  *   corresponding to the reference nodes and the HVDC nodes are set to zero
4590      ACNODEANGLE.fx(currTP,b)
4591         $ sum[ n $ { NodeBus(currTP,n,b) and
4592                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
4593   
4594  *======= AC TRANSMISSION EQUATIONS END =========================================
4595   
4596   
4597  *======= RISK & RESERVE EQUATIONS ==============================================
4598   
4599  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4600      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
4601          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
4602   
4603      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
4604          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
4605   
4606  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
4607      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
4608          = reserveOfferMaximum(validReserveOfferBlock) ;
4609   
4610      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
4611          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4612   
4613  *   Fix the reserve variable for invalid reserve offers. These are offers that
4614  *   are either not connected to the grid or have no reserve quantity offered.
4615      RESERVE.fx(currTP,o,resC,resT)
4616          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
4617   
4618  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
4619  *   offers that are either not connected to the grid or have no reserve quantity offered.
4620      PURCHASEILR.fx(currTP,bd,resC)
4621          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
4622   
4623  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4624      RISKOFFSET.fx(currTP,ild,resC,riskC)
4625          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
4626              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
4627            } = 0 ;
4628   
4629  *   Fix the appropriate deficit variable to zero depending on
4630  *   whether the different CE and ECE CVP flag is set
4631      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
4632      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4633      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4634   
4635  *   Virtual reserve
4636      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
4637   
4638  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
4653  *   NMIR project variables
4654      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4655      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4656   
4657  *   (3.4.2.3) - SPD version 11.0
4658      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
4659   
4660  *   No forward reserve sharing if HVDC capacity is zero
4661      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4662          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
4663   
4664  *   No forward reserve sharing if reserve sharing is disabled
4665      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4666          $ (reserveShareEnabled(currTP,resC)=0) = 0;
4667   
4668  *   No reserve sharing to cover HVDC risk
4669      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
4670      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
4671   
4672  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4673      INZONE.fx(currTP,ild,resC,z)
4674          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
4675   
4676  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
4677      INZONE.fx(currTP,ild,resC,z)
4678          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
4679   
4680  *   Fixing Lambda integer variable for energy sent
4681      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
4682                                          and (ord(bp) = 1) } = 1 ;
4683   
4684      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
4685   
4686  * To be reviewed NMIR
4687      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
4688          $ { (HVDCCapacity(currTP,ild) = 0)
4689          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
4690   
4691      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
4692          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
4693          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
4694  ;
4695   
4696   
4697  *======= RISK & RESERVE EQUATIONS END ==========================================
4698   
4699   
4700  *======= MIXED CONSTRAINTS =====================================================
4701   
4702  *   Mixed constraint
4703      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
4704          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
4705   
4706  *======= MIXED CONSTRAINTS END =================================================
4707   
4708  *   Updating the variable bounds before model solve end
4709   
4710   
4711  *   7d. Solve Models
4712   
4713  *   Solve the LP model ---------------------------------------------------------
4714      if( (Sum[currTP, VSPDModel(currTP)] = 0),
4715   
4716          if( UseShareReserve,
4717              option bratio = 1 ;
4718              vSPD_NMIR.Optfile = 1 ;
4719              vSPD_NMIR.optcr = MIPOptimality ;
4720              vSPD_NMIR.reslim = MIPTimeLimit ;
4721              vSPD_NMIR.iterlim = MIPIterationLimit ;
4722              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
4723  *           Set the model solve status
4724              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
4725                                 or (vSPD_NMIR.modelstat = 8) )
4726                              and ( vSPD_NMIR.solvestat = 1 ) } ;
4727          else
4728              option bratio = 1 ;
4729              vSPD.reslim = LPTimeLimit ;
4730              vSPD.iterlim = LPIterationLimit ;
4731              solve vSPD using lp maximizing NETBENEFIT ;
4732  *           Set the model solve status
4733              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
4734          )
4735   
4736  *       Post a progress message to the console and for use by EMI.
4737          if((ModelSolved = 1) and (sequentialSolve = 0),
4738              putclose runlog 'The case: RTD_20201028_0105_301 '
4739                              'is solved successfully.'/
4740                              'Objective function value: '
4741                              NETBENEFIT.l:<12:1 /
4742                              'Violation Cost          : '
4743                              TOTALPENALTYCOST.l:<12:1 /
4744          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
4745              putclose runlog 'The case: RTD_20201028_0105_301 '
4746                              'is solved unsuccessfully.'/
4747          ) ;
4748   
4749          if((ModelSolved = 1) and (sequentialSolve = 1),
4750              loop(currTP,
4751                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4752                                  'is solved successfully.'/
4753                                  'Objective function value: '
4754                                  NETBENEFIT.l:<12:1 /
4755                                  'Violations cost         : '
4756                                  TOTALPENALTYCOST.l:<12:1 /
4757              ) ;
4758          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
4759              loop(currTP,
4760                  unsolvedPeriod(currTP) = no;
4761                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4762                                  'is solved unsuccessfully.'/
4763              ) ;
4764   
4765          ) ;
4766  *   Solve the LP model end -----------------------------------------------------
4767   
4768   
4769  *   Solve the VSPD_MIP model ---------------------------------------------------
4770      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
4771  *       Fix the values of the integer variables that are not needed
4772          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
4773              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
4774   
4775  *       Fix the integer AC branch flow variable to zero for invalid branches
4776          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
4777              $ (not branch(currTP,br)) = 0 ;
4778   
4779  *       Apply an upper bound on the integer weighting parameter
4780          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
4781   
4782  *       Ensure that the weighting factor value is zero for AC branches
4783  *       and for invalid loss segments on HVDC links
4784          LAMBDAINTEGER.fx(branch(currTP,br),bp)
4785              $ { ACbranch(branch) or (not validLossSegment(branch,bp)) } = 0 ;
4786   
4787  *       Fix the lambda integer variable to zero for invalid branches
4788          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
4789   
4790  *       Fix the value of some binary variables used in the mixed constraints
4791  *       that have no alternate limit
4792          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4793              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
4794   
4795          option bratio = 1 ;
4796          vSPD_MIP.Optfile = 1 ;
4797          vSPD_MIP.optcr = MIPOptimality ;
4798          vSPD_MIP.reslim = MIPTimeLimit ;
4799          vSPD_MIP.iterlim = MIPIterationLimit ;
4800          solve vSPD_MIP using mip maximizing NETBENEFIT ;
4801  *       Set the model solve status
4802          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
4803                                (vSPD_MIP.modelstat = 8)
4804                              ]
4805                              and
4806                              [ vSPD_MIP.solvestat = 1 ]
4807                            } ;
4808   
4809  *       Post a progress message for use by EMI.
4810          if(ModelSolved = 1,
4811              loop(currTP,
4812                  unsolvedPeriod(currTP) = no;
4813                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4814                                  'is solved successfully for FULL integer.'/
4815                                  'Objective function value: '
4816                                  NETBENEFIT.l:<12:1 /
4817                                  'Violations              : '
4818                                  TOTALPENALTYCOST.l:<12:1 /
4819              ) ;
4820          else
4821              loop(currTP,
4822                  unsolvedPeriod(currTP) = yes;
4823                  VSPDModel(currTP) = 4;
4824                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4825                                  'is solved unsuccessfully for FULL integer.'/
4826              ) ;
4827          ) ;
4828  *   Solve the vSPD_MIP model end -----------------------------------------------
4829   
4830   
4831  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
4832      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
4833  *       Fix the values of these integer variables that are not needed
4834          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
4835              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
4836   
4837  *       Fix the integer AC branch flow variable to zero for invalid branches
4838          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
4839              $ (not branch(currTP,br)) = 0 ;
4840   
4841  *       Apply an upper bound on the integer weighting parameter
4842          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
4843   
4844  *       Ensure that the weighting factor value is zero for AC branches
4845  *       and for invalid loss segments on HVDC links
4846          LAMBDAINTEGER.fx(branch(currTP,br),bp)
4847              $ {ACbranch(branch) or (not  validLossSegment(branch,bp)) } = 0 ;
4848   
4849  *       Fix the lambda integer variable to zero for invalid branches
4850          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
4851   
4852          option bratio = 1 ;
4853          vSPD_BranchFlowMIP.Optfile = 1 ;
4854          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
4855          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
4856          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
4857          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
4858  *       Set the model solve status
4859          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
4860                                (vSPD_BranchFlowMIP.modelstat = 8)
4861                              ]
4862                              and
4863                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
4864                            } ;
4865   
4866  *       Post a progress message for use by EMI.
4867          if(ModelSolved = 1,
4868   
4869  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
4870              vSPD_SOS1_Solve(currTP)  = yes;
4871   
4872              loop(currTP,
4873                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4874                                  'is solved successfully for branch integer.'/
4875                                  'Objective function value: '
4876                                  NETBENEFIT.l:<12:1 /
4877                                  'Violations cost         : '
4878                                  TOTALPENALTYCOST.l:<12:1 /
4879              ) ;
4880          else
4881              loop(currTP,
4882                  unsolvedPeriod(currTP) = yes;
4883                  VSPDModel(currTP) = 4;
4884                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4885                                  'is solved unsuccessfully for branch integer.'/
4886              ) ;
4887          ) ;
4888  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
4889   
4890   
4891  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
4892      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
4893  *       Fix the value of some binary variables used in the mixed constraints
4894  *       that have no alternate limit
4895          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4896              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
4897   
4898  *       Use the advanced basis here
4899          option bratio = 0.25 ;
4900          vSPD_MixedConstraintMIP.Optfile = 1 ;
4901  *       Set the optimality criteria for the MIP
4902          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
4903          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
4904          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
4905  *       Solve the model
4906          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
4907  *       Set the model solve status
4908          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
4909                                (vSPD_MixedConstraintMIP.modelstat = 8)
4910                              ]
4911                              and
4912                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
4913                            } ;
4914   
4915  *       Post a progress message for use by EMI.
4916          if(ModelSolved = 1,
4917              loop(currTP,
4918                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4919                                  'is solved successfully for '
4920                                  'mixed constraint integer.'/
4921                                  'Objective function value: '
4922                                  NETBENEFIT.l:<12:1 /
4923                                  'Violations cost         : '
4924                                  TOTALPENALTYCOST.l:<12:1 /
4925              ) ;
4926          else
4927              loop(currTP,
4928                  unsolvedPeriod(currTP) = yes;
4929                  VSPDModel(currTP) = 1;
4930                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ') '
4931                                  'is solved unsuccessfully for '
4932                                  'mixed constraint integer.'/
4933              ) ;
4934          ) ;
4935  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
4936   
4937   
4938  *   Solve the LP model and stop ------------------------------------------------
4939      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
4940   
4941          if( UseShareReserve,
4942              option bratio = 1 ;
4943              vSPD_NMIR.Optfile = 1 ;
4944              vSPD_NMIR.optcr = MIPOptimality ;
4945              vSPD_NMIR.reslim = MIPTimeLimit ;
4946              vSPD_NMIR.iterlim = MIPIterationLimit ;
4947              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
4948  *           Set the model solve status
4949              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
4950                                 or (vSPD_NMIR.modelstat = 8) )
4951                              and ( vSPD_NMIR.solvestat = 1 ) } ;
4952          else
4953              option bratio = 1 ;
4954              vSPD.reslim = LPTimeLimit ;
4955              vSPD.iterlim = LPIterationLimit ;
4956              solve vSPD using lp maximizing NETBENEFIT ;
4957  *           Set the model solve status
4958              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
4959          )
4960   
4961  *       Post a progress message for use by EMI.
4962          if( ModelSolved = 1,
4963              loop(currTP,
4964                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl ')'
4965                                  ' integer resolve was unsuccessful.' /
4966                                  'Reverting back to linear solve and '
4967                                  'solve successfully. ' /
4968                                  'Objective function value: '
4969                                  NETBENEFIT.l:<12:1 /
4970                                  'Violations cost         : '
4971                                  TOTALPENALTYCOST.l:<12:1 /
4972                                  'Solution may have circulating flows '
4973                                  'and/or non-physical losses.' /
4974              ) ;
4975          else
4976              loop(currTP,
4977                  putclose runlog 'The case: RTD_20201028_0105_301 (' currTP.tl
4978                                  ') integer solve was unsuccessful. '
4979                                  'Reverting back to linear solve. '
4980                                  'Linear solve unsuccessful.' /
4981              ) ;
4982          ) ;
4983   
4984          unsolvedPeriod(currTP) = no;
4985   
4986  *   Solve the LP model and stop end --------------------------------------------
4987   
4988      ) ;
4989  *   Solve the models end
4990   
4991   
4992   
4993  *   6e. Check if the LP results are valid --------------------------------------
4994      if((ModelSolved = 1),
4995          useBranchFlowMIP(currTP) = 0 ;
4996          useMixedConstraintMIP(currTP) = 0 ;
4997  *       Check if there is no branch circular flow and non-physical losses
4998          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
4999   
5000  *           Check if there are circulating branch flows on loss AC branches
5001              circularBranchFlowExist(ACbranch(currTP,br))
5002                  $ { LossBranch(ACbranch) and
5003                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
5004                        - abs(ACBRANCHFLOW.l(ACbranch))
5005                        ) > circularBranchFlowTolerance
5006                      ]
5007                    } = 1 ;
5008   
5009  *           Determine the circular branch flow flag on each HVDC pole
5010              TotalHVDCpoleFlow(currTP,pole)
5011                  = sum[ br $ HVDCpoleBranchMap(pole,br)
5012                       , HVDCLINKFLOW.l(currTP,br) ] ;
5013   
5014              MaxHVDCpoleFlow(currTP,pole)
5015                  = smax[ br $ HVDCpoleBranchMap(pole,br)
5016                        , HVDCLINKFLOW.l(currTP,br) ] ;
5017   
5018              poleCircularBranchFlowExist(currTP,pole)
5019                  $ { ( TotalHVDCpoleFlow(currTP,pole)
5020                      - MaxHVDCpoleFlow(currTP,pole)
5021                      ) > circularBranchFlowTolerance
5022                    } = 1 ;
5023   
5024  *           Check if there are circulating branch flows on HVDC
5025              NorthHVDC(currTP)
5026                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
5027                                        i_tradePeriodBusIsland(currTP,b,ild) and
5028                                        HVDClinkSendingBus(currTP,br,b) and
5029                                        HVDCpoles(currTP,br)
5030                                      }, HVDCLINKFLOW.l(currTP,br)
5031                       ] ;
5032   
5033              SouthHVDC(currTP)
5034                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
5035                                        i_tradePeriodBusIsland(currTP,b,ild) and
5036                                        HVDClinkSendingBus(currTP,br,b) and
5037                                        HVDCpoles(currTP,br)
5038                                      }, HVDCLINKFLOW.l(currTP,br)
5039                       ] ;
5040   
5041              circularBranchFlowExist(currTP,br)
5042                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
5043                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
5044                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
5045                    } = 1 ;
5046   
5047  *           Check if there are non-physical losses on HVDC links
5048              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los)
5049                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5050                  and validLossSegment(currTP,br,los) }
5051                  = Min[ Max( 0,
5052                              [ abs(HVDCLINKFLOW.l(HVDClink))
5053                              - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
5054                              ]
5055                            ),
5056                         ( LossSegmentMW(HVDClink,los)
5057                         - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
5058                         )
5059                       ] ;
5060   
5061              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
5062                  = sum[ los, LossSegmentFactor(HVDClink,los)
5063                            * ManualBranchSegmentMWFlow(HVDClink,los) ] ;
5064   
5065              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
5066                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
5067                         - ManualLossCalculation(HVDClink)
5068                         ) > NonPhysicalLossTolerance
5069                    } = 1 ;
5070   
5071  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
5072  *           and non-physical loss branches exceeds the specified tolerance
5073              useBranchFlowMIP(currTP)
5074                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
5075                                , resolveCircularBranchFlows
5076                                * circularBranchFlowExist(currTP,br)
5077                           ]
5078                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
5079                                , (1 - AllowHVDCroundpower(currTP))
5080                                * resolveCircularBranchFlows
5081                                * circularBranchFlowExist(currTP,br)
5082                                + resolveHVDCnonPhysicalLosses
5083                                * NonPhysicalLossExist(currTP,br)
5084                           ]
5085                      + sum[ pole, resolveCircularBranchFlows
5086                                 * poleCircularBranchFlowExist(currTP,pole)
5087                           ]
5088                       ) > UseBranchFlowMIPTolerance
5089                                         } = 1 ;
5090   
5091  *       Check if there is no branch circular flow and non-physical losses end
5092          );
5093   
5094   
5095  *       Check if there is mixed constraint integer is required
5096          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
5097   
5098  *           Check if integer variables are needed for mixed constraint
5099              if( useMixedConstraintRiskOffset,
5100                  HVDChalfPoleSouthFlow(currTP)
5101                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
5102                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
5103                             ] > MixedMIPTolerance
5104                        } = 1 ;
5105   
5106  *               Only calculate violation if the constraint limit is non-zero
5107                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
5108                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
5109                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
5110                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5111                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
5112                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5113                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
5114                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
5115                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
5116                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5117                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
5118   
5119  *               Integer constraints are needed if southward flow on half-poles AND
5120  *               constraint level exceeds the mixed constraint limit2 value
5121                  useMixedConstraintMIP(currTP)
5122                      $ { HVDChalfPoleSouthFlow(currTP) and
5123                          sum[ t1MixCstr
5124                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
5125                                 > MixedMIPTolerance }, 1
5126                             ]
5127                        } = 1 ;
5128              ) ;
5129   
5130  *       Check if there is mixed constraint integer is required end
5131          );
5132   
5133  *       A period is unsolved if MILP model is required
5134          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
5135                                         + UseMixedConstraintMIP(currTP)
5136                                         ] ;
5137   
5138  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
5139          loop( unsolvedPeriod(currTP),
5140              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
5141                  VSPDModel(currTP) = 1;
5142                  putclose runlog 'The case: RTD_20201028_0105_301 requires a'
5143                                  'VSPD_MIP resolve for period ' currTP.tl
5144                                  '. Switching Vectorisation OFF.' /
5145   
5146              elseif UseBranchFlowMIP(currTP) >= 1,
5147                  if( VSPDModel(currTP) = 0,
5148                      VSPDModel(currTP) = 2;
5149                      putclose runlog 'The case: RTD_20201028_0105_301 requires a '
5150                                      'vSPD_BranchFlowMIP resolve for period '
5151                                      currTP.tl '. Switching Vectorisation OFF.'/
5152                  elseif VSPDModel(currTP) = 3,
5153                      VSPDModel(currTP) = 1;
5154                      putclose runlog 'The case: RTD_20201028_0105_301 requires a '
5155                                      'VSPD_MIP resolve for period ' currTP.tl
5156                                      '. Switching Vectorisation OFF.' /
5157                  );
5158   
5159              elseif UseMixedConstraintMIP(currTP) >= 1,
5160                  if( VSPDModel(currTP) = 0,
5161                      VSPDModel(currTP) = 3;
5162                      putclose runlog 'The case: RTD_20201028_0105_301 requires a '
5163                                      'vSPD_MixedConstraintMIP resolve for period '
5164                                      currTP.tl '. Switching Vectorisation OFF.' /
5165                  elseif VSPDModel(currTP) = 2,
5166                      VSPDModel(currTP) = 1;
5167                      putclose runlog 'The case: RTD_20201028_0105_301 requires a '
5168                                      'VSPD_MIP resolve for period ' currTP.tl
5169                                      '. Switching Vectorisation OFF.' /
5170                  );
5171   
5172              ) ;
5173   
5174          ) ;
5175   
5176          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
5177          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
5178   
5179  *   Check if the LP results are valid end
5180      ) ;
5181   
5182   
5183   
5184  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
5185   
5186  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
5187  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load and
                      zero cleared generation needs to be adjusted since actually
                      is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
5213   
5214      busGeneration(bus(currTP,b))
5215          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
5216               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
5217               ] ;
5218   
5219      busLoad(bus(currTP,b))
5220          = sum[ NodeBus(currTP,n,b)
5221               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
5222               ] ;
5223   
5224      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
5225          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
5226   
5227      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
5228          = DCNodeNetInjection.m(currTP,b) ;
5229   
5230      if((disconnectedNodePriceCorrection = 1),
5231  *       Pre-MSP case
5232          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
5233              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
5234                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
5235                                        branch(currTP,br)
5236                                      }, 1 ]
5237                      )
5238                    } ;
5239   
5240  *       Post-MSP cases
5241  *       Scenario C/F/G/H/I:
5242          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
5243                                         and (busLoad(bus) = 0)
5244                                         and (busElectricalIsland(bus) = 0)
5245                                           } = 1 ;
5246  *       Scenario E:
5247          busDisconnected(bus(currTP,b))
5248              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5249                              = busElectricalIsland(bus) }
5250                       , busLoad(currTP,b1) ] = 0
5251                  ) and
5252                  ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5253                              = busElectricalIsland(bus) }
5254                       , busGeneration(currTP,b1) ] = 0
5255                  ) and
5256                  ( busElectricalIsland(bus) > 0 ) and
5257                  ( i_useBusNetworkModel(currTP) = 1 )
5258                } = 1 ;
5259  *       Set prices at dead buses with non-zero load
5260          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5261                                      (busLoad(bus) > 0) and
5262                                      (busElectricalIsland(bus)= 0)
5263                                    } = DeficitBusGenerationPenalty ;
5264   
5265          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5266                                      (busLoad(bus) < 0) and
5267                                      (busElectricalIsland(bus)= 0)
5268                                    } = -SurplusBusGenerationPenalty ;
5269   
5270  *       Set price at identified disconnected buses to 0
5271          busPrice(bus)$busDisconnected(bus) = 0 ;
5272      ) ;
5273   
5274  * End Check for disconnected nodes and adjust prices accordingly
5275   
5276  * TN - Replacing invalid prices after SOS1
5277  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
5278      if ( vSPD_SOS1_Solve(tp),
5279           busSOSinvalid(tp,b)
5280             = 1 $ { [ ( busPrice(tp,b) = 0 )
5281                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5282                      or ( busPrice(tp,b) > 0.9 * surplusBusGenerationPenalty )
5283                       ]
5284                   and bus(tp,b)
5285                   and [ not busDisconnected(tp,b) ]
5286                   and [ busLoad(tp,b) = 0 ]
5287                   and [ busGeneration(tp,b) = 0 ]
5288                   and [ sum[(br,fd)
5289                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5290                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5291                            ] = 0
5292                       ]
5293                   and [ sum[ br
5294                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5295                            , 1
5296                            ] > 0
5297                       ]
5298                     };
5299          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
5300          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
5301   
5302              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
5303   
5304              busPrice(tp,b)
5305                $ { busSOSinvalid(tp,b)
5306                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5307                              and sum[ br $ { branch(tp,br)
5308                                          and BranchBusConnect(tp,br,b)
5309                                          and BranchBusConnect(tp,br,b1)
5310                                            }, 1
5311                                     ]
5312                               }, 1
5313                         ] > 0
5314                    )
5315                  }
5316                 = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5317                           and sum[ br $ { branch(tp,br)
5318                                          and BranchBusConnect(tp,br,b)
5319                                          and BranchBusConnect(tp,br,b1)
5320                                            }, 1 ]
5321                             }, busPrice(tp,b1)
5322                      ]
5323                 / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5324                           and sum[ br $ { branch(tp,br)
5325                                          and BranchBusConnect(tp,br,b)
5326                                          and BranchBusConnect(tp,br,b1)
5327                                            }, 1 ]
5328                            }, 1
5329                      ];
5330                busSOSinvalid(tp,b)
5331                  = 1 $ { [ ( busPrice(tp,b) = 0 )
5332                           or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5333                           or ( busPrice(tp,b) > 0.9 * surplusBusGenerationPenalty )
5334                            ]
5335                        and bus(tp,b)
5336                        and [ not busDisconnected(tp,b) ]
5337                        and [ busLoad(tp,b) = 0 ]
5338                        and [ busGeneration(tp,b) = 0 ]
5339                        and [ sum[(br,fd)
5340                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5341                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5342                            ] = 0
5343                       ]
5344                   and [ sum[ br
5345                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5346                            , 1
5347                            ] > 0
5348                       ]
5349                          };
5350           );
5351      );
5352  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
5353   
5354   
5355  *   6g. Collect and store results of solved periods into output parameters -----
5356  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
5357   
5359  *   Normal vSPD run post processing for reporting
5361      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
5362  *   Reporting at trading period start
5363  *       Node level output
5364          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
5365   
5366          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
5367              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
5368   
5369          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
5370             = NodeDemand(currTP,n)
5371             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
5372   
5373          o_nodePrice_TP(dt,n) $ Node(currTP,n)
5374              = sum[ b $ NodeBus(currTP,n,b)
5375                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
5376                    ] ;
5377   
5378  *       Offer output
5379          o_offer(dt,o) $ offer(currTP,o) = yes ;
5380   
5381          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
5382   
5383          o_offerFIR_TP(dt,o) $ offer(currTP,o)
5384              = sum[ (resC,resT)$(ord(resC) = 1)
5385                   , RESERVE.l(currTP,o,resC,resT) ] ;
5386   
5387          o_offerSIR_TP(dt,o) $ offer(currTP,o)
5388              = sum[ (resC,resT)$(ord(resC) = 2)
5389                   , RESERVE.l(currTP,o,resC,resT) ] ;
5390   
5391  *       Bus level output
5392          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
5393   
5394          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
5395   
5396          o_busLoad_TP(dt,b) $ bus(currTP,b)
5397              = busLoad(currTP,b)
5398              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
5399                   , PURCHASE.l(currTP,bd) ];
5400   
5401          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
5402   
5403          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
5404   
5405          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
5406   
5407  *       Node level output
5408   
5409          totalBusAllocation(dt,b) $ bus(currTP,b)
5410              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
5411   
5412          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
5413              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
5414   
5415  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
5429          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
5430              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
5431   
5432          changedDeficitBus(dt,b) = no;
5433   
5434          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
5435   
5436              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
5437   
5438              Loop b $ unmappedDeficitBus(dt,b) do
5439                  o_busDeficit_TP(dt,b1)
5440                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5441                                and ( branchBusDefn(tp,br,b1,b)
5442                                   or branchBusDefn(tp,br,b,b1) )
5443                                  }, 1 ]
5444                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
5445   
5446                  changedDeficitBus(dt,b1)
5447                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5448                              and ( branchBusDefn(tp,br,b1,b)
5449                                 or branchBusDefn(tp,br,b,b1) )
5450                                }, 1 ] = yes;
5451   
5452                  unmappedDeficitBus(dt,b) = no;
5453                  changedDeficitBus(dt,b) = no;
5454                  o_busDeficit_TP(dt,b) = 0;
5455              EndLoop;
5456   
5457              Loop n $ sum[ b $ changedDeficitBus(dt,b)
5458                          , busNodeAllocationFactor(dt,b,n)] do
5459                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
5460                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
5461                                                    busNodeAllocationFactor(dt,b,n)
5462                                                  * o_busDeficit_TP(dt,b) ] ;
5463              EndLoop;
5464   
5465              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
5466          Endif;
5467  * TN - post processing unmapped generation deficit buses end
5468   
5469          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
5470              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5471                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
5472   
5473          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
5474              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5475                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
5476   
5477  *       branch output
5478          o_branch(dt,br) $ branch(currTP,br) = yes ;
5479   
5480          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
5481   
5482          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
5483   
5484          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
5485              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
5486   
5487          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
5488              = HVDCLINKLOSSES.l(currTP,br) ;
5489   
5490          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
5491              = branchFixedLoss(currTP,br) ;
5492   
5493          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
5494              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
5495   
5496          o_branchFromBus_TP(dt,br,frB)
5497              $ { branch(currTP,br) and
5498                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5499                } = yes ;
5500   
5501          o_branchToBus_TP(dt,br,toB)
5502              $ { branch(currTP,br) and
5503                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5504                } = yes ;
5505   
5506          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
5507              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
5508   
5509          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
5510              = HVDClinkMaximumFlow.m(currTP,br) ;
5511   
5512          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
5513              = i_tradePeriodBranchCapacity(currTP,br) ;
5514   
5515  *       Offer output
5516          o_offerEnergyBlock_TP(dt,o,trdBlk)
5517              = GENERATIONBLOCK.l(currTP,o,trdBlk);
5518   
5519          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
5520              = sum[ resC $ (ord(resC) = 1)
5521              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5522   
5523          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
5524              = sum[ resC $ (ord(resC) = 2)
5525              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5526   
5527  *       bid output
5528          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
5529   
5530          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
5531   
5532          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
5533              = sum[ resC $ (ord(resC) = 1)
5534                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5535   
5536          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
5537              = sum[ resC $ (ord(resC) = 2)
5538                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5539   
5540          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
5541              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
5542   
5543  *       Violation reporting based on the CE and ECE
5544          o_ResViolation_TP(dt,ild,resC)
5545              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
5546              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
5547              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
5548   
5549          o_FIRviolation_TP(dt,ild)
5550              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
5551   
5552          o_SIRviolation_TP(dt,ild)
5553              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
5554   
5555  *       Security constraint data
5556          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
5557   
5558          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5559              = branchConstraintSense(currTP,brCstr) ;
5560   
5561          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5562              = [ branchSecurityConstraintLE.l(currTP,brCstr)
5563                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5564              + [ branchSecurityConstraintGE.l(currTP,brCstr)
5565                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5566              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
5567                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5568   
5569          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5570              = branchConstraintLimit(currTP,brCstr) ;
5571   
5572          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5573              = [ branchSecurityConstraintLE.m(currTP,brCstr)
5574                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5575              + [ branchSecurityConstraintGE.m(currTP,brCstr)
5576                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5577              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
5578                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5579   
5580  *       Mnode constraint data
5581          o_MnodeConstraint_TP(dt,MnodeCstr)
5582              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
5583   
5584          o_MnodeConstraintSense_TP(dt,MnodeCstr)
5585              $ MnodeConstraint(currTP,MnodeCstr)
5586              = MnodeConstraintSense(currTP,MnodeCstr) ;
5587   
5588          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
5589              $ MnodeConstraint(currTP,MnodeCstr)
5590              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
5591                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5592              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
5593                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5594              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
5595                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5596   
5597          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
5598              $ MnodeConstraint(currTP,MnodeCstr)
5599              = MnodeConstraintLimit(currTP,MnodeCstr) ;
5600   
5601          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
5602              $ MnodeConstraint(currTP,MnodeCstr)
5603              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
5604                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5605              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
5606                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5607              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
5608                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5609   
5610  *       Island output
5611          o_island(dt,ild) = yes ;
5612   
5613          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
5614   
5615          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
5616                                            , o_ResPrice_TP(dt,ild,resC) ];
5617   
5618          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
5619                                            , o_ResPrice_TP(dt,ild,resC) ];
5620   
5621          o_islandGen_TP(dt,ild)
5622              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
5623   
5624          o_islandClrBid_TP(dt,ild)
5625              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
5626   
5627          o_islandLoad_TP(dt,ild)
5628              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
5629              + o_islandClrBid_TP(dt,ild) ;
5630   
5631          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
5632   
5633          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
5634                                              , o_ResCleared_TP(dt,ild,resC) ];
5635   
5636          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
5637                                              , o_ResCleared_TP(dt,ild,resC) ];
5638   
5639          o_islandBranchLoss_TP(dt,ild)
5640              = sum[ (br,frB,toB)
5641                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
5642                   and branchBusDefn(currTP,br,frB,toB)
5643                     }, o_branchTotalLoss_TP(dt,br) ] ;
5644   
5645          o_HVDCflow_TP(dt,ild)
5646              = sum[ (br,frB,toB)
5647                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
5648                   and branchBusDefn(currTP,br,frB,toB)
5649                     }, o_branchFlow_TP(dt,br) ] ;
5650   
5651          o_HVDChalfPoleLoss_TP(dt,ild)
5652              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5653                                      branchBusDefn(currTP,br,frB,toB) and
5654                                      busIsland(currTP,toB,ild) and
5655                                      busIsland(currTP,frB,ild)
5656                                        }, o_branchTotalLoss_TP(dt,br)
5657                   ] ;
5658   
5659          o_HVDCpoleFixedLoss_TP(dt,ild)
5660              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5661                                      branchBusDefn(currTP,br,frB,toB) and
5662                                      ( busIsland(currTP,toB,ild) or
5663                                        busIsland(currTP,frB,ild)
5664                                      )
5665                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
5666                   ] ;
5667   
5668          o_HVDCloss_TP(dt,ild)
5669              = o_HVDChalfPoleLoss_TP(dt,ild)
5670              + o_HVDCpoleFixedLoss_TP(dt,ild)
5671              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
5672                                      branchBusDefn(currTP,br,frB,toB) and
5673                                      busIsland(currTP,toB,ild) and
5674                                      (not (busIsland(currTP,frB,ild)))
5675                                    }, o_branchDynamicLoss_TP(dt,br)
5676                   ] ;
5677   
5678  * TN - The code below is added for NMIR project ================================
5679          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
5680              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
5681   
5682          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
5683   
5684              o_FirSent_TP(dt,ild)
5685                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5686                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
5687   
5688              o_FirReceived_TP(dt,ild)
5689                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5690                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
5691   
5692              o_FirEffective_TP(dt,ild,riskC)
5693                  = Sum[ resC $ (ord(resC) = 1),
5694                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5695   
5696              o_FirEffReport_TP(dt,ild)
5697                  = Smax[ (resC,riskC) $ (ord(resC)=1)
5698                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5699   
5700          Endif;
5701   
5702          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
5703   
5704              o_SirSent_TP(dt,ild)
5705                  = Sum[ (rd,resC) $ (ord(resC) = 2),
5706                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
5707   
5708              o_SirReceived_TP(dt,ild)
5709                  = Sum[ (fd,resC) $ (ord(resC) = 2),
5710                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
5711   
5712              o_SirEffective_TP(dt,ild,riskC)
5713                  = Sum[ resC $ (ord(resC) = 2),
5714                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5715   
5716              o_SirEffReport_TP(dt,ild)
5717                  = Smax[ (resC,riskC) $ (ord(resC)=2)
5718                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5719          Endif;
5720   
5721   
5722  * TN - The code for NMIR project end ===========================================
5723   
5724  *       Additional output for audit reporting
5725          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
5726   
5727  *       Check if there are non-physical losses on AC branches
5728          ManualBranchSegmentMWFlow(LossBranch(branch(currTP,br)),los)
5729                  $ { ( ord(los) <= branchLossBlocks(branch) )
5730                  and validLossSegment(branch,los) }
5731                  = Min[ Max( 0,
5732                              [ abs(o_branchFlow_TP(dt,br))
5733                              - [LossSegmentMW(branch,los-1) $ (ord(los) > 1)]
5734                              ]
5735                            ),
5736                         ( LossSegmentMW(branch,los)
5737                         - [LossSegmentMW(branch,los-1) $ (ord(los) > 1)]
5738                         )
5739                       ] ;
5740   
5741          ManualLossCalculation(LossBranch(branch(currTP,br)))
5742              = sum[ los, LossSegmentFactor(branch,los)
5743                        * ManualBranchSegmentMWFlow(branch,los) ] ;
5744   
5745          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
5746                                   - ManualLossCalculation(currTP,br) ;
5747   
5748          o_lossSegmentBreakPoint(dt,br,los) $ validLossSegment(currTP,br,los)
5749                                             = LossSegmentMW(currTP,br,los) ;
5750   
5751          o_lossSegmentFactor(dt,br,los) $ validLossSegment(currTP,br,los)
5752                                         = LossSegmentFactor(currTP,br,los) ;
5753   
5754          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
5755   
5756          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
5757              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
5758                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
5759   
5760          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
5761              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
5762                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
5763   
5764          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
5765              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
5766                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
5767   
5768          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
5769              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
5770                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
5771   
5772          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
5773              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
5774                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
5775   
5776          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
5777              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
5778                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
5779   
5780          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
5781                                                offerNode(currTP,o,n)
5782                                              }, o_ILRO_FIR_TP(dt,o) ] ;
5783   
5784          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
5785                                                offerNode(currTP,o,n)
5786                                              }, o_ILRO_SIR_TP(dt,o) ] ;
5787   
5788          o_marketNodeIsland_TP(dt,o,ild)
5789              $ sum[ n $ { offerIsland(currTP,o,ild) and
5790                           offerNode(currTP,o,n) and
5791                           (o_nodeLoad_TP(dt,n)  = 0)
5792                         },1
5793                   ] = yes ;
5794   
5795          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
5796              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
5797              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
5798              ;
5799   
5800          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
5801              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
5802   
5803          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
5804              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
5805   
5806          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
5807              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
5808   
5809          o_manuRiskLevel(dt,ild,resC,ManualRisk)
5810              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
5811              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
5812              ;
5813   
5814          o_manuRiskPrice(dt,ild,resC,ManualRisk)
5815              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
5816   
5817          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
5818              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
5819   
5820          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
5821              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
5822   
5823          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
5824              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
5825   
5826          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
5827              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
5828   
5829          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
5830              $ islandRiskGroup(currTP,ild,rg,GenRisk)
5831              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
5832              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
5833              ;
5834   
5835          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
5836              $ islandRiskGroup(currTP,ild,rg,GenRisk)
5837              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
5838   
5839  *       FIR and SIR required based on calculations of the island risk to
5840  *       overcome reporting issues of the risk setter under degenerate
5841  *       conditions when reserve price = 0 - See below
5842   
5843          o_ReserveReqd_TP(dt,ild,resC)
5844              = Max[ 0,
5845                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
5846                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
5847                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
5848                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
5849                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
5850                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
5851                   ] ;
5852   
5853          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
5854          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
5855   
5856  *       Summary reporting by trading period
5857          o_solveOK_TP(dt) = ModelSolved ;
5858   
5859          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
5860   
5861          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
5862   
5863          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
5864   
5865          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
5866                       - o_systemCost_TP(dt)
5867                       - o_penaltyCost_TP(dt);
5868   
5869   
5870  *       Separete violation reporting at trade period level
5871          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
5872   
5873          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
5874   
5875          o_surpBranchFlow_TP(dt)
5876              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
5877   
5878          o_defRampRate_TP(dt)
5879              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
5880   
5881          o_surpRampRate_TP(dt)
5882              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
5883   
5884          o_surpBranchGroupConst_TP(dt)
5885              = sum[ brCstr $ branchConstraint(currTP,brCstr)
5886                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
5887   
5888          o_defBranchGroupConst_TP(dt)
5889              = sum[ brCstr $ branchConstraint(currTP,brCstr)
5890                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
5891   
5892          o_defMnodeConst_TP(dt)
5893              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
5894                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
5895   
5896          o_surpMnodeConst_TP(dt)
5897              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
5898                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
5899   
5900          o_defACnodeConst_TP(dt)
5901              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
5902                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
5903   
5904          o_surpACnodeConst_TP(dt)
5905              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
5906                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
5907   
5908          o_defT1MixedConst_TP(dt)
5909              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
5910                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
5911   
5912          o_surpT1MixedConst_TP(dt)
5913              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
5914                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
5915   
5916          o_defGenericConst_TP(dt)
5917              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
5918                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
5919   
5920          o_surpGenericConst_TP(dt)
5921              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
5922                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
5923   
5924          o_defResv_TP(dt)
5925              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
5926   
5927          o_totalViolation_TP(dt)
5928              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
5929              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
5930              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
5931              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
5932              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
5933              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
5934              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
5935              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
5936   
5937  *       Virtual reserve
5938          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
5939   
5940          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
5941                                    , o_vrResMW_TP(dt,ild,resC) ] ;
5942   
5943          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
5944                                    , o_vrResMW_TP(dt,ild,resC) ] ;
5945   
5946  *   Reporting at trading period end
5947      EndLoop;
5949   
5951   
5952  * End of the solve vSPD loop
5953    ] ;
5954  * End of the While loop
5955  );
5956   
5957   
5958  *   Summary reports - only applied for normal and audit vSPD run.
5960   
5961  *   System level
5962      o_numTradePeriods = card(tp) ;
5963   
5964      o_systemOFV = sum[ dt, o_ofv_TP(dt) ] ;
5965   
5966      o_systemGen = sum[ (dt,ild), o_islandGen_TP(dt,ild) ] ;
5967   
5968      o_systemLoad = sum[ (dt,ild), o_islandLoad_TP(dt,ild)
5969                                  - o_islandClrBid_TP(dt,ild) ] ;
5970   
5971      o_systemLoss = sum[ (dt,ild), o_islandBranchLoss_TP(dt,ild)
5972                                  + o_HVDCloss_TP(dt,ild) ] ;
5973   
5974      o_systemViolation = sum[ dt, o_totalViolation_TP(dt) ] ;
5975   
5976      o_systemFIR = sum[ (dt,ild), o_FIRcleared_TP(dt,ild) ] ;
5977   
5978      o_systemSIR = sum[ (dt,ild), o_SIRcleared_TP(dt,ild) ] ;
5979   
5980   
5981  *   Offer level - This does not include revenue from wind generators for
5982  *   final pricing because the wind generation is netted off against load
5983  *   at the particular bus for the final pricing solves
5984   
5985      o_offerTrader(o,trdr)
5986          $ sum[ tp $ i_tradePeriodOfferTrader(tp,o,trdr), 1 ] = yes ;
5987   
5988      o_offerGen(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerEnergy_TP(dt,o)] ;
5989   
5990      o_offerFIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerFIR_TP(dt,o)] ;
5991   
5992      o_offerSIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerSIR_TP(dt,o)] ;
5993   
5995   
5996   
5997  *=====================================================================================
5998  * 8. vSPD scarcity pricing post-processing
5999  *=====================================================================================
6001   
6002  * Mapping scarcity area to islands
6003  scarcityAreaIslandMap(sarea,ild)      = no ;
6004  scarcityAreaIslandMap('NI','NI')      = yes ;
6005  scarcityAreaIslandMap('SI','SI')      = yes ;
6006  scarcityAreaIslandMap('National',ild) = yes ;
6007   
6009   
6010   
6011  * 8b. Calculating price-relating outputs --------------------------------------
6012   
6014  loop(i_dateTimeTradePeriodMap(dt,tp),
6015   
6016  *   bus output update
6017      o_busRevenue_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6018                                        * o_busGeneration_TP(dt,b)
6019                                        * o_busPrice_TP(dt,b) ;
6020   
6021      o_busCost_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6022                                     * o_busLoad_TP(dt,b)
6023                                     * o_busPrice_TP(dt,b);
6024   
6025  *   node output update
6026      o_nodeRevenue_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6027                                          * o_nodeGeneration_TP(dt,n)
6028                                          * o_nodePrice_TP(dt,n) ;
6029   
6030      o_nodeCost_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6031                                       * o_nodeLoad_TP(dt,n)
6032                                       * o_nodePrice_TP(dt,n) ;
6033   
6034  *   branch output update
6035      o_branchFromBusPrice_TP(dt,br) $ branch(tp,br)
6036          = sum[ b $ o_branchFromBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6037   
6038      o_branchToBusPrice_TP(dt,br) $ branch(tp,br)
6039          = sum[ b $ o_branchToBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6040   
6041      o_branchTotalRentals_TP(dt,br)
6042          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) >= 0) }
6043          = (i_tradingPeriodLength/60)
6044          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6045            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
6046            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6047            ] ;
6048   
6049      o_branchTotalRentals_TP(dt,br)
6050          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) < 0) }
6051          = (i_tradingPeriodLength/60)
6052          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6053            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6054            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
6055            ] ;
6056   
6057  *   Island output
6058      o_islandRefPrice_TP(dt,ild)
6059          = sum[ n $ { referenceNode(tp,n)
6060                   and nodeIsland(tp,n,ild) } , o_nodePrice_TP(dt,n) ] ;
6061   
6062      o_islandEnergyRevenue_TP(dt,ild)
6063          = sum[ n $ nodeIsland(tp,n,ild), o_nodeRevenue_TP(dt,n)] ;
6064   
6065      o_islandReserveRevenue_TP(dt,ild) = sum[ resC, o_ResCleared_TP(dt,ild,resC)
6066                                                   * o_ResPrice_TP(dt,ild,resC)
6067                                                   * i_tradingPeriodLength/60 ];
6068   
6069      o_islandLoadCost_TP(dt,ild)
6070          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
6071               , o_nodeCost_TP(dt,n) ] ;
6072   
6073      o_islandLoadRevenue_TP(dt,ild)
6074          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
6075               , - o_nodeCost_TP(dt,n) ] ;
6076   
6078  ) ;
6079   
6080  * System level
6081  o_systemEnergyRevenue  = sum[ (dt,ild), o_islandEnergyRevenue_TP(dt,ild) ] ;
6082   
6083  o_systemReserveRevenue = sum[ (dt,ild), o_islandReserveRevenue_TP(dt,ild) ];
6084   
6085  o_systemLoadCost       = sum[ (dt,ild), o_islandLoadCost_TP(dt,ild) ];
6086   
6087  o_systemLoadRevenue    = sum[ (dt,ild), o_islandLoadRevenue_TP(dt,ild) ];
6088   
6089  * Offer level
6090  o_offerGenRevenue(o)
6091      = sum[ (dt,tp,n) $ { i_dateTimeTradePeriodMap(dt,tp) and offerNode(tp,o,n) }
6092           , (i_tradingPeriodLength/60)
6093           * o_offerEnergy_TP(dt,o) * o_nodePrice_TP(dt,n) ] ;
6094   
6095  o_offerFIRrevenue(o)
6096      = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6097                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6098           , (i_tradingPeriodLength/60)
6099           * o_offerFIR_TP(dt,o) * o_FIRprice_TP(dt,ild) ] ;
6100   
6101  o_offerSIRrevenue(o)
6102     = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6103                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6104           , (i_tradingPeriodLength/60)
6105           * o_offerSIR_TP(dt,o) * o_SIRprice_TP(dt,ild) ] ;
6106   
6108  *   Calculating price-relating outputs end -------------------------------------
6109   
6110   
6112   
6113  *=====================================================================================
6114  * 9. Write results to CSV report files and GDX files
6115  *=====================================================================================
6116  * TN - Pivot analysis end
INCLUDE    A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDreport.gms
6118  *=====================================================================================
6119  * Name:                 vSPDreport.gms
6120  * Function:             Creates the detailed reports for normal SPD mode
6121  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
6122  * Source:               https://github.com/ElectricityAuthority/vSPD
6123  *                       https://www.emi.ea.govt.nz/Tools/vSPD
6124  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
6125  *                       Email: emi@ea.govt.nz
6126  * Last modified on:     1 Oct 2019
6127  *
6128  *=====================================================================================
6129   
6130  * Normal vSPD run output
6131  o_FromDateTime(dt)$( ord(dt) = 1 ) = yes ;
6132   
6133  * System surplus needs to be calculated outside the main loop
6134  o_systemSurplus = o_systemLoadCost-o_systemLoadRevenue-o_systemEnergyRevenue ;
6135   
6136  * Trader level - Currently this does not include revenue from wind generators
6137  * since wind generation in FP is represented as negative load
6138  o_trader(trdr) = yes ;
6139  o_traderGen(trdr) = sum(o_offerTrader(o,trdr), o_offerGen(o)) ;
6140  o_traderFIR(trdr) = sum(o_offerTrader(o,trdr), o_offerFIR(o)) ;
6141  o_traderSIR(trdr) = sum(o_offerTrader(o,trdr), o_offerSIR(o)) ;
6142  o_traderGenRevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerGenRevenue(o));
6143  o_traderFIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerFIRrevenue(o));
6144  o_traderSIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerSIRrevenue(o));
6145   
6146   
6147  *=====================================================================================
6148  * Writing data in to CSV result files
6149  *=====================================================================================
6150   
6151  * System level summary
6152  File SystemResults    / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_SystemResults.csv" / ;
6153  SystemResults.pc = 5 ;     SystemResults.lw = 0 ;
6154  SystemResults.pw = 9999 ;  SystemResults.ap = 1 ;
6155  put SystemResults ;
6156  loop( dt $ o_FromDateTime(dt),
6157      put dt.tl, o_NumTradePeriods, o_systemOFV, o_systemGen, o_systemLoad
6158          o_systemLoss, o_systemViolation, o_systemFIR, o_systemSIR
6159          o_systemEnergyRevenue, o_systemLoadCost, o_systemLoadRevenue
6160          o_systemSurplus / ;
6161  ) ;
6162   
6163  * Offer level summary
6164  File  OfferResults     / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_OfferResults.csv" / ;
6165  OfferResults.pc = 5 ;      OfferResults.lw = 0 ;
6166  OfferResults.pw = 9999 ;   OfferResults.ap = 1 ;
6167  put OfferResults ;
6168  loop( (dt,o,trdr)
6169      $ { o_FromDateTime(dt) and o_offerTrader(o,trdr) and
6170          [ o_offerGen(o) or o_offerFIR(o) or o_offerSIR(o) ]
6171        },
6172      put dt.tl, o_NumTradePeriods, o.tl, trdr.tl
6173          o_offerGen(o), o_offerFIR(o), o_offerSIR(o) / ;
6174  ) ;
6175   
6176  * Trader level summary
6177  File  TraderResults   / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_TraderResults.csv" / ;
6178  TraderResults.pc = 5 ;     TraderResults.lw = 0 ;
6179  TraderResults.pw = 9999 ;  TraderResults.ap = 1 ;
6180  put TraderResults ;
6181  loop( (dt,trdr)
6182      $ { o_FromDateTime(dt) and o_trader(trdr) and
6183          [ o_traderGen(trdr) or o_traderFIR(trdr) or o_traderSIR(trdr) ]
6184        },
6185      put dt.tl, o_NumTradePeriods, trdr.tl
6186          o_traderGen(trdr), o_traderFIR(trdr), o_traderSIR(trdr) / ;
6187  ) ;
6188   
6189   
6190  * Trading period level report
6192   
6193  * Trading period summary result
6194  File
6195  SummaryResults_TP / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_SummaryResults_TP.csv" / ;
6196  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
6197  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
6198  SummaryResults_TP.nd = 5 ;
6199  put SummaryResults_TP ;
6200  loop( dt,
6201      put dt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
6202          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
6203          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
6204          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
6205          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
6206          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
6207          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt)
6208          o_DefACNodeConst_TP(dt), o_SurpACNodeConst_TP(dt)
6209          o_DefT1MixedConst_TP(dt), o_SurpT1MixedConst_TP(dt)
6210          o_DefGenericConst_TP(dt), o_SurpGenericConst_TP(dt) / ;
6211  ) ;
6212   
6213  * Trading period island result
6214  File IslandResults_TP /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_IslandResults_TP.csv"/;
6215  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
6216  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
6217  IslandResults_TP.nd = 5 ;
6218  put IslandResults_TP ;
6219  loop( (dt,ild) $ o_island(dt,ild),
6220      put dt.tl, ild.tl, o_islandGen_TP(dt,ild), o_islandLoad_TP(dt,ild)
6221          o_islandClrBid_TP(dt,ild), o_islandBranchLoss_TP(dt,ild)
6222          o_HVDCFlow_TP(dt,ild), o_HVDCLoss_TP(dt,ild)
6223          o_islandRefPrice_TP(dt,ild), o_FIRReqd_TP(dt,ild)
6224          o_SIRReqd_TP(dt,ild), o_FIRPrice_TP(dt,ild)
6225          o_SIRPrice_TP(dt,ild), o_islandEnergyRevenue_TP(dt,ild)
6226          o_islandLoadCost_TP(dt,ild), o_islandLoadRevenue_TP(dt,ild)
6227  * NIRM output
6228      o_FirCleared_TP(dt,ild), o_SirCleared_TP(dt,ild)
6229      o_FirSent_TP(dt,ild), o_SirSent_TP(dt,ild)
6230      o_FirReceived_TP(dt,ild), o_SirReceived_TP(dt,ild)
6231      o_FirEffReport_TP(dt,ild), o_SirEffReport_TP(dt,ild)
6232  *NIRM output end
6233      / ;
6234  ) ;
6235   
6237   
6238  * Trading period bus result
6239  File BusResults_TP   / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BusResults_TP.csv" / ;
6240  BusResults_TP.pc = 5 ;
6241  BusResults_TP.lw = 0 ;
6242  BusResults_TP.pw = 9999 ;
6243  BusResults_TP.ap = 1 ;
6244  BusResults_TP.nd = 3
6245  put BusResults_TP ;
6246  loop( o_bus(dt,b),
6247      put dt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
6248          o_busPrice_TP(dt,b), o_busRevenue_TP(dt,b), o_busCost_TP(dt,b)
6249          o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
6250  ) ;
6251   
6252  * Trading period node result
6253  File NodeResults_TP  /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_NodeResults_TP.csv" / ;
6254  NodeResults_TP.pc = 5 ;
6255  NodeResults_TP.lw = 0 ;
6256  NodeResults_TP.pw = 9999 ;
6257  NodeResults_TP.ap = 1 ;
6258  NodeResults_TP.nd = 3 ;
6259  put NodeResults_TP ;
6260  loop( (dt,n) $ o_node(dt,n),
6261      put dt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
6262          o_nodePrice_TP(dt,n), o_nodeRevenue_TP(dt,n), o_nodeCost_TP(dt,n)
6263          o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
6264  ) ;
6265   
6266  * Trading period offer result
6267  File OfferResults_TP  /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_OfferResults_TP.csv"/ ;
6268  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
6269  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
6270  OfferResults_TP.nd = 3 ;
6271  put OfferResults_TP ;
6272  loop( (dt,o) $ o_offer(dt,o),
6273      put dt.tl, o.tl, o_offerEnergy_TP(dt,o)
6274          o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
6275  ) ;
6276   
6277  * Trading period bid result
6278  File BidResults_TP    / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BidResults_TP.csv" / ;
6279  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
6280  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
6281  BidResults_TP.nd = 3 ;
6282  put BidResults_TP ;
6283  loop( (dt,bd) $ o_bid(dt,bd),
6284      put dt.tl, bd.tl, o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd)
6285      o_bidFIR_TP(dt,bd), o_bidSIR_TP(dt,bd) / ;
6286  ) ;
6287   
6288  * Trading period reserve result
6289  File
6290  ReserveResults_TP /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_ReserveResults_TP.csv" / ;
6291  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
6292  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
6293  ReserveResults_TP.nd = 3 ;
6294  put ReserveResults_TP ;
6295  loop( (dt,ild) $ o_island(dt,ild),
6296      put dt.tl, ild.tl, o_FIRReqd_TP(dt,ild), o_SIRReqd_TP(dt,ild)
6297          o_FIRPrice_TP(dt,ild), o_SIRPrice_TP(dt,ild)
6298          o_FIRViolation_TP(dt,ild), o_SIRViolation_TP(dt,ild)
6299          o_FIRvrMW_TP(dt,ild), o_SIRvrMW_TP(dt,ild) / ;
6300  ) ;
6301   
6302  * Trading period branch result
6303  File
6304  BranchResults_TP  / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BranchResults_TP.csv" / ;
6305  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
6306  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
6307  BranchResults_TP.nd = 5 ;
6308  put BranchResults_TP ;
6309  loop( (dt,br,frB,toB)
6310      $ { o_branchToBus_TP(dt,br,toB) and
6311          o_branchFromBus_TP(dt,br,frB) and o_branch(dt,br)
6312        },
6313      put dt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
6314          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
6315          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
6316          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
6317          o_branchTotalRentals_TP(dt,br) / ;
6318  ) ;
6319   
6320  * Trading period branch constraint result
6321  File BrCstrResults_TP
6322  / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BrConstraintResults_TP.csv" / ;
6323  BrCstrResults_TP.pc = 5 ;
6324  BrCstrResults_TP.lw = 0 ;
6325  BrCstrResults_TP.pw = 9999 ;
6326  BrCstrResults_TP.ap = 1 ;
6327  BrCstrResults_TP.nd = 5 ;
6328  put BrCstrResults_TP ;
6329  loop( (dt,brCstr) $ o_brConstraint_TP(dt,brCstr),
6330      put dt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
6331          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
6332          o_brConstraintPrice_TP(dt,brCstr) / ;
6333  ) ;
6334   
6335  * Trading period market node constraint result
6336  File MnodeCstrResults_TP
6337  / "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_MnodeConstraintResults_TP.csv" / ;
6338  MnodeCstrResults_TP.pc = 5 ;
6339  MnodeCstrResults_TP.lw = 0 ;
6340  MnodeCstrResults_TP.pw = 9999 ;
6341  MnodeCstrResults_TP.ap = 1 ;
6342  MnodeCstrResults_TP.nd = 5 ;
6343  put MnodeCstrResults_TP ;
6344  loop( (dt,MnodeCstr) $ o_MnodeConstraint_TP(dt,MnodeCstr),
6345      put dt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
6346          o_MnodeConstraintSense_TP(dt,MnodeCstr)
6347          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
6348          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
6349  ) ;
6350   
6352  *===============================================================================
6353   
6354   
6355   
6356  *===============================================================================
6357  * Audit mode reporting process
6358  *===============================================================================
6360   
6361  * Introduce zero tolerance to detect risk setter due to rounding issues
6362  Scalar zeroTolerance / 0.000001 / ;
6363   
6364   
6365  * Audit - branch loss result
6366  File branchLoss_Audit /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BranchLoss.csv"/;
6367  branchLoss_Audit.pc = 5 ;
6368  branchLoss_Audit.lw = 0 ;
6369  branchLoss_Audit.pw = 9999 ;
6370  BranchLoss_Audit.ap = 1 ;
6371  BranchLoss_Audit.nd = 9 ;
6372  put BranchLoss_Audit ;
6373  loop( (dt,br) $ o_branch(dt,br),
6374      put dt.tl, br.tl ;
6375      loop(los $ o_LossSegmentBreakPoint(dt,br,los),
6376          put o_LossSegmentBreakPoint(dt,br,los)
6377              o_LossSegmentFactor(dt,br,los) ;
6378      )
6379      put / ;
6380  ) ;
6381   
6382  * Audit - bus result
6383  File busResults_Audit /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BusResults.csv"/;
6384  busResults_Audit.pc = 5 ;
6385  busResults_Audit.lw = 0 ;
6386  busResults_Audit.pw = 9999 ;
6387  BusResults_Audit.ap = 1 ;
6388  BusResults_Audit.nd = 5 ;
6389  put BusResults_Audit ;
6390  loop( (dt,b,ild) $ { o_bus(dt,b) and o_busIsland_TP(dt,b,ild) },
6391      put dt.tl, ild.tl, b.tl, o_ACBusAngle(dt,b)
6392          o_busPrice_TP(dt,b), o_busLoad_TP(dt,b)
6393          o_ILBus_FIR_TP(dt,b), o_ILBus_SIR_TP(dt,b) / ;
6394  ) ;
6395   
6396  * Audit - market node result
6397  File
6398  MNodeResults_Audit  /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_MNodeResults.csv"/;
6399  MNodeResults_Audit.pc = 5 ;
6400  MNodeResults_Audit.lw = 0 ;
6401  MNodeResults_Audit.pw = 9999 ;
6402  MNodeResults_Audit.ap = 1 ;
6403  MNodeResults_Audit.nd = 5 ;
6404  put MNodeResults_Audit ;
6405  loop( (dt,o,ild) $ {o_offer(dt,o) and o_MarketNodeIsland_TP(dt,o,ild) },
6406      put dt.tl, ild.tl, o.tl, o_offerEnergy_TP(dt,o)
6407          o_PLRO_FIR_TP(dt,o), o_PLRO_SIR_TP(dt,o)
6408          o_TWRO_FIR_TP(dt,o), o_TWRO_SIR_TP(dt,o) / ;
6409  ) ;
6410   
6411  * Audit - branch result
6412  File
6413  brchResults_Audit  /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BranchResults.csv"/;
6414  brchResults_Audit.pc = 5 ;
6415  brchResults_Audit.lw = 0 ;
6416  brchResults_Audit.pw = 9999 ;
6417  brchResults_Audit.ap = 1 ;
6418  brchResults_Audit.nd = 9 ;
6419  put brchResults_Audit ;
6420  loop( (dt,br) $ o_branch(dt,br),
6421      put dt.tl, br.tl, o_branchFlow_TP(dt,br)
6422          o_branchDynamicLoss_TP(dt,br), o_branchFixedLoss_TP(dt,br)
6423          [o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br)] ;
6424      if ( o_branchMarginalPrice_TP(dt,br) <> 0,  put 'Y' ;
6425      else                                        put 'N' ;
6426      ) ;
6427   
6428      put o_branchMarginalPrice_TP(dt,br) ;
6429   
6430      if( o_NonPhysicalLoss(dt,br) > NonPhysicalLossTolerance, put 'Y' / ;
6431      else                                                     put 'N' / ;
6432      ) ;
6433  ) ;
6434   
6435  * Audit - risk result
6436  File
6437  riskResults_Audit    /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_RiskResults.csv"/;
6438  riskResults_Audit.pc = 5 ;
6439  riskResults_Audit.lw = 0 ;
6440  riskResults_Audit.pw = 9999 ;
6441  RiskResults_Audit.ap = 1 ;
6442  RiskResults_Audit.nd = 5 ;
6443  put RiskResults_Audit ;
6444  loop( (dt,ild,resC) $ o_island(dt,ild),
6445      loop( (o,GenRisk) $ { ( o_generationRiskLevel(dt,ild,o,resC,GenRisk) > 0 )
6446                        and ( abs[ o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
6447                                 - o_ReserveReqd_TP(dt,ild,resC)
6448                                 ] <= ZeroTolerance )
6449                           },
6450          put dt.tl, ild.tl, resC.tl, o.tl, GenRisk.tl
6451              o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
6452              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,GenRisk)
6453              o_ResViolation_TP(dt,ild,resC)
6454              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6455   
6456      ) ;
6457   
6458      loop( HVDCrisk $ { (o_HVDCriskLevel(dt,ild,resC,HVDCrisk) > 0)
6459                     and ( abs[  o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6460                               - o_ReserveReqd_TP(dt,ild,resC)
6461                              ] <= ZeroTolerance )
6462                       },
6463          put dt.tl, ild.tl, resC.tl, 'HVDC', HVDCrisk.tl
6464              o_HVDCriskLevel(dt,ild,resC,HVDCrisk), o_ResCleared_TP(dt,ild,resC)
6465              o_EffectiveRes_TP(dt,ild,resC,HVDCRisk)
6466              o_ResViolation_TP(dt,ild,resC)
6467              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6468      ) ;
6469   
6470      loop( manualRisk $ { ( o_manuRiskLevel(dt,ild,resC,ManualRisk) > 0 )
6471                       and ( abs[ o_manuRiskLevel(dt,ild,resC,manualRisk)
6472                                - o_ReserveReqd_TP(dt,ild,resC)
6473                                ] <= ZeroTolerance )
6474                         },
6475          put dt.tl, ild.tl, resC.tl, 'Manual', manualRisk.tl
6476              o_manuRiskLevel(dt,ild,resC,manualRisk),o_ResCleared_TP(dt,ild,resC)
6477              o_EffectiveRes_TP(dt,ild,resC,manualRisk)
6478              o_ResViolation_TP(dt,ild,resC)
6479              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6480      ) ;
6481   
6482      loop( (o,riskC) $ { HVDCsecRisk(riskC)
6483                      and ( o_genHVDCriskLevel(dt,ild,o,resC,riskC) > 0 )
6484                      and ( abs[ o_genHVDCriskLevel(dt,ild,o,resC,riskC)
6485                               - o_ReserveReqd_TP(dt,ild,resC)
6486                               ] <= ZeroTolerance )
6487                        },
6488          put dt.tl, ild.tl, resC.tl, o.tl, riskC.tl
6489              o_GenHVDCRiskLevel(dt,ild,o, resC,riskC)
6490              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
6491              o_ResViolation_TP(dt,ild,resC)
6492              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6493      ) ;
6494   
6495      loop( (o,riskC) $ { HVDCsecRisk(riskC)
6496                      and ( o_manuHVDCriskLevel(dt,ild,resC,riskC) > 0 )
6497                      and ( abs[ o_manuHVDCriskLevel(dt,ild,resC,riskC)
6498                               - o_ReserveReqd_TP(dt,ild,resC)
6499                               ] <= ZeroTolerance )
6500                        },
6501          put dt.tl, ild.tl, resC.tl, 'Manual', riskC.tl
6502              o_manuHVDCriskLevel(dt,ild,resC,riskC)
6503              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
6504              o_ResViolation_TP(dt,ild,resC)
6505              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6506          ) ;
6507   
6508  *   Ensure still reporting for conditions with zero FIR and/or SIR required
6509      if( (o_ReserveReqd_TP(dt,ild,resC) = 0) ,
6510          put dt.tl, ild.tl, resC.tl, ' ', ' ', ' '
6511              o_ResCleared_TP(dt,ild,resC), o_ResViolation_TP(dt,ild,resC)
6512              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6513      ) ;
6514  ) ;
6515   
6516  * Audit - objective result
6517  File objResults_Audit /"A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_ObjResults.csv"/;
6518  objResults_Audit.pc = 5 ;
6519  objResults_Audit.lw = 0 ;
6520  objResults_Audit.pw = 9999 ;
6521  objResults_Audit.ap = 1 ;
6522  objResults_Audit.nd = 5 ;
6523  objResults_Audit.nw = 20 ;
6524  put objResults_Audit
6525  loop( dt,
6526      put dt.tl, o_ofv_TP(dt) /
6527  ) ;
6528   
6529   
6530  execute_unload 'A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\..\Output\\Test_replace_invalid_SOS1_Prices\RTD_20201028_0105_301_AllData.gdx' ;
6532  *===============================================================================
6533  *execute_unload '%outputPath%\%runName%\%vSPDinputData%_AllData.gdx' ;
6534   
6535   
6536   
6537   
6539   
6540   
6541  * Post a progress message for use by EMI.
6542  putclose runlog 'Case: RTD_20201028_0105_301 is complete in ',timeExec,'(secs)'/ ;
6543  putclose runlog 'Case: RTD_20201028_0105_301 is finished in ',timeElapsed,'(secs)'/ ;
6544   
6545  * Go to the next input file
6547   
6548  * Post a progress message for use by EMI.
GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDsolve.gms
     2     2651 INCLUDE        1      58  .A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDsettings.inc
     3     2705 INCLUDE        1      59  .A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDcase.inc
     4     3100 IF EXIST       1     451  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx
     5     3106 GDXIN          1     457  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDPeriod.gdx
     6     3112 GDXIN          1     463  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx
     7     3136 GDXIN          1     487  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx
     8     3316 IF EXIST       1     667  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Override\.gdx
     9     6117 INCLUDE        1    3680  .A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDreport.gms
    10     6191 IF EXIST       9      74  .A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BusResults_TP.csv
    11     6549 IF EXIST       1    3692  A:\Tuong Nguyen\vSPD\GitHub\vSPD\Input\RTD_20201028_0105_301.gdx


COMPILATION TIME     =        0.125 SECONDS      4 MB  32.1.0 r75a5b5d WEX-WEI
GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 4722


LOOPS                            FOR/WHILE   1
                                        tp   28-OCT-2020 01:05


MODEL STATISTICS

BLOCKS OF EQUATIONS          89     SINGLE EQUATIONS       31,007
BLOCKS OF VARIABLES          51     SINGLE VARIABLES       42,159
NON ZERO ELEMENTS        91,524     DISCRETE VARIABLES         12


GENERATION TIME      =        0.328 SECONDS     22 MB  32.1.0 r75a5b5d WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 28-OCT-2020 01:05

GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 4722


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  4722

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE           -11934.0588

 RESOURCE USAGE, LIMIT          1.032      3600.000
 ITERATION COUNT, LIMIT      8843    2000000000

IBM ILOG CPLEX   32.1.0 r75a5b5d Released Jul 31, 2020 WEI x86 64bit/MS Window
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.10.0.0

Reading parameter(s) from "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\cplex.opt"
Space for names approximately 5.11 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.63sec (det. 554.07 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.27sec (det. 254.34 ticks)
Proven optimal solution.

MIP Solution:       -11934.058809    (5478 iterations, 8 nodes)
Final Solve:        -11934.058809    (3365 iterations)

Best possible:      -11934.058809
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_BranchFlowMIP Using MIP From line 4857


LOOPS                            FOR/WHILE   2
                                        tp   28-OCT-2020 01:05


MODEL STATISTICS

BLOCKS OF EQUATIONS          97     SINGLE EQUATIONS       33,337
BLOCKS OF VARIABLES          55     SINGLE VARIABLES       43,719
NON ZERO ELEMENTS        97,740     DISCRETE VARIABLES         12


GENERATION TIME      =        0.453 SECONDS     26 MB  32.1.0 r75a5b5d WEX-WEI
               L O O P S          FOR/WHILE 2
                                         tp 28-OCT-2020 01:05

GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 8
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_BranchFlowMIP Using MIP From line 4857


               S O L V E      S U M M A R Y

     MODEL   vSPD_BranchFlowMIP   OBJECTIVE  NETBENEFIT
     TYPE    MIP                  DIRECTION  MAXIMIZE
     SOLVER  CPLEX                FROM LINE  4857

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE           -11934.4366

 RESOURCE USAGE, LIMIT          1.797      3600.000
 ITERATION COUNT, LIMIT      8229    2000000000

IBM ILOG CPLEX   32.1.0 r75a5b5d Released Jul 31, 2020 WEI x86 64bit/MS Window
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.10.0.0

Reading parameter(s) from "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\cplex.opt"
Space for names approximately 5.42 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 1.47sec (det. 1423.13 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.16sec (det. 127.83 ticks)
Proven optimal solution.

MIP Solution:       -11934.436619    (6464 iterations, 36 nodes)
Final Solve:        -11934.436619    (1765 iterations)

Best possible:      -11934.436619
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 32.1.0  r75a5b5d Released Jul 31, 2020 WEX-WEI x86 64bit/MS Windows - 11/11/20 16:27:54 Page 9
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\ProgressReport.txt
temp A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\temp.put
SystemResults A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_SystemResults.csv
OfferResults A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_OfferResults.csv
TraderResults A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_TraderResults.csv
SummaryResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_SummaryResults_TP.csv
IslandResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_IslandResults_TP.csv
BusResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BusResults_TP.csv
NodeResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_NodeResults_TP.csv
OfferResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_OfferResults_TP.csv
ReserveResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_ReserveResults_TP.csv
BranchResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BranchResults_TP.csv
BrCstrResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_BrConstraintResults_TP.csv
MnodeCstrResults_TP A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_MnodeConstraintResults_TP.csv
branchLoss_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BranchLoss.csv
busResults_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BusResults.csv
MNodeResults_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_MNodeResults.csv
brchResults_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_BranchResults.csv
riskResults_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_RiskResults.csv
objResults_Audit A:\Tuong Nguyen\vSPD\GitHub\vSPD\Output\Test_replace_invalid_SOS1_Prices\Test_replace_invalid_SOS1_Prices_Audit_ObjResults.csv


EXECUTION TIME       =        5.734 SECONDS     32 MB  32.1.0 r75a5b5d WEX-WEI


USER: Small MUD - 5 User License                     G191031/0001CP-WIN
      Electricity Authority - Te Mana Hiko,                      DC5643


**** FILE SUMMARY

Restart    A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDmodel.g00
Input      A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDsolve.gms
Output     A:\Tuong Nguyen\vSPD\GitHub\vSPD\Programs\vSPDsolve.lst
