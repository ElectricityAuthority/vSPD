GAMS 24.2.1  r43572 Released Dec  9, 2013 WEX-WEI x86_64/MS Windows                                                                                                                                                                   03/31/14 09:58:56 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


1958  *=====================================================================================
1959  * Name:                 vSPDsolve.gms
1960  * Function:             Establish base case and override data, prepare data, and solve
1961  *                       the model
1962  * Developed by:         Electricity Authority, New Zealand
1963  * Source:               https://github.com/ElectricityAuthority/vSPD
1964  *                       http://reports.ea.govt.nz/EMIIntro.htm
1965  * Contact:              emi@ea.govt.nz
1966  * Last modified on:     16 December 2013
1967  *=====================================================================================
1968   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file
        3. Manage model and data compatability
        4. Establish which trading periods are to be solved
        5. Input data overrides - declare and apply (include vSPDoverrides.gms)
        6. FTR rental - vSPD setting to calculate branch and constraint participation loading
        7. Initialise constraint violation penalties (CVPs)
        8. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        9. Write results to GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr
2004   
2005   
2006  * Include paths, settings and case name files
INCLUDE    C:\a\vSPD\vSPD_onGithub\Programs\vSPDpaths.inc
2010   
2012   
2017   
2018   
INCLUDE    C:\a\vSPD\vSPD_onGithub\Programs\vSPDsettings.inc
2023  *+++ vSPD settings +++
2026   
2027   
2028  *+++ Network +++
2029  Scalar useAClossModel                    / 1 / ;
2030  Scalar useHVDClossModel                  / 1 / ;
2031  Scalar useACbranchLimits                 / 1 / ;
2032  Scalar useHVDCbranchLimits               / 1 / ;
2033  Scalar resolveCircularBranchFlows        / 1 / ;
2034  Scalar resolveHVDCnonPhysicalLosses      / 1 / ;
2035  Scalar resolveACnonPhysicalLosses        / 0 / ;
2036  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2037  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2038  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2039   
2040   
2041  *+++ Constraints +++
2042  Scalar useReserveModel                   / 1 / ;
2043  Scalar suppressMixedConstraint           / 0 / ;
2044  Scalar mixedMIPtolerance                 / 0.000001 / ;
2045   
2046   
2047  *+++ Model and solver +++
2048  Scalar sequentialSolve                   / 0 / ;
2050  Scalar LPtimeLimit                       / 600 / ;
2051  Scalar LPiterationLimit                  / 1000000 / ;
2052  Scalar MIPtimeLimit                      / 600 / ;
2053  Scalar MIPoptimality                     / 0 / ;
2054  Scalar MIPiterationLimit                 / 1000000 / ;
2055   
2056   
2057  *+++ External loss model from Transpower +++
2058  Scalar useExternalLossModel              / 1 / ;
2059  Scalar lossCoeff_A                       / 0.3101 / ;
2060  Scalar lossCoeff_C                       / 0.14495 / ;
2061  Scalar lossCoeff_D                       / 0.32247 / ;
2062  Scalar lossCoeff_E                       / 0.46742 / ;
2063  Scalar lossCoeff_F                       / 0.82247 / ;
2064  Scalar maxFlowSegment                    / 10000 / ;
2065   
2066   
2067  *+++ Misc +++
2068  Scalar disconnectedNodePriceCorrection   / 1 / ;
2070   
2071   
2072  *+++ Operating switches +++
2076  Scalar     opMode                        / 2 / ;   ! Specify 1 for data warehouse; -1 for audit; otherwise usual vSPD mode
2077  Scalar     tradePeriodReports            / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
INCLUDE    C:\a\vSPD\vSPD_onGithub\Programs\vSPDcase.inc
INCLUDE    C:\a\vSPD\vSPD_onGithub\Programs\FTRrun.inc
2082  Scalar FTRflag  / 0 / ;
2083   
2084   
2085  * Perform integrity checks on operating mode (opMode) and trade period reporting (tradePeriodReports) switches.
2086  * Notes: - Operating mode: 1 --> DW mode; -1 --> Audit mode; all else implies usual vSPD mode.
2087  *        - tradePeriodReports must be 0 or 1 (default = 1) - a value of 1 implies reports by trade period are
2088  *          generated. A value of zero will suppress them. tradePeriodReports must be 1 if opMode is 1 or -1,
2089  *          i.e. data warehouse or audit modes.
2090  if(tradePeriodReports < 0 or tradePeriodReports > 1, tradePeriodReports = 1 ) ;
2092  if( (opMode = -1) or (opMode = 1), tradePeriodReports = 1 ) ;
2093  *Display opMode, tradePeriodReports ;
2094   
2095   
2096  * Update the runlog file
2097  File runlog "Write to a report"      /  "C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\GDXtest_gams24_2_noX_RunLog.txt" / ; runlog.lw = 0 ; runlog.ap = 1 ;
2098  putclose runlog / 'Run: "GDXtest_gams24_2_noX"' / 'Case: "FP_20140221_I" - started at ', system.time, ' on ' system.date;
2099  if(sequentialSolve,
2100    putclose runlog / 'Vectorisation is switched OFF'
2101  else
2102    putclose runlog / 'Vectorisation is switched ON'
2103  ) ;
2104   
2105  * Set the solver for the LP and MIP
2106  option lp = Cplex ;
2107  option mip = Cplex ;
2108   
2109  * Set profile status
2110  option profile = 0 ;
2111   
2112  * Set the solution print status in the lst file
2113  option solprint = off ;
2114   
2115  * Set the column (variable) and row (equation) listing in the lst file
2116  option limcol = 0 ;
2117  option limrow = 0 ;
2118   
2119  * Allow empty data set declaration
2121   
2122   
2123  *=====================================================================================
2124  * 1. Declare symbols and initialise some of them
2125  *=====================================================================================
2126   
2127  Sets
2128  * Initialise 21 fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2129    i_island                    / NI, SI /
2130    i_reserveClass              / FIR, SIR /
2131    i_reserveType               / PLSR, TWDR, ILR /
2132    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2133                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2134    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2135    i_offerType                 / energy, PLSR, TWDR, ILR /
2136    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2137                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW /
2138    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2139    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2140    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2141    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2142    i_energyBidComponent        / i_bidMW, i_bidPrice /
2143    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2144    i_tradeBlock                / t1*t20 /
2145    i_lossSegment               / ls1*ls10 /
2146    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2147    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2148    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2149    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2150    i_flowDirection             / forward, backward /
2151    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2152                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2153                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2154                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2155                                  i_deficitRampRate, i_surplusRampRate
2156                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2157                                  i_deficitBranchFlow, i_surplusBranchFlow
2158                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2159                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2160                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2161   
2162  * Initialise the set called pole
2163    pole  'HVDC poles'          / pole1, pole2 /
2164   
2165  * Initialise sets used when applying overrides. Declared and initialised now (ahead of input GDX load) so as to
2166  * preserve orderedness of elements
2167    tradePeriodNodeIslandTemp(tp,n,ild) 'Temporary mapping set of nodes to islands for island demand override'
2168    ovrd             'Number of overrides per parameter'    / 1*100 /
2169    i_dayNum         'Day number'                           / 1*31 /
2170    i_monthNum       'Month number'                         / 1*12 /
2171    i_yearNum        'Year number'                          / 1900*2200 /
2172    fromTo           'From/To - for override dates'         / frm, to /
2173    ;
2174   
2175  Alias (i_dayNum,day), (i_monthNum,mth), (i_yearNum,yr) ;
2176   
2177  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2178  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2179   
2180  Sets
2181  * Dispatch results reporting
2182    o_fromDateTime(dt)                                  'Start period for summary reports'
2183    o_dateTime(dt)                                      'Date and time for reporting'
2184    o_bus(dt,b)                                         'Set of buses for output report'
2185    o_offer(dt,o)                                       'Set of offers for output report'
2186    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2187    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2188    o_trader(trdr)                                      'Set of traders for trader summary output report'
2189    o_node(dt,n)                                        'Set of nodes for output report'
2190    o_branch(dt,br)                                     'Set of branches for output report'
2191    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2192    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2193    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2194    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2195    ;
2196   
2197  Parameters
2198  * Main iteration counter
2199    iterationCount                                      'Iteration counter for the solve'
2200  * MIP logic
2201    branchFlowMIPInvoked(tp)                            'Flag to detect if branch flow MIP is needed'
2202    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2203  * Introduce flag to detect circular branch flows on each HVDC pole
2204    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2205    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2206    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2207    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2208    manualBranchSegmentMWFlow(tp,br,los)                'Manual calculation of the branch loss segment MW flow'
2209    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2210    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2211    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2212  * Parameters to calculate circular branch flow on each HVDC pole
2213    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2214    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2215  * Disconnected bus post-processing
2216    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2217    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2218    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2219    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2220  * Dispatch results for reporting
2221  * Trade period level
2222    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2223    o_islandLoad_TP(dt,ild)                             'Island MW load for the different time periods'
2224    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2225    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2226    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2227    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
2228    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
2229    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
2230    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
2231    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
2232    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
2233    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
2234    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
2235    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
2236    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
2237    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
2238    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
2239    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
2240    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
2241    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
2242    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
2243    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
2244    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
2245    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
2246    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
2247    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
2248    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
2249    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
2250    o_branchDynamicRentals_TP(dt,br)                    'Output $ rentals on transmission branches using dynamic losses for the different time periods'
2251    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
2252    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
2253    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
2254    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
2255    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
2256    o_bidEnergy_TP(dt,i_bid)                            'Output MW cleared for each energy bid for each trade period'
2257    o_bidReserve_TP(dt,i_bid,i_reserveClass)            'Output MW cleared for each reserve bid for each trade period'
2258    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
2259    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
2260    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
2261    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
2262    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
2263    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
2264    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
2265    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
2266    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
2267    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
2268    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
2269    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
2270    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
2271  * Security constraint data
2272    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
2273    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
2274    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
2275    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
2276  * Mnode constraint data
2277    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
2278    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
2279    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
2280    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
2281  * TradePeriod summary report
2282    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
2283    o_systemCost_TP(dt)                                 'System cost for summary report'
2284    o_ofv_TP(dt)                                        'Objective function value for summary report'
2285    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
2286    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
2287    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
2288    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
2289    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
2290    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
2291    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
2292    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
2293    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
2294    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
2295    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
2296    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
2297    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
2298    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
2299    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
2300    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
2301    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
2302    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
2303  * System level
2304    o_numTradePeriods                                   'Output number of trade periods in summary'
2305    o_systemOFV                                         'System objective function value'
2306    o_systemGen                                         'Output system MWh generation'
2307    o_systemLoad                                        'Output system MWh load'
2308    o_systemLoss                                        'Output system MWh loss'
2309    o_systemViolation                                   'Output system MWh violation'
2310    o_systemFIR                                         'Output system FIR MWh reserve'
2311    o_systemSIR                                         'Output system SIR MWh reserve'
2312    o_systemEnergyRevenue                               'Output offer energy revenue $'
2313    o_systemReserveRevenue                              'Output reserve revenue $'
2314    o_systemLoadCost                                    'Output system load cost $'
2315    o_systemLoadRevenue                                 'Output system load revenue $'
2316    o_systemSurplus                                     'Output system surplus $'
2317    o_systemACrentals                                   'Output system AC rentals $'
2318    o_systemDCrentals                                   'Output system DC rentals $'
2319  * Offer level
2320    o_offerGen(o)                                       'Output offer generation (MWh)'
2321    o_offerFIR(o)                                       'Output offer FIR (MWh)'
2322    o_offerSIR(o)                                       'Output offer SIR (MWh)'
2323    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
2324    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
2325    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
2326  * Trader level
2327    o_traderGen(trdr)                                   'Output trader generation (MWh)'
2328    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
2329    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
2330    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
2331    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
2332    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
2333  * Factor to prorate the deficit and surplus at the nodal level
2334    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
2335    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
2336  * Introduce i_useBusNetworkModel to account for MSP change-over date.
2337    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
2338    ;
2339   
2340  Scalars
2341    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
2342    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
2343    skipResolve                   'Flag to indicate if the integer resolve logic needs to be skipped and resolved in sequential mode'     / 0 /
2344    LPvalid                       'Flag to indicate if the LP solution is valid (1 = Yes)'                                                / 0 /
2345    numTradePeriods               'Number of trade periods in the solve'                                                                  / 0 /
2346    thresholdSimultaneousInteger  'Number of trade periods to skip the integer resolve in simultanous mode and repeat in sequential mode' / 1 /
2347  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
2348    i_useExtendedRiskClass        'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
2349    ;
2350   
2351   
2352  * Audit - extra output declaration
2353  Sets
2354    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2355    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2356    ;
2357   
2358  Parameters
2359    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
2360    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
2361    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
2362    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
2363    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
2364    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
2365    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
2366    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
2367    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
2368    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
2369    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
2370    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
2371    o_generationRiskLevel(dt,ild,o,i_reserveClass,i_riskClass)    'Audit - generation risk'
2372    o_genHVDCriskLevel(dt,ild,o,i_reserveClass,i_riskClass)       'Audit - generation + HVDC secondary risk'
2373    o_HVDCriskLevel(dt,ild,i_reserveClass,i_riskClass)            'Audit - DCCE and DCECE risk'
2374    o_manuRiskLevel(dt,ild,i_reserveClass,i_riskClass)            'Audit - manual risk'
2375    o_manuHVDCriskLevel(dt,ild,i_reserveClass,i_riskClass)        'Audit - manual + HVDC secondary'
2376    o_generationRiskLevelMax(dt,ild,o,i_reserveClass)             'Audit - max generation risk'
2377    o_genHVDCriskLevelMax(dt,ild,o,i_reserveClass)                'Audit - max generation + HVDC secondary risk'
2378    o_HVDCriskLevelMax(dt,ild,i_reserveClass)                     'Audit - max HVDC risk'
2379    o_manuRiskLevelMax(dt,ild,i_reserveClass)                     'Audit - max manual risk'
2380    o_manuHVDCriskLevelMax(dt,ild,i_reserveClass)                 'Audit - max manual + HVDC secondary risk'
2381    o_FIRcleared_TP(dt,ild)                                       'Audit - total FIR cleared by island'
2382    o_SIRcleared_TP(dt,ild)                                       'Audit - total SIR cleared by island'
2383    ;
2384   
2385  * Declare a temporary file
2386  File temp ;
2387   
2388   
2389   
2390  *=====================================================================================
2391  * 2. Load data from GDX file
2392  *=====================================================================================
2393  * Call the GDX routine and load the input data:
2394  * - include .gdx extension to facilitate standalone mode (implies the .gdx extension is omitted from the vSPDcase.inc file)
2395  * - if file does not exist then go to the next input file
GDXIN   C:\a\vSPD\vSPD_onGithub\Input\FP_20140221_I.gdx
2398  * 30 sets
--- LOAD  i_tradePeriod = 7:i_TradePeriod
--- LOAD  i_dateTime = 6:i_DateTime
--- LOAD  i_offer = 25:i_Offer
--- LOAD  i_trader = 26:i_Trader
--- LOAD  i_bid = 38:i_Bid
--- LOAD  i_node = 46:i_Node
--- LOAD  i_bus = 47:i_Bus
--- LOAD  i_branch = 52:i_Branch
--- LOAD  i_branchConstraint = 74:i_BranchConstraint
--- LOAD  i_ACnodeConstraint = 77:i_ACNodeConstraint
--- LOAD  i_MnodeConstraint = 80:i_MNodeConstraint
--- LOAD  i_genericConstraint = 100:i_GenericConstraint
--- LOAD  i_type1MixedConstraint = 86:i_Type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 87:i_Type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 8:i_DateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 27:i_TradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 28:i_TradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 39:i_TradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 40:i_TradePeriodBidNode
--- LOAD  i_tradePeriodNode = 48:i_TradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 49:i_TradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 50:i_TradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 51:i_TradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 53:i_TradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 71:i_TradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 88:i_Type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 90:i_TradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 91:i_TradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 92:i_Type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 101:i_TradePeriodGenericConstraint
2405  * 55 Parameters
--- LOAD  i_day = 2:i_Day
--- LOAD  i_month = 3:i_Month
--- LOAD  i_year = 4:i_Year
--- LOAD  i_tradingPeriodLength = 16:i_TradingPeriodLength
--- LOAD  i_AClineUnit = 15:i_ACLineUnit
--- MERGE i_branchReceivingEndLossProportion = 18:i_BranchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 14:i_StudyTradePeriod
--- LOAD  i_CVPvalues = 17:i_CVPValues
--- LOAD  i_tradePeriodOfferParameter = 29:i_TradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 30:i_TradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 31:i_TradePeriodSustainedPLSROffer
--- LOAD  i_tradePeriodFastPLSRoffer = 32:i_TradePeriodFastPLSROffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 33:i_TradePeriodSustainedTWDROffer
--- LOAD  i_tradePeriodFastTWDRoffer = 34:i_TradePeriodFastTWDROffer
--- LOAD  i_tradePeriodSustainedILRoffer = 35:i_TradePeriodSustainedILROffer
--- LOAD  i_tradePeriodFastILRoffer = 36:i_TradePeriodFastILROffer
--- LOAD  i_tradePeriodNodeDemand = 37:i_TradePeriodNodeDemand
--- LOAD  i_tradePeriodEnergyBid = 43:i_TradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 44:i_TradePeriodSustainedILRBid
--- LOAD  i_tradePeriodFastILRbid = 45:i_TradePeriodFastILRBid
--- LOAD  i_tradePeriodHVDCNode = 56:i_TradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 57:i_TradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 58:i_TradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 59:i_TradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 60:i_TradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 61:i_TradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 62:i_NoLossBranch
--- LOAD  i_AClossBranch = 63:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 64:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 65:i_TradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 66:i_TradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 72:i_TradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 73:i_TradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 75:i_TradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 76:i_TradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 78:i_TradePeriodACNodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 79:i_TradePeriodACNodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 81:i_TradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 82:i_TradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 83:i_TradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 84:i_TradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 85:i_TradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 93:i_Type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 94:i_Type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 95:i_Type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 96:i_Type1MixedConstraintHVDCLineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 97:i_TradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 98:i_Type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 99:i_TradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 102:i_TradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 103:i_TradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 104:i_TradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 105:i_TradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 106:i_TradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 107:i_TradePeriodGenericConstraintRHS
2419   
2420   
2421   
2422  *=====================================================================================
2423  * 3. Manage model and data compatability
2424  *=====================================================================================
2425  * This section manages the changes to model flags to ensure backward compatibility given
2426  * changes in the SPD model formulation over time:
2427  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
2428  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
2429   
2430  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
2431  Scalars
2432    inputGDXGDate                     'Gregorian date of input GDX file'
2433    mixedConstraintRiskOffsetGDXGDate 'Mixed constraint risk offset expired on        17 Oct 2011'    / 40832 /
2434    primarySecondaryGDXGDate          'Primary secondary offer in use from            01 May 2012'    / 41029 /
2435    demandBidChangeGDXGDate           'Change to demand bid on                        28 Jun 2012'    / 41087 /
2436   
2437    HVDCroundPowerGDXGDate            'HVDC round power mode in use from              20 Sep 2012'    / 41171 /
2438    minimumRiskECEGDXGDate            'Manual ECE risk parameters in use from         20 Sep 2012'    / 41171 /
2439    HVDCsecRiskGDXGDate               'HVDC secondary risk parameters in use from     20 Sep 2012'    / 41171 /
2440    addnMixedConstraintVarGDXGDate    'Additional mixed constraint parameters from    24 Feb 2013'    / 41328 /
2441    reserveClassGenMaxGDXGDate        'Reserve class generation parameter in use from 24 Feb 2013'    / 41328 /
2442    primSecGenRiskModelGDXGDate       'Primary secondary risk model in use from       24 Feb 2013'    / 41328 /
2443  * Introduce MSP change-over date to account for change in the node-bus allocation factor from the input gdx files
2444    MSPchangeOverGDXGDate             'MSP change over from mid-day on                20 Jul 2009'    / 40014 /
2445    ;
2446   
2447  * Calculate the Gregorian date of the input data
2448  inputGDXGDate = jdate(i_year,i_month,i_day) ;
2449   
2450  put_utility temp 'gdxin' / 'C:\a\vSPD\vSPD_onGithub\Programs\..\Input\\FP_20140221_I.gdx' ;
2451   
2452  * Conditional load of i_tradePeriodPriamrySecondary set
2453  if(inputGDXGDate >= primarySecondaryGDXGDate,
2454      execute_load i_tradePeriodPrimarySecondaryOffer ;
2455  else
2456    i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
2457  ) ;
2458   
2459  * Conditional load of i_tradePeriodManualRisk_ECE parameter
2460  if(inputGDXGDate >= minimumRiskECEGDXGDate,
2461  *   Set the use extended risk class flag
2462      i_useExtendedRiskClass = 1 ;
2463      execute_load i_tradePeriodManualRisk_ECE ;
2464  else
2465    i_tradePeriodManualRisk_ECE(tp,ild,i_reserveClass) = 0 ;
2466  ) ;
2467   
2468  * Conditional load of HVDC secondary risk parameters
2469  if(inputGDXGDate >= HVDCsecRiskGDXGDate,
2470      execute_load i_tradePeriodHVDCsecRiskEnabled, i_tradePeriodHVDCsecRiskSubtractor ;
2471  else
2472      i_tradePeriodHVDCsecRiskEnabled(tp,ild,i_riskClass) = 0 ;
2473      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
2474  ) ;
2475   
2476  * Conditional load of i_tradePeriodAllowHVDCroundpower parameter
2477  if(inputGDXGDate >= HVDCroundPowerGDXGDate,
2478      execute_load i_tradePeriodAllowHVDCroundpower ;
2479  else
2480      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
2481  ) ;
2482   
2483  * Conditional load of additional mixed constraint parameters
2484  if(inputGDXGDate >= addnMixedConstraintVarGDXGDate,
2485      execute_load i_type1MixedConstraintAClineWeight, i_type1MixedConstraintAClineLossWeight
2486                   i_type1MixedConstraintAClineFixedLossWeight, i_type1MixedConstraintHVDClineLossWeight
2487                   i_type1MixedConstraintHVDClineFixedLossWeight, i_type1MixedConstraintPurWeight ;
2488  else
2489      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
2490      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
2491      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
2492      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
2493      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
2494      i_type1MixedConstraintPurWeight(t1MixCstr,i_bid) = 0 ;
2495  ) ;
2496   
2497  * Conditional load of reserve class generation parameter
2498  if(inputGDXGDate >= reserveClassGenMaxGDXGDate,
2499      execute_load i_tradePeriodReserveClassGenerationMaximum ;
2500  else
2501      i_tradePeriodReserveClassGenerationMaximum(tp,o,i_reserveClass) = 0 ;
2502  ) ;
2503   
2504  * Switch off the mixed constraint based risk offset calculation after 17 October 2011 (data stopped being populated in GDX file)
2505  useMixedConstraintRiskOffset = 1 $ (inputGDXGDate < mixedConstraintRiskOffsetGDXGDate) ;
2506   
2507  * Switch off mixed constraint formulation if no data coming through
2508  useMixedConstraint(tp) $ sum(t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1) = 1 ;
2509  useMixedConstraint(tp) $ suppressMixedConstraint = 0 ;
2510   
2511  * Do not use the extended risk class if no data coming through
2512  i_useExtendedRiskClass $ { sum[ (tp,ild,i_reserveClass,i_riskClass,i_riskParameter) $ (ord(i_riskClass) > 4)
2513                                  , i_tradePeriodRiskParameter(tp,ild,i_reserveClass,i_riskClass,i_riskParameter)
2514                                ] = 0
2515                           } = 0 ;
2516   
2517  * Change to demand bid
2518  useDSBFDemandBidModel = 1 $ ( inputGDXGDate >= demandBidChangeGDXGDate ) ;
2519   
2520  * Use the risk model that accounts for multiple offers per generating unit
2521  usePrimSecGenRiskModel = 1  $( inputGDXGDate >= primSecGenRiskModelGDXGDate ) ;
2522   
2523  * Introduce i_useBusNetworkModel to account for MSP change-over date when for half of the day the old
2524  * market node model and the other half the bus network model was used. The old market model does not
2525  * have the i_tradePeriodBusElectrical island paramter specified since it uses the market node network
2526  * model. This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter to be used
2527  * in the post-MSP solves to indentify 'dead' electrical buses.
2528  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= MSPchangeOverGDXGDate ) and
2529                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
2530                                 } ;
2531   
2532   
2533   
2534  *=====================================================================================
2535  * 4. Establish which trading periods are to be solved
2536  *=====================================================================================
        The symbol called i_tradePeriodSolve is used to change the values of i_studyTradePeriod, which
        itself is loaded from the input GDX file and is by default set equal to 1 for all trading periods.
        The procedure for setting the value of i_tradePeriodSolve depends on the user interface mode. The
        $setglobal called interfaceMode is used to control the process of setting the values of i_tradePeriodSolve.
        interfaceMode: a value of zero implies the EMI interface, a 1 implies the Excel interface; and all other
        values imply standalone interface mode (although ideally users should set it equal to 2 for standalone).
2545   
2546  Sets
2547    allPeriods   'All trading periods to be solved'     / all /
2548    tempPeriod   'Temporary list of trading period to be solved'
INCLUDE    C:\a\vSPD\vSPD_onGithub\Programs\vSPDtpsToSolve.inc
      Examples
      a. To solve all trading periods:
      /
      All
      /
       
      b. To solve trading periods 3 and 6:
      /
      tp3
      tp6
      /
       
      or
       
      /
      tp3, tp6
      /
2569   
2570  /
2571  All
2572  /
2573    ;
2574   
2575  i_studyTradePeriod(tp) = 0 ;
2576  i_studyTradePeriod(tp) $ sum[ tempPeriod, diag(tp,tempPeriod)] = 1 ;
2577  i_studyTradePeriod(tp) $ sum[ tempPeriod, diag(tempPeriod,'all')] = 1 ;
2578   
2579   
2580   
2581  *=====================================================================================
2582  * 5. Input data overrides - declare and apply (include vSPDoverrides.gms)
2583  *=====================================================================================
2584   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms unless suppressOverrides in
         vSPDpaths.inc is set equal to 1.
       - The procedure for introducing data overrides depends on the user interface mode. The $setglobal called
         interfaceMode is used to control the process of introducing data overrides.
       - interfaceMode: a value of zero implies the EMI interface, a 1 implies the Excel interface; and all other
         values imply standalone interface mode (although ideally users should set it equal to 2 for standalone).
       - All override data symbols have the characters 'Ovrd' appended to the original symbol name. After declaring
         the override symbols, the override data is installed and the original symbols are overwritten.
       - Note that the Excel interface permits a very limited number of input data symbols to be overridden. The EMI
         interface will create a GDX file of override values for all data inputs to be overridden. If operating in
         standalone mode, overrides can be installed by any means the user prefers - GDX file, $include file, hard-coding,
         etc. But it probably makes sense to mimic the GDX file as used by EMI.
2599   
2601   
2602   
2603   
2604  *=====================================================================================
2605  * 6. FTR rental - vSPD setting to calculate branch and constraint participation loading
2606  *=====================================================================================
2607  * FTR rental - extra output declaration
2608  Sets
2609    i_FTRdirection                                  'FTR flow direction'
2610    i_FTRfrNode(i_Node)                             'Injection node'
2611    i_FTRtoNode(i_Node)                             'Demand node'
2612   
2613    o_HVDClink(dt,br)                               'HVDC links (branches) defined for the current trading period'
2614    ;
2615   
2616  Alias (i_FTRdirection,ftr) ;
2617   
2618  Parameters
2619    i_FTRinjection(ftr,n,n)                         'Maximun injection'
2620    i_TradePeriodHVDCDirection(tp, br)              '1 --> to NI, -1 --> to SI'
2621   
2622    o_ACbranchTotalRentals(dt)                      'Total AC rental by trading period for reporting'
2623    o_ACbranchLossMW(dt,br,los)                     'MW element of the loss segment curve in MW'
2624    o_ACbranchLossFactor(dt,br,los)                 'Loss factor element of the loss segment curve'
2625   
2626    FTRbranchFlow(ftr,dt,br)                        'FTR directed MW flow on each branch for the different time periods'
2627    FTRbrCstrLHS(ftr,dt,brCstr)                     'FTR directed branch constraint value'
2628    ;
2629   
2631   
2632   
2633   
2634  *=====================================================================================
2635  * 7. Initialise constraint violation penalties (CVPs)
2636  *=====================================================================================
2637   
2638  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
2639   
2640  * Set the flag for the application of the different CVPs for CE and ECE
2641  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
2642  diffCeECeCVP = 0 ;
2643   
2644  * Calculate the Gregorian date of the CE and ECE change - Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
2645  CVPchangeGDate = jdate(2010,06,24) ;
2646   
2647  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
2648  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
2649  * If the user selects Yes (1), set the diffCeECeCVP flag
2650  diffCeECeCVP $ (-1 = 1) = 1 ;
2651   
2652  deficitBusGenerationPenalty                                           = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
2653  surplusBusGenerationPenalty                                           = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
2654  deficitReservePenalty(i_reserveClass) $ (ord(i_reserveClass) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
2655  deficitReservePenalty(i_reserveClass) $ (ord(i_reserveClass) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
2656  deficitBranchGroupConstraintPenalty                                   = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
2657  surplusBranchGroupConstraintPenalty                                   = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
2658  deficitGenericConstraintPenalty                                       = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
2659  surplusGenericConstraintPenalty                                       = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
2660  deficitRampRatePenalty                                                = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
2661  surplusRampRatePenalty                                                = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
2662  deficitACnodeConstraintPenalty                                        = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
2663  surplusACnodeConstraintPenalty                                        = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
2664  deficitBranchFlowPenalty                                              = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
2665  surplusBranchFlowPenalty                                              = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
2666  deficitMnodeConstraintPenalty                                         = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
2667  surplusMnodeConstraintPenalty                                         = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
2668  type1DeficitMixedConstraintPenalty                                    = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
2669  type1SurplusMixedConstraintPenalty                                    = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
2670  * Different CVPs defined for CE and ECE
2671  deficitReservePenalty_CE(i_reserveClass) $ (ord(i_reserveClass) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
2672  deficitReservePenalty_CE(i_reserveClass) $ (ord(i_reserveClass) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
2673  deficitReservePenalty_ECE(i_reserveClass)$ (ord(i_reserveClass) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
2674  deficitReservePenalty_ECE(i_reserveClass)$ (ord(i_reserveClass) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
2675   
2676  * Initialise some reporting parameters
2677  o_numTradePeriods = 0 ;
2678  o_systemOFV = 0 ;
2679  o_systemGen = 0 ;
2680  o_systemLoad = 0 ;
2681  o_systemLoss = 0 ;
2682  o_systemViolation = 0 ;
2683  o_systemFIR = 0 ;
2684  o_systemSIR = 0 ;
2685  o_systemEnergyRevenue = 0 ;
2686  o_systemReserveRevenue = 0 ;
2687  o_systemLoadCost = 0 ;
2688  o_systemLoadRevenue = 0 ;
2689  o_systemSurplus = 0 ;
2690  o_systemACrentals = 0 ;
2691  o_systemDCrentals = 0 ;
2692  o_offerGen(o) = 0 ;
2693  o_offerFIR(o) = 0 ;
2694  o_offerSIR(o) = 0 ;
2695  o_offerGenRevenue(o) = 0 ;
2696  o_offerFIRrevenue(o) = 0 ;
2697  o_offerSIRrevenue(o) = 0 ;
2698  o_solveOK_TP(dt) = 0 ;
2699   
2700  * Initialise some of the Audit reporting parameters to zero
2701  o_FIRreqd_TP(dt,ild) = 0 ;
2702  o_SIRreqd_TP(dt,ild) = 0 ;
2703  o_generationRiskLevel(dt,ild,o,i_reserveClass,i_riskClass) = 0 ;
2704  o_generationRiskLevelMax(dt,ild,o,i_reserveClass) = 0 ;
2705  o_genHVDCriskLevel(dt,ild,o,i_reserveClass,i_riskClass) = 0 ;
2706  o_HVDCriskLevel(dt,ild,i_reserveClass,i_riskClass) = 0 ;
2707  o_manuRiskLevel(dt,ild,i_reserveClass,i_riskClass) = 0 ;
2708  o_manuHVDCriskLevel(dt,ild,i_reserveClass,i_riskClass) = 0 ;
2709  o_HVDCriskLevelMax(dt,ild,i_reserveClass) = 0 ;
2710  o_genHVDCriskLevelMax(dt,ild,o,i_reserveClass) = 0 ;
2711  o_manuHVDCriskLevelMax(dt,ild,i_reserveClass) = 0 ;
2712  o_manuRiskLevelMax(dt,ild,i_reserveClass) = 0 ;
2713  o_FIRcleared_TP(dt,ild) = 0 ;
2714  o_SIRcleared_TP(dt,ild) = 0 ;
2715   
2716  * Update the deficit and surplus reporting at the nodal level
2717  totalBusAllocation(dt,b) = 0 ;
2718  busNodeAllocationFactor(dt,b,n) = 0 ;
2719   
2720  * Determine the number of trade periods
2721  numTradePeriods = card(tp) ;
2722   
2723   
2724   
2725  *=====================================================================================
2726  * 8. The vSPD solve loop
2727  *=====================================================================================
2728   
2729  for[iterationCount = 1 to numTradePeriods,
2730      skipResolve = 0 ;
2731   
2732  *   Determine which trading periods to solve when in sequential solve mode
2733      if( [ ( sequentialSolve and sum[ tp $ (ord(tp) = iterationCount), i_studyTradePeriod(tp) ] )
2734            or
2735            ( not sequentialSolve )
2736          ],
2737   
2738  *       a) Reset all sets, parameters and variables before proceeding with the next study trade period
2739   
2740  *       Model Variables
2741  *       Reset bounds
2742  *       Offers
2743          option clear = GENERATION ;
2744          option clear = GENERATIONBLOCK ;
2745  *       Purchase bids
2746          option clear = PURCHASE ;
2747          option clear = PURCHASEBLOCK ;
2748          option clear = PURCHASEILR ;
2749          option clear = PURCHASEILRBLOCK ;
2750  *       Network
2751          option clear = HVDCLINKFLOW ;
2752          option clear = HVDCLINKLOSSES ;
2753          option clear = LAMBDA ;
2754          option clear = LAMBDAINTEGER ;
2755          option clear = ACBRANCHFLOW ;
2756          option clear = ACBRANCHFLOWDIRECTED ;
2757          option clear = ACBRANCHLOSSESDIRECTED ;
2758          option clear = ACBRANCHFLOWBLOCKDIRECTED ;
2759          option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
2760          option clear = ACNODEANGLE ;
2761          option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
2762          option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
2763  *       Clear the integer variable to prevent intra-pole circulating branch flows
2764          option clear = HVDCPOLEFLOW_INTEGER ;
2765  *       Risk/Reserve
2766          option clear = RESERVEBLOCK ;
2767          option clear = RISKOFFSET ;
2768  *       Mixed constraint
2769          option clear = MIXEDCONSTRAINTVARIABLE ;
2770          option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
2771  *       Reset levels
2772  *       Objective
2773          option clear = NETBENEFIT ;
2774  *       Network
2775          option clear = ACNODENETINJECTION ;
2776          option clear = ACBRANCHFLOW ;
2777          option clear = ACNODEANGLE ;
2778  *       Generation
2779          option clear = GENERATION ;
2780          option clear = GENERATIONBLOCK ;
2781  *       Purchase
2782          option clear = PURCHASE ;
2783          option clear = PURCHASEBLOCK ;
2784          option clear = PURCHASEILR ;
2785          option clear = PURCHASEILRBLOCK ;
2786  *       Reserve
2787          option clear = ISLANDRISK ;
2788          option clear = HVDCREC ;
2789          option clear = RISKOFFSET ;
2790          option clear = RESERVE ;
2791          option clear = RESERVEBLOCK ;
2792          option clear = MAXISLANDRISK ;
2793  *       Network
2794          option clear = HVDCLINKFLOW ;
2795          option clear = HVDCLINKLOSSES ;
2796          option clear = LAMBDA ;
2797          option clear = LAMBDAINTEGER ;
2798          option clear = ACBRANCHFLOWDIRECTED ;
2799          option clear = ACBRANCHLOSSESDIRECTED ;
2800          option clear = ACBRANCHFLOWBLOCKDIRECTED ;
2801          option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
2802          option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
2803          option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
2804  *       Clear the integer variable to prevent intra-pole circulating branch flows
2805          option clear = HVDCPOLEFLOW_INTEGER ;
2806  *       Mixed constraint
2807          option clear = MIXEDCONSTRAINTVARIABLE ;
2808          option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
2809  *       Violations
2810          option clear = TOTALPENALTYCOST ;
2811          option clear = DEFICITBUSGENERATION ;
2812          option clear = SURPLUSBUSGENERATION ;
2813          option clear = DEFICITRESERVE ;
2814          option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
2815          option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
2816          option clear = DEFICITRAMPRATE ;
2817          option clear = SURPLUSRAMPRATE ;
2818          option clear = DEFICITACnodeCONSTRAINT ;
2819          option clear = SURPLUSACnodeCONSTRAINT ;
2820          option clear = DEFICITBRANCHFLOW ;
2821          option clear = SURPLUSBRANCHFLOW ;
2822          option clear = DEFICITMNODECONSTRAINT ;
2823          option clear = SURPLUSMNODECONSTRAINT ;
2824          option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
2825          option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
2826          option clear = DEFICITGENERICCONSTRAINT ;
2827          option clear = SURPLUSGENERICCONSTRAINT ;
2828  *       Seperate CE and ECE deficit
2829          option clear = DEFICITRESERVE_CE ;
2830          option clear = DEFICITRESERVE_ECE ;
2831  *       Study parameters and sets
2832          option clear = currTP ;
2833  *       Offers
2834          option clear = offerNode ;
2835          option clear = generationStart ;
2836          option clear = rampRateUp ;
2837          option clear = rampRateDown ;
2838          option clear = reserveGenerationMaximum ;
2839          option clear = windOffer ;
2840          option clear = generationOfferMW ;
2841          option clear = generationOfferPrice ;
2842          option clear = validGenerationOfferBlock ;
2843  *       Clear the FKband
2844          option clear = FKband ;
2845  *       Clear the positive energy offer set
2846          option clear = positiveEnergyOffer ;
2847          option clear = reserveOfferProportion ;
2848          option clear = reserveOfferMaximum ;
2849          option clear = reserveOfferPrice ;
2850          option clear = validReserveOfferBlock ;
2851          option clear = offer ;
2852  *       Primary-secondary offer mapping
2853          option clear = primarySecondaryOffer ;
2854          option clear = hasSecondaryOffer ;
2855          option clear = hasPrimaryOffer ;
2856  *       Bid
2857          option clear = purchaseBidMW ;
2858          option clear = purchaseBidPrice ;
2859          option clear = validPurchaseBidBlock ;
2860          option clear = purchaseBidILRMW ;
2861          option clear = purchaseBidILRPrice ;
2862          option clear = validPurchaseBidILRBlock ;
2863          option clear = bidNode ;
2864          option clear = bid ;
2865  *       Demand
2866          option clear = nodeDemand ;
2867  *       Network
2868          option clear = ACbranchSendingBus ;
2869          option clear = ACbranchReceivingBus ;
2870          option clear = ACbranchSendingBus ;
2871          option clear = ACbranchReceivingBus ;
2872          option clear = HVDClinkSendingBus ;
2873          option clear = HVDClinkReceivingBus ;
2874          option clear = HVDClinkBus ;
2875          option clear = ACbranchCapacity ;
2876          option clear = HVDClinkCapacity ;
2877          option clear = ACbranchResistance ;
2878          option clear = ACbranchSusceptance ;
2879          option clear = ACbranchFixedLoss ;
2880          option clear = ACbranchLossBlocks ;
2881          option clear = HVDClinkResistance ;
2882          option clear = HVDClinkFixedLoss ;
2883          option clear = HVDClinkLossBlocks ;
2884          option clear = lossSegmentMW ;
2885          option clear = lossSegmentFactor ;
2886          option clear = validLossSegment ;
2887          option clear = closedBranch ;
2888          option clear = openBranch ;
2889          option clear = ACbranch ;
2890          option clear = HVDChalfPoles ;
2891          option clear = HVDCpoles ;
2892          option clear = HVDClink ;
2893          option clear = HVDCpoleDirection ;
2894          option clear = lossBranch ;
2895          option clear = branchBusDefn ;
2896          option clear = branchBusConnect ;
2897          option clear = branch ;
2898          option clear = nodeBus ;
2899          option clear = nodeIsland ;
2900          option clear = busIsland ;
2901          option clear = HVDCnode ;
2902          option clear = ACnode ;
2903          option clear = referenceNode ;
2904          option clear = bus ;
2905          option clear = node ;
2906          option clear = DCbus ;
2907          option clear = ACbus ;
2908          option clear = nodeBusAllocationFactor ;
2909          option clear = busElectricalIsland ;
2910  *       Clear the allow HVDC roundpower flag
2911          option clear = allowHVDCroundpower ;
2912  *       Risk/Reserves
2913          option clear = freeReserve ;
2914          option clear = islandRiskAdjustmentFactor ;
2915          option clear = HVDCpoleRampUp ;
2916          option clear = islandMinimumRisk ;
2917          option clear = reserveClassGenerationMaximum ;
2918          option clear = reserveMaximumFactor ;
2919          option clear = ILreserveType ;
2920          option clear = PLSRreserveType ;
2921          option clear = manualRisk ;
2922          option clear = HVDCrisk ;
2923          option clear = genRisk ;
2924          option clear = islandOffer ;
2925          option clear = islandBid ;
2926          option clear = islandRiskGenerator ;
2927          option clear = riskGenerator ;
2928  *       Define contingent and extended contingent events for CE and ECE risks
2929          option clear = contingentEvents ;
2930          option clear = extendedContingentEvent ;
2931  *       Clear the HVDC secondary risk data
2932          option clear = HVDCsecRisk ;
2933          option clear = HVDCsecRiskEnabled ;
2934          option clear = HVDCsecRiskSubtractor ;
2935          option clear = HVDCsecIslandMinimumRisk ;
2936  *       branch Constraints
2937          option clear = branchConstraint ;
2938          option clear = branchConstraintFactors ;
2939          option clear = branchConstraintSense ;
2940          option clear = branchConstraintLimit ;
2941  *       AC Node Constraints
2942          option clear = ACnodeConstraint ;
2943          option clear = ACnodeConstraintFactors ;
2944          option clear = ACnodeConstraintSense ;
2945          option clear = ACnodeConstraintLimit ;
2946  *       Market Node Constraints
2947          option clear = MnodeConstraint ;
2948          option clear = MnodeEnergyOfferConstraintFactors ;
2949          option clear = MnodeReserveOfferConstraintFactors ;
2950          option clear = MnodeEnergyBidConstraintFactors ;
2951          option clear = MnodeILReserveBidConstraintFactors ;
2952          option clear = MnodeConstraintSense ;
2953          option clear = MnodeConstraintLimit ;
2954  *       Mixed Constraints
2955          option clear = type1MixedConstraint ;
2956          option clear = type2MixedConstraint ;
2957          option clear = type1MixedConstraintCondition ;
2958          option clear = type1MixedConstraintSense ;
2959          option clear = type1MixedConstraintLimit1 ;
2960          option clear = type1MixedConstraintLimit2 ;
2961          option clear = type2MixedConstraintSense ;
2962          option clear = type2MixedConstraintLimit ;
2963  *       Generic Constraints
2964          option clear = genericConstraint ;
2965          option clear = genericEnergyOfferConstraintFactors ;
2966          option clear = genericReserveOfferConstraintFactors ;
2967          option clear = genericEnergyBidConstraintFactors ;
2968          option clear = genericILReserveBidConstraintFactors ;
2969          option clear = genericBranchConstraintFactors ;
2970          option clear = genericConstraintSense ;
2971          option clear = genericConstraintLimit ;
2972  *       Additional parameters
2973          option clear = generationMaximum ;
2974          option clear = rampTimeUp ;
2975          option clear = rampTimeDown ;
2976          option clear = rampTimeUp ;
2977          option clear = generationEndUp ;
2978          option clear = generationMinimum ;
2979          option clear = rampTimeDown ;
2980          option clear = generationEndDown ;
2981          option clear = ACbranchLossMW ;
2982          option clear = ACbranchLossFactor ;
2983          option clear = HVDCbreakPointMWFlow ;
2984          option clear = HVDCbreakPointMWLoss ;
2985          option clear = useMixedConstraintMIP ;
2986          option clear = circularBranchFlowExist ;
2987  *       Clear the pole circular branch flow flag
2988          option clear = poleCircularBranchFlowExist ;
2989          option clear = northHVDC ;
2990          option clear = southHVDC ;
2991          option clear = manualBranchSegmentMWFlow ;
2992          option clear = manualLossCalculation ;
2993          option clear = nonPhysicalLossExist ;
2994          option clear = useBranchFlowMIP ;
2995          option clear = modelSolved ;
2996          option clear = LPmodelSolved ;
2997          option clear = LPvalid ;
2998          option clear = branchFlowMIPInvoked ;
2999  *       Disconnected bus post-processing
3000          option clear = busGeneration ;
3001          option clear = busLoad ;
3002          option clear = busDisconnected ;
3003          option clear = busPrice ;
3004  *       Run logic
3005          option clear = skipResolve ;
3006   
3007   
3008  *       b) Initialise current trade period and model data for the current trade period
3009  *       Set the currTP start
3010  *       For sequential solve
3011          currTP(tp) $ { sequentialSolve and (ord(tp) eq iterationCount) } = yes $ i_studyTradePeriod(tp) ;
3012  *       For simultaneous solve
3013          currTP(tp) $ ( not (sequentialSolve) ) = yes $ i_studyTradePeriod(tp) ;
3014          iterationCount $ ( not (sequentialSolve) ) = numTradePeriods ;
3015   
3016  *       Initialise bus, node, offer, bid for the current trade period start
3017          bus(currTP,b) $ i_tradePeriodBus(currTP,b) = yes ;
3018   
3019          node(currTP,n) $ i_tradePeriodNode(currTP,n) = yes ;
3020   
3021  *       Offer initialisation - offer must be mapped to a node that is mapped to a bus
3022  *       that is not in electrical island = 0 when the i_useBusNetworkModel flag is set to true
3023  *       Pre-MSP case
3024          offer(currTP,o) $ { not ( i_useBusNetworkModel(currTP) ) and
3025                              sum[ (n,b) $ { i_tradePeriodOfferNode(currTP,o,n) and
3026                                             i_tradePeriodNodeBus(currTP,n,b)
3027                                           }, 1
3028                                 ]
3029                            } = yes ;
3030  *       Post-MSP case
3031          offer(currTP,o) $ { i_useBusNetworkModel(currTP) and
3032                              sum[ (n,b) $ { i_tradePeriodOfferNode(currTP,o,n) and
3033                                               i_tradePeriodNodeBus(currTP,n,b) and
3034                                               i_tradePeriodBusElectricalIsland(currTP,b)
3035                                             }, 1
3036                                 ]
3037                            } = yes ;
3038   
3039  *       Initialise Risk/Reserve data for the current trading period
3040          RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3041   
3042  *       Bid initialisation - bid must be mapped to a node that is mapped to a bus
3043  *       that is not in electrical island = 0 when the i_useBusNetworkModel flag is set to true
3044  *       Pre-MSP case
3045          bid(currTP,i_bid) $ { not (i_useBusNetworkModel(currTP) ) and
3046                                sum[ (n,b) $ { i_tradePeriodBidNode(currTP,i_bid,n) and
3047                                               i_tradePeriodNodeBus(currTP,n,b)
3048                                             }, 1
3049                                   ]
3050                              } = yes ;
3051  *       Post-MSP case
3052          bid(currTP,i_bid) $ { i_useBusNetworkModel(currTP) and
3053                                sum[ (n,b) $ { i_tradePeriodBidNode(currTP,i_bid,n) and
3054                                               i_tradePeriodNodeBus(currTP,n,b) and
3055                                               i_tradePeriodBusElectricalIsland(currTP,b)
3056                                             }, 1
3057                                     ]
3058                              } = yes ;
3059   
3060   
3061  *       Mapping bus, node, offer, bid and island start for the current trade period
3062          nodeBus(node,b) $ i_tradePeriodNodeBus(node,b) = yes ;
3063   
3064          busIsland(bus,ild) = i_tradePeriodBusIsland(bus,ild) ;
3065   
3066          offerNode(offer,n) $ i_tradePeriodOfferNode(offer,n) = yes ;
3067   
3068          bidNode(bid,n) $ i_tradePeriodBidNode(bid,n) = yes ;
3069   
3070          nodeIsland(currTP,n,ild) $ { node(currTP,n ) and
3071                                       sum[ b $ { bus(currTP,b) and
3072                                                  busIsland(currTP,b,ild) and
3073                                                  nodeBus(currTP,n,b)
3074                                                }, 1
3075                                          ]
3076                                     } = yes ;
3077   
3078          IslandRiskGenerator(currTP,ild,o) $ { offer(currTP,o) and
3079                                                RiskGenerator(currTP,o) and
3080                                                sum[ n $ { offerNode(currTP,o,n) and
3081                                                           nodeIsland(currTP,n,ild) }, 1 ]
3082                                              } = yes ;
3083   
3084          IslandOffer(currTP,ild,o) $ { offer(currTP,o) and
3085                                        sum[ n $ { offerNode(currTP,o,n) and
3086                                                   nodeIsland(currTP,n,ild) }, 1 ]
3087                                      } = yes ;
3088   
3089          IslandBid(currTP,ild,i_bid) $ { bid(currTP,i_bid) and
3090                                          sum[ n $ { bidNode(currTP,i_bid,n) and
3091                                                     nodeIsland(currTP,n,ild) },1 ]
3092                                        } = yes ;
3093   
3094  *       Set the primary-secondary offer combinations
3095          primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3096   
3097   
3098  *       Initialise offer parameters for the current trade period start
3099          generationStart(offer)          = sum[ i_offerParam $ ( ord(i_offerParam) = 1 )
3100                                               , i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3101   
3102          rampRateUp(offer)               = sum[ i_offerParam $ ( ord(i_offerParam) = 2 )
3103                                               , i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3104   
3105          rampRateDown(offer)             = sum[ i_offerParam $ ( ord(i_offerParam) = 3 )
3106                                               , i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3107   
3108          reserveGenerationMaximum(offer) = sum[ i_offerParam $ ( ord(i_offerParam) = 4 )
3109                                               , i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3110   
3111          windOffer(offer)                = sum[ i_offerParam $ ( ord(i_offerParam) = 5 )
3112                                               , i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3113   
3114          FKband(offer) = sum[ i_offerParam $ ( ord(i_offerParam) = 6 ), i_tradePeriodOfferParameter(offer,i_offerParam) ] ;
3115   
3116   
3117  *       Initialise energy offer data for the current trade period start
3118          generationOfferMW(offer,trdBlk)
3119              = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3120                   , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3121   
3122          generationOfferPrice(offer,trdBlk)
3123              = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3124                   , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3125   
3126  *       Valid generation offer blocks are defined as those with a positive block limit
3127          validGenerationOfferBlock(offer,trdBlk) $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3128   
3129  *       Define set of positive energy offers
3130          positiveEnergyOffer(offer) $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3131   
3132   
3133  *       Initialise reserve offer data for the current trade period start
3134          PLSRReserveType(i_reserveType) $ (ord(i_reserveType) = 1) = yes ;
3135   
3136          TWDRReserveType(i_reserveType) $ (ord(i_reserveType) = 2) = yes ;
3137   
3138          ILReserveType(i_reserveType)   $ (ord(i_reserveType) = 3) = yes ;
3139   
3140          reserveOfferProportion(offer,trdBlk,i_reserveClass) $ ( ord(i_reserveClass) = 1 )
3141              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3142                   , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3143   
3144          reserveOfferProportion(offer,trdBlk,i_reserveClass)$( ord(i_reserveClass) = 2 )
3145              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3146                   , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3147   
3148          reserveOfferMaximum(offer,trdBlk,i_reserveClass,PLSRReserveType) $ ( ord(i_reserveClass) = 1 )
3149              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3150                   , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) ] ;
3151   
3152          reserveOfferMaximum(offer,trdBlk,i_reserveClass,PLSRReserveType) $ ( ord(i_reserveClass) = 2)
3153              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3154                   , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) ] ;
3155   
3156          reserveOfferMaximum(offer,trdBlk,i_reserveClass,TWDRReserveType) $ ( ord(i_reserveClass) = 1 )
3157              = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3158                   , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt) ] ;
3159   
3160          reserveOfferMaximum(offer,trdBlk,i_reserveClass,TWDRReserveType) $ ( ord(i_reserveClass) = 2 )
3161              = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3162                   , i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt) ] ;
3163   
3164          reserveOfferMaximum(offer,trdBlk,i_reserveClass,ILReserveType) $ ( ord(i_reserveClass) = 1 )
3165              = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3166                   , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt) ] ;
3167   
3168          reserveOfferMaximum(offer,trdBlk,i_reserveClass,ILReserveType) $ ( ord(i_reserveClass) = 2 )
3169              = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3170                   , i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt) ] ;
3171   
3172          reserveOfferPrice(offer,trdBlk,i_reserveClass,PLSRReserveType) $ ( ord(i_reserveClass) = 1 )
3173              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3174                   , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) ] ;
3175   
3176          reserveOfferPrice(offer,trdBlk,i_reserveClass,PLSRReserveType) $ ( ord(i_reserveClass) = 2 )
3177              = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3178                   , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) ] ;
3179   
3180          reserveOfferPrice(offer,trdBlk,i_reserveClass,TWDRReserveType) $ ( ord(i_reserveClass) = 1 )
3181              = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3182                   , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt) ] ;
3183   
3184          reserveOfferPrice(offer,trdBlk,i_reserveClass,TWDRReserveType) $ ( ord(i_reserveClass) = 2 )
3185              = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3186                   , i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt) ] ;
3187   
3188          reserveOfferPrice(offer,trdBlk,i_reserveClass,ILReserveType) $ ( ord(i_reserveClass) = 1 )
3189              = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3190                   , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt) ] ;
3191   
3192          reserveOfferPrice(offer,trdBlk,i_reserveClass,ILReserveType) $ ( ord(i_reserveClass) = 2 )
3193              = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3194                   , i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt) ] ;
3195   
3196  *       Valid reserve offer block for each reserve class and reserve type are defined
3197  *       as those with a positive block limit
3198          validReserveOfferBlock(offer,trdBlk,i_reserveClass,i_reserveType)
3199              $ ( reserveOfferMaximum(offer,trdBlk,i_reserveClass,i_reserveType) > 0 ) = yes ;
3200   
3201   
3202  *       Initialise demand/bid data for the current trade period start
3203          nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3204   
3205          purchaseBidMW(bid,trdBlk) = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3206                                         , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3207   
3208          purchaseBidPrice(bid,trdBlk) = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3209                                            , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3210   
3211  *       Valid purchaser bid blocks are defined as those with with a positive block limit before DSBF
3212          validPurchaseBidBlock(bid,trdBlk) $ { ( not useDSBFDemandBidModel ) and
3213                                                ( purchaseBidMW(bid,trdBlk) > 0 ) } = yes ;
3214   
3215  *       Valid purchaser bid blocks are defined as those with a non-zero block limit since both positive
3216  *       and negative limits are allowed with changes to the demand bids following DSBF implementation
3217          validPurchaseBidBlock(bid,trdBlk) $ { useDSBFDemandBidModel and
3218                                                ( purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3219   
3220          purchaseBidILRMW(bid,trdBlk,i_reserveClass) $ ( ord(i_reserveClass) = 1 )
3221              = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3222                   , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt) ] ;
3223   
3224          purchaseBidILRPrice(bid,trdBlk,i_reserveClass) $ ( ord(i_reserveClass) = 1 )
3225              = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3226                   , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt) ] ;
3227   
3228          purchaseBidILRMW(bid,trdBlk,i_reserveClass) $ ( ord(i_reserveClass) = 2 )
3229              = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 1 )
3230                   , i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt) ] ;
3231   
3232          purchaseBidILRPrice(bid,trdBlk,i_reserveClass) $ ( ord(i_reserveClass) = 2 )
3233              = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3234                   , i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt) ] ;
3235   
3236  *       Valid purchaser ILR blocks are defined as those with with a positive block limit
3237          validPurchaseBidILRBlock(bid,trdBlk,i_reserveClass)
3238              $ ( purchaseBidILRMW(bid,trdBlk,i_reserveClass) > 0 ) = yes ;
3239   
3240   
3241  *       Initialise network sets for the current trade period start
3242          HVDCnode(node) $ i_tradePeriodHVDCnode(node) = yes ;
3243   
3244          ACnode(node) $ ( not HVDCnode(node)) = yes ;
3245   
3246          referenceNode(node) $ i_tradePeriodReferenceNode(node) = yes ;
3247   
3248          DCbus(currTP,b) $ sum[ nodeBus(HVDCnode(currTP,n),b), 1 ] = yes ;
3249   
3250          ACbus(currTP,b) $ ( not DCbus(currTP,b) ) = yes ;
3251   
3252  *       Branch is defined if there is a defined terminal bus, it is defined for the trade period,
3253  *       it has a non-zero capacity and is closed for that trade period
3254          branch(currTP,br) $ { sum[ (frB,toB) $ { bus(currTP,frB) and
3255                                                   bus(currTP,toB) and
3256                                                   i_tradePeriodBranchDefn(currTP,br,frB,toB)
3257                                                 }, 1 ] and
3258                                i_tradePeriodBranchCapacity(currTP,br) and
3259                                ( not i_tradePeriodBranchOpenStatus(currTP,br) )
3260                              } = yes ;
3261   
3262          branchBusDefn(branch,frB,toB) $ i_tradePeriodBranchDefn(branch,frB,toB) = yes ;
3263   
3264          branchBusConnect(branch,b) $ sum[ b1 $ { branchBusDefn(branch,b,b1) or
3265                                                   branchBusDefn(branch,b1,b) }, 1 ] = yes ;
3266   
3267  *       HVDC link and AC branch definition
3268          HVDClink(branch) $ i_tradePeriodHVDCBranch(branch) = yes ;
3269   
3270          HVDCpoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3271   
3272          HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3273   
3274          ACbranch(branch) $ ( not HVDClink(branch) ) = yes ;
3275   
3276  *       Determine sending and receiving bus sets
3277          loop((frB,toB),
3278              ACbranchSendingBus(ACbranch,frB,i_flowDirection) $ { branchBusDefn(ACbranch,frB,toB) and
3279                                                                   (ord(i_flowDirection) = 1) } = yes ;
3280   
3281              ACbranchReceivingBus(ACbranch,toB,i_flowDirection) $ { branchBusDefn(ACbranch,frB,toB) and
3282                                                                     (ord(i_flowDirection) = 1) } = yes ;
3283   
3284              ACbranchSendingBus(ACbranch,toB,i_flowDirection) $ { branchBusDefn(ACbranch,frB,toB) and
3285                                                                   (ord(i_flowDirection) = 2) } = yes ;
3286   
3287              ACbranchReceivingBus(ACbranch,frB,i_flowDirection) $ { branchBusDefn(ACbranch,frB,toB) and
3288                                                                     (ord(i_flowDirection) = 2) } = yes ;
3289          );
3290   
3291          HVDClinkSendingBus(HVDClink,frB) $ sum[ branchBusDefn(HVDClink,frB,toB),1 ] = yes ;
3292   
3293          HVDClinkReceivingBus(HVDClink,toB) $ sum[ branchBusDefn(HVDClink,frB,toB),1 ] = yes ;
3294   
3295          HVDClinkBus(HVDClink,b) $ { HVDClinkSendingBus(HVDClink,b) or
3296                                      HVDClinkReceivingBus(HVDClink,b) } = yes ;
3297   
3298  *       Determine the HVDC inter-island pole in the northward and southward direction
3299          HVDCpoleDirection(currTP,br,i_flowDirection) $ { (ord(i_flowDirection) = 1) and
3300                                                           HVDClink(currTP,br) and
3301                                                           sum[ (ild,NodeBus(currTP,n,b)) $ { (ord(ild) = 2) and
3302                                                                                              nodeIsland(currTP,n,ild) and
3303                                                                                              HVDClinkSendingBus(currTP,br,b)
3304                                                                                            }, 1
3305                                                              ]
3306                                                         } = yes ;
3307   
3308          HVDCpoleDirection(currTP,br,i_flowDirection) $ { (ord(i_flowDirection) = 1) and
3309                                                           HVDClink(currTP,br) and
3310                                                           sum[ (ild,NodeBus(currTP,n,b)) $ { (ord(ild) = 2) and
3311                                                                                               nodeIsland(currTP,n,ild) and
3312                                                                                               HVDClinkReceivingBus(currTP,br,b)
3313                                                                                            }, 1
3314                                                              ]
3315                                                         } = no ;
3316   
3317          HVDCpoleDirection(currTP,br,i_flowDirection) $ { (ord(i_flowDirection) = 2) and
3318                                                           HVDClink(currTP,br) and
3319                                                           sum[ (ild,NodeBus(currTP,n,b)) $ { (ord(ild) = 1) and
3320                                                                                              nodeIsland(currTP,n,ild) and
3321                                                                                              HVDClinkSendingBus(currTP,br,b)
3322                                                                                            }, 1
3323                                                              ]
3324                                                         } = yes ;
3325   
3326          HVDCpoleDirection(currTP,br,i_flowDirection) $ { (ord(i_flowDirection) = 2) and
3327                                                           HVDClink(currTP,br) and
3328                                                           sum[ (ild,NodeBus(currTP,n,b)) $ { (ord(ild) = 1) and
3329                                                                                              nodeIsland(currTP,n,ild) and
3330                                                                                              HVDClinkReceivingBus(currTP,br,b)
3331                                                                                            }, 1
3332                                                              ]
3333                                                         } = no ;
3334   
3335  *       Mapping HVDC branch to pole to account for name changes to Pole 3
3336          HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3337          HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3338          HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3339          HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3340          HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3341          HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3342   
3343  *       Determine branch open and closed status. Open status is provided but this
3344  *       is converted to a closed status since this is more compact to use in the formulation
3345          ClosedBranch(branch) $ (not i_tradePeriodBranchOpenStatus(branch)) = yes ;
3346          OpenBranch(branch) $ (not ClosedBranch(branch)) = yes ;
3347   
3348   
3349  *       Initialise network data for the current trade period start
3350   
3351  *       Node-bus allocation factor
3352          nodeBusAllocationFactor(currTP,n,b) $ { node(currTP,n) and bus(currTP,b) }
3353            = i_tradePeriodNodeBusAllocationFactor(currTP,n,b) ;
3354   
3355  *       Bus live island status
3356          busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3357   
3358  *       Flag to allow roundpower on the HVDC link
3359          allowHVDCroundpower(currTP) = i_tradePeriodAllowHVDCroundpower(currTP) ;
3360   
3361  *       Allocate the input branch parameters to the defined model parameters
3362          ACbranchCapacity(ACbranch) = i_tradePeriodBranchCapacity(ACbranch) ;
3363          HVDClinkCapacity(HVDClink) = i_tradePeriodBranchCapacity(HVDClink) ;
3364   
3365          ACbranchResistance(ACbranch) = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3366                                            , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ] ;
3367   
3368  *       Convert susceptance from -Bpu to B% for data post-MSP
3369          ACbranchSusceptance(ACbranch(currTP,br)) $ (not i_useBusNetworkModel(currTP))
3370              = 100 * sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3371                         , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ] ;
3372   
3373          ACbranchSusceptance(ACbranch(currTP,br)) $ i_useBusNetworkModel(currTP)
3374              = -100 * sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3375                          , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ] ;
3376   
3377          ACbranchLossBlocks(ACbranch) = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3378                                            , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ] ;
3379   
3380  *       Ensure fixed losses for no loss branches are not included
3381          ACbranchFixedLoss(ACbranch) = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3382                                           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3383                                           ] $ (ACbranchLossBlocks(ACbranch) > 1) ;
3384   
3385          HVDClinkResistance(HVDClink) = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3386                                            , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3387   
3388          HVDClinkFixedLoss(HVDClink) = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3389                                           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3390   
3391          HVDClinkLossBlocks(HVDClink) = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3392                                            , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3393   
3394  *       Set resistance and fixed loss to zero if do not want to use the loss model
3395          ACbranchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3396          ACbranchFixedLoss(ACbranch) $ (not useAClossModel) = 0 ;
3397   
3398          HVDClinkResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3399          HVDClinkFixedLoss(HVDClink) $ (not useHVDClossModel) = 0 ;
3400   
3401   
3402  *       Initialise loss tranches data for the current trade period start
3403  *       The loss factor coefficients assume that the branch capacity is in MW and the resistance is in p.u.
3404   
3405  *       Branches (AC and HVDC) with zeor or 1 loss segment - External loss model not used
3406          LossSegmentMW(ClosedBranch(ACbranch),los) $ { (not useExternalLossModel) and
3407                                                        (ACbranchLossBlocks(ACbranch) <= 1) and
3408                                                        (ord(los) = 1)
3409                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3410                                                             , i_noLossBranch(los,i_lossParameter) ] ;
3411   
3412          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { (not useExternalLossModel) and
3413                                                            (ACbranchLossBlocks(ACbranch) <= 1) and
3414                                                            (ord(los) = 1)
3415                                                          } = sum[ i_lossParameter $ (ord(i_lossParameter) = 2)
3416                                                                 , i_noLossBranch(los,i_lossParameter)
3417                                                                 * ACbranchResistance(ACbranch)
3418                                                                 * ACbranchCapacity(ACbranch)
3419                                                                 ] ;
3420   
3421          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (not useExternalLossModel) and
3422                                                        (HVDClinkLossBlocks(HVDClink) <= 1) and
3423                                                        (ord(los) = 1)
3424                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3425                                                             , i_noLossBranch(los,i_lossParameter) ] ;
3426   
3427          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (not useExternalLossModel) and
3428                                                            (HVDClinkLossBlocks(HVDClink) <= 1) and
3429                                                            (ord(los) = 1)
3430                                                          } = sum[ i_lossParameter $ (ord(i_lossParameter) = 2)
3431                                                                 , i_noLossBranch(los,i_lossParameter)
3432                                                                 * HVDClinkResistance(HVDClink)
3433                                                                 * HVDClinkCapacity(HVDClink)
3434                                                                 ] ;
3435   
3436  *       AC loss branches with more than one loss segment - External loss model not used
3437          LossSegmentMW(ClosedBranch(ACbranch),los) $ { (not useExternalLossModel) and
3438                                                        (ACbranchLossBlocks(ACbranch) > 1) and
3439                                                        (ord(los) < ACbranchLossBlocks(ACbranch))
3440                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3441                                                             , i_AClossBranch(los,i_lossParameter)
3442                                                             * ACbranchCapacity(ACbranch)
3443                                                             ] ;
3444   
3445          LossSegmentMW(ClosedBranch(ACbranch),los) $ { (not useExternalLossModel) and
3446                                                        (ACbranchLossBlocks(ACbranch) > 1) and
3447                                                        (ord(los) = ACbranchLossBlocks(ACbranch))
3448                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3449                                                             , i_AClossBranch(los,i_lossParameter) ] ;
3450   
3451          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { (not useExternalLossModel) and
3452                                                            (ACbranchLossBlocks(ACbranch) > 1)
3453                                                          } = sum[ i_lossParameter $ (ord(i_lossParameter) = 2)
3454                                                                 , i_AClossBranch(los,i_lossParameter)
3455                                                                 * ACbranchResistance(ACbranch)
3456                                                                 * ACbranchCapacity(ACbranch)
3457                                                                 ] ;
3458   
3459  *       HVDC loss branches with more than one loss segment - External loss model not used
3460          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (not useExternalLossModel) and
3461                                                        (HVDClinkLossBlocks(HVDClink) > 1) and
3462                                                        (ord(los) < HVDClinkLossBlocks(HVDClink))
3463                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3464                                                             , i_HVDClossBranch(los,i_lossParameter)
3465                                                             * HVDClinkCapacity(HVDClink)
3466                                                             ] ;
3467   
3468          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (not useExternalLossModel) and
3469                                                        (HVDClinkLossBlocks(HVDClink) > 1) and
3470                                                        (ord(los) = HVDClinkLossBlocks(HVDClink))
3471                                                      } = sum[ i_lossParameter $ (ord(i_lossParameter) = 1)
3472                                                             , i_HVDClossBranch(los,i_lossParameter) ] ;
3473   
3474          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (not useExternalLossModel) and
3475                                                            (HVDClinkLossBlocks(HVDClink) > 1)
3476                                                          } = sum[ i_lossParameter $ (ord(i_lossParameter) = 2)
3477                                                                 , i_HVDClossBranch(los,i_lossParameter)
3478                                                                 * HVDClinkResistance(HVDClink)
3479                                                                 * HVDClinkCapacity(HVDClink)
3480                                                                 ] ;
3481   
3482   
3483  *       Use the external loss model as provided by Transpower for branches with 0 loss blocks
3484   
3485          LossSegmentMW(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3486                                                        (ACbranchLossBlocks(ACbranch) = 0) and
3487                                                        (ord(los) = 1)
3488                                                      } = maxFlowSegment ;
3489   
3490          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3491                                                            (ACbranchLossBlocks(ACbranch) = 0) and
3492                                                            (ord(los) = 1)
3493                                                          } = 0 ;
3494   
3495          LossSegmentMW(ClosedBranch(HVDClink),los) $ { useExternalLossModel and
3496                                                        (HVDClinkLossBlocks(HVDClink) = 0) and
3497                                                        (ord(los) = 1)
3498                                                      } = maxFlowSegment ;
3499   
3500          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { useExternalLossModel and
3501                                                            (HVDClinkLossBlocks(HVDClink) = 0) and
3502                                                            (ord(los) = 1)
3503                                                          } = 0 ;
3504   
3505   
3506  *       Use the external loss model as provided by Transpower for branches with 1 loss blocks
3507          LossSegmentMW(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3508                                                        (ACbranchLossBlocks(ACbranch) = 1) and
3509                                                        (ord(los) = 1)
3510                                                      } = maxFlowSegment ;
3511   
3512          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3513                                                            (ACbranchLossBlocks(ACbranch) = 1) and
3514                                                            (ord(los) = 1)
3515                                                          } = ACbranchResistance(ACbranch)
3516                                                            * ACbranchCapacity(ACbranch) ;
3517   
3518          LossSegmentMW(ClosedBranch(HVDClink),los) $ { useExternalLossModel and
3519                                                        (HVDClinkLossBlocks(HVDClink) = 1) and
3520                                                        (ord(los) = 1)
3521                                                      } = maxFlowSegment ;
3522   
3523          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { useExternalLossModel and
3524                                                            (HVDClinkLossBlocks(HVDClink) = 1) and
3525                                                            (ord(los) = 1)
3526                                                          } = HVDClinkResistance(HVDClink)
3527                                                            * HVDClinkCapacity(HVDClink) ;
3528   
3529   
3530  *       Use the external loss model as provided by Transpower for branches with 3 loss blocks
3531  *       Segment 1
3532          LossSegmentMW(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3533                                                        (ACbranchLossBlocks(ACbranch) = 3) and
3534                                                        (ord(los) = 1)
3535                                                      } = ACbranchCapacity(ACbranch)
3536                                                        * lossCoeff_A ;
3537   
3538          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3539                                                            (ACbranchLossBlocks(ACbranch) = 3) and
3540                                                            (ord(los) = 1)
3541                                                          } = 0.01
3542                                                            * ACbranchResistance(ACbranch)
3543                                                            * ACbranchCapacity(ACbranch)
3544                                                            * 0.75
3545                                                            * lossCoeff_A ;
3546  *       Segment 2
3547          LossSegmentMW(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3548                                                        (ACbranchLossBlocks(ACbranch) = 3) and
3549                                                        (ord(los) = 2)
3550                                                      } = ACbranchCapacity(ACbranch)
3551                                                        * (1-lossCoeff_A) ;
3552   
3553          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3554                                                            (ACbranchLossBlocks(ACbranch) = 3) and
3555                                                            (ord(los) = 2)
3556                                                          } = 0.01
3557                                                            * ACbranchResistance(ACbranch)
3558                                                            * ACbranchCapacity(ACbranch) ;
3559  *       Segment 3
3560          LossSegmentMW(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3561                                                        (ACbranchLossBlocks(ACbranch) = 3) and
3562                                                        (ord(los) = 3)
3563                                                      } = maxFlowSegment ;
3564   
3565          LossSegmentFactor(ClosedBranch(ACbranch),los) $ { useExternalLossModel and
3566                                                            (ACbranchLossBlocks(ACbranch) = 3) and
3567                                                            (ord(los) = 3)
3568                                                          } = 0.01
3569                                                            * ACbranchResistance(ACbranch)
3570                                                            * ACbranchCapacity(ACbranch)
3571                                                            * (2 - (0.75*lossCoeff_A)) ;
3572   
3573  *       Use the external loss model as provided by Transpower for branches with 6 loss blocks
3574  *       Segment 1
3575          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3576                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3577                                                        (ord(los) = 1)
3578                                                      } = HVDClinkCapacity(HVDClink)
3579                                                        * lossCoeff_C ;
3580   
3581          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3582                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3583                                                            (ord(los) = 1)
3584                                                          } = 0.01
3585                                                            * HVDClinkResistance(HVDClink)
3586                                                            * HVDClinkCapacity(HVDClink)
3587                                                            * 0.75
3588                                                            * lossCoeff_C ;
3589  *       Segment 2
3590          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3591                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3592                                                        (ord(los) = 2)
3593                                                      } = HVDClinkCapacity(HVDClink)
3594                                                        * lossCoeff_D ;
3595   
3596          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3597                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3598                                                            (ord(los) = 2)
3599                                                          } = 0.01
3600                                                            * HVDClinkResistance(HVDClink)
3601                                                            * HVDClinkCapacity(HVDClink)
3602                                                            * lossCoeff_E ;
3603  *       Segment 3
3604          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3605                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3606                                                        (ord(los) = 3)
3607                                                      } = HVDClinkCapacity(HVDClink) * 0.5 ;
3608   
3609          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3610                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3611                                                            (ord(los) = 3)
3612                                                          } = 0.01
3613                                                            * HVDClinkResistance(HVDClink)
3614                                                            * HVDClinkCapacity(HVDClink)
3615                                                            * lossCoeff_F ;
3616  *       Segment 4
3617          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3618                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3619                                                        (ord(los) = 4)
3620                                                      } = HVDClinkCapacity(HVDClink)
3621                                                        * (1 - lossCoeff_D) ;
3622   
3623          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3624                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3625                                                            (ord(los) = 4)
3626                                                          } = 0.01
3627                                                            * HVDClinkResistance(HVDClink)
3628                                                            * HVDClinkCapacity(HVDClink)
3629                                                            * (2 - lossCoeff_F) ;
3630  *       Segment 5
3631          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3632                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3633                                                        (ord(los) = 5)
3634                                                      } = HVDClinkCapacity(HVDClink)
3635                                                        * (1 - lossCoeff_C) ;
3636   
3637          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3638                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3639                                                            (ord(los) = 5)
3640                                                          } = 0.01
3641                                                            * HVDClinkResistance(HVDClink)
3642                                                            * HVDClinkCapacity(HVDClink)
3643                                                            * (2 - lossCoeff_E) ;
3644  *       Segment 6
3645          LossSegmentMW(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3646                                                        (HVDClinkLossBlocks(HVDClink) = 6) and
3647                                                        (ord(los) = 6)
3648                                                      } = maxFlowSegment ;
3649   
3650          LossSegmentFactor(ClosedBranch(HVDClink),los) $ { (useExternalLossModel) and
3651                                                            (HVDClinkLossBlocks(HVDClink) = 6) and
3652                                                            (ord(los) = 6)
3653                                                          } = 0.01
3654                                                            * HVDClinkResistance(HVDClink)
3655                                                            * HVDClinkCapacity(HVDClink)
3656                                                            * (2 - (0.75*lossCoeff_C)) ;
3657   
3658  *       Valid loss segment for a branch is defined as a loss segment that has a non-zero LossSegmentMW or a non-zero LossSegmentFactor
3659  *       Every branch has at least one loss segment block
3660          validLossSegment(branch,los) $ (ord(los) = 1) = yes ;
3661   
3662          validLossSegment(branch,los) $ { (ord(los) > 1) and
3663                                           (LossSegmentMW(branch,los) + LossSegmentFactor(branch,los))
3664                                         } = yes ;
3665   
3666  *       HVDC loss model requires at least two loss segments and an additional loss block due to cumulative loss formulation
3667          validLossSegment(HVDClink,los) $ { (HVDClinkLossBlocks(HVDClink) <= 1) and
3668                                             (ord(los) = 2) } = yes ;
3669   
3670          validLossSegment(HVDClink,los) $ { (HVDClinkLossBlocks(HVDClink) > 1) and
3671                                             (ord(los) = (HVDClinkLossBlocks(HVDClink) + 1)) and
3672                                             (sum[ los1, LossSegmentMW(HVDClink,los1)
3673                                                       + LossSegmentFactor(HVDClink,los1) ] > 0)
3674                                           } = yes ;
3675   
3676  *       branches that have non-zero loss factors
3677          LossBranch(branch) $ sum[ los, LossSegmentFactor(branch,los) ] = yes ;
3678   
3679   
3680  *       Create branch loss segments
3681          ACbranchLossMW(ACbranch,los) $ { validLossSegment(ACbranch,los) and
3682                                           (ord(los) = 1)
3683                                         } = LossSegmentMW(ACbranch,los) ;
3684   
3685          ACbranchLossMW(ACbranch,los) $ { validLossSegment(ACbranch,los) and
3686                                           (ord(los) > 1)
3687                                         } = LossSegmentMW(ACbranch,los)
3688                                           - LossSegmentMW(ACbranch,los-1) ;
3689   
3690          ACbranchLossFactor(ACbranch,los) $ validLossSegment(ACbranch,los) = LossSegmentFactor(ACbranch,los) ;
3691   
3692  *       Let the first point on the HVDCBreakPointMWFlow and HVDCBreakPointMWLoss be 0
3693  *       This allows zero losses and zero flow on the HVDC links otherwise model could be infeasible
3694          HVDCBreakPointMWFlow(HVDClink,los) $ (ord(los) = 1) = 0 ;
3695          HVDCBreakPointMWLoss(HVDClink,los) $ (ord(los) = 1) = 0 ;
3696   
3697          HVDCBreakPointMWFlow(HVDClink,los) $ { validLossSegment(HVDClink,los) and
3698                                                 (ord(los) > 1)
3699                                               } = LossSegmentMW(HVDClink,los-1) ;
3700   
3701          HVDCBreakPointMWLoss(HVDClink,los) $ { validLossSegment(HVDClink,los) and
3702                                                 (ord(los) = 2)
3703                                               } =  LossSegmentMW(HVDClink,los-1)
3704                                                  * LossSegmentFactor(HVDClink,los-1)  ;
3705   
3706          loop( (HVDClink(branch),los) $ (ord(los) > 2),
3707              HVDCBreakPointMWLoss(branch,los) $ validLossSegment(branch,los)
3708                  = LossSegmentFactor(branch,los-1)
3709                  * [ LossSegmentMW(branch,los-1) - LossSegmentMW(branch,los-2) ]
3710                  + HVDCBreakPointMWLoss(branch,los-1) ;
3711          ) ;
3712   
3713   
3714  *       Initialise risk/reserve data for the current trade period start
3715   
3716  *       If the i_useExtendedRiskClass flag is set, update GenRisk and ManualRisk mapping to the RiskClass set
3717  *       since it now includes additional ECE risk classes associated with GenRisk and ManualRisk
3718          GenRisk(i_riskClass) $ { (not i_useExtendedRiskClass) and
3719                                   (ord(i_riskClass) = 1)
3720                                 } = yes ;
3721   
3722          GenRisk(i_riskClass) $ { i_useExtendedRiskClass and
3723                                   ( (ord(i_riskClass) = 1) or
3724                                     (ord(i_riskClass) = 5) )
3725                                 } = yes ;
3726   
3727          ManualRisk(i_riskClass) $ { (not i_useExtendedRiskClass) and
3728                                      (ord(i_riskClass) = 4)
3729                                    } = yes ;
3730   
3731          ManualRisk(i_riskClass) $ { i_useExtendedRiskClass and
3732                                      ( (ord(i_riskClass) = 4) or
3733                                        (ord(i_riskClass) = 6) )
3734                                    } = yes ;
3735   
3736          HVDCrisk(i_riskClass) $ { (ord(i_riskClass) = 2) or
3737                                    (ord(i_riskClass) = 3)
3738                                  } = yes ;
3739   
3740  *       Set the HVDCsecRisk class
3741          HVDCsecRisk(i_riskClass) $ (not i_useExtendedRiskClass) = no ;
3742   
3743          HVDCsecRisk(i_riskClass) $ { i_useExtendedRiskClass and
3744                                       ( (ord(i_riskClass) = 7) or
3745                                         (ord(i_riskClass) = 8) )
3746                                     } = yes ;
3747   
3748  *       Define the CE and ECE risk class set to support the different CE and ECE CVP
3749  *       If the i_useExtendedRiskClass flag is set, update the extended contingency event
3750  *       defintion to include the additional ECE risks included into the i_riskClass set
3751          ExtendedContingentEvent(i_riskClass) $ { (not i_useExtendedRiskClass) and
3752                                                   (ord(i_riskClass) = 3)
3753                                                 } = yes ;
3754   
3755          ExtendedContingentEvent(i_riskClass) $ { i_useExtendedRiskClass and
3756                                                   ( (ord(i_riskClass) = 3) or
3757                                                     (ord(i_riskClass) = 5) or
3758                                                     (ord(i_riskClass) = 6) or
3759                                                     (ord(i_riskClass) = 8)
3760                                                   )
3761                                                 } = yes ;
3762   
3763          ContingentEvents(i_riskClass) $ { (not i_useExtendedRiskClass) and
3764                                            ( (ord(i_riskClass) = 1) or
3765                                              (ord(i_riskClass) = 2) or
3766                                              (ord(i_riskClass) = 4)
3767                                            )
3768                                          } = yes ;
3769   
3770          ContingentEvents(i_riskClass) $ { i_useExtendedRiskClass and
3771                                            ( (ord(i_riskClass) = 1) or
3772                                              (ord(i_riskClass) = 2) or
3773                                              (ord(i_riskClass) = 4) or
3774                                              (ord(i_riskClass) = 7)
3775                                            )
3776                                          } = yes ;
3777   
3778          FreeReserve(currTP,ild,i_reserveClass,i_riskClass)
3779              = sum[ i_riskParameter $ (ord(i_riskParameter) = 1)
3780                   , i_tradePeriodRiskParameter(currTP,ild,i_reserveClass,i_riskClass,i_riskParameter) ] ;
3781   
3782          IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,i_riskClass)
3783              = sum[ i_riskParameter $ (ord(i_riskParameter) = 2)
3784                   , i_tradePeriodRiskParameter(currTP,ild,i_reserveClass,i_riskClass,i_riskParameter) ] ;
3785   
3786  *       Zero the island risk adjustment factor when useReserveModel flag is set to false
3787          IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,i_riskClass) $ (not useReserveModel) = 0 ;
3788   
3789          HVDCpoleRampUp(currTP,ild,i_reserveClass,i_riskClass)
3790              = sum[ i_riskParameter $ (ord(i_riskParameter) = 3)
3791                   , i_tradePeriodRiskParameter(currTP,ild,i_reserveClass,i_riskClass,i_riskParameter) ] ;
3792   
3793  *       Index IslandMinimumRisk to cater for CE and ECE minimum risk
3794          IslandMinimumRisk(currTP,ild,i_reserveClass,i_riskClass) $ (ord(i_riskClass) = 4)
3795              = i_tradePeriodManualRisk(currTP,ild,i_reserveClass) ;
3796   
3797          IslandMinimumRisk(currTP,ild,i_reserveClass,i_riskClass) $ (ord(i_riskClass) = 6)
3798              = i_tradePeriodManualRisk_ECE(currTP,ild,i_reserveClass) ;
3799   
3800  *       HVDC secondary risk parameters
3801          HVDCsecRiskEnabled(currTP,ild,i_riskClass) = i_tradePeriodHVDCsecRiskEnabled(currTP,ild,i_riskClass) ;
3802   
3803          HVDCsecRiskSubtractor(currTP,ild) = i_tradePeriodHVDCsecRiskSubtractor(currTP,ild) ;
3804   
3805  *       Minimum risks for the HVDC secondary risk are the same as the island minimum risk
3806          HVDCsecIslandMinimumRisk(currTP,ild,i_reserveClass,i_riskClass) $ (ord(i_riskClass) = 7)
3807              = i_tradePeriodManualRisk(currTP,ild,i_reserveClass) ;
3808   
3809          HVDCsecIslandMinimumRisk(currTP,ild,i_reserveClass,i_riskClass) $ (ord(i_riskClass) = 8)
3810              = i_tradePeriodManualRisk_ECE(currTP,ild,i_reserveClass) ;
3811   
3812  *       Calculation of reserve maximum factor - 5.2.1.1.
3813          reserveClassGenerationMaximum(offer,i_reserveClass) = ReserveGenerationMaximum(offer) ;
3814   
3815          reserveClassGenerationMaximum(offer,i_reserveClass)
3816              $ i_tradePeriodReserveClassGenerationMaximum(offer,i_reserveClass)
3817                  = i_tradePeriodReserveClassGenerationMaximum(offer,i_reserveClass) ;
3818   
3819          ReserveMaximumFactor(offer,i_reserveClass) = 1 ;
3820          ReserveMaximumFactor(offer,i_reserveClass)
3821              $ (ReserveClassGenerationMaximum(offer,i_reserveClass)>0)
3822                  = (ReserveGenerationMaximum(offer) / reserveClassGenerationMaximum(offer,i_reserveClass)) ;
3823   
3824   
3825  *       Initialise constraint data for the current trade period start
3826   
3827  *       Initialise branch constraint data for the current trading period
3828          branchConstraint(currTP,brCstr) $ sum[ br $ { branch(currTP,br) and
3829                                                        i_tradePeriodBranchConstraintFactors(currTP,brCstr,br)
3830                                                      }, 1
3831                                               ] = yes ;
3832   
3833          branchConstraintFactors(branchConstraint,br) = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
3834   
3835          branchConstraintSense(branchConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 1)
3836                                                       , i_tradePeriodBranchConstraintRHS(branchConstraint,i_ConstraintRHS) ] ;
3837   
3838          branchConstraintLimit(branchConstraint) = sum[ i_ConstraintRHS$(ord(i_ConstraintRHS) = 2)
3839                                                       , i_tradePeriodBranchConstraintRHS(branchConstraint,i_ConstraintRHS) ] ;
3840   
3841  *       Initialise AC node constraint data for the current trading period
3842          ACnodeConstraint(currTP,ACnodeCstr) $ sum[ n $ { ACnode(currTP,n) and
3843                                                                   i_tradePeriodACnodeConstraintFactors(currTP,ACnodeCstr,n)
3844                                                                 }, 1
3845                                                           ] = yes ;
3846   
3847          ACnodeConstraintFactors(ACnodeConstraint,n) = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
3848   
3849          ACnodeConstraintSense(ACnodeConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 1)
3850                                                       , i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,i_ConstraintRHS) ] ;
3851   
3852          ACnodeConstraintLimit(ACnodeConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 2)
3853                                                       , i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,i_ConstraintRHS) ] ;
3854   
3855  *       Initialise market node constraint data for the current trading period
3856          MnodeConstraint(currTP,MnodeCstr)
3857              $ { sum[ (o,i_reserveType,i_reserveClass)
3858                       $ { offer(currTP,o) and
3859                           ( i_tradePeriodMnodeEnergyOfferConstraintFactors(currTP,MnodeCstr,o) or
3860                             i_tradePeriodMnodeReserveOfferConstraintFactors(currTP,MnodeCstr,o,i_reserveClass,i_reserveType)
3861                           )
3862                         }, 1
3863                     ]
3864                  or
3865                  sum[ (i_bid,i_reserveClass)
3866                       $ { bid(currTP,i_bid) and
3867                           ( i_tradePeriodMnodeEnergyBidConstraintFactors(currTP,MnodeCstr,i_bid) or
3868                             i_tradePeriodMnodeILReserveBidConstraintFactors(currTP,MnodeCstr,i_bid,i_reserveClass)
3869                           )
3870                         }, 1
3871                     ]
3872                } = yes ;
3873   
3874          MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
3875              = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
3876   
3877          MnodeReserveOfferConstraintFactors(MnodeConstraint,o,i_reserveClass,i_reserveType)
3878              = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,i_reserveClass,i_reserveType) ;
3879   
3880          MnodeEnergyBidConstraintFactors(MnodeConstraint,i_bid)
3881              = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,i_bid) ;
3882   
3883          MnodeILReserveBidConstraintFactors(MnodeConstraint,i_bid,i_reserveClass)
3884              = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,i_bid,i_reserveClass) ;
3885   
3886          MnodeConstraintSense(MnodeConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 1)
3887                                                     , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,i_ConstraintRHS) ] ;
3888   
3889          MnodeConstraintLimit(MnodeConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 2)
3890                                                     , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,i_ConstraintRHS) ] ;
3891   
3892  *       Initialise mixed constraint data for the current trading period
3893          Type1MixedConstraint(currTP,t1MixCstr)
3894              = i_tradePeriodType1MixedConstraint(currTP,t1MixCstr) ;
3895   
3896          Type2MixedConstraint(currTP,t2MixCstr)
3897              = i_tradePeriodType2MixedConstraint(currTP,t2MixCstr) ;
3898   
3899          Type1MixedConstraintSense(currTP,t1MixCstr)
3900              = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
3901                   , i_tradePeriodType1MixedConstraintRHSParameters(currTP,t1MixCstr,t1MixCstrRHS) ] ;
3902   
3903          Type1MixedConstraintLimit1(currTP,t1MixCstr)
3904              = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
3905                   , i_tradePeriodType1MixedConstraintRHSParameters(currTP,t1MixCstr,t1MixCstrRHS) ] ;
3906   
3907          Type1MixedConstraintLimit2(currTP,t1MixCstr)
3908              = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
3909                   , i_tradePeriodType1MixedConstraintRHSParameters(currTP,t1MixCstr,t1MixCstrRHS) ] ;
3910   
3911          Type2MixedConstraintSense(currTP,t2MixCstr)
3912              = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 1)
3913                   , i_tradePeriodType2MixedConstraintRHSParameters(currTP,t2MixCstr,i_ConstraintRHS) ] ;
3914   
3915          Type2MixedConstraintLimit(currTP,t2MixCstr)
3916              = sum[ i_ConstraintRHS$(ord(i_ConstraintRHS) = 2)
3917                   , i_tradePeriodType2MixedConstraintRHSParameters(currTP,t2MixCstr,i_ConstraintRHS) ] ;
3918   
3919          Type1MixedConstraintCondition(currTP,t1MixCstr)
3920              $ sum[ br $ { HVDChalfPoles(currTP,br) and
3921                            i_type1MixedConstraintBranchCondition(t1MixCstr,br)
3922                          }, 1
3923                   ] = yes ;
3924   
3925  *       Initialise generic constraint data for the current trading period
3926          GenericConstraint(currTP,gnrcCstr)
3927              = i_tradePeriodGenericConstraint(currTP,gnrcCstr) ;
3928   
3929          GenericEnergyOfferConstraintFactors(GenericConstraint,o)
3930              = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
3931   
3932          GenericReserveOfferConstraintFactors(GenericConstraint,o,i_reserveClass,i_reserveType)
3933              = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,i_reserveClass,i_reserveType) ;
3934   
3935          GenericEnergyBidConstraintFactors(GenericConstraint,i_bid)
3936              = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,i_bid) ;
3937   
3938          GenericILReserveBidConstraintFactors(GenericConstraint,i_bid,i_reserveClass)
3939              = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,i_bid,i_reserveClass) ;
3940   
3941          GenericBranchConstraintFactors(GenericConstraint,br)
3942              = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
3943   
3944          GenericConstraintSense(GenericConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 1)
3945                                                         , i_tradePeriodGenericConstraintRHS(GenericConstraint,i_ConstraintRHS) ] ;
3946   
3947          GenericConstraintLimit(GenericConstraint) = sum[ i_ConstraintRHS $ (ord(i_ConstraintRHS) = 2)
3948                                                         , i_tradePeriodGenericConstraintRHS(GenericConstraint,i_ConstraintRHS) ] ;
3949   
3950   
3951   
3952  *       c) Additional pre-processing on parameters and variables before model solve
3953   
3954  *       Calculation of generation limits due to ramp rate limits (See 5.3.1. and 5.3.2. of SPD formulation document)
3955   
3956  *       Identification of primary and secondary units
3957          HasSecondaryOffer(currTP,o) $ sum[ o1 $ PrimarySecondaryOffer(currTP,o,o1), 1 ] = 1 ;
3958   
3959          HasPrimaryOffer(currTP,o) $ sum[ o1 $ PrimarySecondaryOffer(currTP,o1,o), 1 ] = 1 ;
3960   
3961  *       Calculation 5.3.1.1.
3962          GenerationMaximum(offer) $ { not [ HasSecondaryOffer(offer) or HasPrimaryOffer(offer) ] }
3963              = sum[ validGenerationOfferBlock(offer,trdBlk), GenerationOfferMW(offer,trdBlk) ] ;
3964   
3965          GenerationMaximum(currTP,o) $ HasSecondaryOffer(currTP,o)
3966              = sum[ trdBlk $ validGenerationOfferBlock(currTP,o,trdBlk), GenerationOfferMW(currTP,o,trdBlk) ]
3967              + sum[ (o1,trdBlk) $ { validGenerationOfferBlock(currTP,o1,trdBlk) and
3968                                     PrimarySecondaryOffer(currTP,o,o1)
3969                                   }, GenerationOfferMW(currTP,o1,trdBlk)
3970                   ] ;
3971   
3972  *       Set the ramp time
3973          RampTimeUp(offer) = i_tradingPeriodLength ;
3974   
3975          RampTimeDown(offer) = i_tradingPeriodLength ;
3976   
3977  *       Calculation 5.3.1.2. - Update to incorporate primary-secondary offers
3978  *       For primary-secondary offers, only primary offer initial MW and ramp rate is used - Reference: Transpower Market Services
3979          RampTimeUp(offer) $ { ( not [ HasSecondaryOffer(offer) or HasPrimaryOffer(offer) ] ) and
3980                                RampRateUp(offer) and
3981                                ( [ RampRateUp(offer) * i_tradingPeriodLength ]
3982                                  > [ GenerationMaximum(offer) - GenerationStart(offer) ]
3983                                )
3984                              }
3985            = [ GenerationMaximum(offer) - GenerationStart(offer) ] / RampRateUp(offer) ;
3986   
3987          RampTimeUp(offer) $ { HasSecondaryOffer(offer) and
3988                                RampRateUp(offer) and
3989                                ( [ RampRateUp(offer) * i_tradingPeriodLength ]
3990                                  > [ GenerationMaximum(offer) - GenerationStart(offer) ]
3991                                )
3992                              }
3993            = [ GenerationMaximum(offer) - GenerationStart(offer) ] / RampRateUp(offer) ;
3994   
3995  *       Calculation 5.3.1.3. - Update to incorporate primary-secondary offers
3996  *       For primary-secondary offers, only primary offer initial MW and ramp rate is used - Reference: Transpower Market Services
3997          GenerationEndUp(offer) $ { not [ HasSecondaryOffer(offer) or HasPrimaryOffer(offer) ] }
3998              = GenerationStart(offer) + (RampRateUp(offer) * RampTimeUp(offer)) ;
3999   
4000          GenerationEndUp(offer) $ HasSecondaryOffer(offer)
4001             = GenerationStart(offer) + (RampRateUp(offer) * RampTimeUp(offer)) ;
4002   
4003  *       Calculation 5.3.2.1.
4004  *       Negative prices for generation offers are not allowed?
4005          GenerationMinimum(offer) = 0 ;
4006   
4007  *       Calculation 5.3.2.2. - Update to incorporate primary-secondary offers
4008  *       For primary-secondary offers, only primary offer initial MW and ramp rate is used - Reference: Transpower Market Services
4009          RampTimeDown(offer) $ { ( not [ HasSecondaryOffer(offer) or HasPrimaryOffer(offer) ] ) and
4010                                  RampRateDown(offer) and
4011                                  ( [ RampRateDown(offer) * i_tradingPeriodLength ]
4012                                    > [ GenerationStart(offer) - GenerationMinimum(offer) ]
4013                                  )
4014                                }
4015              = [ GenerationStart(offer) - GenerationMinimum(offer) ] / RampRateDown(offer) ;
4016   
4017          RampTimeDown(offer) $ { HasSecondaryOffer(offer) and
4018                                  RampRateDown(offer) and
4019                                  ( [ RampRateDown(offer)*i_tradingPeriodLength ]
4020                                    > [ GenerationStart(offer) - GenerationMinimum(offer) ]
4021                                  )
4022                                }
4023              = [ GenerationStart(offer) - GenerationMinimum(offer) ] / RampRateDown(offer) ;
4024   
4025   
4026  *       Calculation 5.3.2.3. - Update to incorporate primary-secondary offers
4027  *       For primary-secondary offers, only primary offer initial MW and ramp rate is used - Reference: Transpower Market Services
4028          GenerationEndDown(offer) $ { not [ HasSecondaryOffer(offer) or HasPrimaryOffer(offer) ] }
4029              = Max[ 0, GenerationStart(offer) - RampRateDown(offer) * RampTimeDown(offer) ] ;
4030   
4031          GenerationEndDown(offer) $ HasSecondaryOffer(offer)
4032              = Max[ 0, GenerationStart(offer) - RampRateDown(offer) * RampTimeDown(offer) ] ;
4033   
4034   
4035  *       Update the variable bounds and fixing variable values
4036   
4037  *       Offers and Bids
4038  *       Constraint 3.1.1.2
4039          GENERATIONBLOCK.up(validGenerationOfferBlock) = GenerationOfferMW(validGenerationOfferBlock) ;
4040   
4041          GENERATIONBLOCK.fx(offer,trdBlk) $ (not validGenerationOfferBlock(offer,trdBlk)) = 0 ;
4042   
4043  *       Fix the generation variable for generators that are not connected or do not have a non-zero energy offer
4044          GENERATION.fx(offer) $ (not PositiveEnergyOffer(offer)) = 0 ;
4045   
4046  *       Change to demand bid
4047  *       Constraint 3.1.1.3 and 3.1.1.4
4048          PURCHASEBLOCK.up(validPurchaseBidBlock) $ (not UseDSBFDemandBidModel) = purchaseBidMW(validPurchaseBidBlock) ;
4049   
4050          PURCHASEBLOCK.lo(validPurchaseBidBlock) $ (not UseDSBFDemandBidModel) = 0 ;
4051   
4052          PURCHASEBLOCK.up(validPurchaseBidBlock) $ UseDSBFDemandBidModel
4053              = purchaseBidMW(validPurchaseBidBlock) $ (purchaseBidMW(validPurchaseBidBlock) > 0) ;
4054   
4055          PURCHASEBLOCK.lo(validPurchaseBidBlock) $ UseDSBFDemandBidModel
4056              = purchaseBidMW(validPurchaseBidBlock) $ (purchaseBidMW(validPurchaseBidBlock) < 0) ;
4057   
4058          PURCHASEBLOCK.fx(bid,trdBlk) $ (not validPurchaseBidBlock(bid,trdBlk)) = 0 ;
4059   
4060   
4061  *       Fix the purchase variable for purchasers that are not connected or do not have a non-zero purchase bid
4062          PURCHASE.fx(currTP,i_bid) $ (sum[ trdBlk $ validPurchaseBidBlock(currTP,i_bid,trdBlk), 1 ] = 0) = 0 ;
4063   
4064  *       Network
4065  *       Ensure that variables used to specify flow and losses on HVDC link are zero for AC branches and for open HVDC links.
4066          HVDCLINKFLOW.fx(ACbranch) = 0 ;
4067          HVDCLINKFLOW.fx(OpenBranch(HVDClink)) = 0 ;
4068          HVDCLINKLOSSES.fx(ACbranch) = 0 ;
4069          HVDCLINKLOSSES.fx(OpenBranch(HVDClink)) = 0 ;
4070          HVDCLINKFLOW.fx(currTP,br) $ (not branch(currTP,br)) = 0 ;
4071          HVDCLINKLOSSES.fx(currTP,br) $ (not branch(currTP,br)) = 0 ;
4072   
4073  *       Apply an upper bound on the weighting parameter based on its definition
4074          LAMBDA.up(branch,los) = 1 ;
4075   
4076  *       Ensure that the weighting factor value is zero for AC branches and for invalid loss segments on HVDC links
4077          LAMBDA.fx(ACbranch,los) = 0 ;
4078          LAMBDA.fx(HVDClink,los) $ (not validLossSegment(HVDClink,los)) = 0 ;
4079          LAMBDA.fx(currTP,br,los) $ (not branch(currTP,br)) = 0 ;
4080   
4081  *       Ensure that variables used to specify flow and losses on AC branches are zero for HVDC links branches and for open AC branches
4082          ACBRANCHFLOW.fx(HVDClink) = 0 ;
4083          ACBRANCHFLOW.fx(OpenBranch) = 0 ;
4084          ACBRANCHFLOW.fx(currTP,br) $ (not branch(currTP,br)) = 0 ;
4085   
4086          ACBRANCHFLOWDIRECTED.fx(OpenBranch,i_flowDirection) = 0 ;
4087          ACBRANCHFLOWDIRECTED.fx(HVDClink,i_flowDirection) = 0 ;
4088          ACBRANCHFLOWDIRECTED.fx(currTP,br,i_flowDirection) $ (not branch(currTP,br)) = 0 ;
4089   
4090          ACBRANCHLOSSESDIRECTED.fx(OpenBranch,i_flowDirection) = 0 ;
4091          ACBRANCHLOSSESDIRECTED.fx(HVDClink,i_flowDirection) = 0 ;
4092          ACBRANCHLOSSESDIRECTED.fx(currTP,br,i_flowDirection) $ (not branch(currTP,br)) = 0 ;
4093   
4094  *       Ensure that variables used to specify block flow and block losses on AC branches are zero for HVDC links,
4095  *       open AC branches and invalid loss segments on closed AC branches
4096          ACBRANCHFLOWBLOCKDIRECTED.fx(branch,los,i_flowDirection) $ (not validLossSegment(branch,los)) = 0 ;
4097          ACBRANCHFLOWBLOCKDIRECTED.fx(OpenBranch,los,i_flowDirection) = 0 ;
4098          ACBRANCHFLOWBLOCKDIRECTED.fx(HVDClink,los,i_flowDirection) = 0 ;
4099          ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,i_flowDirection) $ (not branch(currTP,br)) = 0 ;
4100   
4101          ACBRANCHLOSSESBLOCKDIRECTED.fx(branch,los,i_flowDirection) $ (not validLossSegment(branch,los)) = 0 ;
4102          ACBRANCHLOSSESBLOCKDIRECTED.fx(OpenBranch,los,i_flowDirection) = 0 ;
4103          ACBRANCHLOSSESBLOCKDIRECTED.fx(HVDClink,los,i_flowDirection) = 0 ;
4104          ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,i_flowDirection) $ (not branch(currTP,br)) = 0 ;
4105   
4106  *       Ensure that the bus voltage angle for the buses corresponding to the reference nodes and the HVDC nodes are set to zero
4107  *       Constraint 3.3.1.10
4108          ACnodeANGLE.fx(currTP,b) $ sum[ n $ { NodeBus(currTP,n,b) and ReferenceNode(currTP,n) }, 1 ] = 0 ;
4109          ACnodeANGLE.fx(currTP,b) $ sum[ n $ { NodeBus(currTP,n,b) and HVDCnode(currTP,n) },1 ] = 0 ;
4110   
4111  *       Risk/Reserve
4112  *       Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4113          RESERVEBLOCK.fx(offer,trdBlk,i_reserveClass,i_reserveType)
4114              $ (not validReserveOfferBlock(offer,trdBlk,i_reserveClass,i_reserveType)) = 0 ;
4115   
4116          PURCHASEILRBLOCK.fx(bid,trdBlk,i_reserveClass) $ (not validPurchaseBidILRBlock(bid,trdBlk,i_reserveClass)) = 0 ;
4117   
4118  *       Reserve block maximum for offers and purchasers - Constraint 3.4.2.2.
4119          RESERVEBLOCK.up(validReserveOfferBlock) = reserveOfferMaximum(validReserveOfferBlock) ;
4120   
4121          PURCHASEILRBLOCK.up(validPurchaseBidILRBlock) = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4122   
4123  *       Fix the reserve variable for invalid reserve offers. These are offers that are either not connected to the grid or have no reserve quantity offered.
4124          RESERVE.fx(currTP,o,i_reserveClass,i_reserveType)
4125              $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,i_reserveClass,i_reserveType), 1 ] ) = 0 ;
4126   
4127  *       Fix the purchase ILR variable for invalid purchase reserve offers. These are offers that are either not connected to the grid or have no reserve quantity offered.
4128          PURCHASEILR.fx(currTP,i_bid,i_reserveClass)
4129              $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,i_bid,trdBlk,i_reserveClass), 1 ] ) = 0 ;
4130   
4131  *       Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4132          RISKOFFSET.fx(currTP,ild,i_reserveClass,i_riskClass)
4133              $ { useMixedConstraintRiskOffset and
4134                  useMixedConstraint(currTP) and
4135                  (not sum[ t1MixCstr $ i_type1MixedConstraintReserveMap(t1MixCstr,ild,i_reserveClass,i_riskClass),1])
4136                } = 0 ;
4137   
4138  *       RDN - Fix the appropriate deficit variable to zero depending on whether the different CE and ECE CVP flag is set
4139          DEFICITRESERVE.fx(currTP,ild,i_reserveClass) $ diffCeECeCVP = 0 ;
4140   
4141          DEFICITRESERVE_CE.fx(currTP,ild,i_reserveClass) $ (not diffCeECeCVP) = 0 ;
4142   
4143          DEFICITRESERVE_ECE.fx(currTP,ild,i_reserveClass) $ (not diffCeECeCVP) = 0 ;
4144   
4145  *       Mixed constraint
4146          MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr) $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
4147   
4148   
4149  *       d) Solve the model
4150   
4151  *       If solving either pattern, using vSPD_FTR simple model
4152          if( (FTRflag = 2),
4153  *           Set the bratio to 1 i.e. do not use advanced basis for LP
4154              option bratio = 1;
4155  *           Set resource limits
4156              VSPD_FTR.reslim = LPTimeLimit;
4157              VSPD_FTR.iterlim = LPIterationLimit;
4158              solve VSPD_FTR using lp maximizing NETBENEFIT;
4159  *           Set the model solve status
4160              ModelSolved = 1 $ ((VSPD_FTR.modelstat = 1) and (VSPD_FTR.solvestat = 1));
4161  *           Post a progress message to report for use by GUI and to the console.
4162              if( (ModelSolved = 1) and (sequentialSolve = 0),
4163                  putclose runlog / 'The case: FP_20140221_I finished at ', system.time '. Solve successful.' /
4164                                    'Objective function value: ' NETBENEFIT.l:<12:1 /
4165                                    'Violation Cost: ' TOTALPENALTYCOST.l:<12:1 /
4166   
4167              elseif((ModelSolved = 0) and (sequentialSolve = 0)),
4168                  putclose runlog / 'The case: FP_20140221_I finished at ', system.time '. Solve unsuccessful.' /
4169              ) ;
4170   
4171              if((ModelSolved = 1) and (sequentialSolve = 1),
4172                  loop(currTP(tp),
4173                      putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') finished at ', system.time
4174                                        '. Solve successful.' /
4175                                        'Objective function value: ' NETBENEFIT.l:<12:1 /
4176                                        'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4177                  );
4178              elseif((ModelSolved = 0) and (sequentialSolve = 1)),
4179                  loop(currTP(tp),
4180                      putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') finished at ', system.time
4181                                        '. Solve unsuccessful.' /
4182                  );
4183              ) ;
4184   
4185          else
4186  *           Set the bratio to 1 i.e. do not use advanced basis for LP
4187              option bratio = 1 ;
4188  *           Set resource limits
4189              vSPD.reslim = LPTimeLimit ;
4190              vSPD.iterlim = LPIterationLimit ;
4191              solve vSPD using lp maximizing NETBENEFIT ;
4192  *           Set the model solve status
4193              ModelSolved = 1$((vSPD.modelstat = 1) and (vSPD.solvestat = 1)) ;
4194   
4195  *           Post a progress message to the console and for use by EMI.
4196              if((ModelSolved = 1) and (sequentialSolve = 0),
4197                  putclose runlog / 'The case: FP_20140221_I finished at ', system.time '. Solve successful.' /
4198                                    'Objective function value: ' NETBENEFIT.l:<12:1 /
4199                                    'Violation Cost: ' TOTALPENALTYCOST.l:<12:1 /
4200              elseif((ModelSolved = 0) and (sequentialSolve = 0)),
4201                  putclose runlog / 'The case: FP_20140221_I finished at ', system.time '. Solve unsuccessful.' /
4202              ) ;
4203   
4204   
4205              if((ModelSolved = 1) and (sequentialSolve = 1),
4206                  loop(currTP(tp),
4207                      putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') finished at ', system.time
4208                                        '. Solve successful.' /
4209                                        'Objective function value: ' NETBENEFIT.l:<12:1 /
4210                                        'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4211                  ) ;
4212              elseif((ModelSolved = 0) and (sequentialSolve = 1)),
4213                  loop(currTP(tp),
4214                      putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') finished at ', system.time
4215                                        '. Solve unsuccessful.' /
4216                  ) ;
4217   
4218              ) ;
4219   
4220          );
4221   
4222   
4223  *       e) Check if the LP results are valid
4224          if((ModelSolved = 1),
4225   
4227   
4228  *           Check if there are circulating branch flows on loss AC branches and HVDC links
4229              circularBranchFlowExist(ACbranch)
4230                  $ { LossBranch(ACbranch) and
4231                      [ abs( sum[ i_flowDirection, ACBRANCHFLOWDIRECTED.l(ACbranch,i_flowDirection) ]
4232                           - abs(ACBRANCHFLOW.l(ACbranch))
4233                           ) > circularBranchFlowTolerance
4234                      ]
4235                    } = 1 ;
4236   
4237  *           Determine the circular branch flow flag on each HVDC pole
4238              TotalHVDCpoleFlow(currTP,pole) = sum[ br $ HVDCpoleBranchMap(pole,br), HVDCLINKFLOW.l(currTP,br) ] ;
4239   
4240              MaxHVDCpoleFlow(currTP,pole) = smax[ br $ HVDCpoleBranchMap(pole,br), HVDCLINKFLOW.l(currTP,br) ] ;
4241   
4242              poleCircularBranchFlowExist(currTP,pole) $ { abs( TotalHVDCpoleFlow(currTP,pole)
4243                                                                - MaxHVDCpoleFlow(currTP,pole)
4244                                                              ) > circularBranchFlowTolerance
4245                                                         } = 1 ;
4246   
4247              NorthHVDC(currTP) = sum[ (ild,b,br) $ { (ord(ild) = 2) and
4248                                                      i_tradePeriodBusIsland(currTP,b,ild) and
4249                                                      HVDClinkSendingBus(currTP,br,b) and
4250                                                      HVDCpoles(currTP,br)
4251                                                    }, HVDCLINKFLOW.l(currTP,br)
4252                                     ] ;
4253   
4254              SouthHVDC(currTP) = sum[ (ild,b,br) $ { (ord(ild) = 1) and
4255                                                      i_tradePeriodBusIsland(currTP,b,ild) and
4256                                                      HVDClinkSendingBus(currTP,br,b) and
4257                                                      HVDCpoles(currTP,br)
4258                                                    }, HVDCLINKFLOW.l(currTP,br)
4259                                     ] ;
4260   
4261              circularBranchFlowExist(currTP,br) $ { HVDCpoles(currTP,br) and
4262                                                     LossBranch(currTP,br) and
4263                                                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
4264                                                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
4265                                                   } = 1 ;
4266   
4267  *           Check if there are non-physical losses on loss AC branches and HVDC links
4268              ManualBranchSegmentMWFlow(validLossSegment(ACbranch,los)) $ LossBranch(ACbranch)
4269                  = Min[ ACbranchLossMW(ACbranch,los),
4270                         Max( 0,
4271                              [ abs(ACBRANCHFLOW.l(ACbranch))
4272                              - [LossSegmentMW(ACbranch,los-1) $ (ord(los) > 1)]
4273                              ]
4274                            )
4275                       ] ;
4276   
4277              ManualBranchSegmentMWFlow(validLossSegment(HVDClink,los)) $ { LossBranch(HVDClink) and
4278                                                                            (ord(los) <= HVDClinkLossBlocks(HVDClink))
4279                                                                          }
4280                  = Min[ Max( 0,
4281                              [ abs(HVDCLINKFLOW.l(HVDClink))
4282                              - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
4283                              ]
4284                            ),
4285                         ( LossSegmentMW(HVDClink,los)
4286                        - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
4287                         )
4288                       ] ;
4289   
4290              ManualLossCalculation(branch) $ LossBranch(branch) = sum[ los, LossSegmentFactor(branch,los)
4291                                                                           * ManualBranchSegmentMWFlow(branch,los)
4292                                                                      ] ;
4293   
4294              NonPhysicalLossExist(ACbranch) $ { LossBranch(ACbranch) and
4295                                                 [ abs( sum[i_flowDirection, ACBRANCHLOSSESDIRECTED.l(ACbranch,i_flowDirection) ]
4296                                                      - ManualLossCalculation(ACbranch)
4297                                                      )
4298                                                   > NonPhysicalLossTolerance
4299                                                 ]
4300                                               } = 1 ;
4301   
4302              NonPhysicalLossExist(HVDClink) $ { LossBranch(HVDClink) and
4303                                                 [ abs( HVDCLINKLOSSES.l(HVDClink)
4304                                                      - ManualLossCalculation(HVDClink)
4305                                                      )
4306                                                   > NonPhysicalLossTolerance
4307                                                 ]
4308                                               } = 1 ;
4309   
4310  *           Invoke the UseBranchFlowMIP flag if the number of circular branch flow
4311  *           and non-physical loss branches exceeds the specified tolerance
4312              useBranchFlowMIP(currTP) $ { ( sum[ br $ { ACbranch(currTP,br) and
4313                                                         LossBranch(currTP,br)
4314                                                       }, resolveCircularBranchFlows
4315                                                        * circularBranchFlowExist(currTP,br)
4316                                                        + resolveACnonPhysicalLosses
4317                                                        * NonPhysicalLossExist(currTP,br)
4318                                                ]
4319                                           + sum[ br $ { HVDClink(currTP,br) and
4320                                                         LossBranch(currTP,br)
4321                                                       }, (1 - AllowHVDCroundpower(currTP))
4322                                                        * resolveCircularBranchFlows
4323                                                        * circularBranchFlowExist(currTP,br)
4324                                                        + resolveHVDCnonPhysicalLosses
4325                                                        * NonPhysicalLossExist(currTP,br)
4326                                                ]
4327                                           + sum[ pole, resolveCircularBranchFlows
4328                                                      * poleCircularBranchFlowExist(currTP,pole)
4329                                                ]
4330                                           ) > UseBranchFlowMIPTolerance
4331                                         } = 1 ;
4332   
4333  *           Detect if branch flow MIP is needed
4334              branchFlowMIPInvoked(currTP) = UseBranchFlowMIP(currTP) ;
4335   
4336  *           Check branch flows for relevant mixed constraint to check if integer variables are needed
4337              if( useMixedConstraintRiskOffset,
4338                  HVDChalfPoleSouthFlow(currTP)
4339                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4340                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
4341                             ] > MixedMIPTolerance
4342                        } = 1 ;
4343   
4344  *               Only calculate violation if the constraint limit is non-zero
4345                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
4346                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
4347                          = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
4348                            - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4349                            ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
4350                          + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4351                            - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
4352                            ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
4353                          + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
4354                               - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4355                               ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
4356   
4357  *               Integer constraints are needed if southward flow on half-poles AND
4358  *               constraint level exceeds the mixed constraint limit2 value
4359                  useMixedConstraintMIP(currTP) $ { HVDChalfPoleSouthFlow(currTP) and
4360                                                    sum[ t1MixCstr
4361                                                         $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
4362                                                             > MixedMIPTolerance }, 1
4363                                                       ]
4364                                                  } = 1 ;
4365              ) ;
4366   
4367  *           Skip the resolve logic if the simultaneous mode requires integer variables since the problem becomes large MILP
4368  *           Resolve in sequential mode
4369              skipResolve $ { (not sequentialSolve) and
4370                              (card(currTP) > ThresholdSimultaneousInteger) and
4371                              sum[ currTP, UseBranchFlowMIP(currTP) + UseMixedConstraintMIP(currTP) ]
4372                            } = 1 ;
4373   
4374   
4375  *           Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
4376              if( { [not sequentialSolve] and sum[ currTP, UseBranchFlowMIP(currTP) + UseMixedConstraintMIP(currTP) ] },
4377                  putclose runlog / 'The case: FP_20140221_I requires an integer resolve.  Switching Vectorisation OFF.' /
4378              ) ;
4379   
4380  *           Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
4381              if( { sequentialSolve and sum[ currTP, UseBranchFlowMIP(currTP) + UseMixedConstraintMIP(currTP) ] },
4382                  loop(currTP(tp),
4383                      putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') requires an integer resolve.' /
4384                  ) ;
4385              ) ;
4386   
4387   
4388  *           f) Resolve the model if required
4389              if( not skipResolve,
4390   
4391                  if( sum[currTP, UseBranchFlowMIP(currTP)] * sum[currTP,UseMixedConstraintMIP(currTP)] >= 1,
4392  *                   Don't use integer variables for periods that do not need them
4393                      MIXEDCONSTRAINTLIMIT2SELECT.fx(currTP,t1MixCstr) $ (not UseMixedConstraintMIP(currTP)) = 0 ;
4394   
4395                      ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4396   
4397                      HVDCLINKFLOWDIRECTION_INTEGER.fx(currTP,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4398   
4399                      HVDCpoleFLOW_INTEGER.fx(currTP,pole,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4400   
4401                      LAMBDAINTEGER.fx(currTP,br,los) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4402   
4403  *                   Fix the values of the integer variables that are not needed
4404                      ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4405                                                                                             ( HVDClink(branch) or
4406                                                                                               (not LossBranch(branch)) or
4407                                                                                               OpenBranch(branch)
4408                                                                                             )
4409                                                                                           } = 0 ;
4410   
4411  *                   Fix the integer AC branch flow variable to zero for invalid branches
4412                      ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4413                                                                                    (not branch(currTP,br))
4414                                                                                   } = 0 ;
4415   
4416  *                   Apply an upper bound on the integer weighting parameter based on its definition
4417                      LAMBDAINTEGER.up(branch(currTP,br),los) $ UseBranchFlowMIP(currTP) = 1 ;
4418   
4419  *                   Ensure that the weighting factor value is zero for AC branches and for invalid loss segments on HVDC links
4420                      LAMBDAINTEGER.fx(branch(currTP,br),los) $ { UseBranchFlowMIP(currTP) and
4421                                                                  ( ACbranch(branch) or
4422                                                                    [ not ( validLossSegment(branch,los) and
4423                                                                            HVDClink(branch)
4424                                                                          )
4425                                                                    ]
4426                                                                  )
4427                                                                } = 0 ;
4428   
4429  *                   Fix the lambda integer variable to zero for invalid branches
4430                      LAMBDAINTEGER.fx(currTP,br,los) $ { UseBranchFlowMIP(currTP) and
4431                                                          (not branch(currTP,br)) } = 0 ;
4432   
4433  *                   Fix the value of some binary variables used in the mixed constraints that have no alternate limit
4434                      MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4435                          $ { UseMixedConstraintMIP(currTP) and
4436                              (not Type1MixedConstraintCondition(Type1MixedConstraint))
4437                            } = 0 ;
4438   
4439  *                   Use the advanced basis here
4440                      option bratio = 0.25 ;
4441  *                   Set the optimality criteria for the MIP
4442                      vSPD_MIP.optcr = MIPOptimality ;
4443                      vSPD_MIP.reslim = MIPTimeLimit ;
4444                      vSPD_MIP.iterlim = MIPIterationLimit ;
4445  *                   Solve the model
4446                      solve vSPD_MIP using mip maximizing NETBENEFIT ;
4447  *                   Set the model solve status
4448                      ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
4449                                            (vSPD_MIP.modelstat = 8)
4450                                          ]
4451                                          and
4452                                          [ vSPD_MIP.solvestat = 1 ]
4453                                        } ;
4454   
4455  *                   Post a progress message for use by EMI.
4456                      if(ModelSolved = 1,
4457                          loop(currTP(tp),
4458                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') FULL integer solve finished at ', system.time '. Solve successful.' /
4459                                                'Objective function value: ' NETBENEFIT.l:<12:1 /
4460                                                'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4461                          ) ;
4462                      else
4463                          loop(currTP(tp),
4464                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') FULL integer solve finished at ', system.time '. Solve unsuccessful.' /
4465                          ) ;
4466                      ) ;
4467   
4468                  elseif sum[ currTP, UseBranchFlowMIP(currTP) ] >= 1,
4469  *                   Don't use integer variables for periods that do not need them
4470                      ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4471   
4472                      HVDCLINKFLOWDIRECTION_INTEGER.fx(currTP,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4473   
4474                      HVDCpoleFLOW_INTEGER.fx(currTP,pole,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4475   
4476                      LAMBDAINTEGER.fx(currTP,br,los) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4477   
4478  *                   Fix the values of these integer variables that are not needed
4479                      ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4480                                                                                             ( HVDClink(branch) or
4481                                                                                               (not LossBranch(branch)) or
4482                                                                                               OpenBranch(branch)
4483                                                                                             )
4484                                                                                           } = 0 ;
4485   
4486   
4487  *                   Fix the integer AC branch flow variable to zero for invalid branches
4488                      ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4489                                                                                     (not branch(currTP,br))
4490                                                                                   } = 0 ;
4491   
4492  *                   Apply an upper bound on the integer weighting parameter based on its definition
4493                      LAMBDAINTEGER.up(branch(currTP,br),los) $ UseBranchFlowMIP(currTP) = 1 ;
4494   
4495  *                   Ensure that the weighting factor value is zero for AC branches and for invalid loss segments on HVDC links
4496                      LAMBDAINTEGER.fx(branch(currTP,br),los) $ { UseBranchFlowMIP(currTP) and
4497                                                                  ( ACbranch(branch) or
4498                                                                    [ not ( validLossSegment(branch,los) and
4499                                                                            HVDClink(branch)
4500                                                                          )
4501                                                                    ]
4502                                                                  )
4503                                                                } = 0 ;
4504   
4505  *                   Fix the lambda integer variable to zero for invalid branches
4506                      LAMBDAINTEGER.fx(currTP,br,los) $ { UseBranchFlowMIP(currTP) and
4507                                                          (not branch(currTP,br))
4508                                                        } = 0 ;
4509   
4510  *                   Use the advanced basis here
4511                      option bratio = 0.25 ;
4512  *                   Set the optimality criteria for the MIP
4513                      vSPD_BranchFlowMIP.optcr = MIPOptimality ;
4514                      vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
4515                      vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
4516  *                   Solve the model
4517                      solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
4518  *                   Set the model solve status
4519                      ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
4520                                            (vSPD_BranchFlowMIP.modelstat = 8)
4521                                          ]
4522                                          and
4523                                          [ vSPD_BranchFlowMIP.solvestat = 1 ]
4524                                        } ;
4525   
4526  *                   Post a progress message for use by EMI.
4527                      if(ModelSolved = 1,
4528                          loop(currTP(tp),
4529                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') branch integer solve finished at ', system.time '. Solve successful.' /
4530                                                'Objective function value: ' NETBENEFIT.l:<12:1 /
4531                                                'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4532                          ) ;
4533                      else
4534                          loop(currTP(tp),
4535                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') branch integer solve finished at ', system.time '. Solve unsuccessful.' /
4536                          ) ;
4537                      ) ;
4538   
4539                  elseif sum[ currTP, UseMixedConstraintMIP(currTP) ] >= 1,
4540  *                   Don't use integer variables for periods that do not need them
4541                      MIXEDCONSTRAINTLIMIT2SELECT.fx(currTP,t1MixCstr) $ (not UseMixedConstraintMIP(currTP)) = 0 ;
4542   
4543  *                   Fix the value of some binary variables used in the mixed constraints that have no alternate limit
4544                      MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4545                          $ { UseMixedConstraintMIP(currTP) and
4546                              (not Type1MixedConstraintCondition(Type1MixedConstraint))
4547                            } = 0 ;
4548   
4549  *                   Use the advanced basis here
4550                      option bratio = 0.25 ;
4551  *                   Set the optimality criteria for the MIP
4552                      vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
4553                      vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
4554                      vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
4555  *                   Solve the model
4556                      solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
4557  *                   Set the model solve status
4558                      ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
4559                                            (vSPD_MixedConstraintMIP.modelstat = 8)
4560                                          ]
4561                                          and
4562                                          [ vSPD_MixedConstraintMIP.solvestat = 1 ]
4563                                        } ;
4564   
4565  *                   Post a progress message for use by EMI.
4566                      if(ModelSolved = 1,
4567                          loop(currTP(tp),
4568                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') MIXED integer solve finished at ', system.time '. Solve successful.' /
4569                                                'Objective function value: ' NETBENEFIT.l:<12:1 /
4570                                                'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4571                          ) ;
4572                      else
4573                          loop(currTP(tp),
4574                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') MIXED integer solve finished at ', system.time '. Solve unsuccessful.' /
4575                          ) ;
4576                      ) ;
4577   
4578                  else
4579  *                   Set the LP valid flag
4580                      LPvalid = 1 ;
4581   
4582                  ) ;
4583   
4584   
4585  *               If either the vSPD_BranchFlowMIP or the vSPD_MixedConstraintMIP returned a valid solution
4586                  if( ModelSolved * sum[ currTP, UseMixedConstraintMIP(currTP) + UseBranchFlowMIP(currTP) ] >= 1,
4587   
4588  *                   Re-check the MIP solved solution
4589  *                   Reset the relevant parameters
4590                      circularBranchFlowExist(branch) = 0 ;
4591                      NorthHVDC(currTP) = 0 ;
4592                      SouthHVDC(currTP) = 0 ;
4593                      poleCircularBranchFlowExist(currTP,pole) = 0 ;
4594                      ManualBranchSegmentMWFlow(tp,br,los) = 0 ;
4595                      ManualLossCalculation(branch) = 0 ;
4596                      NonPhysicalLossExist(branch)= 0 ;
4597                      UseBranchFlowMIP(currTP) = 0 ;
4598   
4599  *                   Check if there are circulating branch flows on loss AC branches and HVDC links
4600                      circularBranchFlowExist(ACbranch) $ { LossBranch(ACbranch) and
4601                                                            ( abs[ sum[ i_flowDirection, ACBRANCHFLOWDIRECTED.l(ACbranch,i_flowDirection) ]
4602                                                                 - abs(ACBRANCHFLOW.l(ACbranch))
4603                                                                 ] > circularBranchFlowTolerance
4604                                                            )
4605                                                          } = 1 ;
4606   
4607                      NorthHVDC(currTP) = sum[ (ild,b,br) $ { (ord(ild) = 2) and
4608                                                              i_tradePeriodBusIsland(currTP,b,ild) and
4609                                                              HVDClinkSendingBus(currTP,br,b) and
4610                                                              HVDCpoles(currTP,br)
4611                                                            }, HVDCLINKFLOW.l(currTP,br)
4612                                             ] ;
4613   
4614                      SouthHVDC(currTP) = sum[ (ild,b,br) $ { (ord(ild) = 1) and
4615                                                              i_tradePeriodBusIsland(currTP,b,ild) and
4616                                                              HVDClinkSendingBus(currTP,br,b) and
4617                                                              HVDCpoles(currTP,br)
4618                                                            }, HVDCLINKFLOW.l(currTP,br)
4619                                             ] ;
4620   
4621                      circularBranchFlowExist(currTP,br) $ { HVDCpoles(currTP,br) and
4622                                                             LossBranch(currTP,br) and
4623                                                             (NorthHVDC(currTP) > circularBranchFlowTolerance) and
4624                                                             (SouthHVDC(currTP) > circularBranchFlowTolerance)
4625                                                           } = 1 ;
4626   
4627  *                   Determine the circular branch flow flag on each HVDC pole
4628                      TotalHVDCpoleFlow(currTP,pole)
4629                          = sum[ br $ HVDCpoleBranchMap(pole,br), HVDCLINKFLOW.l(currTP,br) ] ;
4630   
4631                      MaxHVDCpoleFlow(currTP,pole)
4632                          = smax[ br $ HVDCpoleBranchMap(pole,br), HVDCLINKFLOW.l(currTP,br) ] ;
4633   
4634                      poleCircularBranchFlowExist(currTP,pole) $ { abs[ TotalHVDCpoleFlow(currTP,pole)
4635                                                                      - MaxHVDCpoleFlow(currTP,pole)
4636                                                                      ] > circularBranchFlowTolerance
4637                                                                 } = 1 ;
4638   
4639  *                   Check if there are non-physical losses on loss AC branches and HVDC links
4640                      ManualBranchSegmentMWFlow(validLossSegment(ACbranch,los)) $ LossBranch(ACbranch)
4641                          = Min[ ACbranchLossMW(ACbranch,los),
4642                                 Max( 0,
4643                                      [ abs(ACBRANCHFLOW.l(ACbranch))
4644                                      - [LossSegmentMW(ACbranch,los-1) $ (ord(los) > 1)]
4645                                      ]
4646                                    )
4647                               ] ;
4648   
4649                      ManualBranchSegmentMWFlow(validLossSegment(HVDClink,los)) $ { LossBranch(HVDClink) and
4650                                                                                    (ord(los) <= HVDClinkLossBlocks(HVDClink))
4651                                                                                  }
4652                          = Min[ Max( 0,
4653                                      [ abs(HVDCLINKFLOW.l(HVDClink))
4654                                      - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
4655                                      ]
4656                                    ),
4657                                 ( LossSegmentMW(HVDClink,los)
4658                                 - [LossSegmentMW(HVDClink,los-1) $ (ord(los) > 1)]
4659                                 )
4660                               ] ;
4661   
4662                      ManualLossCalculation(branch) $ LossBranch(branch) = sum[ los, LossSegmentFactor(branch,los)
4663                                                                                   * ManualBranchSegmentMWFlow(branch,los)
4664                                                                              ] ;
4665   
4666                      NonPhysicalLossExist(ACbranch) $ { LossBranch(ACbranch) and
4667                                                         [ abs( sum[ i_flowDirection, ACBRANCHLOSSESDIRECTED.l(ACbranch,i_flowDirection) ]
4668                                                              - ManualLossCalculation(ACbranch)
4669                                                              ) > NonPhysicalLossTolerance
4670                                                         ]
4671                                                       } = 1 ;
4672   
4673                      NonPhysicalLossExist(HVDClink) $ { LossBranch(HVDClink) and
4674                                                         [ abs( HVDCLINKLOSSES.l(HVDClink)
4675                                                              - ManualLossCalculation(HVDClink)
4676                                                              ) > NonPhysicalLossTolerance
4677                                                         ]
4678                                                       } = 1 ;
4679   
4680  *                   Invoke the UseBranchFlowMIP flag if the number of circular branch flow
4681  *                   and non-physical loss branches exceeds the specified tolerance
4682                      UseBranchFlowMIP(currTP) $ { ( sum[ br $ { ACbranch(currTP,br) and
4683                                                                 LossBranch(currTP,br)
4684                                                               }, resolveCircularBranchFlows
4685                                                                * circularBranchFlowExist(currTP,br)
4686                                                                + resolveACnonPhysicalLosses
4687                                                                * NonPhysicalLossExist(currTP,br)
4688                                                        ]
4689                                                   + sum[ br $ { LossBranch(currTP,br) and
4690                                                                 HVDClink(currTP,br)
4691                                                               }, (1-AllowHVDCroundpower(currTP))
4692                                                                * resolveCircularBranchFlows
4693                                                                * circularBranchFlowExist(currTP,br)
4694                                                                + resolveHVDCnonPhysicalLosses
4695                                                                * NonPhysicalLossExist(currTP,br)
4696                                                        ]
4697                                                   + sum[ pole, resolveCircularBranchFlows
4698                                                              * poleCircularBranchFlowExist(currTP,pole)
4699                                                        ]
4700                                                   )
4701                                                   > UseBranchFlowMIPTolerance
4702                                                 } = 1 ;
4703   
4704  *                   Check branch flows for relevant mixed constraint to check if integer variables are needed
4705                      if( useMixedConstraintRiskOffset,
4706  *                       Reset the relevant parameters
4707                          HVDChalfPoleSouthFlow(currTP) = 0 ;
4708                          Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition) = 0 ;
4709                          UseMixedConstraintMIP(currTP) = 0 ;
4710   
4711  *                       Check branch flows for relevant mixed constraint to check if integer variables are needed
4712                          HVDChalfPoleSouthFlow(currTP)
4713                              $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4714                                       $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
4715                                     ] > MixedMIPTolerance
4716                                } = 1 ;
4717   
4718  *                       Only calculate violation if the constraint limit is non-zero
4719                          Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
4720                              $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
4721                                  = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
4722                                    - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4723                                    ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
4724                                  +
4725                                    [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4726                                    - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
4727                                    ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
4728                                  +
4729                                    abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
4730                                       - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
4731                                       ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
4732   
4733  *                       Integer constraints are needed if southward flow on half-poles AND
4734  *                       constraint level exceeds the mixed constraint limit2 value
4735                          useMixedConstraintMIP(currTP) $ { HVDChalfPoleSouthFlow(currTP) and
4736                                                            sum[ t1MixCstr
4737                                                                 $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
4738                                                                     > MixedMIPTolerance }, 1
4739                                                               ]
4740                                                          } = 1 ;
4741   
4742                      ) ;
4743   
4744   
4745  *                   If either circular branch flows or non-physical losses or discontinuous mixed constraint limits then
4746                      if( sum[ currTP, UseBranchFlowMIP(currTP) + UseMixedConstraintMIP(currTP) ] >= 1,
4747   
4748  *                       Reset some bounds
4749                          MIXEDCONSTRAINTLIMIT2SELECT.up(currTP,t1MixCstr) = 1 ;
4750   
4751                          ACBRANCHFLOWDIRECTED_INTEGER.up(currTP,br,i_flowDirection) = +inf ;
4752   
4753                          HVDCLINKFLOWDIRECTION_INTEGER.up(currTP,i_flowDirection) = +inf ;
4754   
4755  *                       Reset the bound of the integer variable
4756                          HVDCpoleFLOW_INTEGER.up(currTP,pole,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = +inf ;
4757   
4758                          LAMBDAINTEGER.up(currTP,br,los) = +inf ;
4759   
4760  *                       Don't use integer variables for periods that do not need them
4761                          MIXEDCONSTRAINTLIMIT2SELECT.fx(currTP,t1MixCstr) $ (not UseMixedConstraintMIP(currTP)) = 0 ;
4762   
4763                          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4764   
4765                          HVDCLINKFLOWDIRECTION_INTEGER.fx(currTP,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4766   
4767                          HVDCpoleFLOW_INTEGER.fx(currTP,pole,i_flowDirection) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4768   
4769                          LAMBDAINTEGER.fx(currTP,br,los) $ (not UseBranchFlowMIP(currTP)) = 0 ;
4770   
4771  *                       Fix the values of the integer variables that are not needed
4772                          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4773                                                                                                 ( HVDClink(branch) or
4774                                                                                                   (not LossBranch(branch)) or
4775                                                                                                   OpenBranch(branch)
4776                                                                                                 )
4777                                                                                               } = 0 ;
4778   
4779  *                       Fix the integer AC branch flow variable to zero for invalid branches
4780                          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,i_flowDirection) $ { UseBranchFlowMIP(currTP) and
4781                                                                                        (not branch(currTP,br))
4782                                                                                       } = 0 ;
4783   
4784  *                       Apply an upper bound on the integer weighting parameter based on its definition
4785                          LAMBDAINTEGER.up(branch(currTP,br),los) $ UseBranchFlowMIP(currTP) = 1 ;
4786   
4787  *                       Ensure that the weighting factor value is zero for AC branches and for invalid loss segments on HVDC links
4788                          LAMBDAINTEGER.fx(branch(currTP,br),los) $ { UseBranchFlowMIP(currTP) and
4789                                                                      ( ACbranch(branch) or
4790                                                                        [ not ( validLossSegment(branch,los) and
4791                                                                                HVDClink(branch)
4792                                                                              )
4793                                                                        ]
4794                                                                      )
4795                                                                    } = 0 ;
4796   
4797  *                       Fix the lambda integer variable to zero for invalid branches
4798                          LAMBDAINTEGER.fx(currTP,br,los) $ { UseBranchFlowMIP(currTP) and
4799                                                              (not branch(currTP,br)) } = 0 ;
4800   
4801  *                       Fix the value of some binary variables used in the mixed constraints that have no alternate limit
4802                          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4803                              $ { UseMixedConstraintMIP(currTP) and
4804                                  (not Type1MixedConstraintCondition(Type1MixedConstraint))
4805                                } = 0 ;
4806   
4807  *                       Use the advanced basis here
4808                          option bratio = 0.25 ;
4809  *                       Set the optimality criteria for the MIP
4810                          vSPD_MIP.optcr = MIPOptimality ;
4811                          vSPD_MIP.reslim = MIPTimeLimit ;
4812                          vSPD_MIP.iterlim = MIPIterationLimit ;
4813   
4814  *                       Solve the model
4815                          solve vSPD_MIP using mip maximizing NETBENEFIT ;
4816   
4817  *                       Set the model solve status
4818                          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
4819                                                (vSPD_MIP.modelstat = 8)
4820                                              ]
4821                                              and
4822                                              [ vSPD_MIP.solvestat = 1 ]
4823                                            } ;
4824   
4825  *                       Post a progress message for use by EMI.
4826                          if(ModelSolved = 1,
4827                              loop(currTP(tp),
4828                                  putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') FULL integer solve finished at ', system.time '. Solve successful.' /
4829                                                    'Objective function value: ' NETBENEFIT.l:<12:1 /
4830                                                    'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4831                              ) ;
4832                          else
4833                              loop(currTP(tp),
4834                                  putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') FULL integer solve finished at ', system.time '. Solve unsuccessful.' /
4835                              ) ;
4836                          ) ;
4837   
4838                      ) ;
4839   
4840  *               End of if-statement for the rechecking of the solution when ModelSolved = 1
4841                  ) ;
4842   
4843   
4844  *               At this point either :-
4845  *               1. LP is valid (LPvalid = 1) - OK
4846  *               2. LP is invalid and MIP is valid ((1-LPvalid)*ModelSolved = 1) - OK
4847  *               3. LP is invlalid and MIP is invalid (ModelSolved = 0) - Resolve LP
4848   
4849                  if(ModelSolved = 0,
4850  *                   Confirmation that branch flow MIP was unsuccessful we are here
4851                      branchFlowMIPInvoked(currTP) = 0 ;
4852   
4853  *                   Set the bratio to 1 i.e. do not use advanced basis for LP
4854                      option bratio = 1 ;
4855   
4856  *                   Set resource limits
4857                      vSPD.reslim = LPTimeLimit ;
4858                      vSPD.iterlim = LPIterationLimit ;
4859                      solve vSPD using lp maximizing NETBENEFIT ;
4860   
4861  *                   Set the model solve status
4862                      LPModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) } ;
4863   
4864  *                   Post a progress message for use by EMI.
4865                      if( LPModelSolved = 1,
4866                          loop(currTP(tp),
4867                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') integer resolve was unsuccessful. Reverting back to linear solve.' /
4868                                                'The case: FP_20140221_I (' currTP.tl ') linear solve finished at ', system.time '. Solve successful. ' /
4869                                                'Objective function value: ' NETBENEFIT.l:<12:1 /
4870                                                'Violations: ' TOTALPENALTYCOST.l:<12:1 /
4871                                                'Solution may have circulating flows and/or non-physical losses.' /
4872                          ) ;
4873                      else
4874                          loop(currTP(tp),
4875                              putclose runlog / 'The case: FP_20140221_I (' currTP.tl ') integer solve was unsuccessful.  Reverting back to linear solve. Linear solve unsuccessful.' /
4876                          ) ;
4877                      ) ;
4878   
4879  *               End of if-statement when the MIP is invalid and the LP is resolved
4880                  ) ;
4881   
4882  *           End of if-statement when the LP is optimal - part f
4883              ) ;
4884   
4885   
4886   
4887  *           g) Check for disconnected nodes and adjust prices accordingly
4888   
4889  *           See Rule Change Proposal August 2008 - Disconnected nodes available at www.systemoperator.co.nz/reports-papers
4890   
4891              busGeneration(bus(currTP,b)) = sum[ (o,n) $ { offerNode(currTP,o,n) and
4892                                                            NodeBus(currTP,n,b)
4893                                                          }, NodeBusAllocationFactor(currTP,n,b)
4894                                                           * GENERATION.l(currTP,o)
4895                                                ] ;
4896   
4897              busLoad(bus(currTP,b)) = sum[ NodeBus(currTP,n,b), NodeBusAllocationFactor(currTP,n,b)
4898                                                               * NodeDemand(currTP,n)
4899                                          ] ;
4900   
4901              busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
4902                  = ACnodeNetInjectionDefinition2.m(currTP,b) ;
4903   
4904              busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] = DCNodeNetInjection.m(currTP,b) ;
4905   
4906  *           Disconnected nodes are defined as follows:
4907  *           Pre-MSP: Have no generation or load, are disconnected from the network and has a price = CVP.
4908  *           Post-MSP: Indication to SPD whether a bus is dead or not.  Dead buses are not processed by the SPD solved
4909  *           and have their prices set by the post-process with the following rules:
4910   
4911  *           Scenario A/B/D: Price for buses in live electrical island determined by the solved
4912  *           Scenario C/F/G/H/I: Buses in the dead electrical island with:
4913  *           a) Null/zero load: Marked as disconnected with $0 price.
4914  *           b) Positive load: Price = CVP for deficit generation
4915  *           c) Negative load: Price = -CVP for surplus generation
4916  *           Scenario E: Price for bus in live electrical island with zero load and zero cleared generation needs to be adjusted since actually is disconnected.
4917   
4918  *           The Post-MSP implementation imply a mapping of a bus to an electrical island and an indication of whether this electrical island is live of dead.
4919  *           The correction of the prices is performed by SPD.
4920   
4921  *           RDN - 20130302 - i_tradePeriodNodeBusAllocationFactor update - Start-----------
4922  *           Update the disconnected nodes logic to use the time-stamped i_useBusNetworkModel flag
4923  *           This allows disconnected nodes logic to work with both pre and post-MSP data structure in the same gdx file
4924   
4925              if((disconnectedNodePriceCorrection = 1),
4926  *               Pre-MSP case
4927                  busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
4928                      = 1 $ { (busGeneration(bus) = 0) and
4929                              (busLoad(bus) = 0) and
4930                              ( not sum[ br $ { branchBusConnect(currTP,br,b) and
4931                                                ClosedBranch(currTP,br)
4932                                              }, 1 ]
4933                              )
4934                            } ;
4935   
4936  *               Post-MSP cases
4937  *               Scenario C/F/G/H/I:
4938                  busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
4939                                                     (busLoad(bus) = 0) and
4940                                                     (busElectricalIsland(bus) = 0)
4941                                                   } = 1 ;
4942  *               Scenario E:
4943                  busDisconnected(bus(currTP,b)) $ { ( sum[ b1 $ {busElectricalIsland(currTP,b1) = busElectricalIsland(bus)}, busLoad(currTP,b1) ] = 0) and
4944                                                     ( sum[ b1 $ {busElectricalIsland(currTP,b1) = busElectricalIsland(bus)}, busGeneration(currTP,b1) ] = 0) and
4945                                                     ( busElectricalIsland(bus) > 0 ) and
4946                                                     ( i_useBusNetworkModel(currTP) = 1 )
4947                                                   } = 1 ;
4948  *               Set prices at dead buses with non-zero load
4949                  busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
4950                                              (busLoad(bus) > 0) and
4951                                              (busElectricalIsland(bus)= 0)
4952                                            } = DeficitBusGenerationPenalty ;
4953   
4954                  busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
4955                                              (busLoad(bus) < 0) and
4956                                              (busElectricalIsland(bus)= 0)
4957                                            } = -SurplusBusGenerationPenalty ;
4958   
4959  *               Set price at identified disconnected buses to 0
4960                  busPrice(bus)$busDisconnected(bus) = 0 ;
4961              ) ;
4962   
4964   
4965   
4966  *       h) Collect and store results from the current model solve in the output (o_xxx) parameters
4967   
4968  *           Normal FTR run reporting processing
4969              if( (FTRflag = 1),
4970  *               Store reslts for FTR reporting at a trade period level
4971                  loop(i_DateTimeTradePeriodMap(dt,currTP),
4972                      o_dateTime(dt) = yes;
4973   
4974                      o_Bus(dt,b) $ { Bus(currTP,b) and
4975                                      (not DCBus(currTP,b)) } = yes;
4976   
4977  *                   branch data
4978                      o_branch(dt,br) $ Branch(currTP,br) = yes;
4979   
4980                      o_branchFlow_TP(dt,br) $ ACBranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
4981   
4982                      o_branchFlow_TP(dt,br) $ HVDCLink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
4983   
4984                      o_branchDynamicLoss_TP(dt,br) $ { HVDCLink(currTP,br) and
4985                                                        ClosedBranch(currTP,br) }
4986                          = HVDCLINKLOSSES.l(currTP,br);
4987   
4988                      o_branchFromBusPrice_TP(dt,br) $ Branch(currTP,br)
4989                          = sum[ (frB,toB) $ BranchBusDefn(currTP,br,frB,toB), BusPrice(currTP,frB) ];
4990   
4991                      o_branchToBusPrice_TP(dt,br) $ Branch(currTP,br)
4992                          = sum[ (frB,toB) $ BranchBusDefn(currTP,br,frB,toB), BusPrice(currTP,toB) ];
4993   
4994                      o_branchMarginalPrice_TP(dt,br) $ ACBranch(currTP,br)
4995                          = sum[ i_FlowDirection, ACBranchMaximumFlow.m(currTP,br,i_FlowDirection) ];
4996   
4997                      o_branchMarginalPrice_TP(dt,br) $ HVDCLink(currTP,br) = HVDCLinkMaximumFlow.m(currTP,br);
4998   
4999                      o_branchCapacity_TP(dt,br) $ Branch(currTP,br) = i_TradePeriodBranchCapacity(currTP,br);
5000   
5001                      o_BranchTotalLoss_TP(dt,br) $ { ACBranch(currTP,br) and
5002                                                      ClosedBranch(currTP,br)
5003                                                    }
5004                          = ACBranchFixedLoss(currTP,br)
5005                          + sum[ i_FlowDirection, ACBRANCHLOSSESDIRECTED.l(currTP,br,i_FlowDirection) ];
5006   
5007                      o_BranchTotalRentals_TP(dt,br) $ { ACBranch(currTP,br) and
5008                                                        (o_branchFlow_TP(dt,br) >= 0) }
5009                          = (i_TradingPeriodLength/60) * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5010                                                         - o_branchToBusPrice_TP(dt,br)   * o_BranchTotalLoss_TP(dt,br)
5011                                                         - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5012                                                         ];
5013   
5014                      o_BranchTotalRentals_TP(dt,br) $ { ACBranch(currTP,br) and
5015                                                        (o_branchFlow_TP(dt,br) < 0) }
5016                          = (i_TradingPeriodLength/60)* [ o_branchFromBusPrice_TP(dt,br) * abs(o_branchFlow_TP(dt,br))
5017                                                        - o_branchFromBusPrice_TP(dt,br) * o_BranchTotalLoss_TP(dt,br)
5018                                                        - o_branchToBusPrice_TP(dt,br)   * abs(o_branchFlow_TP(dt,br))
5019                                                        ];
5020   
5021  *                   Security constraint data
5022                      o_brConstraint_TP(dt,brCstr) $ BranchConstraint(currTP,brCstr) = yes;
5023   
5024                      o_brConstraintLHS_TP(dt,brCstr) $ { BranchConstraint(currTP,brCstr) and
5025                                                          (BranchConstraintSense(currTP,brCstr) = -1)
5026                                                        } = BranchSecurityConstraintLE.l(currTP,brCstr);
5027   
5028                      o_brConstraintPrice_TP(dt,brCstr) $ { BranchConstraint(currTP,brCstr) and
5029                                                            (BranchConstraintSense(currTP,brCstr) = -1)
5030                                                          } = BranchSecurityConstraintLE.m(currTP,brCstr);
5031   
5032  *                   9. --> FTR Output --> Store all branch flows and shadow prices,
5033  *                   all branch constraint LHS's and shadow prices, and all bus prices for later processing
5034                      o_ACbranchTotalRentals(dt) = sum[ br, o_BranchTotalRentals_TP(dt,br) ];
5035   
5036  *                   Ignoring constraints that contain HVDC link
5037                      o_HVDClink(dt,br) $ HVDCLink(currTP,br) = yes;
5038   
5039                      o_brConstraintLHS_TP(dt,brCstr) $ sum[ br $ { i_TradePeriodBranchConstraintFactors(currTP,brCstr,br) and
5040                                                                    HVDCLink(currTP,br)
5041                                                                  }, 1
5042                                                           ] = 0;
5043   
5044                      o_brConstraintPrice_TP(dt,brCstr) $ sum[ br $ { i_TradePeriodBranchConstraintFactors(currTP,brCstr,br) and
5045                                                                      HVDCLink(currTP,br)
5046                                                                    }, 1
5047                                                             ] = 0;
5048   
5049   
5050                      o_ACbranchLossMW(dt,br,los) $ ACbranch(currTP,br) = ACBranchLossMW(currTP,br,los);
5051                      o_ACbranchLossFactor(dt,br,los) $ ACbranch(currTP,br) = ACBranchLossFactor(currTP,br,los);
5052   
5053                  );
5054   
5055  *           Normal FTR flow reporting processing
5056              elseif (FTRflag = 2),
5057                  loop(i_DateTimeTradePeriodMap(dt,currTP),
5058   
5059  *                   Branch data
5060                      o_branchFlow_TP(dt,br) $ ACBranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
5061   
5062                      o_branchFlow_TP(dt,br) $ HVDCLink(currTP,br) = HVDCLINKFLOW.l(currTP,br) ;
5063   
5064  *                   Security constraint data
5065                      o_brConstraintLHS_TP(dt,brCstr) $ BranchConstraint(currTP,brCstr)
5066                          = BranchSecurityConstraintLE.l(currTP,brCstr) $ (BranchConstraintSense(currTP,brCstr) = -1);
5067   
5069                  );
5070   
5071   
5072  *   Normal vSPD reporting processing
5073              else
5074  *               Check if reporting at trading period level purposes is required...
5075                  if((tradePeriodReports = 1),
5076                      loop(i_dateTimeTradePeriodMap(dt,currTP),
5077                          o_dateTime(dt) = yes ;
5078   
5079  *                       Bus level output
5080                          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
5081   
5082                          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
5083   
5084                          o_busLoad_TP(dt,b) $ bus(currTP,b) = busLoad(currTP,b) ;
5085   
5086                          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
5087   
5088                          o_busRevenue_TP(dt,b) $ bus(currTP,b) = (i_tradingPeriodLength / 60)
5089                                                                * busGeneration(currTP,b)
5090                                                                * busPrice(currTP,b) ;
5091   
5092                          o_busCost_TP(dt,b) $ bus(currTP,b) = (i_tradingPeriodLength / 60)
5093                                                             * busLoad(currTP,b)
5094                                                             * busPrice(currTP,b) ;
5095   
5096                          o_busDeficit_TP(dt,b) $ bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
5097   
5098                          o_busSurplus_TP(dt,b) $ bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
5099   
5100  *                       Node level output
5101                          o_node(dt,n) $ { Node(currTP,n) and (not HVDCnode(currTP,n)) } = yes ;
5102   
5103                          o_nodeGeneration_TP(dt,n) $ Node(currTP,n) = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
5104   
5105                          o_nodeLoad_TP(dt,n) $ Node(currTP,n) = NodeDemand(currTP,n) ;
5106   
5107                          o_nodePrice_TP(dt,n) $ Node(currTP,n) = sum[ b $ NodeBus(currTP,n,b), NodeBusAllocationFactor(currTP,n,b)
5108                                                                                              * busPrice(currTP,b)
5109                                                                     ] ;
5110   
5111                          o_nodeRevenue_TP(dt,n) $ Node(currTP,n) = (i_tradingPeriodLength / 60)
5112                                                                  * o_nodeGeneration_TP(dt,n)
5113                                                                  * o_nodePrice_TP(dt,n) ;
5114   
5115                          o_nodeCost_TP(dt,n) $ Node(currTP,n) = (i_tradingPeriodLength / 60)
5116                                                               * o_nodeLoad_TP(dt,n)
5117                                                               * o_nodePrice_TP(dt,n) ;
5118   
5119                          totalBusAllocation(dt,b) $ bus(currTP,b) = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b) ] ;
5120   
5121                          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0) = NodeBusAllocationFactor(currTP,n,b)
5122                                                                                           / totalBusAllocation(dt,b) ;
5123   
5124                          o_nodeDeficit_TP(dt,n) $ Node(currTP,n) = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5125                                                                                                * DEFICITBUSGENERATION.l(currTP,b)
5126                                                                       ] ;
5127   
5128                          o_nodeSurplus_TP(dt,n) $ Node(currTP,n) = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5129                                                                                                * SURPLUSBUSGENERATION.l(currTP,b)
5130                                                                       ] ;
5131   
5132  *                       branch output
5133                          o_branch(dt,br) $ branch(currTP,br) = yes ;
5134   
5135                          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br) ;
5136   
5137                          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br) ;
5138   
5139                          o_branchDynamicLoss_TP(dt,br) $ { ACbranch(currTP,br) and
5140                                                            ClosedBranch(currTP,br)
5141                                                          } = sum[ i_flowDirection, ACBRANCHLOSSESDIRECTED.l(currTP,br,i_flowDirection) ] ;
5142   
5143                          o_branchDynamicLoss_TP(dt,br) $ { HVDClink(currTP,br) and
5144                                                            ClosedBranch(currTP,br)
5145                                                          } = HVDCLINKLOSSES.l(currTP,br) ;
5146   
5147                          o_branchTotalLoss_TP(dt,br) $ { ACbranch(currTP,br) and ClosedBranch(currTP,br)
5148                                                        } = o_branchDynamicLoss_TP(dt,br) + ACbranchFixedLoss(currTP,br) ;
5149   
5150                          o_branchTotalLoss_TP(dt,br) $ { HVDClink(currTP,br) and
5151                                                          ClosedBranch(currTP,br) and
5152                                                          HVDCpoles(currTP,br) and
5153                                                          (o_branchFlow_TP(dt,br) > 0)
5154                                                        } = HVDCLINKLOSSES.l(currTP,br)
5155                                                          + sum[ br1 $ { HVDClink(currTP,br1) and
5156                                                                         ClosedBranch(currTP,br1) and
5157                                                                         HVDCpoles(currTP,br1)
5158                                                                       }, HVDClinkFixedLoss(currTP,br1)
5159                                                               ] ;
5160   
5161                          o_branchTotalLoss_TP(dt,br) $ { HVDClink(currTP,br) and
5162                                                          ClosedBranch(currTP,br) and
5163                                                          HVDChalfPoles(currTP,br) and
5164                                                          (o_branchFlow_TP(dt,br) > 0)
5165                                                        } = HVDCLINKLOSSES.l(currTP,br)
5166                                                          + sum[ br1 $ { HVDClink(currTP,br1) and
5167                                                                         ClosedBranch(currTP,br1) and
5168                                                                         HVDChalfPoles(currTP,br1)
5169                                                                       }, HVDClinkFixedLoss(currTP,br1)
5170                                                               ] ;
5171   
5172                          o_branchFixedLoss_TP(dt,br) $ { ACbranch(currTP,br) and
5173                                                          ClosedBranch(currTP,br)
5174                                                        } = ACbranchFixedLoss(currTP,br) ;
5175   
5176                          o_branchFixedLoss_TP(dt,br) $ { HVDClink(currTP,br) and
5177                                                          ClosedBranch(currTP,br)
5178                                                        } = HVDClinkFixedLoss(currTP,br) ;
5179   
5180                          o_branchFromBus_TP(dt,br,frB) $ { branch(currTP,br) and
5181                                                            sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5182                                                          } = yes ;
5183   
5184                          o_branchToBus_TP(dt,br,toB) $ { branch(currTP,br) and
5185                                                          sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5186                                                        } = yes ;
5187   
5188                          o_branchFromBusPrice_TP(dt,br) $ branch(currTP,br)
5189                              = sum[ (frB,toB) $ branchBusDefn(currTP,br,frB,toB), busPrice(currTP,frB) ] ;
5190   
5191                          o_branchToBusPrice_TP(dt,br)$branch(currTP,br)
5192                              = sum[ (frB,toB) $ branchBusDefn(currTP,br,frB,toB), busPrice(currTP,toB) ] ;
5193   
5194                          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
5195                              = sum[ i_flowDirection, ACbranchMaximumFlow.m(currTP,br,i_flowDirection) ] ;
5196   
5197                          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br) = HVDClinkMaximumFlow.m(currTP,br) ;
5198   
5199                          o_branchDynamicRentals_TP(dt,br) $ { branch(currTP,br) and
5200                                                               (o_branchFlow_TP(dt,br) >= 0)
5201                                                             } = (i_tradingPeriodLength/60)
5202                                                               * ( o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5203                                                                 - o_branchToBusPrice_TP(dt,br)   * o_branchDynamicLoss_TP(dt,br)
5204                                                                 - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5205                                                                 ) ;
5206   
5207                          o_branchDynamicRentals_TP(dt,br) $ { branch(currTP,br) and
5208                                                               (o_branchFlow_TP(dt,br) < 0)
5209                                                             } = (i_tradingPeriodLength/60)
5210                                                               * ( o_branchToBusPrice_TP(dt,br)    * o_branchFlow_TP(dt,br)
5211                                                                  - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5212                                                                  - o_branchFromBusPrice_TP(dt,br) * o_branchDynamicLoss_TP(dt,br)
5213                                                                 ) ;
5214   
5215                          o_branchTotalRentals_TP(dt,br) $ { branch(currTP,br) and
5216                                                             (o_branchFlow_TP(dt,br) >= 0)
5217                                                           } = (i_tradingPeriodLength/60)
5218                                                             * ( o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5219                                                               - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
5220                                                               - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5221                                                               ) ;
5222   
5223                          o_branchTotalRentals_TP(dt,br) $ { branch(currTP,br) and
5224                                                             (o_branchFlow_TP(dt,br) < 0)
5225                                                           } = (i_tradingPeriodLength/60)
5226                                                             * ( o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
5227                                                               - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
5228                                                               - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
5229   
5230                                                               ) ;
5231   
5232                          o_branchCapacity_TP(dt,br) $ branch(currTP,br) = i_tradePeriodBranchCapacity(currTP,br) ;
5233   
5234  *                       Offer output
5235                          o_offer(dt,o) $ offer(currTP,o) = yes ;
5236   
5237                          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
5238   
5239                          o_offerFIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 1)
5240                                                                       , RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ] ;
5241   
5242                          o_offerSIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 2)
5243                                                                       , RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ] ;
5244   
5245                          o_bidEnergy_TP(dt,i_bid) $ bid(currTP,i_bid) = PURCHASE.l(currTP,i_bid) ;
5246   
5247                          o_bidReserve_TP(dt,i_bid,i_reserveClass) $ bid(currTP,i_bid) = PURCHASEILR.l(currTP,i_bid,i_reserveClass) ;
5248   
5249  *                       Violation reporting based on the CE and ECE
5250                          o_FIRviolation_TP(dt,ild) $ (not diffCeECeCVP) = sum[ i_reserveClass $ (ord(i_reserveClass) = 1)
5251                                                                                , DEFICITRESERVE.l(currTP,ild,i_reserveClass) ] ;
5252   
5253                          o_SIRviolation_TP(dt,ild) $ (not diffCeECeCVP) = sum[ i_reserveClass $ (ord(i_reserveClass) = 2)
5254                                                                                , DEFICITRESERVE.l(currTP,ild,i_reserveClass) ] ;
5255   
5256                          o_FIRviolation_TP(dt,ild) $ (diffCeECeCVP) = sum[ i_reserveClass $ (ord(i_reserveClass) = 1)
5257                                                                            , DEFICITRESERVE_CE.l(currTP,ild,i_reserveClass)
5258                                                                            + DEFICITRESERVE_ECE.l(currTP,ild,i_reserveClass)
5259                                                                          ] ;
5260   
5261                          o_SIRviolation_TP(dt,ild) $ (diffCeECeCVP) = sum[ i_reserveClass $ (ord(i_reserveClass) = 2)
5262                                                                            , DEFICITRESERVE_CE.l(currTP,ild,i_reserveClass)
5263                                                                            + DEFICITRESERVE_ECE.l(currTP,ild,i_reserveClass)
5264                                                                          ] ;
5265   
5266  *                       Security constraint data
5267                          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
5268   
5269                          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = branchConstraintSense(currTP,brCstr) ;
5270   
5271                          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5272                              = branchSecurityConstraintLE.l(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = -1)
5273                              + branchSecurityConstraintGE.l(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = 1)
5274                              + branchSecurityConstraintEQ.l(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = 0) ;
5275   
5276                          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = branchConstraintLimit(currTP,brCstr) ;
5277   
5278                          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5279                              = branchSecurityConstraintLE.m(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = -1)
5280                              + branchSecurityConstraintGE.m(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = 1)
5281                              + branchSecurityConstraintEQ.m(currTP,brCstr) $ (branchConstraintSense(currTP,brCstr) = 0) ;
5282   
5283  *                       Mnode constraint data
5284                          o_MnodeConstraint_TP(dt,MnodeCstr) $ MnodeConstraint(currTP,MnodeCstr) = yes ;
5285   
5286                          o_MnodeConstraintSense_TP(dt,MnodeCstr) $ MnodeConstraint(currTP,MnodeCstr) = MnodeConstraintSense(currTP,MnodeCstr) ;
5287   
5288                          o_MnodeConstraintLHS_TP(dt,MnodeCstr) $ MnodeConstraint(currTP,MnodeCstr)
5289                              = MnodeSecurityConstraintLE.l(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = -1)
5290                              + MnodeSecurityConstraintGE.l(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)
5291                              + MnodeSecurityConstraintEQ.l(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = 0) ;
5292   
5293                          o_MnodeConstraintRHS_TP(dt,MnodeCstr)$MnodeConstraint(currTP,MnodeCstr) = MnodeConstraintLimit(currTP,MnodeCstr) ;
5294   
5295                          o_MnodeConstraintPrice_TP(dt,MnodeCstr)$MnodeConstraint(currTP,MnodeCstr)
5296                              = MnodeSecurityConstraintLE.m(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = -1)
5297                              + MnodeSecurityConstraintGE.m(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)
5298                              + MnodeSecurityConstraintEQ.m(currTP,MnodeCstr) $ (MnodeConstraintSense(currTP,MnodeCstr) = 0) ;
5299   
5300  *                       Island output
5301                          o_island(dt,ild) = yes ;
5302   
5303                          o_islandRefPrice_TP(dt,ild) = sum[ n $ { ReferenceNode(currTP,n) and
5304                                                                   nodeIsland(currTP,n,ild)
5305                                                                 }, o_nodePrice_TP(dt,n) ] ;
5306   
5307                          o_FIRprice_TP(dt,ild) = sum[ i_reserveClass $ (ord(i_reserveClass) = 1)
5308                                                       , SupplyDemandReserveRequirement.m(currTP,ild,i_reserveClass) ] ;
5309   
5310                          o_SIRprice_TP(dt,ild) = sum[ i_reserveClass $ (ord(i_reserveClass) = 2)
5311                                                       , SupplyDemandReserveRequirement.m(currTP,ild,i_reserveClass) ] ;
5312   
5313                          o_islandGen_TP(dt,ild) = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
5314   
5315                          o_islandLoad_TP(dt,ild) = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ] ;
5316   
5317                          o_FIRcleared_TP(dt,ild) = sum[ (o,i_reserveClass,i_reserveType) $ { (ord(i_reserveClass) = 1) and
5318                                                                                              offer(currTP,o) and
5319                                                                                              IslandOffer(currTP,ild,o)
5320                                                                                            }, RESERVE.l(currTP,o,i_reserveClass,i_reserveType)
5321                                                       ] ;
5322   
5323                          o_SIRcleared_TP(dt,ild) = sum[ (o,i_reserveClass,i_reserveType) $ { (ord(i_reserveClass) = 2) and
5324                                                                                              offer(currTP,o) and
5325                                                                                              IslandOffer(currTP,ild,o)
5326                                                                                            }, RESERVE.l(currTP,o,i_reserveClass,i_reserveType)
5327                                                       ] ;
5328   
5329                          o_islandEnergyRevenue_TP(dt,ild) = (i_tradingPeriodLength/60)
5330                                                           * sum[ n $ nodeIsland(currTP,n,ild), o_nodeGeneration_TP(dt,n)
5331                                                                                              * o_nodePrice_TP(dt,n) ] ;
5332   
5333                          o_islandReserveRevenue_TP(dt,ild) = (i_tradingPeriodLength/60)
5334                                                            * [ o_FIRcleared_TP(dt,ild) * o_FIRprice_TP(dt,ild)
5335                                                              + o_SIRcleared_TP(dt,ild) * o_SIRprice_TP(dt,ild)
5336                                                              ] ;
5337   
5338                          o_islandLoadCost_TP(dt,ild) = (i_tradingPeriodLength/60)
5339                                                      * sum[ n $ { nodeIsland(currTP,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
5340                                                           , o_nodeLoad_TP(dt,n) * o_nodePrice_TP(dt,n) ] ;
5341   
5342   
5343                          o_islandLoadRevenue_TP(dt,ild) = (i_tradingPeriodLength/60)
5344                                                         * sum[ n $ { nodeIsland(currTP,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
5345                                                              , - o_nodeLoad_TP(dt,n) * o_nodePrice_TP(dt,n) ] ;
5346   
5347                          o_islandBranchLoss_TP(dt,ild) = sum[ (br,frB,toB) $ { ACbranch(currTP,br) and
5348                                                                                ClosedBranch(currTP,br) and
5349                                                                                branchBusDefn(currTP,br,frB,toB) and
5350                                                                                busIsland(currTP,toB,ild)
5351                                                                              }, o_branchTotalLoss_TP(dt,br)
5352                                                             ] ;
5353   
5354                          o_HVDCflow_TP(dt,ild) = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5355                                                                        ClosedBranch(currTP,br) and
5356                                                                        branchBusDefn(currTP,br,frB,toB) and
5357                                                                        busIsland(currTP,frB,ild)
5358                                                                      }, o_branchFlow_TP(dt,br)
5359                                                     ] ;
5360   
5361   
5362                          o_HVDChalfPoleLoss_TP(dt,ild) = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5363                                                                                ClosedBranch(currTP,br) and
5364                                                                                branchBusDefn(currTP,br,frB,toB) and
5365                                                                                busIsland(currTP,toB,ild) and
5366                                                                                busIsland(currTP,frB,ild)
5367                                                                              }, o_branchTotalLoss_TP(dt,br)
5368                                                             ] ;
5369   
5370                          o_HVDCpoleFixedLoss_TP(dt,ild) = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5371                                                                                 ClosedBranch(currTP,br) and
5372                                                                                 branchBusDefn(currTP,br,frB,toB) and
5373                                                                                 ( busIsland(currTP,toB,ild) or
5374                                                                                   busIsland(currTP,frB,ild)
5375                                                                                 )
5376                                                                               }, 0.5 * o_branchFixedLoss_TP(dt,br)
5377                                                              ] ;
5378   
5379                          o_HVDCloss_TP(dt,ild) = o_HVDChalfPoleLoss_TP(dt,ild)
5380                                                + o_HVDCpoleFixedLoss_TP(dt,ild)
5381                                                + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
5382                                                                        ClosedBranch(currTP,br) and
5383                                                                        branchBusDefn(currTP,br,frB,toB) and
5384                                                                        busIsland(currTP,toB,ild) and
5385                                                                        (not (busIsland(currTP,frB,ild)))
5386                                                                      }, o_branchDynamicLoss_TP(dt,br)
5387                                                     ] ;
5388   
5389   
5390  *                       Additional output for audit reporting
5391                          o_ACbusAngle(dt,b) = ACnodeANGLE.l(currTP,b) ;
5392   
5393                          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br) - ManualLossCalculation(currTP,br) ;
5394   
5395                          o_lossSegmentBreakPoint(dt,br,los) $ validLossSegment(currTP,br,los) = LossSegmentMW(currTP,br,los) ;
5396   
5397                          o_lossSegmentFactor(dt,br,los) $ validLossSegment(currTP,br,los) = LossSegmentFactor(currTP,br,los) ;
5398   
5399                          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
5400   
5401   
5402                          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,PLSRReserveType) $ (ord(i_reserveClass) = 1)
5403                                                                     , RESERVE.l(currTP,o,i_reserveClass,PLSRReserveType) ] ;
5404   
5405                          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,PLSRReserveType) $ (ord(i_reserveClass) = 2)
5406                                                                     , RESERVE.l(currTP,o,i_reserveClass,PLSRReserveType)] ;
5407   
5408                          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,TWDRReserveType) $ (ord(i_reserveClass) = 1)
5409                                                                     , RESERVE.l(currTP,o,i_reserveClass,TWDRReserveType)] ;
5410   
5411                          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,TWDRReserveType) $ (ord(i_reserveClass) = 2)
5412                                                                     , RESERVE.l(currTP,o,i_reserveClass,TWDRReserveType)] ;
5413   
5414                          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,ILReserveType) $ (ord(i_reserveClass) = 1)
5415                                                                     , RESERVE.l(currTP,o,i_reserveClass,ILReserveType)] ;
5416   
5417                          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o) = sum[ (i_reserveClass,ILReserveType) $ (ord(i_reserveClass) = 2)
5418                                                                     , RESERVE.l(currTP,o,i_reserveClass,ILReserveType)] ;
5419   
5420                          o_ILbus_FIR_TP(dt,b) = sum[ o $ sameas(o,b), o_ILRO_FIR_TP(dt,o) ] ;
5421   
5422                          o_ILbus_SIR_TP(dt,b) = sum[ o $ sameas(o,b), o_ILRO_SIR_TP(dt,o) ] ;
5423   
5424                          o_marketNodeIsland_TP(dt,o,ild) $ sum[ (n,b) $ { BusIsland(currTP,b,ild) and
5425                                                                           NodeBus(currTP,n,b) and
5426                                                                           offerNode(currTP,o,n) and
5427                                                                           (o_nodeLoad_TP(dt,n)  = 0)
5428                                                                         },1
5429                                                               ] = yes ;
5430   
5431                          o_generationRiskLevel(dt,ild,o,i_reserveClass,GenRisk) $ { (not UsePrimSecGenRiskModel) and
5432                                                                                     IslandRiskGenerator(currTP,ild,o)
5433                                                                                   }
5434                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,GenRisk)
5435                              * [ GENERATION.l(currTP,o)
5436                                - FreeReserve(currTP,ild,i_reserveClass,GenRisk)
5437                                + FKband(currTP,o)
5438                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5439                                ] ;
5440   
5441                          o_generationRiskLevel(dt,ild,o,i_reserveClass,GenRisk) $ { UsePrimSecGenRiskModel and
5442                                                                                     IslandRiskGenerator(currTP,ild,o) and
5443                                                                                     ( not ( HasSecondaryOffer(currTP,o) or
5444                                                                                             HasPrimaryOffer(currTP,o) )
5445                                                                                     )
5446                                                                                   }
5447                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,GenRisk)
5448                              * [ GENERATION.l(currTP,o)
5449                                - FreeReserve(currTP,ild,i_reserveClass,GenRisk)
5450                                + FKband(currTP,o)
5451                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5452                                ] ;
5453   
5454                          o_generationRiskLevel(dt,ild,o,i_reserveClass,GenRisk) $ { UsePrimSecGenRiskModel and
5455                                                                                     IslandRiskGenerator(currTP,ild,o) and
5456                                                                                     HasSecondaryOffer(currTP,o)
5457                                                                                   }
5458                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,GenRisk)
5459                              * [ GENERATION.l(currTP,o)
5460                                + sum[ o1 $ PrimarySecondaryOffer(currTP,o,o1), GENERATION.l(currTP,o1) ]
5461                                - FreeReserve(currTP,ild,i_reserveClass,GenRisk)
5462                                + FKband(currTP,o)
5463                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5464                                + sum[ (o1,i_reserveType) $ PrimarySecondaryOffer(currTP,o,o1)
5465                                     , RESERVE.l(currTP,o1,i_reserveClass,i_reserveType) ]
5466                                ] ;
5467   
5468                          o_generationRiskLevelMax(dt,ild,o,i_reserveClass)
5469                              = smax[ GenRisk, o_generationRiskLevel(dt,ild,o,i_reserveClass,GenRisk) ] ;
5470   
5471                          o_HVDCriskLevel(dt,ild,i_reserveClass,HVDCrisk)
5472                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,HVDCrisk)
5473                              * [ HVDCREC.l(currTP,ild) - RISKOFFSET.l(currTP,ild,i_reserveClass,HVDCrisk) ] ;
5474   
5475                          o_manuRiskLevel(dt,ild,i_reserveClass,ManualRisk)
5476                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,ManualRisk)
5477                              * [ IslandMinimumRisk(currTP,ild,i_reserveClass,ManualRisk)
5478                                - FreeReserve(currTP,ild,i_reserveClass,ManualRisk)
5479                                ] ;
5480   
5481                          o_genHVDCriskLevel(dt,ild,o,i_reserveClass,HVDCsecRisk) $ { (not (UsePrimSecGenRiskModel)) and
5482                                                                                       HVDCsecRiskEnabled(currTP,ild,HVDCsecRisk) and
5483                                                                                       IslandRiskGenerator(currTP,ild,o)
5484                                                                                     }
5485                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,HVDCsecRisk)
5486                              * [ GENERATION.l(currTP,o)
5487                                - FreeReserve(currTP,ild,i_reserveClass,HVDCsecRisk)
5488                                + HVDCREC.l(currTP,ild)
5489                                - HVDCsecRiskSubtractor(currTP,ild)
5490                                + FKband(currTP,o)
5491                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5492                                ] ;
5493   
5494                          o_manuHVDCriskLevel(dt,ild,i_reserveClass,HVDCsecRisk) $ HVDCsecRiskEnabled(currTP,ild,HVDCsecRisk)
5495                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,HVDCsecRisk)
5496                              * [ HVDCsecIslandMinimumRisk(currTP,ild,i_reserveClass,HVDCsecRisk)
5497                                - FreeReserve(currTP,ild,i_reserveClass,HVDCsecRisk)
5498                                + HVDCREC.l(currTP,ild)
5499                                - HVDCsecRiskSubtractor(currTP,ild)
5500                                ] ;
5501   
5502                          o_genHVDCriskLevel(dt,ild,o,i_reserveClass,HVDCsecRisk) $ { UsePrimSecGenRiskModel and
5503                                                                                      HVDCsecRiskEnabled(currTP,ild,HVDCsecRisk) and
5504                                                                                      IslandRiskGenerator(currTP,ild,o) and
5505                                                                                      (not ( HasSecondaryOffer(currTP,o) or
5506                                                                                             HasPrimaryOffer(currTP,o) )
5507                                                                                      )
5508                                                                                    }
5509                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,HVDCsecRisk)
5510                              * [ GENERATION.l(currTP,o)
5511                                - FreeReserve(currTP,ild,i_reserveClass,HVDCsecRisk)
5512                                + HVDCREC.l(currTP,ild)
5513                                - HVDCsecRiskSubtractor(currTP,ild)
5514                                + FKband(currTP,o)
5515                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5516                                ] ;
5517   
5518                          o_genHVDCriskLevel(dt,ild,o,i_reserveClass,HVDCsecRisk) $ { UsePrimSecGenRiskModel and
5519                                                                                      HVDCsecRiskEnabled(currTP,ild,HVDCsecRisk) and
5520                                                                                      IslandRiskGenerator(currTP,ild,o) and
5521                                                                                      HasSecondaryOffer(currTP,o)
5522                                                                                     }
5523                              = IslandRiskAdjustmentFactor(currTP,ild,i_reserveClass,HVDCsecRisk)
5524                              * [ GENERATION.l(currTP,o)
5525                                + sum[ o1 $ PrimarySecondaryOffer(currTP,o,o1), GENERATION.l(currTP,o1) ]
5526                                - FreeReserve(currTP,ild,i_reserveClass,HVDCsecRisk)
5527                                + HVDCREC.l(currTP,ild)
5528                                - HVDCsecRiskSubtractor(currTP,ild)
5529                                + FKband(currTP,o)
5530                                + sum[ i_reserveType, RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ]
5531                                + sum[ (o1,i_reserveType) $ PrimarySecondaryOffer(currTP,o,o1)
5532                                     , RESERVE.l(currTP,o1,i_reserveClass,i_reserveType) ]
5533                                ] ;
5534   
5535   
5536                          o_genHVDCriskLevelMax(dt,ild,o,i_reserveClass)
5537                              = smax[ HVDCsecRisk, o_genHVDCriskLevel(dt,ild,o,i_reserveClass,HVDCsecRisk) ] ;
5538   
5539                          o_HVDCriskLevelMax(dt,ild,i_reserveClass)
5540                              = smax[ HVDCrisk, o_HVDCriskLevel(dt,ild,i_reserveClass,HVDCrisk) ] ;
5541   
5542                          o_manuRiskLevelMax(dt,ild,i_reserveClass)
5543                              = smax[ ManualRisk, o_manuRiskLevel(dt,ild,i_reserveClass,ManualRisk) ] ;
5544   
5545                          o_manuHVDCriskLevelMax(dt,ild,i_reserveClass)
5546                              = smax[ HVDCsecRisk, o_manuHVDCriskLevel(dt,ild,i_reserveClass,HVDCsecRisk) ] ;
5547   
5548  *                       FIR and SIR required based on calculations of the island risk to overcome reporting issues of
5549  *                       the risk setter under degenerate conditions when reserve price = 0 - See below
5550                          o_FIRreqd_TP(dt,ild)
5551                              = Max[ 0,
5552                                     smax[ (i_reserveClass,o) $ (ord(i_reserveClass) = 1), o_generationRiskLevelMax(dt,ild,o,i_reserveClass) ],
5553                                     sum[ i_reserveClass $ (ord(i_reserveClass) = 1), o_HVDCriskLevelMax(dt,ild,i_reserveClass) ],
5554                                     sum[ i_reserveClass $ (ord(i_reserveClass) = 1), o_manuRiskLevelMax(dt,ild,i_reserveClass) ],
5555                                     smax[ (i_reserveClass,o) $ (ord(i_reserveClass) = 1), o_genHVDCriskLevelMax(dt,ild,o,i_reserveClass) ],
5556                                     sum[ i_reserveClass$(ord(i_reserveClass) = 1), o_manuHVDCriskLevelMax(dt,ild,i_reserveClass) ]
5557                                   ] ;
5558   
5559                          o_SIRreqd_TP(dt,ild)
5560                              = Max[ 0,
5561                                     smax[ (i_reserveClass,o) $ (ord(i_reserveClass) = 2), o_generationRiskLevelMax(dt,ild,o,i_reserveClass) ],
5562                                     sum[ i_reserveClass $ (ord(i_reserveClass) = 2), o_HVDCriskLevelMax(dt,ild,i_reserveClass) ],
5563                                     sum[ i_reserveClass $ (ord(i_reserveClass) = 2), o_manuRiskLevelMax(dt,ild,i_reserveClass) ],
5564                                     smax[ (i_reserveClass,o) $ (ord(i_reserveClass) = 2), o_genHVDCriskLevelMax(dt,ild,o,i_reserveClass) ],
5565                                     sum[ i_reserveClass $ (ord(i_reserveClass) = 2), o_manuHVDCriskLevelMax(dt,ild,i_reserveClass) ]
5566                                   ] ;
5567   
5568  *                       Summary reporting
5569                          o_solveOK_TP(dt) = ModelSolved ;
5570   
5571                          o_systemCost_TP(dt) = sum[ (o,trdBlk) $ validGenerationOfferBlock(currTP,o,trdBlk)
5572                                                   , GENERATIONBLOCK.l(currTP,o,trdBlk)
5573                                                   * GenerationOfferPrice(currTP,o,trdBlk)
5574                                                   ]
5575                                              + sum[ (o,trdBlk,i_reserveClass,i_reserveType) $ validReserveOfferBlock(currTP,o,trdBlk,i_reserveClass,i_reserveType)
5576                                                   , RESERVEBLOCK.l(currTP,o,trdBlk,i_reserveClass,i_reserveType)
5577                                                   * reserveOfferPrice(currTP,o,trdBlk,i_reserveClass,i_reserveType)
5578                                                   ]
5579                                              + sum[ (i_bid,trdBlk,i_reserveClass) $ validPurchaseBidILRBlock(currTP,i_bid,trdBlk,i_reserveClass)
5580                                                    , PURCHASEILRBLOCK.l(currTP,i_bid,trdBlk,i_reserveClass)
5581                                                   ] ;
5582   
5583                          o_penaltyCost_TP(dt) = sum[ b $ bus(currTP,b)
5584                                                      , DeficitBusGenerationPenalty * DEFICITBUSGENERATION.l(currTP,b)
5585                                                      + SurplusBusGenerationPenalty * SURPLUSBUSGENERATION.l(currTP,b)
5586                                                    ]
5587                                               + sum[ br $ branch(currTP,br)
5588                                                      , SurplusBranchFlowPenalty * SURPLUSBRANCHFLOW.l(currTP,br) ]
5589                                               + sum[ o $ offer(currTP,o)
5590                                                      , DeficitRampRatePenalty * DEFICITRAMPRATE.l(currTP,o)
5591                                                      + SurplusRampRatePenalty * SURPLUSRAMPRATE.l(currTP,o)
5592                                                    ]
5593                                               + sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
5594                                                      , DeficitACnodeConstraintPenalty * DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr)
5595                                                      + SurplusACnodeConstraintPenalty * SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr)
5596                                                    ]
5597                                               + sum[ brCstr $ branchConstraint(currTP,brCstr)
5598                                                      , DeficitBranchGroupConstraintPenalty * DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr)
5599                                                      + SurplusBranchGroupConstraintPenalty * SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr)
5600                                                    ]
5601                                               + sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
5602                                                      , DeficitMnodeConstraintPenalty * DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr)
5603                                                      + SurplusMnodeConstraintPenalty * SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr)
5604                                                    ]
5605                                               + sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
5606                                                      , Type1DeficitMixedConstraintPenalty * DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr)
5607                                                      + Type1SurplusMixedConstraintPenalty * SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr)
5608                                                    ]
5609                                               + sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
5610                                                      , DeficitGenericConstraintPenalty * DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr)
5611                                                      + SurplusGenericConstraintPenalty * SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr)
5612                                                    ]
5613                                               + sum[ (ild,i_reserveClass)
5614                                                      , DeficitReservePenalty(i_reserveClass) * DEFICITRESERVE.l(currTP,ild,i_reserveClass) $ (not diffCeECeCVP)
5615                                                      + DeficitReservePenalty_CE(i_reserveClass) * DEFICITRESERVE_CE.l(currTP,ild,i_reserveClass) $ diffCeECeCVP
5616                                                      + DeficitReservePenalty_ECE(i_reserveClass) * DEFICITRESERVE_ECE.l(currTP,ild,i_reserveClass) $ diffCeECeCVP
5617                                                    ]
5618                                               - sum[ (i_bid,trdBlk) $ validPurchaseBidBlock(currTP,i_bid,trdBlk)
5619                                                      , PURCHASEBLOCK.l(currTP,i_bid,trdBlk) * purchaseBidPrice(currTP,i_bid,trdBlk)
5620                                                    ] ;
5621   
5622                          o_ofv_TP(dt) = o_systemCost_TP(dt) + o_penaltyCost_TP(dt);
5623   
5624  *                       Separete violation reporting at trade period level
5625                          o_defGenViolation_TP(dt) = sum[ b $ bus(currTP,b),  DEFICITBUSGENERATION.l(currTP,b) ] ;
5626   
5627                          o_surpGenViolation_TP(dt) = sum[ b$bus(currTP,b), SURPLUSBUSGENERATION.l(currTP,b) ] ;
5628   
5629                          o_surpBranchFlow_TP(dt) = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
5630   
5631                          o_defRampRate_TP(dt) = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
5632   
5633                          o_surpRampRate_TP(dt) = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
5634   
5635                          o_surpBranchGroupConst_TP(dt) = sum[ brCstr $ branchConstraint(currTP,brCstr)
5636                                                               , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
5637   
5638                          o_defBranchGroupConst_TP(dt) = sum[ brCstr $ branchConstraint(currTP,brCstr)
5639                                                              , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
5640   
5641                          o_defMnodeConst_TP(dt) = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
5642                                                        , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
5643   
5644                          o_surpMnodeConst_TP(dt) = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
5645                                                         , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
5646   
5647                          o_defACnodeConst_TP(dt) = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
5648                                                         , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
5649   
5650                          o_surpACnodeConst_TP(dt) = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
5651                                                          , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
5652   
5653                          o_defT1MixedConst_TP(dt) = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
5654                                                          , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
5655   
5656                          o_surpT1MixedConst_TP(dt) = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
5657                                                           , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
5658   
5659                          o_defGenericConst_TP(dt) = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
5660                                                          , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
5661   
5662                          o_surpGenericConst_TP(dt) =  sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
5663                                                            , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
5664   
5665                          o_defResv_TP(dt) =  sum[ (ild,i_reserveClass)
5666                                                   , DEFICITRESERVE.l(currTP,ild,i_reserveClass) $ (not diffCeECeCVP)
5667                                                   + DEFICITRESERVE_CE.l(currTP,ild,i_reserveClass) $ diffCeECeCVP
5668                                                   + DEFICITRESERVE_ECE.l(currTP,ild,i_reserveClass) $ diffCeECeCVP
5669                                                 ] ;
5670   
5671                          o_totalViolation_TP(dt) = o_defGenViolation_TP(dt)
5672                                                  + o_surpGenViolation_TP(dt)
5673                                                  + o_surpBranchFlow_TP(dt)
5674                                                  + o_defRampRate_TP(dt)
5675                                                  + o_surpRampRate_TP(dt)
5676                                                  + o_surpBranchGroupConst_TP(dt)
5677                                                  + o_defBranchGroupConst_TP(dt)
5678                                                  + o_defMnodeConst_TP(dt)
5679                                                  + o_surpMnodeConst_TP(dt)
5680                                                  + o_defACnodeConst_TP(dt)
5681                                                  + o_surpACnodeConst_TP(dt)
5682                                                  + o_defT1MixedConst_TP(dt)
5683                                                  + o_surpT1MixedConst_TP(dt)
5684                                                  + o_defGenericConst_TP(dt)
5685                                                  + o_surpGenericConst_TP(dt)
5686                                                  + o_defResv_TP(dt) ;
5687   
5688                      ) ;
5689   
5690                  ) ;
5691   
5692   
5693  *               Summary reports
5694  *               System level
5695                  o_numTradePeriods = o_numTradePeriods + sum(currTP,1) ;
5696   
5697                  o_systemOFV = o_systemOFV + NETBENEFIT.l ;
5698   
5699                  o_systemGen = o_systemGen + sum(bus,BusGeneration(bus)) ;
5700   
5701                  o_systemLoad = o_systemLoad + sum(bus,BusLoad(bus)) ;
5702   
5703                  o_systemLoss = o_systemLoss + sum[ (ClosedBranch,i_flowDirection), ACBRANCHLOSSESDIRECTED.l(ClosedBranch,i_flowDirection) ]
5704                                              + sum[ ClosedBranch, ACbranchFixedLoss(ClosedBranch) ]
5705                                              + sum[ ClosedBranch, HVDCLINKLOSSES.l(ClosedBranch) + HVDClinkFixedLoss(ClosedBranch) ] ;
5706   
5707                  o_systemViolation = o_systemViolation
5708   
5709                                    + sum[ bus, DEFICITBUSGENERATION.l(bus) + SURPLUSBUSGENERATION.l(bus) ]
5710   
5711                                    + sum[ (currTP,ild,i_reserveClass), DEFICITRESERVE.l(currTP,ild,i_reserveClass) $ (not diffCeECeCVP)
5712                                                                      + DEFICITRESERVE_CE.l(currTP,ild,i_reserveClass) $ (diffCeECeCVP)
5713                                                                      + DEFICITRESERVE_ECE.l(currTP,ild,i_reserveClass) $ (diffCeECeCVP)
5714                                         ]
5715                                    + sum[ branchConstraint, DEFICITBRANCHSECURITYCONSTRAINT.l(branchConstraint)
5716                                                           + SURPLUSBRANCHSECURITYCONSTRAINT.l(branchConstraint) ]
5717   
5718                                    + sum[ offer, DEFICITRAMPRATE.l(offer) + SURPLUSRAMPRATE.l(offer) ]
5719   
5720                                    + sum[ ACnodeConstraint, DEFICITACnodeCONSTRAINT.l(ACnodeConstraint)
5721                                                           + SURPLUSACnodeCONSTRAINT.l(ACnodeConstraint) ]
5722   
5723                                    + sum[ branch, DEFICITBRANCHFLOW.l(branch) + SURPLUSBRANCHFLOW.l(branch) ]
5724   
5725                                    + sum[ MnodeConstraint, DEFICITMnodeCONSTRAINT.l(MnodeConstraint)
5726                                                          + SURPLUSMnodeCONSTRAINT.l(MnodeConstraint) ]
5727   
5728                                    + sum[ (currTP,t1MixCstr), DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr)
5729                                                             + SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ]
5730   
5731                                    + sum[ GenericConstraint, SURPLUSGENERICCONSTRAINT.l(GenericConstraint)
5732                                                            + DEFICITGENERICCONSTRAINT.l(GenericConstraint) ] ;
5733   
5734   
5735                  o_systemFIR = o_systemFIR + sum[ (offer,i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 1)
5736                                                   , RESERVE.l(offer,i_reserveClass,i_reserveType)
5737                                                 ]
5738                                            + sum[ (bid,i_reserveClass) $ (ord(i_reserveClass) = 1)
5739                                                   , PURCHASEILR.l(bid,i_reserveClass)
5740                                                 ] ;
5741   
5742   
5743                  o_systemSIR = o_systemSIR + sum[ (offer,i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 2)
5744                                                   , RESERVE.l(offer,i_reserveClass,i_reserveType)
5745                                                 ]
5746                                            + sum[ (bid,i_reserveClass) $ (ord(i_reserveClass) = 2)
5747                                                  , PURCHASEILR.l(bid,i_reserveClass)
5748                                                 ] ;
5749   
5750                  o_systemEnergyRevenue = o_systemEnergyRevenue
5751                                        + (i_tradingPeriodLength/60) * sum[ (currTP,o,b,n) $ { offerNode(currTP,o,n) and
5752                                                                                               NodeBus(currTP,n,b)
5753                                                                                             }, NodeBusAllocationFactor(currTP,n,b)
5754                                                                                                * GENERATION.l(currTP,o)
5755                                                                                                * busPrice(currTP,b)
5756                                                                          ] ;
5757   
5758                  o_systemReserveRevenue = o_systemReserveRevenue
5759                                         + (i_tradingPeriodLength/60) * sum[ (currTP,ild,o,n,b,i_reserveClass,i_reserveType)
5760                                                                             $ { offerNode(currTP,o,n) and
5761                                                                                 NodeBus(currTP,n,b) and
5762                                                                                 BusIsland(currTP,b,ild)
5763                                                                               }, SupplyDemandReserveRequirement.m(currTP,ild,i_reserveClass)
5764                                                                                * RESERVE.l(currTP,o,i_reserveClass,i_reserveType)
5765                                                                           ] ;
5766   
5767                  o_systemLoadCost = o_systemLoadCost
5768                                   + (i_tradingPeriodLength/60) * sum[ (currTP,b,n) $ { NodeBus(currTP,n,b) and
5769                                                                                        (NodeDemand(currTP,n) >= 0)
5770                                                                                      }, NodeBusAllocationFactor(currTP,n,b)
5771                                                                                       * NodeDemand(currTP,n) * busPrice(currTP,b)
5772                                                                     ] ;
5773   
5774                  o_systemLoadRevenue = o_systemLoadRevenue
5775                                      + (i_tradingPeriodLength/60) * sum[ (currTP,b,n) $ { NodeBus(currTP,n,b) and
5776                                                                                           (NodeDemand(currTP,n) < 0)
5777                                                                                         }, - NodeBusAllocationFactor(currTP,n,b)
5778                                                                                            * NodeDemand(currTP,n)
5779                                                                                            * busPrice(currTP,b)
5780                                                                        ] ;
5781                  o_systemACrentals = o_systemACrentals + sum[ (currTP,dt,br) $ { i_dateTimeTradePeriodMap(dt,currTP) and
5782                                                                                  ACbranch(currTP,br)
5783                                                                                }, o_branchTotalRentals_TP(dt,br)
5784                                                             ] ;
5785   
5786                  o_systemDCrentals = o_systemDCrentals + sum[ (currTP,dt,br) $ { i_dateTimeTradePeriodMap(dt,currTP) and
5787                                                                                  HVDClink(currTP,br)
5788                                                                                }, o_branchTotalRentals_TP(dt,br)
5789                                                             ] ;
5790   
5791  *               Offer level
5792  *               This does not include revenue from wind generators for final pricing because the wind generation
5793  *               is netted off against load at the particular bus for the final pricing solves
5794                  o_offerTrader(o,trdr) $ sum[ currTP $ i_tradePeriodOfferTrader(currTP,o,trdr), 1 ] = yes ;
5795   
5796                  o_offerGen(o) = o_offerGen(o) + (i_tradingPeriodLength/60) * sum[ currTP, GENERATION.l(currTP,o) ] ;
5797   
5798                  o_offerFIR(o) = o_offerFIR(o) + (i_tradingPeriodLength/60)
5799                                                * sum[ (currTP,i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 1)
5800                                                       , RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ] ;
5801   
5802                  o_offerSIR(o) = o_offerSIR(o) + (i_tradingPeriodLength/60)
5803                                                * sum[ (currTP,i_reserveClass,i_reserveType) $ (ord(i_reserveClass) = 2)
5804                                                       , RESERVE.l(currTP,o,i_reserveClass,i_reserveType) ] ;
5805   
5806                  o_offerGenRevenue(o) = o_offerGenRevenue(o)
5807                                       + (i_tradingPeriodLength/60) * sum[ (currTP,b,n) $ { offerNode(currTP,o,n) and
5808                                                                                            NodeBus(currTP,n,b)
5809                                                                                          }, NodeBusAllocationFactor(currTP,n,b)
5810                                                                                           * GENERATION.l(currTP,o)
5811                                                                                           * busPrice(currTP,b)
5812                                                                         ] ;
5813   
5814                  o_offerFIRrevenue(o) = o_offerFIRrevenue(o)
5815                                       + (i_tradingPeriodLength/60) * sum[ (currTP,ild,n,b,i_reserveClass,i_reserveType)
5816                                                                           $ { (ord(i_reserveClass) = 1) and
5817                                                                               offerNode(currTP,o,n) and
5818                                                                               NodeBus(currTP,n,b) and
5819                                                                               BusIsland(currTP,b,ild)
5820                                                                             }, SupplyDemandReserveRequirement.m(currTP,ild,i_reserveClass)
5821                                                                              * RESERVE.l(currTP,o,i_reserveClass,i_reserveType)
5822                                                                         ] ;
5823   
5824                  o_offerSIRrevenue(o) = o_offerSIRrevenue(o)
5825                                      + (i_tradingPeriodLength/60) * sum[ (currTP,ild,n,b,i_reserveClass,i_reserveType)
5826                                                                           $ { (ord(i_reserveClass) = 2) and
5827                                                                               offerNode(currTP,o,n) and
5828                                                                               NodeBus(currTP,n,b) and
5829                                                                               BusIsland(currTP,b,ild)
5830                                                                             }, SupplyDemandReserveRequirement.m(currTP,ild,i_reserveClass)
5831                                                                              * RESERVE.l(currTP,o,i_reserveClass,i_reserveType)
5832                                                                         ] ;
5833   
5834              );
5835   
5836  *       End of if statement for the resolve skipped
5837          ) ;
5838   
5839  * End of if statement to determine which periods to solve
5840      ) ;
5841   
5842      if(skipResolve,
5843  *       Set to sequential solve if the simultaneous solve failed and reset iteration counter
5844          sequentialSolve = 1 ;
5845          iterationCount = 0 ;
5846  *       Reset some of the reporting parameters if reverting to a sequential solve after simultaneous solve fails
5847          o_numTradePeriods = 0 ;
5848          o_systemOFV = 0 ;
5849          o_systemGen = 0 ;
5850          o_systemLoad = 0 ;
5851          o_systemLoss = 0 ;
5852          o_systemViolation = 0 ;
5853          o_systemFIR = 0 ;
5854          o_systemSIR = 0 ;
5855          o_systemEnergyRevenue = 0 ;
5856          o_systemReserveRevenue = 0 ;
5857          o_systemLoadCost = 0 ;
5858          o_systemLoadRevenue = 0 ;
5859          o_systemACrentals = 0 ;
5860          o_systemDCrentals = 0 ;
5861          o_offerGen(o) = 0 ;
5862          o_offerFIR(o) = 0 ;
5863          o_offerSIR(o) = 0 ;
5864          o_offerGenRevenue(o) = 0 ;
5865          o_offerFIRrevenue(o) = 0 ;
5866          o_offerSIRrevenue(o) = 0 ;
5867      ) ;
5868   
5869   
5870  * i) End of the solve vSPD loop
5871  ] ;
5872   
5873   
5874   
5875  *=====================================================================================
5876  * 9. Write results to GDX files
5877  *=====================================================================================
5878  * Report the results from the above solves and write out summary report
5879   
5880  if( (FTRflag = 0),
5881  *   Normal vSPD run output
5882  *   System level
5883      o_fromDateTime(dt)$( ord(dt) = 1 ) = yes ;
5884   
5885  *   System surplus needs to be calculated outside the main loop
5886      o_systemSurplus = o_systemLoadCost - o_systemLoadRevenue - o_systemEnergyRevenue ;
5887   
5888      execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_SystemOutput.gdx'
5889                     o_fromDateTime, o_numTradePeriods, o_systemOFV, o_systemGen
5890                     o_systemLoad, o_systemLoss, o_systemViolation, o_systemFIR
5891                     o_systemSIR, o_systemEnergyRevenue, o_systemLoadCost
5892                     o_systemLoadRevenue, o_systemSurplus ;
5893   
5894  *   Offer level
5895      execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_OfferOutput.gdx'
5896                     i_offer, i_trader, o_offerTrader, o_offerGen, o_offerFIR, o_offerSIR ;
5897   
5898  *   Trader level
5899  *   Currently this does not include revenue from wind generators since wind generation in FP is represented as negative load
5900      o_trader(trdr) = yes ;
5901      o_traderGen(trdr) = sum(o$o_offerTrader(o,trdr), o_offerGen(o)) ;
5902      o_traderFIR(trdr) = sum(o$o_offerTrader(o,trdr), o_offerFIR(o)) ;
5903      o_traderSIR(trdr) = sum(o$o_offerTrader(o,trdr), o_offerSIR(o)) ;
5904      o_traderGenRevenue(trdr) = sum(o$o_offerTrader(o,trdr), o_offerGenRevenue(o)) ;
5905      o_traderFIRrevenue(trdr) = sum(o$o_offerTrader(o,trdr), o_offerFIRrevenue(o)) ;
5906      o_traderSIRrevenue(trdr) = sum(o$o_offerTrader(o,trdr), o_offerSIRrevenue(o)) ;
5907   
5908      execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_TraderOutput.gdx'
5909                     o_trader, o_traderGen, o_traderFIR, o_traderSIR ;
5910   
5911  *   Write out detailed reports if requested
5912      if(tradePeriodReports = 1,
5913   
5914          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_SummaryOutput_TP.gdx'
5915                         o_dateTime, o_solveOK_TP, o_systemCost_TP, o_defGenViolation_TP
5916                         o_surpGenViolation_TP, o_surpBranchFlow_TP, o_defRampRate_TP
5917                         o_surpRampRate_TP, o_surpBranchGroupConst_TP, o_defBranchGroupConst_TP
5918                         o_defMnodeConst_TP, o_surpMnodeConst_TP, o_defACnodeConst_TP
5919                         o_surpACnodeConst_TP, o_defT1MixedConst_TP, o_surpT1MixedConst_TP
5920                         o_defGenericConst_TP, o_surpGenericConst_TP, o_defResv_TP, o_totalViolation_TP
5921                         o_ofv_TP, o_penaltyCost_TP ;
5922   
5923          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_IslandOutput_TP.gdx'
5924                         o_islandGen_TP, o_islandLoad_TP, o_islandEnergyRevenue_TP
5925                         o_islandLoadCost_TP, o_islandLoadRevenue_TP, o_islandBranchLoss_TP
5926                         o_HVDCflow_TP, o_HVDCloss_TP, o_islandRefPrice_TP ;
5927   
5928          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_BusOutput_TP.gdx'
5929                         o_bus, o_busGeneration_TP, o_busLoad_TP, o_busPrice_TP, o_busRevenue_TP
5930                         o_busCost_TP, o_busDeficit_TP, o_busSurplus_TP ;
5931   
5932          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_BranchOutput_TP.gdx'
5933                         o_branch, o_branchFromBus_TP, o_branchToBus_TP, o_branchFlow_TP
5934                         o_branchDynamicLoss_TP, o_branchFixedLoss_TP, o_branchFromBusPrice_TP
5935                         o_branchToBusPrice_TP, o_branchMarginalPrice_TP, o_branchTotalRentals_TP
5936                         o_branchCapacity_TP ;
5937   
5938          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_NodeOutput_TP.gdx'
5939                         o_node, o_nodeGeneration_TP, o_nodeLoad_TP, o_nodePrice_TP
5940                         o_nodeRevenue_TP, o_nodeCost_TP, o_nodeDeficit_TP, o_nodeSurplus_TP ;
5941   
5942          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_OfferOutput_TP.gdx'
5943                         o_offer, o_offerEnergy_TP, o_offerFIR_TP, o_offerSIR_TP ;
5944   
5945          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_ReserveOutput_TP.gdx'
5946                         o_island, o_FIRreqd_TP, o_SIRreqd_TP, o_FIRprice_TP, o_SIRprice_TP
5947                         o_FIRviolation_TP, o_SIRviolation_TP ;
5948   
5949          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_BrConstraintOutput_TP.gdx'
5950                         o_brConstraint_TP, o_brConstraintSense_TP, o_brConstraintLHS_TP
5951                         o_brConstraintRHS_TP, o_brConstraintPrice_TP ;
5952   
5953          execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_MnodeConstraintOutput_TP.gdx'
5954                         o_MnodeConstraint_TP, o_MnodeConstraintSense_TP, o_MnodeConstraintLHS_TP
5955                         o_MnodeConstraintRHS_TP, o_MnodeConstraintPrice_TP ;
5956   
5957  *       Additional output for audit reporting
5958          if(opMode = -1,
5959              execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\\GDXtest_gams24_2_noX\RunNum1_AuditOutput_TP.gdx'
5960                             o_ACbusAngle, o_lossSegmentBreakPoint, o_lossSegmentFactor
5961                             o_nonPhysicalLoss, o_busIsland_TP, o_marketNodeIsland_TP
5962                             o_ILRO_FIR_TP, o_ILRO_SIR_TP, o_ILbus_FIR_TP, o_ILbus_SIR_TP
5963                             o_PLRO_FIR_TP, o_PLRO_SIR_TP, o_TWRO_FIR_TP, o_TWRO_SIR_TP
5964                             o_generationRiskLevel, o_genHVDCriskLevel, o_HVDCriskLevel
5965                             o_manuRiskLevel, o_manuHVDCriskLevel
5966                             o_FIRcleared_TP, o_SIRcleared_TP ;
5967          );
5968   
5969      );
5970   
5971  elseif (FTRflag = 1),
5972  *   Normal FTR run output
5973      execute_unload 'C:\a\vSPD\vSPD_onGithub\Programs\..\Output\GDXtest_gams24_2_noX\runNum1_FTRoutput.gdx'
5974                     o_dateTime, i_branch, i_branchConstraint, o_branch, o_HVDClink
5975                     o_brConstraint_TP, o_ACbranchLossMW, o_ACbranchLossFactor
5976                     o_branchFlow_TP, o_branchFromBusPrice_TP, o_branchToBusPrice_TP
5977                     o_branchDynamicLoss_TP, o_branchMarginalPrice_TP, o_branchCapacity_TP
5978                     o_brConstraintLHS_TP, o_brConstraintPrice_TP, o_ACbranchTotalRentals ;
5979   
5981   
5982  );
5983   
5984   
5985  * Post a progress message for use by EMI.
5986  putclose runlog / 'The case: FP_20140221_I is complete. (', system.time, ').' //// ;
5987   
5988   
5989  * Go to the next input file
5991   
5992   
5993  * Post a progress message for use by EMI.
GAMS 24.2.1  r43572 Released Dec  9, 2013 WEX-WEI x86_64/MS Windows                                                                                                                                                                   03/31/14 09:58:56 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\a\vSPD\vSPD_onGithub\Programs\vSPDsolve.gms
     2     2007 INCLUDE        1      50  .C:\a\vSPD\vSPD_onGithub\Programs\vSPDpaths.inc
     3     2022 INCLUDE        1      51  .C:\a\vSPD\vSPD_onGithub\Programs\vSPDsettings.inc
     4     2078 INCLUDE        1      52  .C:\a\vSPD\vSPD_onGithub\Programs\vSPDcase.inc
     5     2081 INCLUDE        1      53  .C:\a\vSPD\vSPD_onGithub\Programs\FTRrun.inc
     6     2396 IF EXIST       1     367  C:\a\vSPD\vSPD_onGithub\Input\FP_20140221_I.gdx
     7     2397 GDXIN          1     368  C:\a\vSPD\vSPD_onGithub\Input\FP_20140221_I.gdx
     8     2549 INCLUDE        1     520  .C:\a\vSPD\vSPD_onGithub\Programs\vSPDtpsToSolve.inc
     9     2630 IF EXIST       1     578  C:\a\vSPD\vSPD_onGithub\Programs\FTRdirect.inc
    10     4226 IF EXIST       1    2279  C:\a\vSPD\vSPD_onGithub\Programs\FTRdirect.inc
    11     5068 IF EXIST       1    3121  C:\a\vSPD\vSPD_onGithub\Programs\FTRdirect.inc
    12     5980 IF EXIST       1    4036  C:\a\vSPD\vSPD_onGithub\Programs\FTRdirect.inc
    13     5994 IF EXIST       1    4057  C:\a\vSPD\vSPD_onGithub\Input\FP_20140221_I.gdx


COMPILATION TIME     =        0.219 SECONDS     28 MB  24.2.1 r43572 WEX-WEI
GAMS 24.2.1  r43572 Released Dec  9, 2013 WEX-WEI x86_64/MS Windows                                                                                                                                                                   03/31/14 09:58:56 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD Using LP From line 4191


LOOPS                            FOR/WHILE   1


MODEL STATISTICS

BLOCKS OF EQUATIONS          62     SINGLE EQUATIONS    1,107,819
BLOCKS OF VARIABLES          31     SINGLE VARIABLES    1,708,915
NON ZERO ELEMENTS     3,497,795


GENERATION TIME      =        5.974 SECONDS    715 MB  24.2.1 r43572 WEX-WEI


EXECUTION TIME       =       17.799 SECONDS    715 MB  24.2.1 r43572 WEX-WEI

STEP SUMMARY:     0.015       0.015 STARTUP
                  0.219       0.219 COMPILATION
                 17.799      17.799 EXECUTION
                  0.843       0.843 CLOSEDOWN
                 18.876      18.876 TOTAL SECONDS
                 18.886      18.886 ELAPSED SECONDS
                714.965     714.965 MAX HEAP SIZE (MB)
               L O O P S          FOR/WHILE 1

GAMS 24.2.1  r43572 Released Dec  9, 2013 WEX-WEI x86_64/MS Windows                                                                                                                                                                   03/31/14 09:58:56 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD Using LP From line 4191


               S O L V E      S U M M A R Y

     MODEL   vSPD                OBJECTIVE  NETBENEFIT
     TYPE    LP                  DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  4191

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE         -2105691.8266

 RESOURCE USAGE, LIMIT         33.337       600.000
 ITERATION COUNT, LIMIT    205718       1000000

IBM ILOG CPLEX   24.2.1 r43572 Released Dec  9, 2013 WEI x86_64/MS Windows    
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.0.0

Space for names approximately 150.84 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 29.97sec (det. 22510.13 ticks)
Optimal solution found.
Objective :    -2105691.826588



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.2.1  r43572 Released Dec  9, 2013 WEX-WEI x86_64/MS Windows                                                                                                                                                                   03/31/14 09:58:56 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog C:\a\vSPD\vSPD_onGithub\Output\GDXtest_gams24_2_noX\GDXtest_gams24_2_noX_RunLog.txt
temp C:\a\vSPD\vSPD_onGithub\Programs\temp.put


EXECUTION TIME       =       17.613 SECONDS    551 MB  24.2.1 r43572 WEX-WEI


USER: Phil Bishop                                    R131028:1641CV-WIN
      Electricity Authority - Te Mana Hiko                       DC5643


**** FILE SUMMARY

Restart    C:\a\vSPD\vSPD_onGithub\Programs\vSPDmodel.g0?
Input      C:\a\vSPD\vSPD_onGithub\Programs\vSPDsolve.gms
Output     C:\a\vSPD\vSPD_onGithub\Programs\vSPDsolve.lst

STEP SUMMARY:     1.123       1.138 STARTUP
                  0.000       0.219 COMPILATION
                 17.613      35.412 EXECUTION
                  0.000       0.843 CLOSEDOWN
                 18.736      37.612 TOTAL SECONDS
                 53.538      72.423 ELAPSED SECONDS
                551.379     714.965 MAX HEAP SIZE (MB)
