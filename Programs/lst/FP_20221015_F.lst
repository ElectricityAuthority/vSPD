GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


2678  *=====================================================================================
2679  * Name:                 vSPDsolve.gms
2680  * Function:             Establish base case and override data, prepare data, and solve
2681  *                       the model
2682  * Developed by:         Electricity Authority, New Zealand
2683  * Source:               https://github.com/ElectricityAuthority/vSPD
2684  *                       http://www.emi.ea.govt.nz/Tools/vSPD
2685  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
2686  *                       Email: emi@ea.govt.nz
2687  * Modified on:          1 Oct 2019
2688  *                       New feature added: new wind offer arrangements
2689  * Modified on:          11 Nov 2020
2690  *                       Replacing invalid bus prices after SOS1 (6.1.3)
2691  * Last modified on:     11 Dec 2020
2692  *                       From 11 Dec 2020, GDX input file have i_tradePeriodBranchCapacityDirected
2693  *                       and i_tradePeriodReverseRatingsApplied symbols
2694  *                       Applying branch reverse rating  s only when i_tradePeriodReverseRatingsApplied = 1
2695  * Last modified on:     27 June 2021
2696  *                       Fixing the bug that remove HVDC because of zero  reverse rating limits
2697   
2698  *=====================================================================================
2699   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file f
        3. Manage model and data compatability
        4. Input data overrides - declare and apply (include vSPDoverrides.gms)
        5. Initialise constraint violation penalties (CVPs)
        6. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        7. vSPD scarcity pricing post-processing
        8. Write results to CSV report files and GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr            i_scarcityArea = sarea
        i_reserveType = resT                      i_reserveClass = resC
        i_riskClass = riskC                       i_constraintRHS = CstrRHS
        i_riskParameter = riskPar                 i_offerParam = offerPar
        i_dczone = z,z1,rrz,rrz1                  i_riskGroup = rg,rg1)
2738   
2739   
2740  * Include paths, settings and case name files
INCLUDE    C:\vSPD\vSPD_v3.1.0\Programs\vSPDsettings.inc
2742  *+++ vSPD settings +++
2745   
2746  *+++ Paths +++
2752   
2754   
2755   
2756  *+++ Model +++
2757  Scalar sequentialSolve                   / 0 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2758  Scalar disconnectedNodePriceCorrection   / 1 / ;
2759  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2760   
2761   
2762  *+++ Network +++
2763  Scalar useACLossModel                    / 1 / ;
2764  Scalar useHVDCLossModel                  / 1 / ;
2765  Scalar useACBranchLimits                 / 1 / ;
2766  Scalar useHVDCBranchLimits               / 1 / ;
2767  Scalar resolveCircularBranchFlows        / 1 / ;
2768  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2769  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2770  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2771  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2772  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2773   
2774   
2775  *+++ Constraints +++
2776  Scalar useReserveModel                   / 1 / ;
2777  Scalar suppressMixedConstraint           / 0 / ;
2778  Scalar mixedMIPtolerance                 / 0.000001 / ;
2779   
2780   
2781  *+++ Solver +++
2782  Scalar LPtimeLimit                       / 3600 / ;
2783  Scalar LPiterationLimit                  / 2000000000 / ;
2784  Scalar MIPtimeLimit                      / 3600 / ;
2785  Scalar MIPiterationLimit                 / 2000000000 / ;
2786  Scalar MIPoptimality                     / 0 / ;
2789   
2790   
2791  *+++ Various switches +++
2794   
INCLUDE    C:\vSPD\vSPD_v3.1.0\Programs\vSPDcase.inc
2800   
2801   
2802  * Update the runlog file
2803  File runlog "Write to a report"  / "ProgressReport.txt" /;
2804  runlog.lw = 0 ; runlog.ap = 1 ;
2805  putclose runlog / 'Case "FP_20221015_F" started at: '
2806                    system.date " " system.time /;
2807  if(sequentialSolve,
2808    putclose runlog 'Vectorisation is switched OFF' /;
2809  else
2810    putclose runlog 'Vectorisation is switched ON' /;
2811  ) ;
2812   
2813  * Set the solver for the LP and MIP
2814  option lp = Cplex ;
2815  option mip = Cplex ;
2816   
2817  * Set profile status
2818  option profile = 0 ;
2819   
2820  * Set the solution print status in the lst file
2821  option solprint = off;
2822   
2823  * Set the column (variable) and row (equation) listing in the lst file
2824  option limcol = 0 ;
2825  option limrow = 0 ;
2826   
2827  * Allow empty data set declaration
2829   
2830  * Declare a temporary file
2831  File temp ;
2832   
2833  *=====================================================================================
2834  * 1. Declare symbols and initialise some of them
2835  *=====================================================================================
2836   
2837  Sets
2838  * Initialise fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2839    i_island                    / NI, SI /
2840    i_reserveClass              / FIR, SIR /
2841   
       Scarcity pricing updates --> i_reserveType
       Rather than include an additional reserve type element an additional virutal
       reserve paramter and associated variable is created. This is more efficient
       implementation in terms of the problem size as all other reserve providers
       are indexed on i_reserveType which would include an additional index on all
       these variables thus increasing the problem size. This increase would then
       need additional pre-processing to fix variables to zero. To avoid this and
       keep the problem size small the additional virtual reserve variable is included.
2852    i_reserveType               / PLSR, TWDR, ILR /
2853   
2854    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2855                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2856    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2857    i_offerType                 / energy, PLSR, TWDR, ILR /
2858    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2859                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW,
2860                                  i_IsPriceResponse, i_PotentialMW  /
2861    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2862    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2863    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2864    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2865    i_energyBidComponent        / i_bidMW, i_bidPrice /
2866    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2867    i_tradeBlock                / t1*t20 /
2868    i_lossSegment               / ls1*ls13 /
2869    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2870    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2871    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2872    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2873    i_flowDirection             / forward, backward /
2874    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2875                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2876                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2877                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2878                                  i_deficitRampRate, i_surplusRampRate
2879                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2880                                  i_deficitBranchFlow, i_surplusBranchFlow
2881                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2882                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2883                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2884   
2885  * Initialise the set called pole
2886    pole  'HVDC poles'          / pole1, pole2 /
2887   
2888  * Scarcity pricing updates
2889    i_scarcityArea              /NI, SI, National/
2890   
2891  * NMIR - HVDC flow zones for reverse reserve sharing
2892    i_dczone                    /RP, NR, RZ/
2893   
2894    ;
2895   
2896   
2897   
2898  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2899  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2900   
2901  Sets
2902    scarcityAreaIslandMap(sarea,ild)                    'Mapping of scarcity area to island'
2903    unsolvedPeriod(tp)                                  'Set of periods that are not solved yet'
2904  * Unmmaped bus defificit temporary sets
2905    unmappedDeficitBus(dt,b)                            'List of buses that have deficit generation (price) and are not mapped to any pnode'
2906    changedDeficitBus(dt,b)                             'List of buses that have deficit generation added from unmapped deficit bus'
2907  * TN - Replacing invalid prices after SOS1
2908    vSPD_SOS1_Solve(tp)                                 'Flag period that is resolved using SOS1'
2909    ;
2910   
2911  Parameters
2912  * Flag to apply corresponding vSPD model
2913    VSPDModel(tp)                                       '0=VSPD, 1=VSPD_MIP, 2=vSPD_BranchFlowMIP, 3=vSPD_MixedConstraintMIP, 4=VSPD (last solve)'
2914  * Main iteration counter
2915    iterationCount                                      'Iteration counter for the solve'
2916  * MIP logic
2917    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2918  * Introduce flag to detect circular branch flows on each HVDC pole
2919    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2920    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2921    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2922    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2923    manualBranchSegmentMWFlow(tp,br,los,fd)             'Manual calculation of the branch loss segment MW flow'
2924    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2925    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2926    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2927  * Parameters to calculate circular branch flow on each HVDC pole
2928    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2929    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2930  * Disconnected bus post-processing
2931    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2932    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2933    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2934    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2935  * Scarcity pricing processing parameters
2936    scarcitySituation(tp,sarea)                         'Flag to indicate that a scarcity situation exists (1 = Yes)'
2937    GWAPFloor(tp,sarea)                                 'Floor price for the scarcity situation in scarcity area'
2938    GWAPCeiling(tp,sarea)                               'Ceiling price for the scarcity situation in scarcity area'
2939    GWAPPastDaysAvg(tp,ild)                             'Average GWAP over past days - number of periods in GWAP count'
2940    GWAPCountForAvg(tp,ild)                             'Number of periods used for the i_gwapPastDaysAvg'
2941    GWAPThreshold(tp,ild)                               'Threshold on previous 336 trading period GWAP - cumulative price threshold'
2942    islandGWAP(tp,ild)                                  'Island GWAP calculation used to update GWAPPastDaysAvg'
2943    scarcityAreaGWAP(tp,sarea)                          'Scarcity area GWAP used to calculate the scaling factor'
2944    pastGWAPsumforCPT(tp,ild)
2945    pastTPcntforCPT(tp,ild)
2946    currentDayGWAPsumforCPT(ild)
2947    currentDayTPsumforCPT(ild)
2948    avgPriorGWAP(tp,ild)
2949    cptIslandPassed(tp,sarea)
2950    cptPassed(tp,sarea)
2951    cptIslandReq(sarea)
2952    scarcityScalingFactor(tp,sarea)
2953    scaledbusPrice(tp,b)
2954    scalednodePrice(tp,n)
2955    scaledFIRprice(tp,ild)
2956    scaledSIRprice(tp,ild)
2957    scaledislandGWAP(tp,ild)
2958    scaledscarcityAreaGWAP(tp,sarea)
2959  * Unmmaped bus defificit temporary parameters
2960    temp_busDeficit_TP(dt,b) 'Bus deficit violation for each trade period'
2961  * TN - Replacing invalid prices after SOS1
2962    busSOSinvalid(tp,b)                                 'Buses with invalid bus prices after SOS1 solve'
2963    numberofbusSOSinvalid(tp)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration) '
2964  * TN - Flag to apply branch reverse ratings
2965    reverseRatingsApplied(tp)
2966    ;
2967   
2968  Sets
2969  * Dispatch results reporting
2970    o_fromDateTime(dt)                                  'Start period for summary reports'
2971    o_dateTime(dt)                                      'Date and time for reporting'
2972    o_bus(dt,b)                                         'Set of buses for output report'
2973    o_offer(dt,o)                                       'Set of offers for output report'
2974    o_bid(dt,bd)                                        'Set of bids for output report'
2975    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2976    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2977    o_trader(trdr)                                      'Set of traders for trader summary output report'
2978    o_node(dt,n)                                        'Set of nodes for output report'
2979    o_branch(dt,br)                                     'Set of branches for output report'
2980    o_HVDClink(dt,br)                                   'HVDC links (branches) defined for the current trading period'
2981    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2982    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2983    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2984    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2985  * Audit - extra output declaration
2986    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2987    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2988    ;
2989   
2990  Parameters
2991  * Dispatch results for reporting - Trade period level - Island output
2992    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2993    o_islandLoad_TP(dt,ild)                             'Island MW fixed load for the different time periods'
2994    o_islandClrBid_TP(dt,ild)                           'Island cleared MW bid for the different time periods'
2995    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2996    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2997    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2998    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
2999    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
3000    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
3001    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
3002    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
3003    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
3004    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
3005    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
3006    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
3007    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
3008    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
3009    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
3010    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
3011    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
3012    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
3013    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
3014    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
3015    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
3016    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
3017    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
3018    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
3019    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
3020    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
3021    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
3022    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
3023    o_ACbranchTotalRentals(dt)                          'Total AC rental by trading period for reporting'
3024    o_ACbranchLossMW(dt,br,los)                         'MW element of the loss segment curve in MW'
3025    o_ACbranchLossFactor(dt,br,los)                     'Loss factor element of the loss segment curve'
3026    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
3027    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
3028    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
3029    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
3030    o_offerEnergyBlock_TP(dt,o,trdBlk)                  'Output MW cleared for each energy offer for each trade period'
3031    o_offerFIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for FIR for each trade period'
3032    o_offerSIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for SIR for each trade period'
3033    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
3034    o_bidFIR_TP(dt,bd)                                  'Output MW cleared for FIR for each trade period'
3035    o_bidSIR_TP(dt,bd)                                  'Output MW cleared for SIR for each trade period'
3036    o_ReserveReqd_TP(dt,ild,resC)                       'Output MW required for each reserve class in each trade period'
3037    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
3038    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
3039    o_ResCleared_TP(dt,ild,resC)                        'Reserve cleared from an island for each trade period'
3040    o_FIRcleared_TP(dt,ild)                             'Output - total FIR cleared by island'
3041    o_SIRcleared_TP(dt,ild)                             'Output - total SIR cleared by island'
3042    o_ResPrice_TP(dt,ild,resC)                          'Output $/MW price for each reserve classes for each trade period'
3043    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
3044    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
3045    o_ResViolation_TP(dt,ild,resC)                      'Violation MW for each reserve classes for each trade period'
3046    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
3047    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
3048    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
3049    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
3050    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
3051    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
3052    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
3053    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
3054    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
3055  * Security constraint data
3056    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
3057    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
3058    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
3059    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
3060  * Mnode constraint data
3061    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
3062    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
3063    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
3064    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
3065  * TradePeriod summary report
3066    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
3067    o_systemCost_TP(dt)                                 'System cost for summary report'
3068    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
3069    o_ofv_TP(dt)                                        'Objective function value for summary report'
3070    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
3071    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
3072    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
3073    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
3074    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
3075    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
3076    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
3077    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
3078    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
3079    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
3080    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
3081    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
3082    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
3083    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
3084    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
3085    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
3086    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
3087    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
3088  * System level
3089    o_numTradePeriods                                   'Output number of trade periods in summary'
3090    o_systemOFV                                         'System objective function value'
3091    o_systemGen                                         'Output system MWh generation'
3092    o_systemLoad                                        'Output system MWh load'
3093    o_systemLoss                                        'Output system MWh loss'
3094    o_systemViolation                                   'Output system MWh violation'
3095    o_systemFIR                                         'Output system FIR MWh reserve'
3096    o_systemSIR                                         'Output system SIR MWh reserve'
3097    o_systemEnergyRevenue                               'Output offer energy revenue $'
3098    o_systemReserveRevenue                              'Output reserve revenue $'
3099    o_systemLoadCost                                    'Output system load cost $'
3100    o_systemLoadRevenue                                 'Output system load revenue $'
3101    o_systemSurplus                                     'Output system surplus $'
3102  * Offer level
3103    o_offerGen(o)                                       'Output offer generation (MWh)'
3104    o_offerFIR(o)                                       'Output offer FIR (MWh)'
3105    o_offerSIR(o)                                       'Output offer SIR (MWh)'
3106    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
3107    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
3108    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
3109  * Trader level
3110    o_traderGen(trdr)                                   'Output trader generation (MWh)'
3111    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
3112    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
3113    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
3114    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
3115    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
3116  * Factor to prorate the deficit and surplus at the nodal level
3117    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
3118    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
3119  * Introduce i_useBusNetworkModel to account for MSP change-over date.
3120    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
3121  * Virtual reserve output
3122    o_vrResMW_TP(dt,ild,resC)                           'MW scheduled from virtual reserve resource'
3123    o_FIRvrMW_TP(dt,ild)                                'MW scheduled from virtual FIR resource'
3124    o_SIRvrMW_TP(dt,ild)                                'MW scheduled from virtual SIR resource'
3125  * Scarcity pricing output
3126    o_scarcityExists_TP(dt,ild)
3127    o_cptPassed_TP(dt,ild)
3128    o_avgPriorGWAP_TP(dt,ild)
3129    o_islandGWAPbefore_TP(dt,ild)
3130    o_islandGWAPafter_TP(dt,ild)
3131    o_scarcityGWAPbefore_TP(dt,ild)
3132    o_scarcityGWAPafter_TP(dt,ild)
3133    o_scarcityScalingFactor_TP(dt,ild)
3134    o_GWAPthreshold_TP(dt,ild)
3135    o_GWAPfloor_TP(dt,ild)
3136    o_GWAPceiling_TP(dt,ild)
3137  * Audit - extra output declaration
3138    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
3139    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
3140    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
3141    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
3142    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
3143    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
3144    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
3145    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
3146    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
3147    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
3148    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
3149    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
3150    o_generationRiskLevel(dt,ild,o,resC,riskC)                    'Audit - generation risk'
3151    o_generationRiskPrice(dt,ild,o,resC,riskC)                    'Audit - generation risk shadow price'
3152    o_HVDCriskLevel(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk'
3153    o_HVDCriskPrice(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk shadow price'
3154    o_manuRiskLevel(dt,ild,resC,riskC)                            'Audit - manual risk'
3155    o_manuRiskPrice(dt,ild,resC,riskC)                            'Audit - manual risk shadow price'
3156    o_genHVDCriskLevel(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
3157    o_genHVDCriskPrice(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk shadow price'
3158    o_manuHVDCriskLevel(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary'
3159    o_manuHVDCriskPrice(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary shadow price'
3160    o_generationRiskGroupLevel(dt,ild,rg,resC,riskC)                 'Audit - generation group risk'
3161    o_generationRiskGroupPrice(dt,ild,rg,resC,riskC)                 'Audit - generation group risk shadow price'
3162  * TN - output parameters added for NMIR project --------------------------------
3163    o_FirSent_TP(dt,ild)                        'FIR export from an island for each trade period'
3164    o_SirSent_TP(dt,ild)                        'SIR export from an island for each trade period'
3165    o_FirReceived_TP(dt,ild)                    'FIR received at an island for each trade period'
3166    o_SirReceived_TP(dt,ild)                    'SIR received at an island for each trade period'
3167    o_FirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3168    o_SirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3169    o_EffectiveRes_TP(dt,ild,resC,riskC)        'Effective reserve share to an island for each trade period'
3170    o_FirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3171    o_SirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3172  * TN - output parameters added for NMIR project end ----------------------------
3173    ;
3174   
3175  Scalars
3176    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
3177    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
3178  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
3179    useExtendedRiskClass          'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
3180  * Scarcity pricing
3181    scarcityExists                'Flag to indicate that a scarcity situation exists for at least 1 trading period in the solve'
3182    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
3183    ;
3184   
3185   
3186   
3187  *=====================================================================================
3188  * 2. Load data from GDX file
3189  *=====================================================================================
3190   
3191  * If input file does not exist then go to the next input file
3193   
3194  * Load trading period to be solved
3195  * If scarcity pricing situation exists --> load and solve all trading periods
GDXIN   C:\vSPD\vSPD_v3.1.0\Programs\vSPDPeriod.gdx
--- LOAD  i_tradePeriod = 1:i_TradePeriod
--- LOAD  i_dateTime = 2:i_DateTime
3201   
3202   
3203  * Call the GDX routine and load the input data:
GDXIN   C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx
3205  * Sets
--- LOAD  i_offer = 84:i_Offer
--- LOAD  i_trader = 83:i_Trader
--- LOAD  i_bid = 101:i_bid
--- LOAD  i_node = 15:i_node
--- LOAD  i_bus = 16:i_bus
--- LOAD  i_branch = 32:i_branch
--- LOAD  i_branchConstraint = 42:i_branchConstraint
--- LOAD  i_ACnodeConstraint = 45:i_ACnodeConstraint
--- LOAD  i_MnodeConstraint = 48:i_MnodeConstraint
--- LOAD  i_genericConstraint = 54:i_genericConstraint
--- LOAD  i_type1MixedConstraint = 63:i_type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 78:i_type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 7:i_dateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 90:i_tradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 91:i_tradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 104:i_tradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 105:i_tradePeriodBidNode
--- LOAD  i_tradePeriodNode = 17:i_tradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 19:i_tradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 18:i_tradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 20:i_tradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 33:i_tradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 115:i_tradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 64:i_type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 65:i_tradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 79:i_tradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 66:i_type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 55:i_tradePeriodGenericConstraint
3212  * Parameters
--- LOAD  i_day = 2:i_day
--- LOAD  i_month = 3:i_month
--- LOAD  i_year = 4:i_year
--- LOAD  i_tradingPeriodLength = 10:i_tradingPeriodLength
--- LOAD  i_AClineUnit = 9:i_AClineUnit
--- MERGE i_branchReceivingEndLossProportion = 11:i_branchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 8:i_studyTradePeriod
--- LOAD  i_CVPvalues = 13:i_CVPvalues
--- LOAD  i_tradePeriodOfferParameter = 92:i_tradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 93:i_tradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 94:i_tradePeriodSustainedPLSRoffer
--- LOAD  i_tradePeriodFastPLSRoffer = 95:i_tradePeriodFastPLSRoffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 96:i_tradePeriodSustainedTWDRoffer
--- LOAD  i_tradePeriodFastTWDRoffer = 97:i_tradePeriodFastTWDRoffer
--- LOAD  i_tradePeriodSustainedILRoffer = 98:i_tradePeriodSustainedILRoffer
--- LOAD  i_tradePeriodFastILRoffer = 99:i_tradePeriodFastILRoffer
--- LOAD  i_tradePeriodNodeDemand = 110:i_tradePeriodNodeDemand
--- LOAD  i_tradePeriodEnergyBid = 106:i_tradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 107:i_tradePeriodSustainedILRbid
--- LOAD  i_tradePeriodFastILRbid = 108:i_tradePeriodFastILRbid
--- LOAD  i_tradePeriodHVDCNode = 23:i_tradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 24:i_tradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 34:i_tradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 35:i_tradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 36:i_tradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 38:i_tradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 27:i_noLossBranch
--- LOAD  i_AClossBranch = 28:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 29:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 21:i_tradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 22:i_tradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 116:i_tradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 117:i_tradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 43:i_tradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 44:i_tradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 46:i_tradePeriodACnodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 47:i_tradePeriodACnodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 49:i_tradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 50:i_tradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 51:i_tradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 52:i_tradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 53:i_tradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 67:i_type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 69:i_type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 70:i_type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 71:i_type1MixedConstraintHVDClineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 72:i_tradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 80:i_type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 81:i_tradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 56:i_tradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 57:i_tradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 58:i_tradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 59:i_tradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 60:i_tradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 61:i_tradePeriodGenericConstraintRHS
3226   
3227  * New risk group sets
GDXIN   C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx
--- LOAD  i_riskGroup = 147:i_riskGroup
--- LOAD  riskGroupOffer = 145:i_tradePeriodRiskGroup
3233   
3234   
3235  *=====================================================================================
3236  * 3. Manage model and data compatability
3237  *=====================================================================================
3238   
3239  * This section manages the changes to model flags to ensure backward compatibility
3240  * given changes in the SPD model formulation over time:
3241  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
3242  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
3243   
3244  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
3245  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
3246   
3247  * Calculate the Gregorian date of the input data
3248  inputGDXGDate = jdate(i_year,i_month,i_day) ;
3249   
3250  * Introduce i_useBusNetworkModel to account for MSP change-over date when for
3251  * half of the day the old market node model and the other half the bus network
3252  * model was used. The old model does not have the i_tradePeriodBusElectrical
3253  * island paramter specified since it uses the market node network model.
3254  * This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter
3255  * to be used in the post-MSP solves to indentify 'dead' electrical buses.
3256  * MSP change over from mid-day on 21 Jul 2009
3257  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= jdate(2009,7,21) ) and
3258                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
3259                                 } ;
3260   
3261  * Switch off the mixed constraint based risk offset calculation after 17 October 2011
3262  useMixedConstraintRiskOffset = 1 $ { inputGDXGDate < jdate(2011,10,17) } ;
3263   
3264  * Switch off mixed constraint formulation if no data coming through
3265  * or mixed constraint is suppressed manually in vSPDsetting.inc
3266  useMixedConstraint(tp)
3267      = 1 $ { sum[t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1]
3268          and (suppressMixedConstraint = 0) } ;
3269   
3270  put_utility temp 'gdxin' / 'C:\vSPD\vSPD_v3.1.0\Programs\..\Input\\FP_20221015_F.gdx' ;
3271   
3272  * Primary secondary offer in use from 01 May 2012'
3273  if(inputGDXGDate >= jdate(2012,05,01),
3274      execute_load i_tradePeriodPrimarySecondaryOffer ;
3275  else
3276      i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
3277  ) ;
3278   
3279  * Change to demand bid on 28 Jun 2012
3280  useDSBFDemandBidModel = 1 $ { inputGDXGDate >= jdate(2012,6,28) } ;
3281   
3282  * Manual ECE risk parameters in use from 20 Sep 2012
3283  if(inputGDXGDate >= jdate(2012,9,20),
3284      execute_load i_tradePeriodManualRisk_ECE ;
3285  else
3286      i_tradePeriodManualRisk_ECE(tp,ild,resC) = 0 ;
3287  ) ;
3288   
3289  * HVDC secondary risk parameters in use from 20 Sep 2012
3290  if(inputGDXGDate >= jdate(2012,9,20),
3291      execute_load i_tradePeriodHVDCsecRiskEnabled
3292                   i_tradePeriodHVDCsecRiskSubtractor ;
3293  else
3294      i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC) = 0 ;
3295      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
3296  ) ;
3297   
3298  * Do not use the extended risk class if no data coming through
3299  useExtendedRiskClass
3300      = 1 $ { sum[ (tp,ild,resC,riskC,riskPar) $ (ord(riskC) > 4)
3301                 , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] };
3302   
3303  * HVDC round power mode in use from 20 Sep 2012
3304  if(inputGDXGDate >= jdate(2012,9,20),
3305      execute_load i_tradePeriodAllowHVDCroundpower ;
3306  else
3307      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
3308  ) ;
3309   
3310  * Additional mixed constraint parameters exist from 24 Feb 2013
3311   
3312  if(inputGDXGDate >= jdate(2013,2,24),
3313      execute_load i_type1MixedConstraintAClineWeight
3314                   i_type1MixedConstraintAClineLossWeight
3315                   i_type1MixedConstraintAClineFixedLossWeight
3316                   i_type1MixedConstraintHVDClineLossWeight
3317                   i_type1MixedConstraintHVDClineFixedLossWeight
3318                   i_type1MixedConstraintPurWeight ;
3319  else
3320      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
3321      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
3322      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
3323      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
3324      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
3325      i_type1MixedConstraintPurWeight(t1MixCstr,bd) = 0 ;
3326  ) ;
3327   
3328  *  Reserve class generation parameter in use from 24 Feb 2013
3329  if(inputGDXGDate >= jdate(2013,2,24),
3330      execute_load i_tradePeriodReserveClassGenerationMaximum ;
3331  else
3332      i_tradePeriodReserveClassGenerationMaximum(tp,o,resC) = 0 ;
3333  ) ;
3334   
3335  * Primary secondary risk model in use from 24 Feb 2013
3336  usePrimSecGenRiskModel = 1 $ { inputGDXGDate >= jdate(2013,2,24) } ;
3337   
3338  * Dispatchable Demand effective date 20 May 2014
3339  if(inputGDXGDate >= jdate(2014,5,20),
3340      execute_load i_tradePeriodDispatchableBid;
3341  else
3342      i_tradePeriodDispatchableBid(tp,bd) =  Yes $ useDSBFDemandBidModel ;
3343  ) ;
3344  * MODD modification end
3345   
3346  * Scarcity pricing scheme for reserve available from 27 May 2014
3347  if(inputGDXGDate >= jdate(2014,5,27),
3348      execute_load i_tradePeriodVROfferMax, i_tradePeriodVROfferPrice ;
3349  else
3350      i_tradePeriodVROfferMax(tp,ild,resC) = 0 ;
3351      i_tradePeriodVROfferPrice(tp,ild,resC) = 0 ;
3352  ) ;
3353   
3354   
3355  * National market for IR effective date 20 Oct 2016
3356  if (inputGDXGDate >= jdate(2016,10,20),
3357      execute_load
3358      reserveRoundPower     = i_tradePeriodReserveRoundPower
3359      reserveShareEnabled   = i_tradePeriodReserveSharing
3360      modulationRiskClass   = i_tradePeriodModulationRisk
3361      roundPower2MonoLevel  = i_tradePeriodRoundPower2Mono
3362      bipole2MonoLevel      = i_tradePeriodBipole2Mono
3363      monopoleMinimum       = i_tradePeriodReserveSharingPoleMin
3364      HVDCControlBand       = i_tradePeriodHVDCcontrolBand
3365      HVDClossScalingFactor = i_tradePeriodHVDClossScalingFactor
3366      sharedNFRfactor       = i_tradePeriodSharedNFRfactor
3367      sharedNFRLoadOffset   = i_tradePeriodSharedNFRLoadOffset
3368      effectiveFactor       = i_tradePeriodReserveEffectiveFactor
3369      RMTreserveLimitTo     = i_tradePeriodRMTreserveLimit
3370      rampingConstraint     = i_tradePeriodRampingConstraint
3371    ;
3372  else
3373      reserveRoundPower(tp,resC)         = 0    ;
3374      reserveShareEnabled(tp,resC)       = 0    ;
3375      modulationRiskClass(tp,riskC)      = 0    ;
3376      roundPower2MonoLevel(tp)           = 0    ;
3377      bipole2MonoLevel(tp)               = 0    ;
3378      MonopoleMinimum(tp)                = 0    ;
3379      HVDCControlBand(tp,fd)             = 0    ;
3380      HVDClossScalingFactor(tp)          = 0    ;
3381      sharedNFRfactor(tp)                = 0    ;
3382      sharedNFRloadOffset(tp,ild)        = 0    ;
3383      effectiveFactor(tp,ild,resC,riskC) = 0    ;
3384      RMTreserveLimitTo(tp,ild,resC)     = 0    ;
3385      rampingConstraint(tp,brCstr)       = no   ;
3386  ) ;
3387   
3388  UseShareReserve = 1 $ sum[ (tp,resC), reserveShareEnabled(tp,resC)] ;
3389   
3390  * Branch Reverse Ratings planned to go-live on 03/Feb/2021 (this will be flagged in GDX using i_tradePeriodReverseRatingsApplied)
3391  * From 11 Dec 2020, GDX file will have i_tradePeriodBranchCapacityDirected and i_tradePeriodReverseRatingsApplied symbols
3392  if (inputGDXGDate >= jdate(2020,12,11),
3393      execute_load i_tradePeriodBranchCapacityDirected;
3394      execute_load reverseRatingsApplied = i_tradePeriodReverseRatingsApplied;
3395   
3396      i_tradePeriodBranchCapacityDirected(tp,br,'backward') $ (reverseRatingsApplied(tp)=0)
3397          = i_tradePeriodBranchCapacityDirected(tp,br,'forward');
3398   
3399  else
3400      i_tradePeriodBranchCapacityDirected(tp,br,fd)
3401          = i_tradePeriodBranchCapacity(tp,br) ;
3402  ) ;
3403   
3404   
3405  * Real Time Pricing phase 2 planned to go live on 22 March 2022
3406  * From 24 March 2022, GDX file will have following symbols
3407  if (inputGDXGDate >= jdate(2022,3,22),
3408      execute_load
3409      studyMode                   = i_studyMode
3410      useGenInitialMW             = i_useGenInitialMW
3411      runEnrgShortfallTransfer    = i_runEnrgShortfallTransfer
3412      runPriceTransfer            = i_runPriceTransfer
3413      InputInitialLoad            = i_tradePeriodInputInitialLoad
3414      LoadIsOverride              = i_tradePeriodLoadIsOverride
3415      LoadIsBad                   = i_tradePeriodLoadIsBad
3416      LoadIsNCL                   = i_tradePeriodLoadIsNCL
3417      ConformingFactor            = i_tradePeriodConformingFactor
3418      NonConformingLoad           = i_tradePeriodNonConformingLoad
3419      MaxLoad                     = i_tradePeriodMaxLoad
3420   
3421      useActualLoad               = i_useActualLoad
3422      dontScaleNegativeLoad       = i_dontScaleNegativeLoad
3423   
3424      islandMWIPS                 = i_tradePeriodIslandMWIPS
3425      islandPDS                   = i_tradePeriodIslandPDS
3426      islandLosses                = i_tradePeriodIslandLosses
3427   
3428      energyScarcityEnabled       = i_energyScarcityEnabled
3429      reserveScarcityEnabled      = i_reserveScarcityEnabled
3430      scarcityEnrgNationalFactor  = i_tradePeriodScarcityEnrgNationalFactor
3431      scarcityEnrgNationalPrice   = i_tradePeriodScarcityEnrgNationalPrice
3432      scarcityEnrgNodeFactor      = i_tradePeriodScarcityEnrgNodeFactor
3433      scarcityEnrgNodeFactorPrice = i_tradePeriodScarcityEnrgNodeFactorPrice
3434      scarcityEnrgNodeLimit       = i_tradePeriodScarcityEnrgNodeLimit
3435      scarcityEnrgNodeLimitPrice  = i_tradePeriodScarcityEnrgNodeLimitPrice
3436      scarcityResrvIslandLimit    = i_tradePeriodScarcityResrvIslandLimit
3437      scarcityResrvIslandPrice    = i_tradePeriodScarcityResrvIslandPrice
3438      ;
3439   
3440  else
3441      studyMode                                    = 111 ;
3442      useGenInitialMW                              = 0;
3443      runEnrgShortfallTransfer                     = 0;
3444      runPriceTransfer                             = 0;
3445      InputInitialLoad(tp,n)                       = 0;
3446      LoadIsOverride(tp,n)                         = 0;
3447      LoadIsBad(tp,n)                              = 0;
3448      LoadIsNCL(tp,n)                              = 0;
3449      ConformingFactor(tp,n)                       = 0;
3450      NonConformingLoad(tp,n)                      = 0;
3451      MaxLoad(tp,n)                                = 10000;
3452   
3453      useActualLoad(tp)                            = 1;
3454      dontScaleNegativeLoad(tp)                    = 1;
3455   
3456      islandMWIPS(tp,ild)                          = 0 ;
3457      islandPDS(tp,ild)                            = 0 ;
3458      islandLosses(tp,ild)                         = 0 ;
3459   
3460      energyScarcityEnabled(tp)                    = 0 ;
3461      reserveScarcityEnabled(tp)                   = 0 ;
3462      scarcityEnrgNationalFactor(tp,trdBlk)        = 0 ;
3463      scarcityEnrgNationalPrice(tp,trdBlk)         = 0 ;
3464      scarcityEnrgNodeFactor(tp,n,trdBlk)          = 0 ;
3465      scarcityEnrgNodeFactorPrice(tp,n,trdBlk)     = 0 ;
3466      scarcityEnrgNodeLimit(tp,n,trdBlk)           = 0 ;
3467      scarcityEnrgNodeLimitPrice(tp,n,trdBlk)      = 0 ;
3468      scarcityResrvIslandLimit(tp,ild,resC,trdBlk) = 0 ;
3469      scarcityResrvIslandPrice(tp,ild,resC,trdBlk) = 0 ;
3470  ) ;
3471   
3472   
3473   
3474  *=====================================================================================
3475  * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
3476  *=====================================================================================
3477   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
3491   
3493   
3494   
3495  *=====================================================================================
3496  * 5. Initialise constraint violation penalties (CVPs)
3497  *=====================================================================================
3498   
3499  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
3500  * Calculate the Gregorian date of the CE and ECE change
3501  * Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
3502  CVPchangeGDate = jdate(2010,06,24) ;
3503   
3504  * Set the flag for the application of the different CVPs for CE and ECE
3505  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
3506  diffCeECeCVP = 0 ;
3507  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
3508  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
3509  * If the user selects Yes (1), set the diffCeECeCVP flag
3510  diffCeECeCVP $ (-1 = 1) = 1 ;
3511   
3512  deficitBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
3513  surplusBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
3514  deficitReservePenalty(resC) $ (ord(resC) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3515  deficitReservePenalty(resC) $ (ord(resC) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3516  deficitBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
3517  surplusBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
3518  deficitGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
3519  surplusGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
3520  deficitRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
3521  surplusRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
3522  deficitACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
3523  surplusACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
3524  deficitBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
3525  surplusBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
3526  deficitMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
3527  surplusMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
3528  deficitT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
3529  surplusT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
3530  * Different CVPs defined for CE and ECE
3531  deficitReservePenalty_CE(resC) $ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3532  deficitReservePenalty_CE(resC) $ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3533  deficitReservePenalty_ECE(resC)$ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
3534  deficitReservePenalty_ECE(resC)$ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
3535   
3536  *=====================================================================================
3537  * 6. Initialise model mapping and inputs
3538  *=====================================================================================
3539   
3540  * Pre-dispatch schedule is solved sequentially
3541  sequentialSolve
3542      $ ( sum[ (tp,o,offerPar) $ {(ord(tp) = 2) and (ord(offerPar) = 1)}
3543                               , i_tradePeriodOfferParameter(tp,o,offerPar) ] = 0
3544        ) = 1 ;
3545   
3546  sequentialSolve $ UseShareReserve = 1;
3547   
3548  * Initialise bus, node, offer, bid for the current trade period start
3549  bus(tp,b)  $ i_tradePeriodBus(tp,b)  = yes  ;
3550  node(tp,n) $ i_tradePeriodNode(tp,n) = yes  ;
3551   
3552  * Initialise network sets for the current trade period start
3553  nodeBus(node,b)     $ i_tradePeriodNodeBus(node,b)        = yes ;
3554  HVDCnode(node)      $ i_tradePeriodHVDCnode(node)         = yes ;
3555  ACnode(node)        $ ( not HVDCnode(node))               = yes ;
3556  referenceNode(node) $ i_tradePeriodReferenceNode(node)    = yes ;
3557  DCbus(tp,b)         $ sum[ nodeBus(HVDCnode(tp,n),b), 1 ] = yes ;
3558  ACbus(tp,b)         $ ( not DCbus(tp,b) )                 = yes ;
3559   
3560  * Bus live island status
3561  busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3562   
3563  * Offer initialisation - offer must be mapped to a node that is mapped to a
3564  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3565  offer(tp,o) $ sum[ (n,b) $ { i_tradePeriodOfferNode(tp,o,n) and
3566                               nodeBus(tp,n,b) and
3567                               ( (not i_useBusNetworkModel(tp)) or
3568                                 busElectricalIsland(tp,b))
3569                             }, 1 ] = yes ;
3570   
3571  * IL offer mapped to a node that is mapped to a bus always valid
3572  * (updated on 23 July 2015 based on an email from SO Bennet Tucker on 21 July 2015))
3573  offer(tp,o)
3574      $ sum[ (n,b)
3575           $ { i_tradePeriodOfferNode(tp,o,n) and nodeBus(tp,n,b)
3576           and sum[ (trdBlk,ILofrCmpnt)
3577                  , i_tradePeriodFastILRoffer(tp,o,trdBlk,ILofrCmpnt)
3578                  + i_tradePeriodSustainedILRoffer(tp,o,trdBlk,ILofrCmpnt) ]
3579             }, 1 ] = yes ;
3580   
3581  * Bid initialisation - bid must be mapped to a node that is mapped to a bus
3582  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3583  bid(tp,bd) $ sum[ (n,b) $ { i_tradePeriodBidNode(tp,bd,n) and
3584                              nodeBus(tp,n,b) and
3585                              ( (not i_useBusNetworkModel(tp)) or
3586                                busElectricalIsland(tp,b) )
3587                            }, 1 ] = yes ;
3588   
3589  * Initialise Risk/Reserve data for the current trading period
3590  RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3591   
3592  * Mapping bus, node, offer, bid and island start for the current trade period
3593  offerNode(offer,n)   $ i_tradePeriodOfferNode(offer,n)                 = yes ;
3594  bidNode(bid,n)       $ i_tradePeriodBidNode(bid,n)                     = yes ;
3595  busIsland(bus,ild)   $ i_tradePeriodBusIsland(bus,ild)                 = yes ;
3596  nodeIsland(tp,n,ild) $ sum[ b $ { bus(tp,b) and node(tp,n)
3597                                and nodeBus(tp,n,b)
3598                                and busIsland(tp,b,ild) }, 1 ]           = yes ;
3599  offerIsland(offer(tp,o),ild)
3600      $ sum[ n $ { offerNode(tp,o,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3601  bidIsland(bid(tp,bd),ild)
3602      $ sum[ n $ { bidNode(tp,bd,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3603   
3604  IslandRiskGenerator(tp,ild,o)
3605      $ { offerIsland(tp,o,ild) and RiskGenerator(tp,o) } = yes ;
3606   
3607  * Set the primary-secondary offer combinations
3608  primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3609   
3610  * Identification of primary and secondary units
3611  hasSecondaryOffer(tp,o) = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o,o1), 1 ] ;
3612  hasPrimaryOffer(tp,o)   = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o1,o), 1 ];
3613   
3614  * Initialise offer parameters for the current trade period start
3615  generationStart(offer(tp,o))
3616      = sum[ offerPar $ ( ord(offerPar) = 1 )
3617                      , i_tradePeriodOfferParameter(tp,o,offerPar)
3618                      + sum[ o1 $ primarySecondaryOffer(tp,o,o1)
3619                                ,i_tradePeriodOfferParameter(tp,o1,offerPar) ]
3620           ];
3622  If useGenInitialMW = 1 then
3623      generationStart(tp,o) $ (ord(tp) > 1) = 0;
3624  Endif;
3626   
3627  rampRateUp(offer)
3628      = sum[ offerPar $ ( ord(offerPar) = 2 )
3629                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3630  rampRateDown(offer)
3631      = sum[ offerPar $ ( ord(offerPar) = 3 )
3632                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3633  reserveGenerationMaximum(offer)
3634      = sum[ offerPar $ ( ord(offerPar) = 4 )
3635                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3636  windOffer(offer)
3637      = sum[ offerPar $ ( ord(offerPar) = 5 )
3638                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3639  FKband(offer)
3640      = sum[ offerPar $ ( ord(offerPar) = 6 )
3641                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3642   
3643  priceResponsive(offer)
3644      = sum[ offerPar $ ( ord(offerPar) = 7 )
3645                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3646   
3647  potentialMW(offer)
3648      = sum[ offerPar $ ( ord(offerPar) = 8 )
3649                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3650   
3651   
3652  * Initialise energy offer data for the current trade period start
3653  generationOfferMW(offer,trdBlk)
3654      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3655                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3656  generationOfferPrice(offer,trdBlk)
3657      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3658                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3659   
3660  * Valid generation offer blocks are defined as those with a positive block limit
3661  validGenerationOfferBlock(offer,trdBlk)
3662      $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3663   
3664  * Define set of positive energy offers
3665  positiveEnergyOffer(offer)
3666      $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3667   
3668  * Initialise reserve offer data for the current trade period start
3669  PLSRReserveType(resT) $ (ord(resT) = 1) = yes ;
3670  TWDRReserveType(resT) $ (ord(resT) = 2) = yes ;
3671  ILReserveType(resT)   $ (ord(resT) = 3) = yes ;
3672   
3673  reserveOfferProportion(offer,trdBlk,resC)
3674      $ ( ord(resC) = 1 )
3675      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3676           , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3677   
3678  reserveOfferProportion(offer,trdBlk,resC)
3679      $ ( ord(resC) = 2 )
3680      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3681           , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3682   
3683  reserveOfferMaximum(offer(tp,o),trdBlk,resC,PLSRReserveType)
3684      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3685      , i_tradePeriodFastPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3686      + i_tradePeriodSustainedPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3687   
3688  reserveOfferMaximum(offer(tp,o),trdBlk,resC,TWDRReserveType)
3689      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3690      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3691      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3692   
3693  reserveOfferMaximum(offer,trdBlk,resC,ILReserveType)
3694      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3695      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3696      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ];
3697   
3698  reserveOfferPrice(offer,trdBlk,resC,PLSRReserveType)
3699      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3700      , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3701      + i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3702   
3703   
3704  reserveOfferPrice(offer,trdBlk,resC,TWDRReserveType)
3705      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3706      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3707      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3708   
3709  reserveOfferPrice(offer,trdBlk,resC,ILReserveType)
3710      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3711      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3712      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ] ;
3713   
3714  * Only reserve offer block with a positive block limit is valid
3715  validReserveOfferBlock(offer,trdBlk,resC,resT)
3716      $ (reserveOfferMaximum(offer,trdBlk,resC,resT) > 0) = yes ;
3717   
3718  * Bid energy data
3719  purchaseBidMW(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3720      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3721           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3722   
3723  purchaseBidPrice(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3724      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3725           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3726   
3727  validPurchaseBidBlock(bid,trdBlk)
3728      $ { ( purchaseBidMW(bid,trdBlk) > 0 ) or
3729          ( useDSBFDemandBidModel * purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3730   
3731  * Bid IL data
3732  purchaseBidILRMW(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3733      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3734           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3735           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3736   
3737  purchaseBidILRPrice(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3738      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3739           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3740           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3741   
3742  validPurchaseBidILRBlock(bid,trdBlk,resC)
3743      $ ( purchaseBidILRMW(bid,trdBlk,resC) > 0 ) = yes ;
3744   
3745   
3746  * Initialise demand/bid data for the current trade period start
3747  nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3748   
3749  * If a bid is valid --> ignore the demand at the node connected to the bid
3750  * (PA suggested during v1.4 Audit)
3751  nodeDemand(node(tp,n))
3752      $ { useDSBFDemandBidModel and
3753          Sum[ bd $ { bidNode(tp,bd,n) and i_tradePeriodDispatchableBid(tp,bd) }
3754             , 1 ]
3755        } = 0;
3756   
3757  * Real Time Pricing - First RTD load calculation
3759  if studyMode = 101 then
3760   
3761  *   Calculate first target total load [3.8.5.5]
3762  *   Island-level MW load forecast. For the fist loop:
3763  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
3764      TargetTotalLoad(tp,ild) = islandMWIPS(tp,ild) + islandPDS(tp,ild) - islandLosses(tp,ild);
3765   
3766  *   Flag if estimate load is scalable [3.8.5.7]
3767  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
3768  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
3769  *   assigned directly to EstimatedInitialLoad
3770      EstLoadIsScalable(tp,n) =  1 $ { (LoadIsNCL(tp,n) = 0)
3771                                   and (ConformingFactor(tp,n) > 0) } ;
3772   
3773  *   Calculate estimate non-scalable load [3.8.5.8]
3774  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
3775  *   conforming Pnode this will be the ConformingFactor MW input if that value is
3776  *   negative, otherwise it will be zero
3777      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 1 ) = NonConformingLoad(tp,n);
3778      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 0 ) = ConformingFactor(tp,n);
3779      EstNonScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = 0;
3780   
3781  *   Calculate estimate scalable load [3.8.5.10]
3782  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
3783  *   this value will be the ConformingFactor if it is non-negative, otherwise this
3784  *   value will be zero'
3785      EstScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = ConformingFactor(tp,n);
3786   
3787   
3788  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
3789  *   in order to calculate EstimatedInitialLoad
3790      EstScalingFactor(tp,ild)
3791          = (islandMWIPS(tp,ild) - islandLosses(tp,ild)
3792            - Sum[ n $ nodeIsland(tp,n,ild), EstNonScalableLoad(tp,n) ]
3793            ) / Sum[ n $ nodeIsland(tp,n,ild), EstScalableLoad(tp,n) ]
3794   
3795          ;
3796   
3797  *   Calculate estimate initial load [3.8.5.6]
3798  *   Calculated estimate of initial MW load, available to be used as an
3799  *   alternative to InputInitialLoad
3800      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 )
3801          = ConformingFactor(tp,n) * Sum[ ild $ nodeisland(tp,n,ild)
3802                                        , EstScalingFactor(tp,ild)] ;
3803  * TN- There is a bug in this equarion
3804      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 0 )
3805  *        = NonConformingLoad(tp,n);
3806          = EstNonScalableLoad(tp,n);
3807   
3808  *   Calculate initial load [3.8.5.2]
3809  *   Value that represents the Pnode load MW at the start of the solution
3810  *   interval. Depending on the inputs this value will be either actual load,
3811  *   an operator applied override or an estimated initial load
3812      InitialLoad(tp,n) = InputInitialLoad(tp,n);
3813      InitialLoad(tp,n) $ { (LoadIsOverride(tp,n) = 0)
3814                        and ( (useActualLoad(tp) = 0) or (LoadIsBad(tp,n) = 1) )
3815                          } = EstimatedInitialLoad(tp,n) ;
3816   
3817  *   Flag if load is scalable [3.8.5.4]
3818  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
3819  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
3820  *   assigned to nodedemand
3821      LoadIsScalable(tp,n) = 1 $ { (LoadIsNCL(tp,n) = 0)
3822                               and (LoadIsOverride(tp,n) = 0)
3823                               and (InitialLoad(tp,n) >= 0) } ;
3824   
3825  *   Calculate Island-level scaling factor [3.8.5.3]
3826  *   --> applied to InitialLoad in order to calculate nodedemand
3827      LoadScalingFactor(tp,ild)
3828          = ( TargetTotalLoad(tp,ild)
3829            - Sum[ n $ { nodeIsland(tp,n,ild)
3830                     and (LoadIsScalable(tp,n) = 0) }, InitialLoad(tp,n) ]
3831            ) / Sum[ n $ { nodeIsland(tp,n,ild)
3832                       and (LoadIsScalable(tp,n) = 1) }, InitialLoad(tp,n) ]
3833          ;
3834   
3835  *   Calculate nodedemand [3.8.5.1]
3836      nodedemand(tp,n) $ LoadIsScalable(tp,n)
3837          = InitialLoad(tp,n) * sum[ ild $ nodeisland(tp,n,ild)
3838                                   , LoadScalingFactor(tp,ild) ];
3839   
3840      nodedemand(tp,n) $ (LoadIsScalable(tp,n) = 0) = InitialLoad(tp,n);
3841   
3842  Endif;
3844   
3845   
3846   
3847   
3848   
3849  * Branch is defined if there is a defined terminal bus, it has a non-zero
3850  * capacity and is closed for that trade period
3851  * Update the pre-processing code that removes branches which have a limit of zero
3852  * so that it removes a branch if either direction has a limit of zero.
3853  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3854                    (not i_tradePeriodHVDCBranch(tp,br)) and
3855                    sum[ fd $ (ord(fd)=1), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3856                    sum[ fd $ (ord(fd)=2), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3857                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3858                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3859                  } = yes ;
3860   
3861  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3862                    (i_tradePeriodHVDCBranch(tp,br)) and
3863                    sum[ fd, i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3864                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3865                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3866                  } = yes ;
3867   
3868   
3869  branchBusDefn(branch,b,b1) $ i_tradePeriodBranchDefn(branch,b,b1)    = yes ;
3870  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b,b1), 1] = yes ;
3871  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b1,b), 1] = yes ;
3872   
3873  * HVDC link and AC branch definition
3874  HVDClink(branch)      $ i_tradePeriodHVDCBranch(branch)         = yes ;
3875  HVDCpoles(branch)     $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3876  HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3877  ACbranch(branch)      $ ( not HVDClink(branch) )                = yes ;
3878   
3879  * Determine sending and receiving bus sets
3880  loop((frB,toB),
3881      ACbranchSendingBus(ACbranch,frB,fd)
3882          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3883   
3884      ACbranchReceivingBus(ACbranch,toB,fd)
3885          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3886   
3887      ACbranchSendingBus(ACbranch,toB,fd)
3888          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3889   
3890      ACbranchReceivingBus(ACbranch,frB,fd)
3891          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3892  );
3893   
3894  HVDClinkSendingBus(HVDClink,frB)
3895      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3896   
3897  HVDClinkReceivingBus(HVDClink,toB)
3898      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3899   
3900  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
3901  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
3902   
3903  * Determine the HVDC inter-island pole in the northward and southward direction
3904   
3905  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 1) and HVDClink(tp,br) }
3906      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 2)
3907                                         and nodeIsland(tp,n,ild)
3908                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3909   
3910  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 2) and HVDClink(tp,br) }
3911      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 1)
3912                                         and nodeIsland(tp,n,ild)
3913                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3914   
3915  * Mapping HVDC branch to pole to account for name changes to Pole 3
3916  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3917  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3918  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3919  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3920  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3921  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3922   
3923  * Initialise network data for the current trade period start
3924  * Node-bus allocation factor
3925  nodeBusAllocationFactor(tp,n,b) $ { node(tp,n) and bus(tp,b) }
3926      = i_tradePeriodNodeBusAllocationFactor(tp,n,b) ;
3927   
3928  * Flag to allow roundpower on the HVDC link
3929  allowHVDCroundpower(tp) = i_tradePeriodAllowHVDCroundpower(tp) ;
3930   
3931  * Allocate the input branch parameters to the defined branchCapacity
3932  branchCapacity(branch,fd)
3933      = i_tradePeriodBranchCapacityDirected(branch,fd) ;
3934  * HVDC Links do not have reverse capacity
3935  branchCapacity(HVDClink,fd) $ ( ord(fd) = 2 ) = 0 ;
3936   
3937  * Allocate the input branch parameters to the defined branchResistance
3938  branchResistance(branch)
3939      = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3940           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3941   
3942  * Convert susceptance from -Bpu to B% for data post-MSP
3943  branchSusceptance(ACbranch(tp,br))
3944      = sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3945           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ]
3946      * [ 100$(not i_useBusNetworkModel(tp)) - 100$i_useBusNetworkModel(tp) ];
3947   
3948  branchLossBlocks(branch)
3949      = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3950           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3951   
3952  * Ensure fixed losses for no loss AC branches are not included
3953  branchFixedLoss(ACbranch)
3954      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3955           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3956           ] $ (branchLossBlocks(ACbranch) > 1) ;
3957   
3958  branchFixedLoss(HVDClink)
3959      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3960           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3961   
3962  * Set resistance and fixed loss to zero if do not want to use the loss model
3963  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3964  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
3965   
3966  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3967  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
3968   
3969  * Initialise loss tranches data for the current trade period start
3970  * The loss factor coefficients assume that the branch capacity is in MW
3971  * and the resistance is in p.u.
3972   
3973  * Loss branches with 0 loss blocks
3974  lossSegmentMW(branch,los,fd)
3975      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3976      = branchCapacity(branch,fd) ;
3977   
3978  LossSegmentFactor(branch,los,fd)
3979      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3980      = 0 ;
3981   
3982  * Loss branches with 1 loss blocks
3983  LossSegmentMW(branch,los,fd)
3984      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3985      = maxFlowSegment ;
3986   
3987  LossSegmentFactor(branch,los,fd)
3988      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3989      = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
3990   
3991  * Loss branches with 3 loss blocks
3992  loop( branch $ (branchLossBlocks(branch) = 3),
3993  *   Segment 1
3994      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3995          = lossCoeff_A * branchCapacity(branch,fd) ;
3996   
3997      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3998          = 0.01 * 0.75 * lossCoeff_A
3999          * branchResistance(branch) * branchCapacity(branch,fd) ;
4000   
4001  *   Segment 2
4002      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
4003          = (1-lossCoeff_A) * branchCapacity(branch,fd) ;
4004   
4005      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4006          = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
4007   
4008  *   Segment 3
4009      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4010          = maxFlowSegment ;
4011   
4012      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4013          = 0.01 * (2 - (0.75*lossCoeff_A))
4014          * branchResistance(branch) * branchCapacity(branch,fd) ;
4015  );
4016   
4017  * Loss branches with 6 loss blocks
4018  loop( branch $ (branchLossBlocks(branch) = 6),
4019  *   Segment 1
4020      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
4021          = lossCoeff_C  * branchCapacity(branch,fd) ;
4022   
4023      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
4024          = 0.01 * 0.75 * lossCoeff_C
4025          * branchResistance(branch) * branchCapacity(branch,fd) ;
4026   
4027  *   Segment 2
4028      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
4029          = lossCoeff_D * branchCapacity(branch,fd) ;
4030   
4031      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4032          = 0.01 * lossCoeff_E
4033          * branchResistance(branch) * branchCapacity(branch,fd) ;
4034   
4035  *   Segment 3
4036      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4037          = 0.5 * branchCapacity(branch,fd) ;
4038   
4039      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4040          = 0.01 * lossCoeff_F
4041          * branchResistance(branch) * branchCapacity(branch,fd) ;
4042   
4043  *   Segment 4
4044      LossSegmentMW(branch,los,fd) $ (ord(los) = 4)
4045          = (1 - lossCoeff_D) * branchCapacity(branch,fd) ;
4046   
4047      LossSegmentFactor(branch,los,fd) $ (ord(los) = 4)
4048          = 0.01 * (2 - lossCoeff_F)
4049          * branchResistance(branch) * branchCapacity(branch,fd) ;
4050   
4051  *   Segment 5
4052      LossSegmentMW(branch,los,fd) $ (ord(los) = 5)
4053          = (1 - lossCoeff_C) * branchCapacity(branch,fd) ;
4054   
4055      LossSegmentFactor(branch,los,fd) $ (ord(los) = 5)
4056          = 0.01 * (2 - lossCoeff_E)
4057          * branchResistance(branch) * branchCapacity(branch,fd) ;
4058   
4059  *   Segment 6
4060      LossSegmentMW(branch,los,fd) $ (ord(los) = 6)
4061          = maxFlowSegment ;
4062   
4063      LossSegmentFactor(branch,los,fd) $ (ord(los) = 6)
4064          = 0.01 * (2 - (0.75*lossCoeff_C))
4065          * branchResistance(branch) * branchCapacity(branch,fd) ;
4066  ) ;
4067   
4068  * HVDC does not have backward flow --> No loss segment for backward flow
4069  LossSegmentMW(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4070  LossSegmentFactor(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4071   
4072   
4073  * Valid loss segment for a branch is defined as a loss segment that
4074  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
4075  validLossSegment(branch,los,fd) = yes $ { (ord(los) = 1) or
4076                                            LossSegmentMW(branch,los,fd) or
4077                                            LossSegmentFactor(branch,los,fd) } ;
4078   
4079  * HVDC loss model requires at least two loss segments and
4080  * an additional loss block due to cumulative loss formulation
4081  validLossSegment(HVDClink,los,fd)
4082      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
4083   
4084  validLossSegment(HVDClink,los,fd)
4085      $ { (branchLossBlocks(HVDClink) > 1) and
4086          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
4087          (sum[ los1, LossSegmentMW(HVDClink,los1,fd)
4088                    + LossSegmentFactor(HVDClink,los1,fd) ] > 0)
4089        } = yes ;
4090   
4091  * branches that have non-zero loss factors
4092  LossBranch(branch) $ sum[ (los,fd), LossSegmentFactor(branch,los,fd) ] = yes ;
4093   
4094  * Create AC branch loss segments
4095  ACbranchLossMW(ACbranch,los,fd)
4096      $ { validLossSegment(ACbranch,los,fd) and (ord(los) = 1) }
4097      = LossSegmentMW(ACbranch,los,fd) ;
4098   
4099  ACbranchLossMW(ACbranch,los,fd)
4100      $ { validLossSegment(ACbranch,los,fd) and (ord(los) > 1) }
4101      = LossSegmentMW(ACbranch,los,fd) - LossSegmentMW(ACbranch,los-1,fd) ;
4102   
4103  ACbranchLossFactor(ACbranch,los,fd)
4104      $ validLossSegment(ACbranch,los,fd) = LossSegmentFactor(ACbranch,los,fd) ;
4105   
4106  * Create HVDC loss break points
4107  HVDCBreakPointMWFlow(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4108  HVDCBreakPointMWLoss(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4109   
4110  HVDCBreakPointMWFlow(HVDClink,bp,fd)
4111      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) > 1) }
4112      = LossSegmentMW(HVDClink,bp-1,fd) ;
4113   
4114  HVDCBreakPointMWLoss(HVDClink,bp,fd)
4115      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) = 2) }
4116      =  LossSegmentMW(HVDClink,bp-1,fd) * LossSegmentFactor(HVDClink,bp-1,fd) ;
4117   
4118  loop( (HVDClink(branch),bp) $ (ord(bp) > 2),
4119      HVDCBreakPointMWLoss(branch,bp,fd) $ validLossSegment(branch,bp,fd)
4120          = LossSegmentFactor(branch,bp-1,fd)
4121          * [ LossSegmentMW(branch,bp-1,fd) - LossSegmentMW(branch,bp-2,fd) ]
4122          + HVDCBreakPointMWLoss(branch,bp-1,fd) ;
4123  ) ;
4124   
4125  * Initialise branch constraint data for the current trading period
4126  branchConstraint(tp,brCstr)
4127      $ sum[ branch(tp,br)
4128           $ i_tradePeriodBranchConstraintFactors(tp,brCstr,br), 1 ] = yes ;
4129   
4130  branchConstraintFactors(branchConstraint,br)
4131      = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
4132   
4133  branchConstraintSense(branchConstraint)
4134      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4135           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4136   
4137  branchConstraintLimit(branchConstraint)
4138      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4139           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4140   
4141  * Calculate parameters for NMIR project ----------------------------------------
4142  islandRiskGroup(tp,ild,rg,riskC)
4143      = yes $ sum[ o $ { offerIsland(tp,o,ild)
4144                     and riskGroupOffer(tp,rg,o,riskC) }, 1 ] ;
4145   
4146  modulationRisk(tp) = smax[ riskC, modulationRiskClass(tp,RiskC) ];
4147   
4148  reserveShareEnabledOverall(tp) = smax[ resC, reserveShareEnabled(tp,resC) ];
4149   
4150  roPwrZoneExit(tp,resC)
4151      = [ roundPower2MonoLevel(tp) - modulationRisk(tp) ]$(ord(resC)=1)
4152      + bipole2MonoLevel(tp)$(ord(resC)=2) ;
4153   
4154  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition by SPD pre-processing (same as for SIR),
            a change from the existing where the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone for FIR will be removed by SPD pre-processing (same as for SIR),
            a change from the existing where the InNoReverseZone for FIR is never removed by SPD pre-processing.
4162   
4163  if (inputGDXGDate >= jdate(2019,03,28),
4164      roPwrZoneExit(tp,resC) = bipole2MonoLevel(tp) ;
4165  ) ;
4166   
4167  * National market refinement end
4168   
4169   
4170  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
4171  sharedNFRLoad(tp,ild)
4172      = sum[ nodeIsland(tp,n,ild), nodeDemand(tp,n)]
4173      + sum[ (bd,trdBlk) $ bidIsland(tp,bd,ild), purchaseBidMW(tp,bd,trdBlk) ]
4174      - sharedNFRLoadOffset(tp,ild) ;
4175   
4176  sharedNFRMax(tp,ild) = Min{ RMTReserveLimitTo(tp,ild,'FIR'),
4177                              sharedNFRFactor(tp)*sharedNFRLoad(tp,ild) } ;
4178   
4179  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
4180  * TN on 22 May 2017: Usually a branch group constraint that limits the HVDC flow only involves
4181  * the HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017, the
4182  * constraint HAY_BEN_High_Frequency_limit involved all four branches in the form:
4183  *   HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
4184  * This method of formulating the constraint prevented the previous formulation of monopoleConstraint
4185  * and bipoleConstraintfrom working properly. Those constraints have been reformulated (see below)
4186  * in order to cope with the formulation observed on 18 May 2017.
4187  monopoleConstraint(tp,ild,brCstr,br)
4188      $ { HVDCpoles(tp,br)
4189      and ( not rampingConstraint(tp,brCstr) )
4190      and ( branchConstraintSense(tp,brCstr) = -1 )
4191      and (Sum[ (br1,b) $ {HVDClinkSendingBus(tp,br1,b) and busIsland(tp,b,ild)}
4192                        , branchConstraintFactors(tp,brCstr,br1)    ] = 1)
4193      and (Sum[ b $ {HVDClinkSendingBus(tp,br,b) and busIsland(tp,b,ild)}
4194                   , branchConstraintFactors(tp,brCstr,br)      ] = 1)
4195         } = yes ;
4196   
4197  bipoleConstraint(tp,ild,brCstr)
4198      $ { ( not rampingConstraint(tp,brCstr) )
4199      and ( branchConstraintSense(tp,brCstr) = -1 )
4200      and (Sum[ (br,b) $ { HVDCpoles(tp,br)
4201                       and HVDClinkSendingBus(tp,br,b)
4202                       and busIsland(tp,b,ild) }
4203                      , branchConstraintFactors(tp,brCstr,br)  ] = 2)
4204                         } = yes ;
4205   
4206  monoPoleCapacity(tp,ild,br)
4207      = Sum[ (b,fd) $ { BusIsland(tp,b,ild)
4208                    and HVDCPoles(tp,br)
4209                    and HVDClinkSendingBus(tp,br,b)
4210                    and ( ord(fd) = 1 )
4211                      }, branchCapacity(tp,br,fd) ] ;
4212   
4213  monoPoleCapacity(tp,ild,br)
4214      $ Sum[ brCstr $ monopoleConstraint(tp,ild,brCstr,br), 1]
4215      = Smin[ brCstr $ monopoleConstraint(tp,ild,brCstr,br)
4216            , branchConstraintLimit(tp,brCstr) ];
4217   
4218  monoPoleCapacity(tp,ild,br)
4219      = Min( monoPoleCapacity(tp,ild,br),
4220             sum[ fd $ ( ord(fd) = 1 ), branchCapacity(tp,br,fd) ] );
4221   
4222  biPoleCapacity(tp,ild)
4223      $ Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1]
4224      = Smin[ brCstr $ bipoleConstraint(tp,ild,brCstr)
4225            , branchConstraintLimit(tp,brCstr) ];
4226   
4227  biPoleCapacity(tp,ild)
4228      $ { Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1] = 0 }
4229      = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4230                       and HVDClinkSendingBus(tp,br,b)
4231                       and ( ord(fd) = 1 )
4232                         }, branchCapacity(tp,br,fd) ] ;
4233   
4234  HVDCMax(tp,ild)
4235      = Min( biPoleCapacity(tp,ild), Sum[ br, monoPoleCapacity(tp,ild,br) ] ) ;
4236   
4237  * Calculate HVDC HVDC Loss segment applied for NMIR
4238   
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
4244  if (inputGDXGDate >= jdate(2016,11,22),
4245        HVDCCapacity(tp,ild)
4246            = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4247                             and HVDClinkSendingBus(tp,br,b)
4248                             and ( ord(fd) = 1 )
4249                               }, branchCapacity(tp,br,fd) ] ;
4250   
4251        numberOfPoles(tp,ild)
4252            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4253                          and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
4254   
4255        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4256            = Prod[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4257                           and HVDClinkSendingBus(tp,br,b)
4258                             }, branchResistance(tp,br) ]
4259            / Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4260                          and HVDClinkSendingBus(tp,br,b)
4261                            }, branchResistance(tp,br) ] ;
4262   
4263        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 1)
4264            = Sum[ br $ monoPoleCapacity(tp,ild,br), branchResistance(tp,br) ] ;
4265  else
4266      HVDCCapacity(tp,ild)
4267          = Sum[ (br,b,b1,fd) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4268                              and i_tradePeriodBusIsland(tp,b,ild)
4269                              and i_tradePeriodBranchDefn(tp,br,b,b1)
4270                              and ( ord(fd) = 1 )
4271                                }, i_tradePeriodBranchCapacityDirected(tp,br,fd) ] ;
4272   
4273      numberOfPoles(tp,ild)
4274          =Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4275                        and i_tradePeriodBusIsland(tp,b,ild)
4276                        and i_tradePeriodBranchDefn(tp,br,b,b1)
4277                        and sum[ fd $ ( ord(fd) = 1 )
4278                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4279                          }, 1 ] ;
4280   
4281      HVDCResistance(tp,ild)
4282          =  Sum[ (br,b,b1,i_branchParameter)
4283                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4284                and i_tradePeriodBusIsland(tp,b,ild)
4285                and i_tradePeriodBranchDefn(tp,br,b,b1)
4286                and (ord(i_branchParameter) = 1)
4287                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter) ] ;
4288   
4289      HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4290          = Prod[ (br,b,b1,i_branchParameter)
4291                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4292                and i_tradePeriodBusIsland(tp,b,ild)
4293                and i_tradePeriodBranchDefn(tp,br,b,b1)
4294                and sum[ fd $ ( ord(fd) = 1 )
4295                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4296                and (ord(i_branchParameter) = 1)
4297                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter)
4298                ] / HVDCResistance(tp,ild) ;
4299  ) ;
4300   
4301  * Segment 1
4302  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 1)
4303      = HVDCCapacity(tp,ild) * lossCoeff_C ;
4304   
4305  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 1)
4306      = 0.01 * 0.75 * lossCoeff_C
4307      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4308   
4309  * Segment 2
4310  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 2)
4311      = HVDCCapacity(tp,ild) * lossCoeff_D ;
4312   
4313  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 2)
4314      = 0.01 * lossCoeff_E
4315      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4316   
4317  * Segment 3
4318  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 3)
4319      = HVDCCapacity(tp,ild) * 0.5 ;
4320   
4321  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 3)
4322      = 0.01 * lossCoeff_F
4323      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4324   
4325  * Segment 4
4326  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 4)
4327      = HVDCCapacity(tp,ild) * (1 - lossCoeff_D) ;
4328   
4329  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 4)
4330      = 0.01 * (2 - lossCoeff_F)
4331      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4332   
4333  * Segment 5
4334  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 5)
4335      = HVDCCapacity(tp,ild) * (1 - lossCoeff_C) ;
4336   
4337  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 5)
4338      = 0.01 * (2 - lossCoeff_E)
4339      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4340   
4341  * Segment 6
4342  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 6)
4343      = HVDCCapacity(tp,ild) ;
4344   
4345  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 6)
4346      = 0.01 * (2 - (0.75*lossCoeff_C))
4347      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4348   
4349  * Parameter for energy lambda loss model
4350  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4351  HVDCSentBreakPointMWLoss(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4352   
4353  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) > 1)
4354      = HVDCLossSegmentMW(tp,ild,bp-1) ;
4355   
4356  loop( (tp,ild,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)},
4357      HVDCSentBreakPointMWLoss(tp,ild,bp)
4358          = HVDClossScalingFactor(tp)
4359          * HVDCLossSegmentFactor(tp,ild,bp-1)
4360          * [ HVDCLossSegmentMW(tp,ild,bp-1)
4361            - HVDCSentBreakPointMWFlow(tp,ild,bp-1) ]
4362          + HVDCSentBreakPointMWLoss(tp,ild,bp-1) ;
4363  ) ;
4364   
4365  * Parameter for energy+reserve lambda loss model
4366   
4367  * Ideally SO should use asymmetric loss curve
4368  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4369      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4370                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4371           , -HVDCSentBreakPointMWFlow(tp,ild1,rsbp1) ];
4372   
4373  * SO decide to use symmetric loss curve instead
4374  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4375      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4376           , -HVDCSentBreakPointMWFlow(tp,ild,rsbp1) ];
4377   
4378  HVDCReserveBreakPointMWFlow(tp,ild,rsbp)
4379      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4380      = HVDCSentBreakPointMWFlow(tp,ild,rsbp-6) ;
4381   
4382   
4383  * Ideally SO should use asymmetric loss curve
4384  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4385      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4386                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4387           , HVDCSentBreakPointMWLoss(tp,ild1,rsbp1) ];
4388   
4389  * SO decide to use symmetric loss curve instead
4390  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4391      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4392           , HVDCSentBreakPointMWLoss(tp,ild,rsbp1) ];
4393   
4394  HVDCReserveBreakPointMWLoss(tp,ild,rsbp)
4395      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4396      = HVDCSentBreakPointMWLoss(tp,ild,rsbp-6);
4397   
4398  * Parameter for lambda loss model  end
4399   
4400  * Initialze parameters for NMIR project end ----------------------------------
4401   
4402   
4403  * Initialise risk/reserve data for the current trade period start
4404   
4405  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
4406  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
4407  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
4408  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
4409  GenRisk(riskC)     $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4410  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4411  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4412  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4413   
4414  * Define the CE and ECE risk class set to support the different CE and ECE CVP
4415  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
4416  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
4417  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
4418  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
4419  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4420  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4421  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4422  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4423   
4424  * Risk parameters
4425  FreeReserve(tp,ild,resC,riskC)
4426      = sum[ riskPar $ (ord(riskPar) = 1)
4427                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ]
4428  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4429      - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(tp,ild1)
4430           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4431             and (inputGDXGDate >= jdate(2016,10,20)) }
4432      ;
4433   
4434  IslandRiskAdjustmentFactor(tp,ild,resC,riskC) $ useReserveModel
4435      = sum[ riskPar $ (ord(riskPar) = 2)
4436                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4437   
4438  * HVDC rampup max - (3.4.1.3) - SPD version 11
4439  HVDCpoleRampUp(tp,ild,resC,riskC)
4440      = sum[ riskPar $ (ord(riskPar) = 3)
4441                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4442   
4443  * Index IslandMinimumRisk to cater for CE and ECE minimum risk
4444  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 4)
4445      = i_tradePeriodManualRisk(tp,ild,resC) ;
4446   
4447  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 6)
4448      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4449   
4450  * HVDC secondary risk parameters
4451  HVDCsecRiskEnabled(tp,ild,riskC)= i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC);
4452  HVDCsecRiskSubtractor(tp,ild)   = i_tradePeriodHVDCsecRiskSubtractor(tp,ild) ;
4453   
4454  * Min risks for the HVDC secondary risk are the same as the island min risk
4455  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 7)
4456      = i_tradePeriodManualRisk(tp,ild,resC) ;
4457   
4458  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 8)
4459      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4460   
4461  * The MW combined maximum capability for generation and reserve of class.
4462  reserveClassGenerationMaximum(offer,resC) = ReserveGenerationMaximum(offer) ;
4463   
4464  reserveClassGenerationMaximum(offer,resC)
4465      $ i_tradePeriodReserveClassGenerationMaximum(offer,resC)
4466      = i_tradePeriodReserveClassGenerationMaximum(offer,resC) ;
4467   
4468  * Calculation of reserve maximum factor - 5.2.1.1
4469  ReserveMaximumFactor(offer,resC) = 1 ;
4470  ReserveMaximumFactor(offer,resC)
4471      $ (ReserveClassGenerationMaximum(offer,resC)>0)
4472      = ReserveGenerationMaximum(offer)
4473      / reserveClassGenerationMaximum(offer,resC) ;
4474   
4475  * Virtual reserve
4476  virtualReserveMax(tp,ild,resC) = i_tradePeriodVROfferMax(tp,ild,resC) ;
4477  virtualReservePrice(tp,ild,resC) = i_tradePeriodVROfferPrice(tp,ild,resC) ;
4478   
4479  * Initialise AC node constraint data for the current trading period
4480  ACnodeConstraint(tp,ACnodeCstr)
4481      $ sum[ ACnode(tp,n)
4482           $ i_tradePeriodACnodeConstraintFactors(tp,ACnodeCstr,n), 1 ] = yes ;
4483   
4484  ACnodeConstraintFactors(ACnodeConstraint,n)
4485      = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
4486   
4487  ACnodeConstraintSense(ACnodeConstraint)
4488      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4489           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4490   
4491  ACnodeConstraintLimit(ACnodeConstraint)
4492      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4493           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4494   
4495  * Initialise market node constraint data for the current trading period
4496  MnodeConstraint(tp,MnodeCstr)
4497      $ { sum[ (offer(tp,o),resT,resC)
4498             $ { i_tradePeriodMnodeEnergyOfferConstraintFactors(tp,MnodeCstr,o) or
4499                 i_tradePeriodMnodeReserveOfferConstraintFactors(tp,MnodeCstr,o,resC,resT)
4500               }, 1
4501             ]
4502        or
4503          sum[ (bid(tp,bd),resC)
4504             $ { i_tradePeriodMnodeEnergyBidConstraintFactors(tp,MnodeCstr,bd) or
4505                 i_tradePeriodMnodeILReserveBidConstraintFactors(tp,MnodeCstr,bd,resC)
4506               }, 1
4507             ]
4508        } = yes ;
4509   
4510  MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
4511      = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
4512   
4513  MnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT)
4514      = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT) ;
4515   
4516  MnodeEnergyBidConstraintFactors(MnodeConstraint,bd)
4517      = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,bd) ;
4518   
4519  MnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC)
4520      = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC) ;
4521   
4522  MnodeConstraintSense(MnodeConstraint)
4523      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4524           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4525   
4526  MnodeConstraintLimit(MnodeConstraint)
4527      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4528           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4529   
4530  * Initialise mixed constraint data for the current trading period
4531  Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC)
4532      = i_type1MixedConstraintReserveMap(t1MixCstr,ild,resC,riskC) ;
4533   
4534  Type1MixedConstraint(tp,t1MixCstr)
4535      = i_tradePeriodType1MixedConstraint(tp,t1MixCstr) ;
4536   
4537  Type2MixedConstraint(tp,t2MixCstr)
4538      = i_tradePeriodType2MixedConstraint(tp,t2MixCstr) ;
4539   
4540  Type1MixedConstraintSense(tp,t1MixCstr)
4541      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
4542           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4543   
4544  Type1MixedConstraintLimit1(tp,t1MixCstr)
4545      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
4546           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4547   
4548  Type1MixedConstraintLimit2(tp,t1MixCstr)
4549      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
4550           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4551   
4552  Type2MixedConstraintSense(tp,t2MixCstr)
4553      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4554           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4555   
4556  Type2MixedConstraintLimit(tp,t2MixCstr)
4557      = sum[ CstrRHS$(ord(CstrRHS) = 2)
4558           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4559   
4560  Type1MixedConstraintCondition(tp,t1MixCstr)
4561      $ sum[ br $ { HVDChalfPoles(tp,br) and
4562                    i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4563                  }, 1
4564           ] = yes ;
4565   
4566  * Initialise generic constraint data for the current trading period
4567  GenericConstraint(tp,gnrcCstr) = i_tradePeriodGenericConstraint(tp,gnrcCstr) ;
4568   
4569  GenericEnergyOfferConstraintFactors(GenericConstraint,o)
4570      = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
4571   
4572  GenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT)
4573      = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT) ;
4574   
4575  GenericEnergyBidConstraintFactors(GenericConstraint,bd)
4576      = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,bd) ;
4577   
4578  GenericILReserveBidConstraintFactors(GenericConstraint,bd,resC)
4579      = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,bd,resC) ;
4580   
4581  GenericBranchConstraintFactors(GenericConstraint,br)
4582      = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
4583   
4584  GenericConstraintSense(GenericConstraint)
4585      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4586           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4587   
4588  GenericConstraintLimit(GenericConstraint)
4589      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4590           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4591   
4592   
4593  * Additional pre-processing on parameters --------------------------------------
4594   
4595  * Calculation of generation upper limits due to ramp rate limits
4596   
4597  * Only primary offers are considered (5.3.1.1)
4598  generationMaximum(tp,o) $ (not hasPrimaryOffer(tp,o))
4599      = sum[ validGenerationOfferBlock(tp,o,trdBlk)
4600           , generationOfferMW(tp,o,trdBlk) ]
4601      + sum[ (o1,trdBlk) $ { primarySecondaryOffer(tp,o,o1) and
4602                             validGenerationOfferBlock(tp,o1,trdBlk) }
4603           , generationOfferMW(tp,o1,trdBlk)
4604           ] ;
4605   
4606  * Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4607  * initial MW and ramp rate is used - Reference: Transpower Market Services
4608  rampTimeUp(offer) $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4609      = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4610                                     - generationStart(offer)
4611                                     ) / rampRateUp(offer)
4612           ] ;
4613   
4614  * Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4615  * initial MW and ramp rate is used - Reference: Transpower Market Services
4616  generationEndUp(offer) $ (not hasPrimaryOffer(offer))
4617      = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4618   
4619   
4620  * Calculation of generation lower limits due to ramp rate limits
4621   
4622  * Only primary offers are considered (5.3.2.1)
4623  * Negative prices for generation offers are not allowed? (5.3.2.1)
4624  generationMinimum(offer) = 0;
4625   
4626  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4627  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4628  rampTimeDown(offer) $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4629      = Min[ i_tradingPeriodLength, ( generationStart(offer)
4630                                    - generationMinimum(offer)
4631                                    ) / rampRateDown(offer)
4632           ] ;
4633   
4634  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4635  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4636  generationEndDown(offer) $ (not hasPrimaryOffer(offer))
4637      = Max[ 0, generationStart(offer) - rampRateDown(offer)*rampTimeDown(offer) ] ;
4638   
4639  o_offerEnergy_TP(dt,o) = 0;
4640  *   Additional pre-processing on parameters end
4641   
4642   
4643   
4644  * TN - Pivot or demand analysis begin
4647  * TN - Pivot or demand analysis begin end
4648   
4649  *=====================================================================================
4650  * 7. The vSPD solve loop
4651  *=====================================================================================
4652  if (studyMode = 101,
INCLUDE    C:\vSPD\vSPD_v3.1.0\Programs\vSPDsolve_RTP.gms
4654  *=====================================================================================
4655  * Name:                 vSPDsolve_RTP.gms
4656  * Function:             First RTD solve to update island loss in order to
4657  *                       adjust node demand
4658  *                       A new development for Rea
4659  * Developed by:         Electricity Authority, New Zealand
4660  * Source:               https://github.com/ElectricityAuthority/vSPD
4661  *                       http://www.emi.ea.govt.nz/Tools/vSPD
4662  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
4663  *                       Email: emi@ea.govt.nz
4664  * Created on:           14 Jan 2022
4665   
4666  *=====================================================================================
4667   
4668  *   7d. Solve Models First Time For Real Time Pricing
4669  *=====================================================================================
4670  * 7. The vSPD solve loop
4671  *=====================================================================================
4672   
4673  unsolvedPeriod(tp) = yes;
4674  VSPDModel(tp) = 0 ;
4675  option clear = useBranchFlowMIP ;
4676  option clear = useMixedConstraintMIP ;
4677   
4678  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
4679    exitLoop = 0;
4680    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
4681   
4682  *   7a. Reset all sets, parameters and variables -------------------------------
4683      option clear = currTP ;
4684  *   Generation variables
4685      option clear = GENERATION ;
4686      option clear = GENERATIONBLOCK ;
4687  *   Purchase variables
4688      option clear = PURCHASE ;
4689      option clear = PURCHASEBLOCK ;
4690      option clear = PURCHASEILR ;
4691      option clear = PURCHASEILRBLOCK ;
4692  *   Network variables
4693      option clear = ACNODENETINJECTION ;
4694      option clear = ACNODEANGLE ;
4695      option clear = ACBRANCHFLOW ;
4696      option clear = ACBRANCHFLOWDIRECTED ;
4697      option clear = ACBRANCHLOSSESDIRECTED ;
4698      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4699      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4700      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4701      option clear = HVDCLINKFLOW ;
4702      option clear = HVDCLINKLOSSES ;
4703      option clear = LAMBDA ;
4704      option clear = LAMBDAINTEGER ;
4705      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
4706      option clear = HVDCPOLEFLOW_INTEGER ;
4707  *   Risk/Reserve variables
4708      option clear = RISKOFFSET ;
4709      option clear = HVDCREC ;
4710      option clear = ISLANDRISK ;
4711      option clear = RESERVEBLOCK ;
4712      option clear = RESERVE ;
4713      option clear = ISLANDRESERVE;
4714  *   NMIR variables
4715      option clear = SHAREDNFR ;
4716      option clear = SHAREDRESERVE ;
4717      option clear = HVDCSENT ;
4718      option clear = RESERVESHAREEFFECTIVE ;
4719      option clear = RESERVESHARERECEIVED ;
4720      option clear = RESERVESHARESENT ;
4721      option clear = HVDCSENDING ;
4722      option clear = INZONE ;
4723      option clear = HVDCSENTINSEGMENT ;
4724      option clear = HVDCRESERVESENT ;
4725      option clear = HVDCSENTLOSS ;
4726      option clear = HVDCRESERVELOSS ;
4727      option clear = LAMBDAHVDCENERGY ;
4728      option clear = LAMBDAHVDCRESERVE ;
4729      option clear = RESERVESHAREPENALTY ;
4730  *   Mixed constraint variables
4731      option clear = MIXEDCONSTRAINTVARIABLE ;
4732      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
4733  *   Objective
4734      option clear = NETBENEFIT ;
4735  *   Violation variables
4736      option clear = TOTALPENALTYCOST ;
4737      option clear = DEFICITBUSGENERATION ;
4738      option clear = SURPLUSBUSGENERATION ;
4739      option clear = DEFICITRESERVE ;
4740      option clear = DEFICITRESERVE_CE ;
4741      option clear = DEFICITRESERVE_ECE ;
4742      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4743      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4744      option clear = DEFICITRAMPRATE ;
4745      option clear = SURPLUSRAMPRATE ;
4746      option clear = DEFICITACnodeCONSTRAINT ;
4747      option clear = SURPLUSACnodeCONSTRAINT ;
4748      option clear = DEFICITBRANCHFLOW ;
4749      option clear = SURPLUSBRANCHFLOW ;
4750      option clear = DEFICITMNODECONSTRAINT ;
4751      option clear = SURPLUSMNODECONSTRAINT ;
4752      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
4753      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
4754      option clear = DEFICITGENERICCONSTRAINT ;
4755      option clear = SURPLUSGENERICCONSTRAINT ;
4756   
4757  *   Clear the pole circular branch flow flag
4758      option clear = circularBranchFlowExist ;
4759      option clear = poleCircularBranchFlowExist ;
4760      option clear = northHVDC ;
4761      option clear = southHVDC ;
4762      option clear = manualBranchSegmentMWFlow ;
4763      option clear = manualLossCalculation ;
4764      option clear = nonPhysicalLossExist ;
4765      option clear = modelSolved ;
4766      option clear = LPmodelSolved ;
4767  *   Disconnected bus post-processing
4768      option clear = busGeneration ;
4769      option clear = busLoad ;
4770      option clear = busDisconnected ;
4771      option clear = busPrice ;
4772   
4773   
4774  *   End reset
4775   
4776   
4777  *   7b. Initialise current trade period and model data -------------------------
4778      currTP(tp)  $ sequentialSolve       = yes;
4779      currTP(tp1) $ (not sequentialSolve) = yes;
4780   
4781  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4782      generationStart(offer(currTP(tp),o))
4783          $ (sum[ o1, generationStart(currTP,o1)] = 0)
4784          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
4785  *   Calculation of generation upper limits due to ramp rate limits
4786  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4787  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4788      rampTimeUp(offer(currTP(tp),o))
4789          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4790          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4791                                         - generationStart(offer)
4792                                         ) / rampRateUp(offer)
4793               ] ;
4794   
4795  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4796  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4797      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4798          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4799   
4800   
4801  *   Calculation of generation lower limits due to ramp rate limits
4802   
4803  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4804  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4805      rampTimeDown(offer(currTP(tp),o))
4806          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4807          = Min[ i_tradingPeriodLength, ( generationStart(offer)
4808                                        - generationMinimum(offer)
4809                                        ) / rampRateDown(offer)
4810               ] ;
4811   
4812  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4813  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4814      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4815          = Max[ 0, generationStart(offer)
4816                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
4817   
4818  *   Additional pre-processing on parameters end
4819   
4820   
4821  *   7c. Updating the variable bounds before model solve ------------------------
4822   
4823  * TN - Pivot or Demand Analysis - revise input data
4826  * TN - Pivot or Demand Analysis - revise input data end
4827   
4828  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4829   
4830  *   Offer blocks - Constraint 3.1.1.1
4831      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
4832          = generationOfferMW(validGenerationOfferBlock) ;
4833   
4834      GENERATIONBLOCK.fx(currTP,o,trdBlk)
4835          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
4836   
4837  *   Constraint 3.1.1.2 - Fix the generation variable for generators
4838  *   that are not connected or do not have a non-zero energy offer
4839      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
4840   
4841  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
4842      GENERATION.up(offer(currTP,o))
4843          $ { windOffer(offer) and priceResponsive(offer) }
4844          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4845   
4846  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
4847      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4848          $ (not UseDSBFDemandBidModel)
4849          = purchaseBidMW(validPurchaseBidBlock) ;
4850   
4851      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4852          $ (not UseDSBFDemandBidModel)
4853          = 0 ;
4854   
4855      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4856          $ UseDSBFDemandBidModel
4857          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
4858   
4859      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4860          $ UseDSBFDemandBidModel
4861          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
4862   
4863      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
4864          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
4865          = 0 ;
4866   
4867  *   Fix the purchase variable for purchasers that are not connected
4868  *   or do not have a non-zero purchase bid
4869      PURCHASE.fx(currTP,bd)
4870          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
4871   
4872  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4873   
4874   
4875  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4876   
4877  *   Ensure that variables used to specify flow and losses on HVDC link are
4878  *   zero for AC branches and for open HVDC links.
4879      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
4880      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
4881   
4882  *   Apply an upper bound on the weighting parameter based on its definition
4883      LAMBDA.up(branch,bp) = 1 ;
4884   
4885  *   Ensure that the weighting factor value is zero for AC branches and for
4886  *   invalid loss segments on HVDC links
4887      LAMBDA.fx(HVDClink,bp)
4888          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
4889      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
4890   
4891  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4892   
4893   
4894  *======= AC TRANSMISSION EQUATIONS =============================================
4895   
4896  *   Ensure that variables used to specify flow and losses on AC branches are
4897  *   zero for HVDC links branches and for open AC branches
4898      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
4899      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
4900      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
4901   
4902  *   Ensure directed block flow and loss block variables are zero for
4903  *   non-AC branches and invalid loss segments on AC branches
4904     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
4905         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4906   
4907     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
4908         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4909   
4910   
4911  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
4912  *   corresponding to the reference nodes and the HVDC nodes are set to zero
4913      ACNODEANGLE.fx(currTP,b)
4914         $ sum[ n $ { NodeBus(currTP,n,b) and
4915                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
4916   
4917  *======= AC TRANSMISSION EQUATIONS END =========================================
4918   
4919   
4920  *======= RISK & RESERVE EQUATIONS ==============================================
4921   
4922  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4923      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
4924          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
4925   
4926      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
4927          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
4928   
4929  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
4930      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
4931          = reserveOfferMaximum(validReserveOfferBlock) ;
4932   
4933      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
4934          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4935   
4936  *   Fix the reserve variable for invalid reserve offers. These are offers that
4937  *   are either not connected to the grid or have no reserve quantity offered.
4938      RESERVE.fx(currTP,o,resC,resT)
4939          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
4940   
4941  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
4942  *   offers that are either not connected to the grid or have no reserve quantity offered.
4943      PURCHASEILR.fx(currTP,bd,resC)
4944          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
4945   
4946  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4947      RISKOFFSET.fx(currTP,ild,resC,riskC)
4948          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
4949              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
4950            } = 0 ;
4951   
4952  *   Fix the appropriate deficit variable to zero depending on
4953  *   whether the different CE and ECE CVP flag is set
4954      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
4955      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4956      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4957   
4958  *   Virtual reserve
4959      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
4960   
4961  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
4976  *   NMIR project variables
4977      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4978      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4979   
4980  *   (3.4.2.3) - SPD version 11.0
4981      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
4982   
4983  *   No forward reserve sharing if HVDC capacity is zero
4984      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4985          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
4986   
4987  *   No forward reserve sharing if reserve sharing is disabled
4988      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4989          $ (reserveShareEnabled(currTP,resC)=0) = 0;
4990   
4991  *   No reserve sharing to cover HVDC risk
4992      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
4993      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
4994   
4995  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4996      INZONE.fx(currTP,ild,resC,z)
4997          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
4998   
4999  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
5000      INZONE.fx(currTP,ild,resC,z)
5001          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
5002   
5003  *   Fixing Lambda integer variable for energy sent
5004      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
5005                                          and (ord(bp) = 1) } = 1 ;
5006   
5007      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
5008   
5009  * To be reviewed NMIR
5010      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
5011          $ { (HVDCCapacity(currTP,ild) = 0)
5012          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
5013   
5014      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
5015          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
5016          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
5017  ;
5018   
5019   
5020  *======= RISK & RESERVE EQUATIONS END ==========================================
5021   
5022   
5023  *======= MIXED CONSTRAINTS =====================================================
5024   
5025  *   Mixed constraint
5026      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
5027          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
5028   
5029  *======= MIXED CONSTRAINTS END =================================================
5030   
5031  *   Updating the variable bounds before model solve end
5032   
5033   
5034  *   7d. Solve Models
5035  *   Solve the LP model ---------------------------------------------------------
5036      if( (Sum[currTP, VSPDModel(currTP)] = 0),
5037   
5038          if( UseShareReserve,
5039              option bratio = 1 ;
5040              vSPD_NMIR.Optfile = 1 ;
5041              vSPD_NMIR.optcr = MIPOptimality ;
5042              vSPD_NMIR.reslim = MIPTimeLimit ;
5043              vSPD_NMIR.iterlim = MIPIterationLimit ;
5044              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5045  *           Set the model solve status
5046              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5047                                 or (vSPD_NMIR.modelstat = 8) )
5048                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5049          else
5050              option bratio = 1 ;
5051              vSPD.reslim = LPTimeLimit ;
5052              vSPD.iterlim = LPIterationLimit ;
5053              solve vSPD using lp maximizing NETBENEFIT ;
5054  *           Set the model solve status
5055              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5056          )
5057   
5058  *       Post a progress message to the console and for use by EMI.
5059          if((ModelSolved = 1) and (sequentialSolve = 0),
5060              putclose runlog 'The case: FP_20221015_F '
5061                              'is 1st solved successfully.'/
5062                              'Objective function value: '
5063                              NETBENEFIT.l:<12:1 /
5064                              'Violation Cost          : '
5065                              TOTALPENALTYCOST.l:<12:1 /
5066          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
5067              putclose runlog 'The case: FP_20221015_F '
5068                              'is 1st solved unsuccessfully.'/
5069          ) ;
5070   
5071          if((ModelSolved = 1) and (sequentialSolve = 1),
5072              loop(currTP,
5073                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5074                                  'is 1st solved successfully.'/
5075                                  'Objective function value: '
5076                                  NETBENEFIT.l:<12:1 /
5077                                  'Violations cost         : '
5078                                  TOTALPENALTYCOST.l:<12:1 /
5079              ) ;
5080          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
5081              loop(currTP,
5082                  unsolvedPeriod(currTP) = no;
5083                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5084                                  'is 1st solved unsuccessfully.'/
5085              ) ;
5086   
5087          ) ;
5088  *   Solve the LP model end -----------------------------------------------------
5089   
5090   
5091  *   Solve the VSPD_MIP model ---------------------------------------------------
5092      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
5093  *       Fix the values of the integer variables that are not needed
5094          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5095              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5096   
5097  *       Fix the integer AC branch flow variable to zero for invalid branches
5098          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5099              $ (not branch(currTP,br)) = 0 ;
5100   
5101  *       Apply an upper bound on the integer weighting parameter
5102          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5103   
5104  *       Ensure that the weighting factor value is zero for AC branches
5105  *       and for invalid loss segments on HVDC links
5106          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5107              $ { ACbranch(branch)
5108              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5109                } = 0 ;
5110   
5111  *       Fix the lambda integer variable to zero for invalid branches
5112          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5113   
5114  *       Fix the value of some binary variables used in the mixed constraints
5115  *       that have no alternate limit
5116          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5117              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5118   
5119          option bratio = 1 ;
5120          vSPD_MIP.Optfile = 1 ;
5121          vSPD_MIP.optcr = MIPOptimality ;
5122          vSPD_MIP.reslim = MIPTimeLimit ;
5123          vSPD_MIP.iterlim = MIPIterationLimit ;
5124          solve vSPD_MIP using mip maximizing NETBENEFIT ;
5125  *       Set the model solve status
5126          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
5127                                (vSPD_MIP.modelstat = 8)
5128                              ]
5129                              and
5130                              [ vSPD_MIP.solvestat = 1 ]
5131                            } ;
5132   
5133  *       Post a progress message for use by EMI.
5134          if(ModelSolved = 1,
5135              loop(currTP,
5136                  unsolvedPeriod(currTP) = no;
5137                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5138                                  'is 1st solved successfully for FULL integer.'/
5139                                  'Objective function value: '
5140                                  NETBENEFIT.l:<12:1 /
5141                                  'Violations              : '
5142                                  TOTALPENALTYCOST.l:<12:1 /
5143              ) ;
5144          else
5145              loop(currTP,
5146                  unsolvedPeriod(currTP) = yes;
5147                  VSPDModel(currTP) = 4;
5148                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5149                                  'is 1st solved unsuccessfully for FULL integer.'/
5150              ) ;
5151          ) ;
5152  *   Solve the vSPD_MIP model end -----------------------------------------------
5153   
5154   
5155  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5156      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5157  *       Fix the values of these integer variables that are not needed
5158          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5159              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5160   
5161  *       Fix the integer AC branch flow variable to zero for invalid branches
5162          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5163              $ (not branch(currTP,br)) = 0 ;
5164   
5165  *       Apply an upper bound on the integer weighting parameter
5166          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5167   
5168  *       Ensure that the weighting factor value is zero for AC branches
5169  *       and for invalid loss segments on HVDC links
5170          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5171              $ { ACbranch(branch)
5172              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5173                } = 0 ;
5174   
5175  *       Fix the lambda integer variable to zero for invalid branches
5176          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5177   
5178          option bratio = 1 ;
5179          vSPD_BranchFlowMIP.Optfile = 1 ;
5180          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5181          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5182          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5183          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5184  *       Set the model solve status
5185          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5186                                (vSPD_BranchFlowMIP.modelstat = 8)
5187                              ]
5188                              and
5189                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5190                            } ;
5191   
5192  *       Post a progress message for use by EMI.
5193          if(ModelSolved = 1,
5194   
5195  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5196              vSPD_SOS1_Solve(currTP)  = yes;
5197   
5198              loop(currTP,
5199                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5200                                  'is 1st solved successfully for branch integer.'/
5201                                  'Objective function value: '
5202                                  NETBENEFIT.l:<12:1 /
5203                                  'Violations cost         : '
5204                                  TOTALPENALTYCOST.l:<12:1 /
5205              ) ;
5206          else
5207              loop(currTP,
5208                  unsolvedPeriod(currTP) = yes;
5209                  VSPDModel(currTP) = 4;
5210                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5211                                  'is 1st solved unsuccessfully for branch integer.'/
5212              ) ;
5213          ) ;
5214  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5215   
5216   
5217  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5218      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5219  *       Fix the value of some binary variables used in the mixed constraints
5220  *       that have no alternate limit
5221          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5222              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5223   
5224  *       Use the advanced basis here
5225          option bratio = 0.25 ;
5226          vSPD_MixedConstraintMIP.Optfile = 1 ;
5227  *       Set the optimality criteria for the MIP
5228          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5229          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5230          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5231  *       Solve the model
5232          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5233  *       Set the model solve status
5234          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5235                                (vSPD_MixedConstraintMIP.modelstat = 8)
5236                              ]
5237                              and
5238                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5239                            } ;
5240   
5241  *       Post a progress message for use by EMI.
5242          if(ModelSolved = 1,
5243              loop(currTP,
5244                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5245                                  'is 1st solved successfully for '
5246                                  'mixed constraint integer.'/
5247                                  'Objective function value: '
5248                                  NETBENEFIT.l:<12:1 /
5249                                  'Violations cost         : '
5250                                  TOTALPENALTYCOST.l:<12:1 /
5251              ) ;
5252          else
5253              loop(currTP,
5254                  unsolvedPeriod(currTP) = yes;
5255                  VSPDModel(currTP) = 1;
5256                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
5257                                  'is 1st solved unsuccessfully for '
5258                                  'mixed constraint integer.'/
5259              ) ;
5260          ) ;
5261  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5262   
5263   
5264  *   Solve the LP model and stop ------------------------------------------------
5265      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5266   
5267          if( UseShareReserve,
5268              option bratio = 1 ;
5269              vSPD_NMIR.Optfile = 1 ;
5270              vSPD_NMIR.optcr = MIPOptimality ;
5271              vSPD_NMIR.reslim = MIPTimeLimit ;
5272              vSPD_NMIR.iterlim = MIPIterationLimit ;
5273              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5274  *           Set the model solve status
5275              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5276                                 or (vSPD_NMIR.modelstat = 8) )
5277                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5278          else
5279              option bratio = 1 ;
5280              vSPD.reslim = LPTimeLimit ;
5281              vSPD.iterlim = LPIterationLimit ;
5282              solve vSPD using lp maximizing NETBENEFIT ;
5283  *           Set the model solve status
5284              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5285          )
5286   
5287  *       Post a progress message for use by EMI.
5288          if( ModelSolved = 1,
5289              loop(currTP,
5290                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ')'
5291                                  ' integer resolve was unsuccessful.' /
5292                                  'Reverting back to linear solve and '
5293                                  'solve successfully. ' /
5294                                  'Objective function value: '
5295                                  NETBENEFIT.l:<12:1 /
5296                                  'Violations cost         : '
5297                                  TOTALPENALTYCOST.l:<12:1 /
5298                                  'Solution may have circulating flows '
5299                                  'and/or non-physical losses.' /
5300              ) ;
5301          else
5302              loop(currTP,
5303                  putclose runlog 'The case: FP_20221015_F (' currTP.tl
5304                                  ') integer solve was unsuccessful. '
5305                                  'Reverting back to linear solve. '
5306                                  'Linear solve unsuccessful.' /
5307              ) ;
5308          ) ;
5309   
5310          unsolvedPeriod(currTP) = no;
5311   
5312  *   Solve the LP model and stop end --------------------------------------------
5313   
5314      ) ;
5315  *   Solve the models end
5316   
5317   
5318   
5319  *   6e. Check if the LP results are valid --------------------------------------
5320      if((ModelSolved = 1),
5321          useBranchFlowMIP(currTP) = 0 ;
5322          useMixedConstraintMIP(currTP) = 0 ;
5323  *       Check if there is no branch circular flow and non-physical losses
5324          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
5325   
5326  *           Check if there are circulating branch flows on loss AC branches
5327              circularBranchFlowExist(ACbranch(currTP,br))
5328                  $ { LossBranch(ACbranch) and
5329                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
5330                        - abs(ACBRANCHFLOW.l(ACbranch))
5331                        ) > circularBranchFlowTolerance
5332                      ]
5333                    } = 1 ;
5334   
5335  *           Determine the circular branch flow flag on each HVDC pole
5336              TotalHVDCpoleFlow(currTP,pole)
5337                  = sum[ br $ HVDCpoleBranchMap(pole,br)
5338                       , HVDCLINKFLOW.l(currTP,br) ] ;
5339   
5340              MaxHVDCpoleFlow(currTP,pole)
5341                  = smax[ br $ HVDCpoleBranchMap(pole,br)
5342                        , HVDCLINKFLOW.l(currTP,br) ] ;
5343   
5344              poleCircularBranchFlowExist(currTP,pole)
5345                  $ { ( TotalHVDCpoleFlow(currTP,pole)
5346                      - MaxHVDCpoleFlow(currTP,pole)
5347                      ) > circularBranchFlowTolerance
5348                    } = 1 ;
5349   
5350  *           Check if there are circulating branch flows on HVDC
5351              NorthHVDC(currTP)
5352                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
5353                                        i_tradePeriodBusIsland(currTP,b,ild) and
5354                                        HVDClinkSendingBus(currTP,br,b) and
5355                                        HVDCpoles(currTP,br)
5356                                      }, HVDCLINKFLOW.l(currTP,br)
5357                       ] ;
5358   
5359              SouthHVDC(currTP)
5360                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
5361                                        i_tradePeriodBusIsland(currTP,b,ild) and
5362                                        HVDClinkSendingBus(currTP,br,b) and
5363                                        HVDCpoles(currTP,br)
5364                                      }, HVDCLINKFLOW.l(currTP,br)
5365                       ] ;
5366   
5367              circularBranchFlowExist(currTP,br)
5368                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
5369                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
5370                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
5371                    } = 1 ;
5372   
5373  *           Check if there are non-physical losses on HVDC links
5374              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
5375                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5376                  and validLossSegment(currTP,br,los,fd) }
5377                  = Min[ Max( 0,
5378                              [ abs(HVDCLINKFLOW.l(HVDClink))
5379                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5380                              ]
5381                            ),
5382                         ( LossSegmentMW(HVDClink,los,fd)
5383                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5384                         )
5385                       ] ;
5386   
5387              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
5388                  = sum[ (los,fd) $ validLossSegment(currTP,br,los,fd)
5389                                  , LossSegmentFactor(HVDClink,los,fd)
5390                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
5391                       ] ;
5392   
5393              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
5394                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
5395                         - ManualLossCalculation(HVDClink)
5396                         ) > NonPhysicalLossTolerance
5397                    } = 1 ;
5398   
5399  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
5400  *           and non-physical loss branches exceeds the specified tolerance
5401              useBranchFlowMIP(currTP)
5402                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
5403                                , resolveCircularBranchFlows
5404                                * circularBranchFlowExist(currTP,br)
5405                           ]
5406                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
5407                                , (1 - AllowHVDCroundpower(currTP))
5408                                * resolveCircularBranchFlows
5409                                * circularBranchFlowExist(currTP,br)
5410                                + resolveHVDCnonPhysicalLosses
5411                                * NonPhysicalLossExist(currTP,br)
5412                           ]
5413                      + sum[ pole, resolveCircularBranchFlows
5414                                 * poleCircularBranchFlowExist(currTP,pole)
5415                           ]
5416                       ) > UseBranchFlowMIPTolerance
5417                                         } = 1 ;
5418   
5419  *       Check if there is no branch circular flow and non-physical losses end
5420          );
5421   
5422   
5423  *       Check if there is mixed constraint integer is required
5424          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
5425   
5426  *           Check if integer variables are needed for mixed constraint
5427              if( useMixedConstraintRiskOffset,
5428                  HVDChalfPoleSouthFlow(currTP)
5429                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
5430                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
5431                             ] > MixedMIPTolerance
5432                        } = 1 ;
5433   
5434  *               Only calculate violation if the constraint limit is non-zero
5435                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
5436                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
5437                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
5438                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5439                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
5440                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5441                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
5442                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
5443                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
5444                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5445                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
5446   
5447  *               Integer constraints are needed if southward flow on half-poles AND
5448  *               constraint level exceeds the mixed constraint limit2 value
5449                  useMixedConstraintMIP(currTP)
5450                      $ { HVDChalfPoleSouthFlow(currTP) and
5451                          sum[ t1MixCstr
5452                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
5453                                 > MixedMIPTolerance }, 1
5454                             ]
5455                        } = 1 ;
5456              ) ;
5457   
5458  *       Check if there is mixed constraint integer is required end
5459          );
5460   
5461  *       A period is unsolved if MILP model is required
5462          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
5463                                         + UseMixedConstraintMIP(currTP)
5464                                         ] ;
5465   
5466  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
5467          loop( unsolvedPeriod(currTP),
5468              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
5469                  VSPDModel(currTP) = 1;
5470                  putclose runlog 'The case: FP_20221015_F requires a'
5471                                  'VSPD_MIP resolve for period ' currTP.tl
5472                                  '. Switching Vectorisation OFF.' /
5473   
5474              elseif UseBranchFlowMIP(currTP) >= 1,
5475                  if( VSPDModel(currTP) = 0,
5476                      VSPDModel(currTP) = 2;
5477                      putclose runlog 'The case: FP_20221015_F requires a '
5478                                      'vSPD_BranchFlowMIP resolve for period '
5479                                      currTP.tl '. Switching Vectorisation OFF.'/
5480                  elseif VSPDModel(currTP) = 3,
5481                      VSPDModel(currTP) = 1;
5482                      putclose runlog 'The case: FP_20221015_F requires a '
5483                                      'VSPD_MIP resolve for period ' currTP.tl
5484                                      '. Switching Vectorisation OFF.' /
5485                  );
5486   
5487              elseif UseMixedConstraintMIP(currTP) >= 1,
5488                  if( VSPDModel(currTP) = 0,
5489                      VSPDModel(currTP) = 3;
5490                      putclose runlog 'The case: FP_20221015_F requires a '
5491                                      'vSPD_MixedConstraintMIP resolve for period '
5492                                      currTP.tl '. Switching Vectorisation OFF.' /
5493                  elseif VSPDModel(currTP) = 2,
5494                      VSPDModel(currTP) = 1;
5495                      putclose runlog 'The case: FP_20221015_F requires a '
5496                                      'VSPD_MIP resolve for period ' currTP.tl
5497                                      '. Switching Vectorisation OFF.' /
5498                  );
5499   
5500              ) ;
5501   
5502          ) ;
5503   
5504          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
5505          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
5506   
5507  *   Check if the LP results are valid end
5508      ) ;
5509   
5510   
5511   
5512  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
5513   
5514  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
5515  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
5540   
5541      busGeneration(bus(currTP,b))
5542          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
5543               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
5544               ] ;
5545   
5546      busLoad(bus(currTP,b))
5547          = sum[ NodeBus(currTP,n,b)
5548               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
5549               ] ;
5550   
5551      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
5552          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
5553   
5554      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
5555          = DCNodeNetInjection.m(currTP,b) ;
5556   
5557      if((disconnectedNodePriceCorrection = 1),
5558  *       Pre-MSP case
5559          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
5560              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
5561                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
5562                                        branch(currTP,br)
5563                                      }, 1 ]
5564                      )
5565                    } ;
5566   
5567  *       Post-MSP cases
5568  *       Scenario C/F/G/H/I:
5569          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
5570                                         and (busLoad(bus) = 0)
5571                                         and (busElectricalIsland(bus) = 0)
5572                                           } = 1 ;
5573  *       Scenario E:
5574          busDisconnected(bus(currTP,b))
5575              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5576                              = busElectricalIsland(bus) }
5577                       , busLoad(currTP,b1) ] = 0
5578                  ) and
5579                  ( busElectricalIsland(bus) > 0 ) and
5580                  ( i_useBusNetworkModel(currTP) = 1 )
5581                } = 1 ;
5582  *       Set prices at dead buses with non-zero load
5583          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5584                                      (busLoad(bus) > 0) and
5585                                      (busElectricalIsland(bus)= 0)
5586                                    } = DeficitBusGenerationPenalty ;
5587   
5588          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5589                                      (busLoad(bus) < 0) and
5590                                      (busElectricalIsland(bus)= 0)
5591                                    } = -SurplusBusGenerationPenalty ;
5592   
5593  *       Set price at identified disconnected buses to 0
5594          busPrice(bus)$busDisconnected(bus) = 0 ;
5595      ) ;
5596   
5597  * End Check for disconnected nodes and adjust prices accordingly
5598   
5599  * TN - Replacing invalid prices after SOS1
5600  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
5601      if ( vSPD_SOS1_Solve(tp),
5602           busSOSinvalid(tp,b)
5603             = 1 $ { [ ( busPrice(tp,b) = 0 )
5604                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5605                      or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
5606                       ]
5607                   and bus(tp,b)
5608                   and [ not busDisconnected(tp,b) ]
5609  *                 and [ busLoad(tp,b) = 0 ]
5610  *                 and [ busGeneration(tp,b) = 0 ]
5611                   and [ busLoad(tp,b) = busGeneration(tp,b) ]
5612                   and [ sum[(br,fd)
5613                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5614                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5615                            ] = 0
5616                       ]
5617                   and [ sum[ br
5618                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5619                            , 1
5620                            ] > 0
5621                       ]
5622                     };
5623          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
5624          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
5625              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
5626              busPrice(tp,b)
5627                $ { busSOSinvalid(tp,b)
5628                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5629                              and sum[ br $ { branch(tp,br)
5630                                          and BranchBusConnect(tp,br,b)
5631                                          and BranchBusConnect(tp,br,b1)
5632                                            }, 1
5633                                     ]
5634                               }, 1
5635                         ] > 0
5636                    )
5637                  }
5638                = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5639                          and sum[ br $ { branch(tp,br)
5640                                      and BranchBusConnect(tp,br,b)
5641                                      and BranchBusConnect(tp,br,b1)
5642                                        }, 1 ]
5643                            }, busPrice(tp,b1)
5644                     ]
5645                / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5646                          and sum[ br $ { branch(tp,br)
5647                                      and BranchBusConnect(tp,br,b)
5648                                      and BranchBusConnect(tp,br,b1)
5649                                        }, 1 ]
5650                            }, 1
5651                     ];
5652   
5653              busSOSinvalid(tp,b)
5654                = 1 $ { [ ( busPrice(tp,b) = 0 )
5655                       or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5656                       or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
5657                        ]
5658                    and bus(tp,b)
5659                    and [ not busDisconnected(tp,b) ]
5660  *                  and [ busLoad(tp,b) = 0 ]
5661  *                  and [ busGeneration(tp,b) = 0 ]
5662                    and [ busLoad(tp,b) = busGeneration(tp,b) ]
5663                    and [ sum[(br,fd)
5664                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5665                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5666                             ] = 0
5667                        ]
5668                    and [ sum[ br
5669                             $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5670                             , 1
5671                             ] > 0
5672                        ]
5673                      };
5674           );
5675      );
5676  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
5677   
5678   
5679  *   6g. Collect and store results of solved periods into output parameters -----
5680  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
5681   
5683  *   Normal vSPD run post processing for reporting
5685      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
5686  *   Reporting at trading period start
5687  *       Node level output
5688          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
5689   
5690          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
5691              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
5692   
5693          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
5694             = NodeDemand(currTP,n)
5695             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
5696   
5697          o_nodePrice_TP(dt,n) $ Node(currTP,n)
5698              = sum[ b $ NodeBus(currTP,n,b)
5699                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
5700                    ] ;
5701   
5702  *       Offer output
5703          o_offer(dt,o) $ offer(currTP,o) = yes ;
5704   
5705          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
5706   
5707          o_offerFIR_TP(dt,o) $ offer(currTP,o)
5708              = sum[ (resC,resT)$(ord(resC) = 1)
5709                   , RESERVE.l(currTP,o,resC,resT) ] ;
5710   
5711          o_offerSIR_TP(dt,o) $ offer(currTP,o)
5712              = sum[ (resC,resT)$(ord(resC) = 2)
5713                   , RESERVE.l(currTP,o,resC,resT) ] ;
5714   
5715  *       Bus level output
5716          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
5717   
5718          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
5719   
5720          o_busLoad_TP(dt,b) $ bus(currTP,b)
5721              = busLoad(currTP,b)
5722              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
5723                   , PURCHASE.l(currTP,bd) ];
5724   
5725          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
5726   
5727          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
5728   
5729          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
5730   
5731  *       Node level output
5732   
5733          totalBusAllocation(dt,b) $ bus(currTP,b)
5734              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
5735   
5736          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
5737              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
5738   
5739  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
5753          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
5754              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
5755   
5756          changedDeficitBus(dt,b) = no;
5757   
5758          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
5759   
5760              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
5761   
5762              Loop b $ unmappedDeficitBus(dt,b) do
5763                  o_busDeficit_TP(dt,b1)
5764                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5765                                and ( branchBusDefn(tp,br,b1,b)
5766                                   or branchBusDefn(tp,br,b,b1) )
5767                                  }, 1 ]
5768                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
5769   
5770                  changedDeficitBus(dt,b1)
5771                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5772                              and ( branchBusDefn(tp,br,b1,b)
5773                                 or branchBusDefn(tp,br,b,b1) )
5774                                }, 1 ] = yes;
5775   
5776                  unmappedDeficitBus(dt,b) = no;
5777                  changedDeficitBus(dt,b) = no;
5778                  o_busDeficit_TP(dt,b) = 0;
5779              EndLoop;
5780   
5781              Loop n $ sum[ b $ changedDeficitBus(dt,b)
5782                          , busNodeAllocationFactor(dt,b,n)] do
5783                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
5784                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
5785                                                    busNodeAllocationFactor(dt,b,n)
5786                                                  * o_busDeficit_TP(dt,b) ] ;
5787              EndLoop;
5788   
5789              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
5790          Endif;
5791  * TN - post processing unmapped generation deficit buses end
5792   
5793          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
5794              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5795                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
5796   
5797          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
5798              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5799                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
5800   
5801  *       branch output
5802          o_branch(dt,br) $ branch(currTP,br) = yes ;
5803   
5804          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
5805   
5806          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
5807   
5808          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
5809              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
5810   
5811          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
5812              = HVDCLINKLOSSES.l(currTP,br) ;
5813   
5814          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
5815              = branchFixedLoss(currTP,br) ;
5816   
5817          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
5818              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
5819   
5820          o_branchFromBus_TP(dt,br,frB)
5821              $ { branch(currTP,br) and
5822                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5823                } = yes ;
5824   
5825          o_branchToBus_TP(dt,br,toB)
5826              $ { branch(currTP,br) and
5827                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5828                } = yes ;
5829   
5830          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
5831              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
5832   
5833          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
5834              = HVDClinkMaximumFlow.m(currTP,br) ;
5835   
5836          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
5837              = sum[ fd $ ( ord(fd) = 1 )
5838                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
5839                   ] $  { o_branchFlow_TP(dt,br) >= 0 }
5840              + sum[ fd $ ( ord(fd) = 2 )
5841                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
5842                   ] $  { o_branchFlow_TP(dt,br) < 0 } ;
5843   
5844   
5845  *       Offer output
5846          o_offerEnergyBlock_TP(dt,o,trdBlk)
5847              = GENERATIONBLOCK.l(currTP,o,trdBlk);
5848   
5849          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
5850              = sum[ resC $ (ord(resC) = 1)
5851              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5852   
5853          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
5854              = sum[ resC $ (ord(resC) = 2)
5855              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5856   
5857  *       bid output
5858          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
5859   
5860          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
5861   
5862          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
5863              = sum[ resC $ (ord(resC) = 1)
5864                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5865   
5866          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
5867              = sum[ resC $ (ord(resC) = 2)
5868                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5869   
5870          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
5871              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
5872   
5873  *       Violation reporting based on the CE and ECE
5874          o_ResViolation_TP(dt,ild,resC)
5875              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
5876              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
5877              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
5878   
5879          o_FIRviolation_TP(dt,ild)
5880              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
5881   
5882          o_SIRviolation_TP(dt,ild)
5883              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
5884   
5885  *       Security constraint data
5886          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
5887   
5888          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5889              = branchConstraintSense(currTP,brCstr) ;
5890   
5891          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5892              = [ branchSecurityConstraintLE.l(currTP,brCstr)
5893                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5894              + [ branchSecurityConstraintGE.l(currTP,brCstr)
5895                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5896              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
5897                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5898   
5899          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5900              = branchConstraintLimit(currTP,brCstr) ;
5901   
5902          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5903              = [ branchSecurityConstraintLE.m(currTP,brCstr)
5904                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5905              + [ branchSecurityConstraintGE.m(currTP,brCstr)
5906                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5907              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
5908                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5909   
5910  *       Mnode constraint data
5911          o_MnodeConstraint_TP(dt,MnodeCstr)
5912              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
5913   
5914          o_MnodeConstraintSense_TP(dt,MnodeCstr)
5915              $ MnodeConstraint(currTP,MnodeCstr)
5916              = MnodeConstraintSense(currTP,MnodeCstr) ;
5917   
5918          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
5919              $ MnodeConstraint(currTP,MnodeCstr)
5920              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
5921                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5922              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
5923                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5924              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
5925                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5926   
5927          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
5928              $ MnodeConstraint(currTP,MnodeCstr)
5929              = MnodeConstraintLimit(currTP,MnodeCstr) ;
5930   
5931          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
5932              $ MnodeConstraint(currTP,MnodeCstr)
5933              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
5934                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5935              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
5936                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5937              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
5938                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5939   
5940  *       Island output
5941          o_island(dt,ild) = yes ;
5942   
5943          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
5944   
5945          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
5946                                            , o_ResPrice_TP(dt,ild,resC) ];
5947   
5948          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
5949                                            , o_ResPrice_TP(dt,ild,resC) ];
5950   
5951          o_islandGen_TP(dt,ild)
5952              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
5953   
5954          o_islandClrBid_TP(dt,ild)
5955              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
5956   
5957          o_islandLoad_TP(dt,ild)
5958              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
5959              + o_islandClrBid_TP(dt,ild) ;
5960   
5961          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
5962   
5963          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
5964                                              , o_ResCleared_TP(dt,ild,resC) ];
5965   
5966          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
5967                                              , o_ResCleared_TP(dt,ild,resC) ];
5968   
5969          o_islandBranchLoss_TP(dt,ild)
5970              = sum[ (br,frB,toB)
5971                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
5972                   and branchBusDefn(currTP,br,frB,toB)
5973                     }, o_branchTotalLoss_TP(dt,br) ] ;
5974   
5975          o_HVDCflow_TP(dt,ild)
5976              = sum[ (br,frB,toB)
5977                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
5978                   and branchBusDefn(currTP,br,frB,toB)
5979                     }, o_branchFlow_TP(dt,br) ] ;
5980   
5981          o_HVDChalfPoleLoss_TP(dt,ild)
5982              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5983                                      branchBusDefn(currTP,br,frB,toB) and
5984                                      busIsland(currTP,toB,ild) and
5985                                      busIsland(currTP,frB,ild)
5986                                        }, o_branchTotalLoss_TP(dt,br)
5987                   ] ;
5988   
5989          o_HVDCpoleFixedLoss_TP(dt,ild)
5990              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5991                                      branchBusDefn(currTP,br,frB,toB) and
5992                                      ( busIsland(currTP,toB,ild) or
5993                                        busIsland(currTP,frB,ild)
5994                                      )
5995                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
5996                   ] ;
5997   
5998          o_HVDCloss_TP(dt,ild)
5999              = o_HVDChalfPoleLoss_TP(dt,ild)
6000              + o_HVDCpoleFixedLoss_TP(dt,ild)
6001              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
6002                                      branchBusDefn(currTP,br,frB,toB) and
6003                                      busIsland(currTP,toB,ild) and
6004                                      (not (busIsland(currTP,frB,ild)))
6005                                    }, o_branchDynamicLoss_TP(dt,br)
6006                   ] ;
6007   
6008  * TN - The code below is added for NMIR project ================================
6009          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
6010              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
6011   
6012          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
6013   
6014              o_FirSent_TP(dt,ild)
6015                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6016                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
6017   
6018              o_FirReceived_TP(dt,ild)
6019                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6020                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
6021   
6022              o_FirEffective_TP(dt,ild,riskC)
6023                  = Sum[ resC $ (ord(resC) = 1),
6024                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6025   
6026              o_FirEffReport_TP(dt,ild)
6027                  = Smax[ (resC,riskC) $ (ord(resC)=1)
6028                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6029   
6030          Endif;
6031   
6032          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
6033   
6034              o_SirSent_TP(dt,ild)
6035                  = Sum[ (rd,resC) $ (ord(resC) = 2),
6036                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
6037   
6038              o_SirReceived_TP(dt,ild)
6039                  = Sum[ (fd,resC) $ (ord(resC) = 2),
6040                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
6041   
6042              o_SirEffective_TP(dt,ild,riskC)
6043                  = Sum[ resC $ (ord(resC) = 2),
6044                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6045   
6046              o_SirEffReport_TP(dt,ild)
6047                  = Smax[ (resC,riskC) $ (ord(resC)=2)
6048                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6049          Endif;
6050   
6051   
6052  * TN - The code for NMIR project end ===========================================
6053   
6054  *       Additional output for audit reporting
6055          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
6056   
6057  *       Check if there are non-physical losses on AC branches
6058          ManualBranchSegmentMWFlow(LossBranch(ACbranch(currTP,br)),los,fd)
6059                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
6060                  and validLossSegment(ACbranch,los,fd)
6061                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
6062                    }
6063                  = Min[ Max( 0,
6064                              [ abs(o_branchFlow_TP(dt,br))
6065                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6066                              ]
6067                            ),
6068                         ( LossSegmentMW(ACbranch,los,fd)
6069                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6070                         )
6071                       ] ;
6072   
6073          ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
6074                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
6075                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
6076                    }
6077                  = Min[ Max( 0,
6078                              [ abs(o_branchFlow_TP(dt,br))
6079                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6080                              ]
6081                            ),
6082                         ( LossSegmentMW(HVDClink,los,fd)
6083                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6084                         )
6085                       ] ;
6086   
6087          ManualLossCalculation(LossBranch(branch(currTP,br)))
6088              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
6089                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
6090   
6091          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
6092                                   - ManualLossCalculation(currTP,br) ;
6093   
6094          o_lossSegmentBreakPoint(dt,br,los)
6095              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6096                         and (ord(fd) = 1)
6097                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6098              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6099                         and (ord(fd) = 2)
6100                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6101          ;
6102   
6103          o_lossSegmentFactor(dt,br,los)
6104              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6105                         and (ord(fd) = 1)
6106                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6107              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6108                         and (ord(fd) = 2)
6109                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6110          ;
6111   
6112          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
6113   
6114          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
6115              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
6116                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
6117   
6118          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
6119              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
6120                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
6121   
6122          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
6123              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
6124                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6125   
6126          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
6127              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
6128                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6129   
6130          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
6131              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
6132                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6133   
6134          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
6135              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
6136                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6137   
6138          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6139                                                offerNode(currTP,o,n)
6140                                              }, o_ILRO_FIR_TP(dt,o) ] ;
6141   
6142          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6143                                                offerNode(currTP,o,n)
6144                                              }, o_ILRO_SIR_TP(dt,o) ] ;
6145   
6146          o_marketNodeIsland_TP(dt,o,ild)
6147              $ sum[ n $ { offerIsland(currTP,o,ild) and
6148                           offerNode(currTP,o,n) and
6149                           (o_nodeLoad_TP(dt,n)  = 0)
6150                         },1
6151                   ] = yes ;
6152   
6153          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
6154              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
6155              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6156              ;
6157   
6158          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
6159              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
6160   
6161          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6162              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
6163   
6164          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
6165              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
6166   
6167          o_manuRiskLevel(dt,ild,resC,ManualRisk)
6168              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
6169              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
6170              ;
6171   
6172          o_manuRiskPrice(dt,ild,resC,ManualRisk)
6173              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
6174   
6175          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
6176              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
6177   
6178          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
6179              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
6180   
6181          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
6182              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
6183   
6184          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
6185              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
6186   
6187          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
6188              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6189              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
6190              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6191              ;
6192   
6193          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
6194              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6195              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
6196   
6197  *       FIR and SIR required based on calculations of the island risk to
6198  *       overcome reporting issues of the risk setter under degenerate
6199  *       conditions when reserve price = 0 - See below
6200   
6201          o_ReserveReqd_TP(dt,ild,resC)
6202              = Max[ 0,
6203                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
6204                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
6205                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
6206                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
6207                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
6208                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
6209                   ] ;
6210   
6211          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
6212          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
6213   
6214  *       Summary reporting by trading period
6215          o_solveOK_TP(dt) = ModelSolved ;
6216   
6217          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
6218   
6219          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
6220   
6221          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
6222   
6223          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
6224                       - o_systemCost_TP(dt)
6225                       - o_penaltyCost_TP(dt);
6226   
6227   
6228  *       Separete violation reporting at trade period level
6229          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
6230   
6231          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
6232   
6233          o_surpBranchFlow_TP(dt)
6234              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
6235   
6236          o_defRampRate_TP(dt)
6237              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
6238   
6239          o_surpRampRate_TP(dt)
6240              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
6241   
6242          o_surpBranchGroupConst_TP(dt)
6243              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6244                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6245   
6246          o_defBranchGroupConst_TP(dt)
6247              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6248                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6249   
6250          o_defMnodeConst_TP(dt)
6251              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6252                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6253   
6254          o_surpMnodeConst_TP(dt)
6255              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6256                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6257   
6258          o_defACnodeConst_TP(dt)
6259              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6260                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6261   
6262          o_surpACnodeConst_TP(dt)
6263              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6264                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6265   
6266          o_defT1MixedConst_TP(dt)
6267              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6268                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6269   
6270          o_surpT1MixedConst_TP(dt)
6271              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6272                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6273   
6274          o_defGenericConst_TP(dt)
6275              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6276                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6277   
6278          o_surpGenericConst_TP(dt)
6279              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6280                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6281   
6282          o_defResv_TP(dt)
6283              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
6284   
6285          o_totalViolation_TP(dt)
6286              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
6287              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
6288              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
6289              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
6290              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
6291              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
6292              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
6293              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
6294   
6295  *       Virtual reserve
6296          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
6297   
6298          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6299                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6300   
6301          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6302                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6303   
6304  *   Reporting at trading period end
6305      EndLoop;
6307   
6309   
6310  * End of the solve vSPD loop
6311    ] ;
6312  * End of the While loop
6313  );
6314   
6315   
6316  * Real Time Pricing - Second RTD load calculation
6317   
6318  *   Calculate Island-level MW losses used to calculate the Island-level load
6319  *   forecast from the InputIPS and the IslandPSD.
6320  *   2nd solve loop --> SystemLosses as calculated in section 6.3'
6321      LoadCalcLosses(currTP,ild)
6322          = Sum[ (br,frB,toB)
6323               $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
6324               and branchBusDefn(currTP,br,frB,toB)
6325                 }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
6326                  + branchFixedLoss(currTP,br)
6327               ]
6328          + Sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
6329                                  branchBusDefn(currTP,br,frB,toB) and
6330                                  busIsland(currTP,toB,ild) and
6331                                  busIsland(currTP,frB,ild)
6332                                }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
6333                                 + HVDCLINKLOSSES.l(currTP,br)
6334                                 + branchFixedLoss(currTP,br)
6335               ]
6336          + Sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
6337                                  branchBusDefn(currTP,br,frB,toB) and
6338                                  ( busIsland(currTP,toB,ild) or
6339                                    busIsland(currTP,frB,ild)
6340                                  )
6341                                }, 0.5 * branchFixedLoss(currTP,br)
6342               ]
6343          + Sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
6344                                  branchBusDefn(currTP,br,frB,toB) and
6345                                  busIsland(currTP,toB,ild) and
6346                                  (not (busIsland(currTP,frB,ild)))
6347                                }, HVDCLINKLOSSES.l(currTP,br)
6348               ]
6349            ;
6350   
6351   
6352  *   Calculate first target total load [3.8.5.5]
6353  *   Island-level MW load forecast. For the second loop:
6354  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
6355      TargetTotalLoad(currTP,ild) = islandMWIPS(currTP,ild) + islandPDS(currTP,ild) - LoadCalcLosses(currTP,ild) ;
6356   
6357  *   Flag if estimate load is scalable [3.8.5.7]
6358  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
6359  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
6360  *   assigned directly to EstimatedInitialLoad
6361      EstLoadIsScalable(currTP,n) =  1 $ { (LoadIsNCL(currTP,n) = 0)
6362                                       and (ConformingFactor(currTP,n) > 0) } ;
6363   
6364  *   Calculate estimate non-scalable load [3.8.5.8]
6365  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
6366  *   conforming Pnode this will be the ConformingFactor MW input if that value is
6367  *   negative, otherwise it will be zero
6368      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 1 ) = NonConformingLoad(currTP,n);
6369      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 0 ) = ConformingFactor(currTP,n);
6370      EstNonScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = 0;
6371   
6372  *   Calculate estimate scalable load [3.8.5.10]
6373  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
6374  *   this value will be the ConformingFactor if it is non-negative, otherwise this
6375  *   value will be zero'
6376      EstScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = ConformingFactor(currTP,n);
6377   
6378   
6379  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
6380  *   in order to calculate EstimatedInitialLoad
6381      EstScalingFactor(currTP,ild)
6382          = (islandMWIPS(currTP,ild) - LoadCalcLosses(currTP,ild)
6383            - Sum[ n $ nodeIsland(currTP,n,ild), EstNonScalableLoad(currTP,n) ]
6384            ) / Sum[ n $ nodeIsland(currTP,n,ild), EstScalableLoad(currTP,n) ]
6385   
6386          ;
6387   
6388  *   Calculate estimate initial load [3.8.5.6]
6389  *   Calculated estimate of initial MW load, available to be used as an
6390  *   alternative to InputInitialLoad
6391      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 )
6392          = ConformingFactor(currTP,n) * Sum[ ild $ nodeisland(currTP,n,ild)
6393                                            , EstScalingFactor(currTP,ild)] ;
6394  * TN- There is a bug in this equarion
6395      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 0 )
6396  *        = NonConformingLoad(currTP,n);
6397          = EstNonScalableLoad(currTP,n);
6398   
6399  *   Calculate initial load [3.8.5.2]
6400  *   Value that represents the Pnode load MW at the start of the solution
6401  *   interval. Depending on the inputs this value will be either actual load,
6402  *   an operator applied override or an estimated initial load
6403      InitialLoad(currTP,n) = InputInitialLoad(currTP,n);
6404      InitialLoad(currTP,n) $ { (LoadIsOverride(currTP,n) = 0)
6405                            and ( (useActualLoad(currTP) = 0)
6406                               or (LoadIsBad(currTP,n) = 1) )
6407                              } = EstimatedInitialLoad(currTP,n) ;
6408   
6409  *   Flag if load is scalable [3.8.5.4]
6410  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
6411  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
6412  *   assigned to nodedemand
6413      LoadIsScalable(currTP,n) = 1 $ { (LoadIsNCL(currTP,n) = 0)
6414                                   and (LoadIsOverride(currTP,n) = 0)
6415                                   and (InitialLoad(currTP,n) >= 0) } ;
6416   
6417  *   Calculate Island-level scaling factor [3.8.5.3]
6418  *   --> applied to InitialLoad in order to calculate nodedemand
6419      LoadScalingFactor(currTP,ild)
6420          = ( TargetTotalLoad(currTP,ild)
6421            - Sum[ n $ { nodeIsland(currTP,n,ild)
6422                     and (LoadIsScalable(currTP,n) = 0) }, InitialLoad(currTP,n) ]
6423            ) / Sum[ n $ { nodeIsland(currTP,n,ild)
6424                       and (LoadIsScalable(currTP,n) = 1) }, InitialLoad(currTP,n) ]
6425          ;
6426   
6427  *   Calculate nodedemand [3.8.5.1]
6428      nodedemand(currTP,n) $ LoadIsScalable(currTP,n)
6429          = InitialLoad(currTP,n) * sum[ ild $ nodeisland(currTP,n,ild)
6430                                   , LoadScalingFactor(currTP,ild) ];
6431   
6432      nodedemand(currTP,n) $ (LoadIsScalable(currTP,n) = 0) = InitialLoad(currTP,n);
6433   
6434   
6435  *   Update Free Reserve and SharedNFRmax
6436  *   Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
6437      sharedNFRLoad(currTP,ild)
6438          = sum[ nodeIsland(currTP,n,ild), nodeDemand(currTP,n)]
6439          + sum[ (bd,trdBlk) $ bidIsland(currTP,bd,ild), purchaseBidMW(currTP,bd,trdBlk) ]
6440          - sharedNFRLoadOffset(currTP,ild) ;
6441   
6442      sharedNFRMax(currTP,ild) = Min{ RMTReserveLimitTo(currTP,ild,'FIR'),
6443                                      sharedNFRFactor(currTP)*sharedNFRLoad(currTP,ild) } ;
6444   
6445  *   Risk parameters
6446      FreeReserve(currTP,ild,resC,riskC)
6447          = sum[ riskPar $ (ord(riskPar) = 1)
6448                         , i_tradePeriodRiskParameter(currTP,ild,resC,riskC,riskPar) ]
6449  *   NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
6450          - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(currTP,ild1)
6451               ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
6452                 and (inputGDXGDate >= jdate(2016,10,20)) }
6453      ;
6454   
6455  *   (3.4.2.3) - SPD version 11.0
6456      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
6457   
6458  *);
6459   
6460   
6461   
6462  );
6463   
6464  unsolvedPeriod(tp) = yes;
6465  VSPDModel(tp) = 0 ;
6466  option clear = useBranchFlowMIP ;
6467  option clear = useMixedConstraintMIP ;
6468   
6469  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
6470    exitLoop = 0;
6471    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
6472   
6473  *   7a. Reset all sets, parameters and variables -------------------------------
6474      option clear = currTP ;
6475  *   Generation variables
6476      option clear = GENERATION ;
6477      option clear = GENERATIONBLOCK ;
6478  *   Purchase variables
6479      option clear = PURCHASE ;
6480      option clear = PURCHASEBLOCK ;
6481      option clear = PURCHASEILR ;
6482      option clear = PURCHASEILRBLOCK ;
6483  *   Network variables
6484      option clear = ACNODENETINJECTION ;
6485      option clear = ACNODEANGLE ;
6486      option clear = ACBRANCHFLOW ;
6487      option clear = ACBRANCHFLOWDIRECTED ;
6488      option clear = ACBRANCHLOSSESDIRECTED ;
6489      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
6490      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
6491      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
6492      option clear = HVDCLINKFLOW ;
6493      option clear = HVDCLINKLOSSES ;
6494      option clear = LAMBDA ;
6495      option clear = LAMBDAINTEGER ;
6496      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
6497      option clear = HVDCPOLEFLOW_INTEGER ;
6498  *   Risk/Reserve variables
6499      option clear = RISKOFFSET ;
6500      option clear = HVDCREC ;
6501      option clear = ISLANDRISK ;
6502      option clear = RESERVEBLOCK ;
6503      option clear = RESERVE ;
6504      option clear = ISLANDRESERVE;
6505  *   NMIR variables
6506      option clear = SHAREDNFR ;
6507      option clear = SHAREDRESERVE ;
6508      option clear = HVDCSENT ;
6509      option clear = RESERVESHAREEFFECTIVE ;
6510      option clear = RESERVESHARERECEIVED ;
6511      option clear = RESERVESHARESENT ;
6512      option clear = HVDCSENDING ;
6513      option clear = INZONE ;
6514      option clear = HVDCSENTINSEGMENT ;
6515      option clear = HVDCRESERVESENT ;
6516      option clear = HVDCSENTLOSS ;
6517      option clear = HVDCRESERVELOSS ;
6518      option clear = LAMBDAHVDCENERGY ;
6519      option clear = LAMBDAHVDCRESERVE ;
6520      option clear = RESERVESHAREPENALTY ;
6521  *   Mixed constraint variables
6522      option clear = MIXEDCONSTRAINTVARIABLE ;
6523      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
6524  *   Objective
6525      option clear = NETBENEFIT ;
6526  *   Violation variables
6527      option clear = TOTALPENALTYCOST ;
6528      option clear = DEFICITBUSGENERATION ;
6529      option clear = SURPLUSBUSGENERATION ;
6530      option clear = DEFICITRESERVE ;
6531      option clear = DEFICITRESERVE_CE ;
6532      option clear = DEFICITRESERVE_ECE ;
6533      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
6534      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
6535      option clear = DEFICITRAMPRATE ;
6536      option clear = SURPLUSRAMPRATE ;
6537      option clear = DEFICITACnodeCONSTRAINT ;
6538      option clear = SURPLUSACnodeCONSTRAINT ;
6539      option clear = DEFICITBRANCHFLOW ;
6540      option clear = SURPLUSBRANCHFLOW ;
6541      option clear = DEFICITMNODECONSTRAINT ;
6542      option clear = SURPLUSMNODECONSTRAINT ;
6543      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
6544      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
6545      option clear = DEFICITGENERICCONSTRAINT ;
6546      option clear = SURPLUSGENERICCONSTRAINT ;
6547   
6548  *   Clear the pole circular branch flow flag
6549      option clear = circularBranchFlowExist ;
6550      option clear = poleCircularBranchFlowExist ;
6551      option clear = northHVDC ;
6552      option clear = southHVDC ;
6553      option clear = manualBranchSegmentMWFlow ;
6554      option clear = manualLossCalculation ;
6555      option clear = nonPhysicalLossExist ;
6556      option clear = modelSolved ;
6557      option clear = LPmodelSolved ;
6558  *   Disconnected bus post-processing
6559      option clear = busGeneration ;
6560      option clear = busLoad ;
6561      option clear = busDisconnected ;
6562      option clear = busPrice ;
6563   
6564   
6565  *   End reset
6566   
6567   
6568  *   7b. Initialise current trade period and model data -------------------------
6569      currTP(tp)  $ sequentialSolve       = yes;
6570      currTP(tp1) $ (not sequentialSolve) = yes;
6571   
6572  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
6573      generationStart(offer(currTP(tp),o))
6574          $ (sum[ o1, generationStart(currTP,o1)] = 0)
6575          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
6576  *   Calculation of generation upper limits due to ramp rate limits
6577  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
6578  *   initial MW and ramp rate is used - Reference: Transpower Market Services
6579      rampTimeUp(offer(currTP(tp),o))
6580          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
6581          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
6582                                         - generationStart(offer)
6583                                         ) / rampRateUp(offer)
6584               ] ;
6585   
6586  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
6587  *   initial MW and ramp rate is used - Reference: Transpower Market Services
6588      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
6589          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
6590   
6591   
6592  *   Calculation of generation lower limits due to ramp rate limits
6593   
6594  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
6595  *   initial MW and ramp rate is used - Reference: Transpower Market Services
6596      rampTimeDown(offer(currTP(tp),o))
6597          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
6598          = Min[ i_tradingPeriodLength, ( generationStart(offer)
6599                                        - generationMinimum(offer)
6600                                        ) / rampRateDown(offer)
6601               ] ;
6602   
6603  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
6604  *   initial MW and ramp rate is used - Reference: Transpower Market Services
6605      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
6606          = Max[ 0, generationStart(offer)
6607                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
6608   
6609  *   Additional pre-processing on parameters end
6610   
6611   
6612  *   7c. Updating the variable bounds before model solve ------------------------
6613   
6614  * TN - Pivot or Demand Analysis - revise input data
6617  * TN - Pivot or Demand Analysis - revise input data end
6618   
6619  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
6620   
6621  *   Offer blocks - Constraint 3.1.1.1
6622      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
6623          = generationOfferMW(validGenerationOfferBlock) ;
6624   
6625      GENERATIONBLOCK.fx(currTP,o,trdBlk)
6626          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
6627   
6628  *   Constraint 3.1.1.2 - Fix the generation variable for generators
6629  *   that are not connected or do not have a non-zero energy offer
6630      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
6631   
6632  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
6633      GENERATION.up(offer(currTP,o))
6634          $ { windOffer(offer) and priceResponsive(offer) }
6635          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
6636   
6637  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
6638      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
6639          $ (not UseDSBFDemandBidModel)
6640          = purchaseBidMW(validPurchaseBidBlock) ;
6641   
6642      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
6643          $ (not UseDSBFDemandBidModel)
6644          = 0 ;
6645   
6646      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
6647          $ UseDSBFDemandBidModel
6648          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
6649   
6650      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
6651          $ UseDSBFDemandBidModel
6652          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
6653   
6654      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
6655          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
6656          = 0 ;
6657   
6658  *   Fix the purchase variable for purchasers that are not connected
6659  *   or do not have a non-zero purchase bid
6660      PURCHASE.fx(currTP,bd)
6661          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
6662   
6663  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
6664   
6665   
6666  *======= HVDC TRANSMISSION EQUATIONS ===========================================
6667   
6668  *   Ensure that variables used to specify flow and losses on HVDC link are
6669  *   zero for AC branches and for open HVDC links.
6670      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
6671      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
6672   
6673  *   Apply an upper bound on the weighting parameter based on its definition
6674      LAMBDA.up(branch,bp) = 1 ;
6675   
6676  *   Ensure that the weighting factor value is zero for AC branches and for
6677  *   invalid loss segments on HVDC links
6678      LAMBDA.fx(HVDClink,bp)
6679          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
6680      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
6681   
6682  *======= HVDC TRANSMISSION EQUATIONS END =======================================
6683   
6684   
6685  *======= AC TRANSMISSION EQUATIONS =============================================
6686   
6687  *   Ensure that variables used to specify flow and losses on AC branches are
6688  *   zero for HVDC links branches and for open AC branches
6689      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
6690      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
6691      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
6692   
6693  *   Ensure directed block flow and loss block variables are zero for
6694  *   non-AC branches and invalid loss segments on AC branches
6695     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
6696         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
6697   
6698     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
6699         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
6700   
6701   
6702  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
6703  *   corresponding to the reference nodes and the HVDC nodes are set to zero
6704      ACNODEANGLE.fx(currTP,b)
6705         $ sum[ n $ { NodeBus(currTP,n,b) and
6706                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
6707   
6708  *======= AC TRANSMISSION EQUATIONS END =========================================
6709   
6710   
6711  *======= RISK & RESERVE EQUATIONS ==============================================
6712   
6713  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
6714      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
6715          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
6716   
6717      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
6718          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
6719   
6720  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
6721      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
6722          = reserveOfferMaximum(validReserveOfferBlock) ;
6723   
6724      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
6725          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
6726   
6727  *   Fix the reserve variable for invalid reserve offers. These are offers that
6728  *   are either not connected to the grid or have no reserve quantity offered.
6729      RESERVE.fx(currTP,o,resC,resT)
6730          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
6731   
6732  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
6733  *   offers that are either not connected to the grid or have no reserve quantity offered.
6734      PURCHASEILR.fx(currTP,bd,resC)
6735          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
6736   
6737  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
6738      RISKOFFSET.fx(currTP,ild,resC,riskC)
6739          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
6740              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
6741            } = 0 ;
6742   
6743  *   Fix the appropriate deficit variable to zero depending on
6744  *   whether the different CE and ECE CVP flag is set
6745      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
6746      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
6747      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
6748   
6749  *   Virtual reserve
6750      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
6751   
6752  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
6767  *   NMIR project variables
6768      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
6769      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
6770   
6771  *   (3.4.2.3) - SPD version 11.0
6772      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
6773   
6774  *   No forward reserve sharing if HVDC capacity is zero
6775      RESERVESHARESENT.fx(currTP,ild,resC,rd)
6776          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
6777   
6778  *   No forward reserve sharing if reserve sharing is disabled
6779      RESERVESHARESENT.fx(currTP,ild,resC,rd)
6780          $ (reserveShareEnabled(currTP,resC)=0) = 0;
6781   
6782  *   No reserve sharing to cover HVDC risk
6783      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
6784      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
6785   
6786  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
6787      INZONE.fx(currTP,ild,resC,z)
6788          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
6789   
6790  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
6791      INZONE.fx(currTP,ild,resC,z)
6792          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
6793   
6794  *   Fixing Lambda integer variable for energy sent
6795      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
6796                                          and (ord(bp) = 1) } = 1 ;
6797   
6798      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
6799   
6800  * To be reviewed NMIR
6801      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
6802          $ { (HVDCCapacity(currTP,ild) = 0)
6803          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
6804   
6805      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
6806          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
6807          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
6808  ;
6809   
6810   
6811  *======= RISK & RESERVE EQUATIONS END ==========================================
6812   
6813   
6814  *======= MIXED CONSTRAINTS =====================================================
6815   
6816  *   Mixed constraint
6817      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
6818          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
6819   
6820  *======= MIXED CONSTRAINTS END =================================================
6821   
6822  *   Updating the variable bounds before model solve end
6823   
6824   
6825  *   7d. Solve Models
6826  *   Solve the LP model ---------------------------------------------------------
6827      if( (Sum[currTP, VSPDModel(currTP)] = 0),
6828   
6829          if( UseShareReserve,
6830              option bratio = 1 ;
6831              vSPD_NMIR.Optfile = 1 ;
6832              vSPD_NMIR.optcr = MIPOptimality ;
6833              vSPD_NMIR.reslim = MIPTimeLimit ;
6834              vSPD_NMIR.iterlim = MIPIterationLimit ;
6835              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
6836  *           Set the model solve status
6837              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
6838                                 or (vSPD_NMIR.modelstat = 8) )
6839                              and ( vSPD_NMIR.solvestat = 1 ) } ;
6840          else
6841              option bratio = 1 ;
6842              vSPD.reslim = LPTimeLimit ;
6843              vSPD.iterlim = LPIterationLimit ;
6844              solve vSPD using lp maximizing NETBENEFIT ;
6845  *           Set the model solve status
6846              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
6847          )
6848   
6849  *       Post a progress message to the console and for use by EMI.
6850          if((ModelSolved = 1) and (sequentialSolve = 0),
6851              putclose runlog 'The case: FP_20221015_F '
6852                              'is solved successfully.'/
6853                              'Objective function value: '
6854                              NETBENEFIT.l:<12:1 /
6855                              'Violation Cost          : '
6856                              TOTALPENALTYCOST.l:<12:1 /
6857          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
6858              putclose runlog 'The case: FP_20221015_F '
6859                              'is solved unsuccessfully.'/
6860          ) ;
6861   
6862          if((ModelSolved = 1) and (sequentialSolve = 1),
6863              loop(currTP,
6864                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
6865                                  'is solved successfully.'/
6866                                  'Objective function value: '
6867                                  NETBENEFIT.l:<12:1 /
6868                                  'Violations cost         : '
6869                                  TOTALPENALTYCOST.l:<12:1 /
6870              ) ;
6871          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
6872              loop(currTP,
6873                  unsolvedPeriod(currTP) = no;
6874                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
6875                                  'is solved unsuccessfully.'/
6876              ) ;
6877   
6878          ) ;
6879  *   Solve the LP model end -----------------------------------------------------
6880   
6881   
6882  *   Solve the VSPD_MIP model ---------------------------------------------------
6883      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
6884  *       Fix the values of the integer variables that are not needed
6885          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
6886              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
6887   
6888  *       Fix the integer AC branch flow variable to zero for invalid branches
6889          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
6890              $ (not branch(currTP,br)) = 0 ;
6891   
6892  *       Apply an upper bound on the integer weighting parameter
6893          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
6894   
6895  *       Ensure that the weighting factor value is zero for AC branches
6896  *       and for invalid loss segments on HVDC links
6897          LAMBDAINTEGER.fx(branch(currTP,br),bp)
6898              $ { ACbranch(branch)
6899              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
6900                } = 0 ;
6901   
6902  *       Fix the lambda integer variable to zero for invalid branches
6903          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
6904   
6905  *       Fix the value of some binary variables used in the mixed constraints
6906  *       that have no alternate limit
6907          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
6908              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
6909   
6910          option bratio = 1 ;
6911          vSPD_MIP.Optfile = 1 ;
6912          vSPD_MIP.optcr = MIPOptimality ;
6913          vSPD_MIP.reslim = MIPTimeLimit ;
6914          vSPD_MIP.iterlim = MIPIterationLimit ;
6915          solve vSPD_MIP using mip maximizing NETBENEFIT ;
6916  *       Set the model solve status
6917          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
6918                                (vSPD_MIP.modelstat = 8)
6919                              ]
6920                              and
6921                              [ vSPD_MIP.solvestat = 1 ]
6922                            } ;
6923   
6924  *       Post a progress message for use by EMI.
6925          if(ModelSolved = 1,
6926              loop(currTP,
6927                  unsolvedPeriod(currTP) = no;
6928                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
6929                                  'is solved successfully for FULL integer.'/
6930                                  'Objective function value: '
6931                                  NETBENEFIT.l:<12:1 /
6932                                  'Violations              : '
6933                                  TOTALPENALTYCOST.l:<12:1 /
6934              ) ;
6935          else
6936              loop(currTP,
6937                  unsolvedPeriod(currTP) = yes;
6938                  VSPDModel(currTP) = 4;
6939                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
6940                                  'is solved unsuccessfully for FULL integer.'/
6941              ) ;
6942          ) ;
6943  *   Solve the vSPD_MIP model end -----------------------------------------------
6944   
6945   
6946  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
6947      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
6948  *       Fix the values of these integer variables that are not needed
6949          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
6950              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
6951   
6952  *       Fix the integer AC branch flow variable to zero for invalid branches
6953          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
6954              $ (not branch(currTP,br)) = 0 ;
6955   
6956  *       Apply an upper bound on the integer weighting parameter
6957          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
6958   
6959  *       Ensure that the weighting factor value is zero for AC branches
6960  *       and for invalid loss segments on HVDC links
6961          LAMBDAINTEGER.fx(branch(currTP,br),bp)
6962              $ { ACbranch(branch)
6963              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
6964                } = 0 ;
6965   
6966  *       Fix the lambda integer variable to zero for invalid branches
6967          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
6968   
6969          option bratio = 1 ;
6970          vSPD_BranchFlowMIP.Optfile = 1 ;
6971          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
6972          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
6973          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
6974          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
6975  *       Set the model solve status
6976          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
6977                                (vSPD_BranchFlowMIP.modelstat = 8)
6978                              ]
6979                              and
6980                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
6981                            } ;
6982   
6983  *       Post a progress message for use by EMI.
6984          if(ModelSolved = 1,
6985   
6986  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
6987              vSPD_SOS1_Solve(currTP)  = yes;
6988   
6989              loop(currTP,
6990                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
6991                                  'is solved successfully for branch integer.'/
6992                                  'Objective function value: '
6993                                  NETBENEFIT.l:<12:1 /
6994                                  'Violations cost         : '
6995                                  TOTALPENALTYCOST.l:<12:1 /
6996              ) ;
6997          else
6998              loop(currTP,
6999                  unsolvedPeriod(currTP) = yes;
7000                  VSPDModel(currTP) = 4;
7001                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
7002                                  'is solved unsuccessfully for branch integer.'/
7003              ) ;
7004          ) ;
7005  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
7006   
7007   
7008  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
7009      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
7010  *       Fix the value of some binary variables used in the mixed constraints
7011  *       that have no alternate limit
7012          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
7013              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
7014   
7015  *       Use the advanced basis here
7016          option bratio = 0.25 ;
7017          vSPD_MixedConstraintMIP.Optfile = 1 ;
7018  *       Set the optimality criteria for the MIP
7019          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
7020          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
7021          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
7022  *       Solve the model
7023          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
7024  *       Set the model solve status
7025          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
7026                                (vSPD_MixedConstraintMIP.modelstat = 8)
7027                              ]
7028                              and
7029                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
7030                            } ;
7031   
7032  *       Post a progress message for use by EMI.
7033          if(ModelSolved = 1,
7034              loop(currTP,
7035                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
7036                                  'is solved successfully for '
7037                                  'mixed constraint integer.'/
7038                                  'Objective function value: '
7039                                  NETBENEFIT.l:<12:1 /
7040                                  'Violations cost         : '
7041                                  TOTALPENALTYCOST.l:<12:1 /
7042              ) ;
7043          else
7044              loop(currTP,
7045                  unsolvedPeriod(currTP) = yes;
7046                  VSPDModel(currTP) = 1;
7047                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ') '
7048                                  'is solved unsuccessfully for '
7049                                  'mixed constraint integer.'/
7050              ) ;
7051          ) ;
7052  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
7053   
7054   
7055  *   Solve the LP model and stop ------------------------------------------------
7056      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
7057   
7058          if( UseShareReserve,
7059              option bratio = 1 ;
7060              vSPD_NMIR.Optfile = 1 ;
7061              vSPD_NMIR.optcr = MIPOptimality ;
7062              vSPD_NMIR.reslim = MIPTimeLimit ;
7063              vSPD_NMIR.iterlim = MIPIterationLimit ;
7064              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
7065  *           Set the model solve status
7066              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
7067                                 or (vSPD_NMIR.modelstat = 8) )
7068                              and ( vSPD_NMIR.solvestat = 1 ) } ;
7069          else
7070              option bratio = 1 ;
7071              vSPD.reslim = LPTimeLimit ;
7072              vSPD.iterlim = LPIterationLimit ;
7073              solve vSPD using lp maximizing NETBENEFIT ;
7074  *           Set the model solve status
7075              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
7076          )
7077   
7078  *       Post a progress message for use by EMI.
7079          if( ModelSolved = 1,
7080              loop(currTP,
7081                  putclose runlog 'The case: FP_20221015_F (' currTP.tl ')'
7082                                  ' integer resolve was unsuccessful.' /
7083                                  'Reverting back to linear solve and '
7084                                  'solve successfully. ' /
7085                                  'Objective function value: '
7086                                  NETBENEFIT.l:<12:1 /
7087                                  'Violations cost         : '
7088                                  TOTALPENALTYCOST.l:<12:1 /
7089                                  'Solution may have circulating flows '
7090                                  'and/or non-physical losses.' /
7091              ) ;
7092          else
7093              loop(currTP,
7094                  putclose runlog 'The case: FP_20221015_F (' currTP.tl
7095                                  ') integer solve was unsuccessful. '
7096                                  'Reverting back to linear solve. '
7097                                  'Linear solve unsuccessful.' /
7098              ) ;
7099          ) ;
7100   
7101          unsolvedPeriod(currTP) = no;
7102   
7103  *   Solve the LP model and stop end --------------------------------------------
7104   
7105      ) ;
7106  *   Solve the models end
7107   
7108   
7109   
7110  *   6e. Check if the LP results are valid --------------------------------------
7111      if((ModelSolved = 1),
7112          useBranchFlowMIP(currTP) = 0 ;
7113          useMixedConstraintMIP(currTP) = 0 ;
7114  *       Check if there is no branch circular flow and non-physical losses
7115          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
7116   
7117  *           Check if there are circulating branch flows on loss AC branches
7118              circularBranchFlowExist(ACbranch(currTP,br))
7119                  $ { LossBranch(ACbranch) and
7120                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
7121                        - abs(ACBRANCHFLOW.l(ACbranch))
7122                        ) > circularBranchFlowTolerance
7123                      ]
7124                    } = 1 ;
7125   
7126  *           Determine the circular branch flow flag on each HVDC pole
7127              TotalHVDCpoleFlow(currTP,pole)
7128                  = sum[ br $ HVDCpoleBranchMap(pole,br)
7129                       , HVDCLINKFLOW.l(currTP,br) ] ;
7130   
7131              MaxHVDCpoleFlow(currTP,pole)
7132                  = smax[ br $ HVDCpoleBranchMap(pole,br)
7133                        , HVDCLINKFLOW.l(currTP,br) ] ;
7134   
7135              poleCircularBranchFlowExist(currTP,pole)
7136                  $ { ( TotalHVDCpoleFlow(currTP,pole)
7137                      - MaxHVDCpoleFlow(currTP,pole)
7138                      ) > circularBranchFlowTolerance
7139                    } = 1 ;
7140   
7141  *           Check if there are circulating branch flows on HVDC
7142              NorthHVDC(currTP)
7143                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
7144                                        i_tradePeriodBusIsland(currTP,b,ild) and
7145                                        HVDClinkSendingBus(currTP,br,b) and
7146                                        HVDCpoles(currTP,br)
7147                                      }, HVDCLINKFLOW.l(currTP,br)
7148                       ] ;
7149   
7150              SouthHVDC(currTP)
7151                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
7152                                        i_tradePeriodBusIsland(currTP,b,ild) and
7153                                        HVDClinkSendingBus(currTP,br,b) and
7154                                        HVDCpoles(currTP,br)
7155                                      }, HVDCLINKFLOW.l(currTP,br)
7156                       ] ;
7157   
7158              circularBranchFlowExist(currTP,br)
7159                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
7160                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
7161                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
7162                    } = 1 ;
7163   
7164  *           Check if there are non-physical losses on HVDC links
7165              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
7166                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
7167                  and validLossSegment(currTP,br,los,fd) }
7168                  = Min[ Max( 0,
7169                              [ abs(HVDCLINKFLOW.l(HVDClink))
7170                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
7171                              ]
7172                            ),
7173                         ( LossSegmentMW(HVDClink,los,fd)
7174                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
7175                         )
7176                       ] ;
7177   
7178              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
7179                  = sum[ (los,fd) $ validLossSegment(currTP,br,los,fd)
7180                                  , LossSegmentFactor(HVDClink,los,fd)
7181                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
7182                       ] ;
7183   
7184              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
7185                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
7186                         - ManualLossCalculation(HVDClink)
7187                         ) > NonPhysicalLossTolerance
7188                    } = 1 ;
7189   
7190  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
7191  *           and non-physical loss branches exceeds the specified tolerance
7192              useBranchFlowMIP(currTP)
7193                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
7194                                , resolveCircularBranchFlows
7195                                * circularBranchFlowExist(currTP,br)
7196                           ]
7197                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
7198                                , (1 - AllowHVDCroundpower(currTP))
7199                                * resolveCircularBranchFlows
7200                                * circularBranchFlowExist(currTP,br)
7201                                + resolveHVDCnonPhysicalLosses
7202                                * NonPhysicalLossExist(currTP,br)
7203                           ]
7204                      + sum[ pole, resolveCircularBranchFlows
7205                                 * poleCircularBranchFlowExist(currTP,pole)
7206                           ]
7207                       ) > UseBranchFlowMIPTolerance
7208                                         } = 1 ;
7209   
7210  *       Check if there is no branch circular flow and non-physical losses end
7211          );
7212   
7213   
7214  *       Check if there is mixed constraint integer is required
7215          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
7216   
7217  *           Check if integer variables are needed for mixed constraint
7218              if( useMixedConstraintRiskOffset,
7219                  HVDChalfPoleSouthFlow(currTP)
7220                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
7221                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
7222                             ] > MixedMIPTolerance
7223                        } = 1 ;
7224   
7225  *               Only calculate violation if the constraint limit is non-zero
7226                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
7227                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
7228                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
7229                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
7230                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
7231                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
7232                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
7233                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
7234                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
7235                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
7236                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
7237   
7238  *               Integer constraints are needed if southward flow on half-poles AND
7239  *               constraint level exceeds the mixed constraint limit2 value
7240                  useMixedConstraintMIP(currTP)
7241                      $ { HVDChalfPoleSouthFlow(currTP) and
7242                          sum[ t1MixCstr
7243                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
7244                                 > MixedMIPTolerance }, 1
7245                             ]
7246                        } = 1 ;
7247              ) ;
7248   
7249  *       Check if there is mixed constraint integer is required end
7250          );
7251   
7252  *       A period is unsolved if MILP model is required
7253          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
7254                                         + UseMixedConstraintMIP(currTP)
7255                                         ] ;
7256   
7257  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
7258          loop( unsolvedPeriod(currTP),
7259              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
7260                  VSPDModel(currTP) = 1;
7261                  putclose runlog 'The case: FP_20221015_F requires a'
7262                                  'VSPD_MIP resolve for period ' currTP.tl
7263                                  '. Switching Vectorisation OFF.' /
7264   
7265              elseif UseBranchFlowMIP(currTP) >= 1,
7266                  if( VSPDModel(currTP) = 0,
7267                      VSPDModel(currTP) = 2;
7268                      putclose runlog 'The case: FP_20221015_F requires a '
7269                                      'vSPD_BranchFlowMIP resolve for period '
7270                                      currTP.tl '. Switching Vectorisation OFF.'/
7271                  elseif VSPDModel(currTP) = 3,
7272                      VSPDModel(currTP) = 1;
7273                      putclose runlog 'The case: FP_20221015_F requires a '
7274                                      'VSPD_MIP resolve for period ' currTP.tl
7275                                      '. Switching Vectorisation OFF.' /
7276                  );
7277   
7278              elseif UseMixedConstraintMIP(currTP) >= 1,
7279                  if( VSPDModel(currTP) = 0,
7280                      VSPDModel(currTP) = 3;
7281                      putclose runlog 'The case: FP_20221015_F requires a '
7282                                      'vSPD_MixedConstraintMIP resolve for period '
7283                                      currTP.tl '. Switching Vectorisation OFF.' /
7284                  elseif VSPDModel(currTP) = 2,
7285                      VSPDModel(currTP) = 1;
7286                      putclose runlog 'The case: FP_20221015_F requires a '
7287                                      'VSPD_MIP resolve for period ' currTP.tl
7288                                      '. Switching Vectorisation OFF.' /
7289                  );
7290   
7291              ) ;
7292   
7293          ) ;
7294   
7295          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
7296          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
7297   
7298  *   Check if the LP results are valid end
7299      ) ;
7300   
7301   
7302   
7303  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
7304   
7305  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
7306  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
7331   
7332      busGeneration(bus(currTP,b))
7333          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
7334               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
7335               ] ;
7336   
7337      busLoad(bus(currTP,b))
7338          = sum[ NodeBus(currTP,n,b)
7339               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
7340               ] ;
7341   
7342      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
7343          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
7344   
7345      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
7346          = DCNodeNetInjection.m(currTP,b) ;
7347   
7348      if((disconnectedNodePriceCorrection = 1),
7349  *       Pre-MSP case
7350          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
7351              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
7352                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
7353                                        branch(currTP,br)
7354                                      }, 1 ]
7355                      )
7356                    } ;
7357   
7358  *       Post-MSP cases
7359  *       Scenario C/F/G/H/I:
7360          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
7361                                         and (busLoad(bus) = 0)
7362                                         and (busElectricalIsland(bus) = 0)
7363                                           } = 1 ;
7364  *       Scenario E:
7365          busDisconnected(bus(currTP,b))
7366              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
7367                              = busElectricalIsland(bus) }
7368                       , busLoad(currTP,b1) ] = 0
7369                  ) and
7370                  ( busElectricalIsland(bus) > 0 ) and
7371                  ( i_useBusNetworkModel(currTP) = 1 )
7372                } = 1 ;
7373  *       Set prices at dead buses with non-zero load
7374          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
7375                                      (busLoad(bus) > 0) and
7376                                      (busElectricalIsland(bus)= 0)
7377                                    } = DeficitBusGenerationPenalty ;
7378   
7379          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
7380                                      (busLoad(bus) < 0) and
7381                                      (busElectricalIsland(bus)= 0)
7382                                    } = -SurplusBusGenerationPenalty ;
7383   
7384  *       Set price at identified disconnected buses to 0
7385          busPrice(bus)$busDisconnected(bus) = 0 ;
7386      ) ;
7387   
7388  * End Check for disconnected nodes and adjust prices accordingly
7389   
7390  * TN - Replacing invalid prices after SOS1
7391  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
7392      if ( vSPD_SOS1_Solve(tp),
7393           busSOSinvalid(tp,b)
7394             = 1 $ { [ ( busPrice(tp,b) = 0 )
7395                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
7396                      or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
7397                       ]
7398                   and bus(tp,b)
7399                   and [ not busDisconnected(tp,b) ]
7400  *                 and [ busLoad(tp,b) = 0 ]
7401  *                 and [ busGeneration(tp,b) = 0 ]
7402                   and [ busLoad(tp,b) = busGeneration(tp,b) ]
7403                   and [ sum[(br,fd)
7404                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
7405                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
7406                            ] = 0
7407                       ]
7408                   and [ sum[ br
7409                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
7410                            , 1
7411                            ] > 0
7412                       ]
7413                     };
7414          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
7415          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
7416              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
7417              busPrice(tp,b)
7418                $ { busSOSinvalid(tp,b)
7419                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
7420                              and sum[ br $ { branch(tp,br)
7421                                          and BranchBusConnect(tp,br,b)
7422                                          and BranchBusConnect(tp,br,b1)
7423                                            }, 1
7424                                     ]
7425                               }, 1
7426                         ] > 0
7427                    )
7428                  }
7429                = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
7430                          and sum[ br $ { branch(tp,br)
7431                                      and BranchBusConnect(tp,br,b)
7432                                      and BranchBusConnect(tp,br,b1)
7433                                        }, 1 ]
7434                            }, busPrice(tp,b1)
7435                     ]
7436                / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
7437                          and sum[ br $ { branch(tp,br)
7438                                      and BranchBusConnect(tp,br,b)
7439                                      and BranchBusConnect(tp,br,b1)
7440                                        }, 1 ]
7441                            }, 1
7442                     ];
7443   
7444              busSOSinvalid(tp,b)
7445                = 1 $ { [ ( busPrice(tp,b) = 0 )
7446                       or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
7447                       or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
7448                        ]
7449                    and bus(tp,b)
7450                    and [ not busDisconnected(tp,b) ]
7451  *                  and [ busLoad(tp,b) = 0 ]
7452  *                  and [ busGeneration(tp,b) = 0 ]
7453                    and [ busLoad(tp,b) = busGeneration(tp,b) ]
7454                    and [ sum[(br,fd)
7455                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
7456                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
7457                             ] = 0
7458                        ]
7459                    and [ sum[ br
7460                             $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
7461                             , 1
7462                             ] > 0
7463                        ]
7464                      };
7465           );
7466      );
7467  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
7468   
7469   
7470  *   6g. Collect and store results of solved periods into output parameters -----
7471  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
7472   
7474  *   Normal vSPD run post processing for reporting
7476      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
7477  *   Reporting at trading period start
7478  *       Node level output
7479          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
7480   
7481          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
7482              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
7483   
7484          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
7485             = NodeDemand(currTP,n)
7486             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
7487   
7488          o_nodePrice_TP(dt,n) $ Node(currTP,n)
7489              = sum[ b $ NodeBus(currTP,n,b)
7490                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
7491                    ] ;
7492   
7493  *       Offer output
7494          o_offer(dt,o) $ offer(currTP,o) = yes ;
7495   
7496          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
7497   
7498          o_offerFIR_TP(dt,o) $ offer(currTP,o)
7499              = sum[ (resC,resT)$(ord(resC) = 1)
7500                   , RESERVE.l(currTP,o,resC,resT) ] ;
7501   
7502          o_offerSIR_TP(dt,o) $ offer(currTP,o)
7503              = sum[ (resC,resT)$(ord(resC) = 2)
7504                   , RESERVE.l(currTP,o,resC,resT) ] ;
7505   
7506  *       Bus level output
7507          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
7508   
7509          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
7510   
7511          o_busLoad_TP(dt,b) $ bus(currTP,b)
7512              = busLoad(currTP,b)
7513              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
7514                   , PURCHASE.l(currTP,bd) ];
7515   
7516          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
7517   
7518          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
7519   
7520          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
7521   
7522  *       Node level output
7523   
7524          totalBusAllocation(dt,b) $ bus(currTP,b)
7525              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
7526   
7527          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
7528              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
7529   
7530  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
7544          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
7545              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
7546   
7547          changedDeficitBus(dt,b) = no;
7548   
7549          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
7550   
7551              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
7552   
7553              Loop b $ unmappedDeficitBus(dt,b) do
7554                  o_busDeficit_TP(dt,b1)
7555                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
7556                                and ( branchBusDefn(tp,br,b1,b)
7557                                   or branchBusDefn(tp,br,b,b1) )
7558                                  }, 1 ]
7559                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
7560   
7561                  changedDeficitBus(dt,b1)
7562                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
7563                              and ( branchBusDefn(tp,br,b1,b)
7564                                 or branchBusDefn(tp,br,b,b1) )
7565                                }, 1 ] = yes;
7566   
7567                  unmappedDeficitBus(dt,b) = no;
7568                  changedDeficitBus(dt,b) = no;
7569                  o_busDeficit_TP(dt,b) = 0;
7570              EndLoop;
7571   
7572              Loop n $ sum[ b $ changedDeficitBus(dt,b)
7573                          , busNodeAllocationFactor(dt,b,n)] do
7574                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
7575                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
7576                                                    busNodeAllocationFactor(dt,b,n)
7577                                                  * o_busDeficit_TP(dt,b) ] ;
7578              EndLoop;
7579   
7580              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
7581          Endif;
7582  * TN - post processing unmapped generation deficit buses end
7583   
7584          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
7585              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
7586                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
7587   
7588          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
7589              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
7590                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
7591   
7592  *       branch output
7593          o_branch(dt,br) $ branch(currTP,br) = yes ;
7594   
7595          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
7596   
7597          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
7598   
7599          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
7600              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
7601   
7602          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
7603              = HVDCLINKLOSSES.l(currTP,br) ;
7604   
7605          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
7606              = branchFixedLoss(currTP,br) ;
7607   
7608          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
7609              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
7610   
7611          o_branchFromBus_TP(dt,br,frB)
7612              $ { branch(currTP,br) and
7613                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
7614                } = yes ;
7615   
7616          o_branchToBus_TP(dt,br,toB)
7617              $ { branch(currTP,br) and
7618                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
7619                } = yes ;
7620   
7621          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
7622              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
7623   
7624          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
7625              = HVDClinkMaximumFlow.m(currTP,br) ;
7626   
7627          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
7628              = sum[ fd $ ( ord(fd) = 1 )
7629                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
7630                   ] $  { o_branchFlow_TP(dt,br) >= 0 }
7631              + sum[ fd $ ( ord(fd) = 2 )
7632                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
7633                   ] $  { o_branchFlow_TP(dt,br) < 0 } ;
7634   
7635   
7636  *       Offer output
7637          o_offerEnergyBlock_TP(dt,o,trdBlk)
7638              = GENERATIONBLOCK.l(currTP,o,trdBlk);
7639   
7640          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
7641              = sum[ resC $ (ord(resC) = 1)
7642              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
7643   
7644          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
7645              = sum[ resC $ (ord(resC) = 2)
7646              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
7647   
7648  *       bid output
7649          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
7650   
7651          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
7652   
7653          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
7654              = sum[ resC $ (ord(resC) = 1)
7655                   , PURCHASEILR.l(currTP,bd,resC) ] ;
7656   
7657          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
7658              = sum[ resC $ (ord(resC) = 2)
7659                   , PURCHASEILR.l(currTP,bd,resC) ] ;
7660   
7661          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
7662              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
7663   
7664  *       Violation reporting based on the CE and ECE
7665          o_ResViolation_TP(dt,ild,resC)
7666              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
7667              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
7668              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
7669   
7670          o_FIRviolation_TP(dt,ild)
7671              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
7672   
7673          o_SIRviolation_TP(dt,ild)
7674              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
7675   
7676  *       Security constraint data
7677          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
7678   
7679          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
7680              = branchConstraintSense(currTP,brCstr) ;
7681   
7682          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
7683              = [ branchSecurityConstraintLE.l(currTP,brCstr)
7684                $ (branchConstraintSense(currTP,brCstr) = -1) ]
7685              + [ branchSecurityConstraintGE.l(currTP,brCstr)
7686                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
7687              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
7688                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
7689   
7690          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
7691              = branchConstraintLimit(currTP,brCstr) ;
7692   
7693          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
7694              = [ branchSecurityConstraintLE.m(currTP,brCstr)
7695                $ (branchConstraintSense(currTP,brCstr) = -1) ]
7696              + [ branchSecurityConstraintGE.m(currTP,brCstr)
7697                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
7698              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
7699                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
7700   
7701  *       Mnode constraint data
7702          o_MnodeConstraint_TP(dt,MnodeCstr)
7703              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
7704   
7705          o_MnodeConstraintSense_TP(dt,MnodeCstr)
7706              $ MnodeConstraint(currTP,MnodeCstr)
7707              = MnodeConstraintSense(currTP,MnodeCstr) ;
7708   
7709          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
7710              $ MnodeConstraint(currTP,MnodeCstr)
7711              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
7712                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
7713              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
7714                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
7715              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
7716                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
7717   
7718          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
7719              $ MnodeConstraint(currTP,MnodeCstr)
7720              = MnodeConstraintLimit(currTP,MnodeCstr) ;
7721   
7722          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
7723              $ MnodeConstraint(currTP,MnodeCstr)
7724              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
7725                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
7726              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
7727                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
7728              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
7729                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
7730   
7731  *       Island output
7732          o_island(dt,ild) = yes ;
7733   
7734          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
7735   
7736          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
7737                                            , o_ResPrice_TP(dt,ild,resC) ];
7738   
7739          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
7740                                            , o_ResPrice_TP(dt,ild,resC) ];
7741   
7742          o_islandGen_TP(dt,ild)
7743              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
7744   
7745          o_islandClrBid_TP(dt,ild)
7746              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
7747   
7748          o_islandLoad_TP(dt,ild)
7749              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
7750              + o_islandClrBid_TP(dt,ild) ;
7751   
7752          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
7753   
7754          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
7755                                              , o_ResCleared_TP(dt,ild,resC) ];
7756   
7757          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
7758                                              , o_ResCleared_TP(dt,ild,resC) ];
7759   
7760          o_islandBranchLoss_TP(dt,ild)
7761              = sum[ (br,frB,toB)
7762                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
7763                   and branchBusDefn(currTP,br,frB,toB)
7764                     }, o_branchTotalLoss_TP(dt,br) ] ;
7765   
7766          o_HVDCflow_TP(dt,ild)
7767              = sum[ (br,frB,toB)
7768                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
7769                   and branchBusDefn(currTP,br,frB,toB)
7770                     }, o_branchFlow_TP(dt,br) ] ;
7771   
7772          o_HVDChalfPoleLoss_TP(dt,ild)
7773              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
7774                                      branchBusDefn(currTP,br,frB,toB) and
7775                                      busIsland(currTP,toB,ild) and
7776                                      busIsland(currTP,frB,ild)
7777                                        }, o_branchTotalLoss_TP(dt,br)
7778                   ] ;
7779   
7780          o_HVDCpoleFixedLoss_TP(dt,ild)
7781              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
7782                                      branchBusDefn(currTP,br,frB,toB) and
7783                                      ( busIsland(currTP,toB,ild) or
7784                                        busIsland(currTP,frB,ild)
7785                                      )
7786                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
7787                   ] ;
7788   
7789          o_HVDCloss_TP(dt,ild)
7790              = o_HVDChalfPoleLoss_TP(dt,ild)
7791              + o_HVDCpoleFixedLoss_TP(dt,ild)
7792              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
7793                                      branchBusDefn(currTP,br,frB,toB) and
7794                                      busIsland(currTP,toB,ild) and
7795                                      (not (busIsland(currTP,frB,ild)))
7796                                    }, o_branchDynamicLoss_TP(dt,br)
7797                   ] ;
7798   
7799  * TN - The code below is added for NMIR project ================================
7800          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
7801              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
7802   
7803          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
7804   
7805              o_FirSent_TP(dt,ild)
7806                  = Sum[ (rd,resC) $ (ord(resC) = 1)
7807                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
7808   
7809              o_FirReceived_TP(dt,ild)
7810                  = Sum[ (rd,resC) $ (ord(resC) = 1)
7811                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
7812   
7813              o_FirEffective_TP(dt,ild,riskC)
7814                  = Sum[ resC $ (ord(resC) = 1),
7815                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
7816   
7817              o_FirEffReport_TP(dt,ild)
7818                  = Smax[ (resC,riskC) $ (ord(resC)=1)
7819                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
7820   
7821          Endif;
7822   
7823          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
7824   
7825              o_SirSent_TP(dt,ild)
7826                  = Sum[ (rd,resC) $ (ord(resC) = 2),
7827                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
7828   
7829              o_SirReceived_TP(dt,ild)
7830                  = Sum[ (fd,resC) $ (ord(resC) = 2),
7831                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
7832   
7833              o_SirEffective_TP(dt,ild,riskC)
7834                  = Sum[ resC $ (ord(resC) = 2),
7835                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
7836   
7837              o_SirEffReport_TP(dt,ild)
7838                  = Smax[ (resC,riskC) $ (ord(resC)=2)
7839                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
7840          Endif;
7841   
7842   
7843  * TN - The code for NMIR project end ===========================================
7844   
7845  *       Additional output for audit reporting
7846          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
7847   
7848  *       Check if there are non-physical losses on AC branches
7849          ManualBranchSegmentMWFlow(LossBranch(ACbranch(currTP,br)),los,fd)
7850                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
7851                  and validLossSegment(ACbranch,los,fd)
7852                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
7853                    }
7854                  = Min[ Max( 0,
7855                              [ abs(o_branchFlow_TP(dt,br))
7856                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
7857                              ]
7858                            ),
7859                         ( LossSegmentMW(ACbranch,los,fd)
7860                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
7861                         )
7862                       ] ;
7863   
7864          ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
7865                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
7866                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
7867                    }
7868                  = Min[ Max( 0,
7869                              [ abs(o_branchFlow_TP(dt,br))
7870                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
7871                              ]
7872                            ),
7873                         ( LossSegmentMW(HVDClink,los,fd)
7874                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
7875                         )
7876                       ] ;
7877   
7878          ManualLossCalculation(LossBranch(branch(currTP,br)))
7879              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
7880                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
7881   
7882          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
7883                                   - ManualLossCalculation(currTP,br) ;
7884   
7885          o_lossSegmentBreakPoint(dt,br,los)
7886              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
7887                         and (ord(fd) = 1)
7888                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
7889              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
7890                         and (ord(fd) = 2)
7891                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
7892          ;
7893   
7894          o_lossSegmentFactor(dt,br,los)
7895              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
7896                         and (ord(fd) = 1)
7897                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
7898              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
7899                         and (ord(fd) = 2)
7900                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
7901          ;
7902   
7903          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
7904   
7905          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
7906              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
7907                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
7908   
7909          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
7910              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
7911                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
7912   
7913          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
7914              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
7915                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
7916   
7917          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
7918              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
7919                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
7920   
7921          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
7922              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
7923                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
7924   
7925          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
7926              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
7927                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
7928   
7929          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
7930                                                offerNode(currTP,o,n)
7931                                              }, o_ILRO_FIR_TP(dt,o) ] ;
7932   
7933          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
7934                                                offerNode(currTP,o,n)
7935                                              }, o_ILRO_SIR_TP(dt,o) ] ;
7936   
7937          o_marketNodeIsland_TP(dt,o,ild)
7938              $ sum[ n $ { offerIsland(currTP,o,ild) and
7939                           offerNode(currTP,o,n) and
7940                           (o_nodeLoad_TP(dt,n)  = 0)
7941                         },1
7942                   ] = yes ;
7943   
7944          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
7945              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
7946              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
7947              ;
7948   
7949          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
7950              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
7951   
7952          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
7953              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
7954   
7955          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
7956              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
7957   
7958          o_manuRiskLevel(dt,ild,resC,ManualRisk)
7959              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
7960              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
7961              ;
7962   
7963          o_manuRiskPrice(dt,ild,resC,ManualRisk)
7964              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
7965   
7966          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
7967              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
7968   
7969          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
7970              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
7971   
7972          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
7973              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
7974   
7975          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
7976              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
7977   
7978          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
7979              $ islandRiskGroup(currTP,ild,rg,GenRisk)
7980              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
7981              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
7982              ;
7983   
7984          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
7985              $ islandRiskGroup(currTP,ild,rg,GenRisk)
7986              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
7987   
7988  *       FIR and SIR required based on calculations of the island risk to
7989  *       overcome reporting issues of the risk setter under degenerate
7990  *       conditions when reserve price = 0 - See below
7991   
7992          o_ReserveReqd_TP(dt,ild,resC)
7993              = Max[ 0,
7994                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
7995                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
7996                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
7997                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
7998                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
7999                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
8000                   ] ;
8001   
8002          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
8003          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
8004   
8005  *       Summary reporting by trading period
8006          o_solveOK_TP(dt) = ModelSolved ;
8007   
8008          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
8009   
8010          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
8011   
8012          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
8013   
8014          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
8015                       - o_systemCost_TP(dt)
8016                       - o_penaltyCost_TP(dt);
8017   
8018   
8019  *       Separete violation reporting at trade period level
8020          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
8021   
8022          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
8023   
8024          o_surpBranchFlow_TP(dt)
8025              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
8026   
8027          o_defRampRate_TP(dt)
8028              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
8029   
8030          o_surpRampRate_TP(dt)
8031              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
8032   
8033          o_surpBranchGroupConst_TP(dt)
8034              = sum[ brCstr $ branchConstraint(currTP,brCstr)
8035                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
8036   
8037          o_defBranchGroupConst_TP(dt)
8038              = sum[ brCstr $ branchConstraint(currTP,brCstr)
8039                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
8040   
8041          o_defMnodeConst_TP(dt)
8042              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
8043                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
8044   
8045          o_surpMnodeConst_TP(dt)
8046              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
8047                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
8048   
8049          o_defACnodeConst_TP(dt)
8050              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
8051                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
8052   
8053          o_surpACnodeConst_TP(dt)
8054              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
8055                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
8056   
8057          o_defT1MixedConst_TP(dt)
8058              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
8059                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
8060   
8061          o_surpT1MixedConst_TP(dt)
8062              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
8063                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
8064   
8065          o_defGenericConst_TP(dt)
8066              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
8067                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
8068   
8069          o_surpGenericConst_TP(dt)
8070              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
8071                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
8072   
8073          o_defResv_TP(dt)
8074              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
8075   
8076          o_totalViolation_TP(dt)
8077              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
8078              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
8079              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
8080              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
8081              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
8082              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
8083              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
8084              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
8085   
8086  *       Virtual reserve
8087          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
8088   
8089          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
8090                                    , o_vrResMW_TP(dt,ild,resC) ] ;
8091   
8092          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
8093                                    , o_vrResMW_TP(dt,ild,resC) ] ;
8094   
8095  *   Reporting at trading period end
8096      EndLoop;
8098   
8100   
8101  * End of the solve vSPD loop
8102    ] ;
8103  * End of the While loop
8104  );
8105   
8106   
8107  *   Summary reports - only applied for normal and audit vSPD run.
8109   
8110  *   System level
8111      o_numTradePeriods = card(tp) ;
8112   
8113      o_systemOFV = sum[ dt, o_ofv_TP(dt) ] ;
8114   
8115      o_systemGen = sum[ (dt,ild), o_islandGen_TP(dt,ild) ] ;
8116   
8117      o_systemLoad = sum[ (dt,ild), o_islandLoad_TP(dt,ild)
8118                                  - o_islandClrBid_TP(dt,ild) ] ;
8119   
8120      o_systemLoss = sum[ (dt,ild), o_islandBranchLoss_TP(dt,ild)
8121                                  + o_HVDCloss_TP(dt,ild) ] ;
8122   
8123      o_systemViolation = sum[ dt, o_totalViolation_TP(dt) ] ;
8124   
8125      o_systemFIR = sum[ (dt,ild), o_FIRcleared_TP(dt,ild) ] ;
8126   
8127      o_systemSIR = sum[ (dt,ild), o_SIRcleared_TP(dt,ild) ] ;
8128   
8129   
8130  *   Offer level - This does not include revenue from wind generators for
8131  *   final pricing because the wind generation is netted off against load
8132  *   at the particular bus for the final pricing solves
8133   
8134      o_offerTrader(o,trdr)
8135          $ sum[ tp $ i_tradePeriodOfferTrader(tp,o,trdr), 1 ] = yes ;
8136   
8137      o_offerGen(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerEnergy_TP(dt,o)] ;
8138   
8139      o_offerFIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerFIR_TP(dt,o)] ;
8140   
8141      o_offerSIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerSIR_TP(dt,o)] ;
8142   
8144   
8145   
8146  *=====================================================================================
8147  * 8. vSPD scarcity pricing post-processing
8148  *=====================================================================================
8150   
8151  * Mapping scarcity area to islands
8152  scarcityAreaIslandMap(sarea,ild)      = no ;
8153  scarcityAreaIslandMap('NI','NI')      = yes ;
8154  scarcityAreaIslandMap('SI','SI')      = yes ;
8155  scarcityAreaIslandMap('National',ild) = yes ;
8156   
8158   
8159   
8160  * 8b. Calculating price-relating outputs --------------------------------------
8161   
8163  loop(i_dateTimeTradePeriodMap(dt,tp),
8164   
8165  *   bus output update
8166      o_busRevenue_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
8167                                        * o_busGeneration_TP(dt,b)
8168                                        * o_busPrice_TP(dt,b) ;
8169   
8170      o_busCost_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
8171                                     * o_busLoad_TP(dt,b)
8172                                     * o_busPrice_TP(dt,b);
8173   
8174  *   node output update
8175      o_nodeRevenue_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
8176                                          * o_nodeGeneration_TP(dt,n)
8177                                          * o_nodePrice_TP(dt,n) ;
8178   
8179      o_nodeCost_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
8180                                       * o_nodeLoad_TP(dt,n)
8181                                       * o_nodePrice_TP(dt,n) ;
8182   
8183  *   branch output update
8184      o_branchFromBusPrice_TP(dt,br) $ branch(tp,br)
8185          = sum[ b $ o_branchFromBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
8186   
8187      o_branchToBusPrice_TP(dt,br) $ branch(tp,br)
8188          = sum[ b $ o_branchToBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
8189   
8190      o_branchTotalRentals_TP(dt,br)
8191          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) >= 0) }
8192          = (i_tradingPeriodLength/60)
8193          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
8194            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
8195            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
8196            ] ;
8197   
8198      o_branchTotalRentals_TP(dt,br)
8199          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) < 0) }
8200          = (i_tradingPeriodLength/60)
8201          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
8202            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
8203            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
8204            ] ;
8205   
8206  *   Island output
8207      o_islandRefPrice_TP(dt,ild)
8208          = sum[ n $ { referenceNode(tp,n)
8209                   and nodeIsland(tp,n,ild) } , o_nodePrice_TP(dt,n) ] ;
8210   
8211      o_islandEnergyRevenue_TP(dt,ild)
8212          = sum[ n $ nodeIsland(tp,n,ild), o_nodeRevenue_TP(dt,n)] ;
8213   
8214      o_islandReserveRevenue_TP(dt,ild) = sum[ resC, o_ResCleared_TP(dt,ild,resC)
8215                                                   * o_ResPrice_TP(dt,ild,resC)
8216                                                   * i_tradingPeriodLength/60 ];
8217   
8218      o_islandLoadCost_TP(dt,ild)
8219          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
8220               , o_nodeCost_TP(dt,n) ] ;
8221   
8222      o_islandLoadRevenue_TP(dt,ild)
8223          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
8224               , - o_nodeCost_TP(dt,n) ] ;
8225   
8227  ) ;
8228   
8229  * System level
8230  o_systemEnergyRevenue  = sum[ (dt,ild), o_islandEnergyRevenue_TP(dt,ild) ] ;
8231   
8232  o_systemReserveRevenue = sum[ (dt,ild), o_islandReserveRevenue_TP(dt,ild) ];
8233   
8234  o_systemLoadCost       = sum[ (dt,ild), o_islandLoadCost_TP(dt,ild) ];
8235   
8236  o_systemLoadRevenue    = sum[ (dt,ild), o_islandLoadRevenue_TP(dt,ild) ];
8237   
8238  * Offer level
8239  o_offerGenRevenue(o)
8240      = sum[ (dt,tp,n) $ { i_dateTimeTradePeriodMap(dt,tp) and offerNode(tp,o,n) }
8241           , (i_tradingPeriodLength/60)
8242           * o_offerEnergy_TP(dt,o) * o_nodePrice_TP(dt,n) ] ;
8243   
8244  o_offerFIRrevenue(o)
8245      = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
8246                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
8247           , (i_tradingPeriodLength/60)
8248           * o_offerFIR_TP(dt,o) * o_FIRprice_TP(dt,ild) ] ;
8249   
8250  o_offerSIRrevenue(o)
8251     = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
8252                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
8253           , (i_tradingPeriodLength/60)
8254           * o_offerSIR_TP(dt,o) * o_SIRprice_TP(dt,ild) ] ;
8255   
8257  *   Calculating price-relating outputs end -------------------------------------
8258   
8259   
8261   
8262  *=====================================================================================
8263  * 9. Write results to CSV report files and GDX files
8264  *=====================================================================================
8265  * TN - Pivot analysis end
INCLUDE    C:\vSPD\vSPD_v3.1.0\Programs\vSPDreport.gms
8267  *=====================================================================================
8268  * Name:                 vSPDreport.gms
8269  * Function:             Creates the detailed reports for normal SPD mode
8270  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
8271  * Source:               https://github.com/ElectricityAuthority/vSPD
8272  *                       https://www.emi.ea.govt.nz/Tools/vSPD
8273  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
8274  *                       Email: emi@ea.govt.nz
8275  * Last modified on:     1 Oct 2019
8276  *
8277  *=====================================================================================
8278   
8279  * Normal vSPD run output
8280  o_FromDateTime(dt)$( ord(dt) = 1 ) = yes ;
8281   
8282  * System surplus needs to be calculated outside the main loop
8283  o_systemSurplus = o_systemLoadCost-o_systemLoadRevenue-o_systemEnergyRevenue ;
8284   
8285  * Trader level - Currently this does not include revenue from wind generators
8286  * since wind generation in FP is represented as negative load
8287  o_trader(trdr) = yes ;
8288  o_traderGen(trdr) = sum(o_offerTrader(o,trdr), o_offerGen(o)) ;
8289  o_traderFIR(trdr) = sum(o_offerTrader(o,trdr), o_offerFIR(o)) ;
8290  o_traderSIR(trdr) = sum(o_offerTrader(o,trdr), o_offerSIR(o)) ;
8291  o_traderGenRevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerGenRevenue(o));
8292  o_traderFIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerFIRrevenue(o));
8293  o_traderSIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerSIRrevenue(o));
8294   
8295   
8296  *=====================================================================================
8297  * Writing data in to CSV result files
8298  *=====================================================================================
8299   
8300  * System level summary
8301  File SystemResults    / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_SystemResults.csv" / ;
8302  SystemResults.pc = 5 ;     SystemResults.lw = 0 ;
8303  SystemResults.pw = 9999 ;  SystemResults.ap = 1 ;
8304  put SystemResults ;
8305  loop( dt $ o_FromDateTime(dt),
8306      put dt.tl, o_NumTradePeriods, o_systemOFV, o_systemGen, o_systemLoad
8307          o_systemLoss, o_systemViolation, o_systemFIR, o_systemSIR
8308          o_systemEnergyRevenue, o_systemLoadCost, o_systemLoadRevenue
8309          o_systemSurplus / ;
8310  ) ;
8311   
8312  * Offer level summary
8313  File  OfferResults     / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_OfferResults.csv" / ;
8314  OfferResults.pc = 5 ;      OfferResults.lw = 0 ;
8315  OfferResults.pw = 9999 ;   OfferResults.ap = 1 ;
8316  put OfferResults ;
8317  loop( (dt,o,trdr)
8318      $ { o_FromDateTime(dt) and o_offerTrader(o,trdr) and
8319          [ o_offerGen(o) or o_offerFIR(o) or o_offerSIR(o) ]
8320        },
8321      put dt.tl, o_NumTradePeriods, o.tl, trdr.tl
8322          o_offerGen(o), o_offerFIR(o), o_offerSIR(o) / ;
8323  ) ;
8324   
8325  * Trader level summary
8326  File  TraderResults   / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_TraderResults.csv" / ;
8327  TraderResults.pc = 5 ;     TraderResults.lw = 0 ;
8328  TraderResults.pw = 9999 ;  TraderResults.ap = 1 ;
8329  put TraderResults ;
8330  loop( (dt,trdr)
8331      $ { o_FromDateTime(dt) and o_trader(trdr) and
8332          [ o_traderGen(trdr) or o_traderFIR(trdr) or o_traderSIR(trdr) ]
8333        },
8334      put dt.tl, o_NumTradePeriods, trdr.tl
8335          o_traderGen(trdr), o_traderFIR(trdr), o_traderSIR(trdr) / ;
8336  ) ;
8337   
8338   
8339  * Trading period level report
8341   
8342  * Trading period summary result
8343  File
8344  SummaryResults_TP / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_SummaryResults_TP.csv" / ;
8345  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
8346  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
8347  SummaryResults_TP.nd = 5 ;
8348  put SummaryResults_TP ;
8349  loop( dt,
8350      put dt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
8351          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
8352          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
8353          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
8354          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
8355          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
8356          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt)
8357          o_DefACNodeConst_TP(dt), o_SurpACNodeConst_TP(dt)
8358          o_DefT1MixedConst_TP(dt), o_SurpT1MixedConst_TP(dt)
8359          o_DefGenericConst_TP(dt), o_SurpGenericConst_TP(dt) / ;
8360  ) ;
8361   
8362  * Trading period island result
8363  File IslandResults_TP /"C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_IslandResults_TP.csv"/;
8364  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
8365  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
8366  IslandResults_TP.nd = 5 ;
8367  put IslandResults_TP ;
8368  loop( (dt,ild) $ o_island(dt,ild),
8369      put dt.tl, ild.tl, o_islandGen_TP(dt,ild), o_islandLoad_TP(dt,ild)
8370          o_islandClrBid_TP(dt,ild), o_islandBranchLoss_TP(dt,ild)
8371          o_HVDCFlow_TP(dt,ild), o_HVDCLoss_TP(dt,ild)
8372          o_islandRefPrice_TP(dt,ild), o_FIRReqd_TP(dt,ild)
8373          o_SIRReqd_TP(dt,ild), o_FIRPrice_TP(dt,ild)
8374          o_SIRPrice_TP(dt,ild), o_islandEnergyRevenue_TP(dt,ild)
8375          o_islandLoadCost_TP(dt,ild), o_islandLoadRevenue_TP(dt,ild)
8376  * NIRM output
8377      o_FirCleared_TP(dt,ild), o_SirCleared_TP(dt,ild)
8378      o_FirSent_TP(dt,ild), o_SirSent_TP(dt,ild)
8379      o_FirReceived_TP(dt,ild), o_SirReceived_TP(dt,ild)
8380      o_FirEffReport_TP(dt,ild), o_SirEffReport_TP(dt,ild)
8381  *NIRM output end
8382      / ;
8383  ) ;
8384   
8386   
8387  * Trading period bus result
8388  File BusResults_TP   / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_BusResults_TP.csv" / ;
8389  BusResults_TP.pc = 5 ;
8390  BusResults_TP.lw = 0 ;
8391  BusResults_TP.pw = 9999 ;
8392  BusResults_TP.ap = 1 ;
8393  BusResults_TP.nd = 3
8394  put BusResults_TP ;
8395  loop( o_bus(dt,b),
8396      put dt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
8397          o_busPrice_TP(dt,b), o_busRevenue_TP(dt,b), o_busCost_TP(dt,b)
8398          o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
8399  ) ;
8400   
8401  * Trading period node result
8402  File NodeResults_TP  /"C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_NodeResults_TP.csv" / ;
8403  NodeResults_TP.pc = 5 ;
8404  NodeResults_TP.lw = 0 ;
8405  NodeResults_TP.pw = 9999 ;
8406  NodeResults_TP.ap = 1 ;
8407  NodeResults_TP.nd = 3 ;
8408  put NodeResults_TP ;
8409  loop( (dt,n) $ o_node(dt,n),
8410      put dt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
8411          o_nodePrice_TP(dt,n), o_nodeRevenue_TP(dt,n), o_nodeCost_TP(dt,n)
8412          o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
8413  ) ;
8414   
8415  * Trading period offer result
8416  File OfferResults_TP  /"C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_OfferResults_TP.csv"/ ;
8417  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
8418  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
8419  OfferResults_TP.nd = 3 ;
8420  put OfferResults_TP ;
8421  loop( (dt,o) $ o_offer(dt,o),
8422      put dt.tl, o.tl, o_offerEnergy_TP(dt,o)
8423          o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
8424  ) ;
8425   
8426  * Trading period bid result
8427  File BidResults_TP    / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_BidResults_TP.csv" / ;
8428  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
8429  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
8430  BidResults_TP.nd = 3 ;
8431  put BidResults_TP ;
8432  loop( (dt,bd) $ o_bid(dt,bd),
8433      put dt.tl, bd.tl, o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd)
8434      o_bidFIR_TP(dt,bd), o_bidSIR_TP(dt,bd) / ;
8435  ) ;
8436   
8437  * Trading period reserve result
8438  File
8439  ReserveResults_TP /"C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_ReserveResults_TP.csv" / ;
8440  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
8441  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
8442  ReserveResults_TP.nd = 3 ;
8443  put ReserveResults_TP ;
8444  loop( (dt,ild) $ o_island(dt,ild),
8445      put dt.tl, ild.tl, o_FIRReqd_TP(dt,ild), o_SIRReqd_TP(dt,ild)
8446          o_FIRPrice_TP(dt,ild), o_SIRPrice_TP(dt,ild)
8447          o_FIRViolation_TP(dt,ild), o_SIRViolation_TP(dt,ild)
8448          o_FIRvrMW_TP(dt,ild), o_SIRvrMW_TP(dt,ild) / ;
8449  ) ;
8450   
8451  * Trading period branch result
8452  File
8453  BranchResults_TP  / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_BranchResults_TP.csv" / ;
8454  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
8455  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
8456  BranchResults_TP.nd = 5 ;
8457  put BranchResults_TP ;
8458  loop( (dt,br,frB,toB)
8459      $ { o_branchToBus_TP(dt,br,toB) and
8460          o_branchFromBus_TP(dt,br,frB) and o_branch(dt,br)
8461        },
8462      put dt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
8463          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
8464          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
8465          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
8466          o_branchTotalRentals_TP(dt,br) / ;
8467  ) ;
8468   
8469  * Trading period branch constraint result
8470  File BrCstrResults_TP
8471  / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_BrConstraintResults_TP.csv" / ;
8472  BrCstrResults_TP.pc = 5 ;
8473  BrCstrResults_TP.lw = 0 ;
8474  BrCstrResults_TP.pw = 9999 ;
8475  BrCstrResults_TP.ap = 1 ;
8476  BrCstrResults_TP.nd = 5 ;
8477  put BrCstrResults_TP ;
8478  loop( (dt,brCstr) $ o_brConstraint_TP(dt,brCstr),
8479      put dt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
8480          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
8481          o_brConstraintPrice_TP(dt,brCstr) / ;
8482  ) ;
8483   
8484  * Trading period market node constraint result
8485  File MnodeCstrResults_TP
8486  / "C:\vSPD\vSPD_v3.1.0\Programs\..\Output\\Test_Run_All\Test_Run_All_MnodeConstraintResults_TP.csv" / ;
8487  MnodeCstrResults_TP.pc = 5 ;
8488  MnodeCstrResults_TP.lw = 0 ;
8489  MnodeCstrResults_TP.pw = 9999 ;
8490  MnodeCstrResults_TP.ap = 1 ;
8491  MnodeCstrResults_TP.nd = 5 ;
8492  put MnodeCstrResults_TP ;
8493  loop( (dt,MnodeCstr) $ o_MnodeConstraint_TP(dt,MnodeCstr),
8494      put dt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
8495          o_MnodeConstraintSense_TP(dt,MnodeCstr)
8496          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
8497          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
8498  ) ;
8499   
8501  *===============================================================================
8502   
8503   
8504   
8505  *===============================================================================
8506  * Audit mode reporting process
8507  *===============================================================================
8509  *===============================================================================
8510  *execute_unload '%outputPath%\%runName%\%vSPDinputData%_AllData.gdx' ;
8511   
8512   
8513   
8514   
8516   
8517   
8518  * Post a progress message for use by EMI.
8519  putclose runlog 'Case: FP_20221015_F is complete in ',timeExec,'(secs)'/ ;
8520  putclose runlog 'Case: FP_20221015_F is finished in ',timeElapsed,'(secs)'/ ;
8521   
8522  * Go to the next input file
8524   
8525  * Post a progress message for use by EMI.
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\vSPD\vSPD_v3.1.0\Programs\vSPDsolve.gms
     2     2741 INCLUDE        1      64  .C:\vSPD\vSPD_v3.1.0\Programs\vSPDsettings.inc
     3     2795 INCLUDE        1      65  .C:\vSPD\vSPD_v3.1.0\Programs\vSPDcase.inc
     4     3192 IF EXIST       1     459  C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx
     5     3198 GDXIN          1     465  C:\vSPD\vSPD_v3.1.0\Programs\vSPDPeriod.gdx
     6     3204 GDXIN          1     471  C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx
     7     3228 GDXIN          1     495  C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx
     8     3492 IF EXIST       1     759  C:\vSPD\vSPD_v3.1.0\Override\.gdx
     9     4653 INCLUDE        1    1920  .C:\vSPD\vSPD_v3.1.0\Programs\vSPDsolve_RTP.gms
    10     8266 INCLUDE        1    3937  .C:\vSPD\vSPD_v3.1.0\Programs\vSPDreport.gms
    11     8340 IF EXIST      10      74  .C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_BusResults_TP.csv
    12     8526 IF EXIST       1    3949  C:\vSPD\vSPD_v3.1.0\Input\FP_20221015_F.gdx


COMPILATION TIME     =        0.109 SECONDS     28 MB  36.2.0 r433180e WEX-WEI
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP1


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,951
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,332
NON ZERO ELEMENTS        94,445     DISCRETE VARIABLES         14


GENERATION TIME      =        0.172 SECONDS    262 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP1

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -23982.8761

 RESOURCE USAGE, LIMIT          1.031      3600.000
 ITERATION COUNT, LIMIT      5861    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.12 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.29 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 705.61 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 233.66 ticks)


Proven optimal solution
MIP Solution:       -23982.876071    (5861 iterations, 2 nodes)
Final Solve:        -23982.876071    (3148 iterations)

Best possible:      -23982.876071
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP10


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,270
NON ZERO ELEMENTS        94,294     DISCRETE VARIABLES         14


GENERATION TIME      =        0.156 SECONDS    266 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP10

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 8
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -2373.4728

 RESOURCE USAGE, LIMIT          1.016      3600.000
 ITERATION COUNT, LIMIT      6107    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.35 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.67sec (det. 765.31 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.26sec (det. 259.79 ticks)


Proven optimal solution
MIP Solution:        -2373.472849    (6107 iterations, 4 nodes)
Final Solve:         -2373.472849    (3217 iterations)

Best possible:       -2373.472849
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             2  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 9
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP11


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,883
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,270
NON ZERO ELEMENTS        94,269     DISCRETE VARIABLES         14


GENERATION TIME      =        0.187 SECONDS    269 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP11

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 10
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -2339.1325

 RESOURCE USAGE, LIMIT          1.172      3600.000
 ITERATION COUNT, LIMIT      5954    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.14 Mb (peak 13.47 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.35 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.81sec (det. 801.75 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.28sec (det. 262.87 ticks)


Proven optimal solution
MIP Solution:        -2339.132495    (5954 iterations, 3 nodes)
Final Solve:         -2339.132495    (3178 iterations)

Best possible:       -2339.132495
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 11
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP12


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,885
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,270
NON ZERO ELEMENTS        94,271     DISCRETE VARIABLES         14


GENERATION TIME      =        0.218 SECONDS    272 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP12

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 12
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -4982.2086

 RESOURCE USAGE, LIMIT          1.140      3600.000
 ITERATION COUNT, LIMIT      6150    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.14 Mb (peak 13.47 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.35 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.86sec (det. 876.94 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 270.38 ticks)


Proven optimal solution
MIP Solution:        -4982.208559    (6150 iterations, 3 nodes)
Final Solve:         -4982.208559    (3640 iterations)

Best possible:       -4982.208559
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 13
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP13


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,951
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,332
NON ZERO ELEMENTS        94,431     DISCRETE VARIABLES         14


GENERATION TIME      =        0.187 SECONDS    276 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP13

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 14
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -14989.1747

 RESOURCE USAGE, LIMIT          1.047      3600.000
 ITERATION COUNT, LIMIT      5810    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.36 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 805.13 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 251.33 ticks)


Proven optimal solution
MIP Solution:       -14989.174669    (5810 iterations, 5 nodes)
Final Solve:        -14989.174669    (3313 iterations)

Best possible:      -14989.174669
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 15
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP14


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,952
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,331
NON ZERO ELEMENTS        94,425     DISCRETE VARIABLES         14


GENERATION TIME      =        0.203 SECONDS    279 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP14

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 16
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -10329.3480

 RESOURCE USAGE, LIMIT          0.891      3600.000
 ITERATION COUNT, LIMIT      5832    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.36 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.62sec (det. 737.75 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 237.11 ticks)


Proven optimal solution
MIP Solution:       -10329.347968    (5832 iterations, 9 nodes)
Final Solve:        -10329.347968    (3128 iterations)

Best possible:      -10329.347968
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 17
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP15


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,984
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,358
NON ZERO ELEMENTS        94,500     DISCRETE VARIABLES         14


GENERATION TIME      =        0.219 SECONDS    282 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP15

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 18
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -8675.6031

 RESOURCE USAGE, LIMIT          0.922      3600.000
 ITERATION COUNT, LIMIT      6031    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.62sec (det. 665.56 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.22sec (det. 251.45 ticks)


Proven optimal solution
MIP Solution:        -8675.603078    (6031 iterations, 1 nodes)
Final Solve:         -8675.603078    (3262 iterations)

Best possible:       -8675.603078
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 19
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP16


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,984
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,359
NON ZERO ELEMENTS        94,496     DISCRETE VARIABLES         14


GENERATION TIME      =        0.250 SECONDS    286 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP16

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 20
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -14824.5117

 RESOURCE USAGE, LIMIT          0.906      3600.000
 ITERATION COUNT, LIMIT      6289    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.64sec (det. 674.29 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.19sec (det. 234.83 ticks)


Proven optimal solution
MIP Solution:       -14824.511735    (6289 iterations, 0 nodes)
Final Solve:        -14824.511735    (3248 iterations)

Best possible:      -14824.511735
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 21
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP17


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,999
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,389
NON ZERO ELEMENTS        94,543     DISCRETE VARIABLES         14


GENERATION TIME      =        0.250 SECONDS    289 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP17

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 22
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -11175.8594

 RESOURCE USAGE, LIMIT          1.203      3600.000
 ITERATION COUNT, LIMIT      5985    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.80sec (det. 782.26 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.33sec (det. 291.26 ticks)


Proven optimal solution
MIP Solution:       -11175.859431    (5985 iterations, 27 nodes)
Final Solve:        -11175.859431    (3679 iterations)

Best possible:      -11175.859431
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 23
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP18


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,994
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,387
NON ZERO ELEMENTS        94,522     DISCRETE VARIABLES         14


GENERATION TIME      =        0.250 SECONDS    292 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP18

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 24
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -18438.9285

 RESOURCE USAGE, LIMIT          1.109      3600.000
 ITERATION COUNT, LIMIT      5934    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.81sec (det. 921.50 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 287.42 ticks)


Proven optimal solution
MIP Solution:       -18438.928500    (5934 iterations, 17 nodes)
Final Solve:        -18438.928500    (3663 iterations)

Best possible:      -18438.928500
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 25
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP19


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,994
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,386
NON ZERO ELEMENTS        94,520     DISCRETE VARIABLES         14


GENERATION TIME      =        0.266 SECONDS    296 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP19

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 26
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -23644.0224

 RESOURCE USAGE, LIMIT          1.156      3600.000
 ITERATION COUNT, LIMIT      6552    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.83sec (det. 844.72 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 255.39 ticks)


Proven optimal solution
MIP Solution:       -23644.022441    (6552 iterations, 14 nodes)
Final Solve:        -23644.022441    (3389 iterations)

Best possible:      -23644.022441
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 27
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP2


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,954
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,331
NON ZERO ELEMENTS        94,452     DISCRETE VARIABLES         14


GENERATION TIME      =        0.297 SECONDS    299 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP2

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 28
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -22672.5641

 RESOURCE USAGE, LIMIT          0.890      3600.000
 ITERATION COUNT, LIMIT      6015    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.12 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.29 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.58sec (det. 607.60 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.22sec (det. 250.76 ticks)


Proven optimal solution
MIP Solution:       -22672.564140    (6015 iterations, 0 nodes)
Final Solve:        -22672.564140    (3310 iterations)

Best possible:      -22672.564140
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 29
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP20


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,994
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,386
NON ZERO ELEMENTS        94,520     DISCRETE VARIABLES         14


GENERATION TIME      =        0.282 SECONDS    302 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP20

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 30
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -22036.9306

 RESOURCE USAGE, LIMIT          0.937      3600.000
 ITERATION COUNT, LIMIT      6450    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.67sec (det. 749.17 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 256.25 ticks)


Proven optimal solution
MIP Solution:       -22036.930620    (6450 iterations, 16 nodes)
Final Solve:        -22036.930620    (3364 iterations)

Best possible:      -22036.930620
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 31
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP21


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,994
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,385
NON ZERO ELEMENTS        94,518     DISCRETE VARIABLES         14


GENERATION TIME      =        0.265 SECONDS    306 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP21

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 32
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -19018.9678

 RESOURCE USAGE, LIMIT          1.062      3600.000
 ITERATION COUNT, LIMIT      6106    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.73sec (det. 822.29 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 283.80 ticks)


Proven optimal solution
MIP Solution:       -19018.967826    (6106 iterations, 10 nodes)
Final Solve:        -19018.967826    (3802 iterations)

Best possible:      -19018.967826
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 33
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP22


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,996
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,386
NON ZERO ELEMENTS        94,524     DISCRETE VARIABLES         14


GENERATION TIME      =        0.282 SECONDS    309 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP22

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 34
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9683.8991

 RESOURCE USAGE, LIMIT          1.141      3600.000
 ITERATION COUNT, LIMIT      5992    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.77sec (det. 764.59 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.30sec (det. 279.80 ticks)


Proven optimal solution
MIP Solution:        -9683.899114    (5992 iterations, 20 nodes)
Final Solve:         -9683.899114    (3602 iterations)

Best possible:       -9683.899114
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 35
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP23


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,996
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,387
NON ZERO ELEMENTS        94,526     DISCRETE VARIABLES         14


GENERATION TIME      =        0.297 SECONDS    313 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP23

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 36
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -6715.6575

 RESOURCE USAGE, LIMIT          1.031      3600.000
 ITERATION COUNT, LIMIT      6108    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.74sec (det. 798.17 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.22sec (det. 260.66 ticks)


Proven optimal solution
MIP Solution:        -6715.657496    (6108 iterations, 5 nodes)
Final Solve:         -6715.657496    (3190 iterations)

Best possible:       -6715.657496
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 37
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP24


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,388
NON ZERO ELEMENTS        94,582     DISCRETE VARIABLES         14


GENERATION TIME      =        0.281 SECONDS    316 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP24

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 38
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -5571.6320

 RESOURCE USAGE, LIMIT          1.203      3600.000
 ITERATION COUNT, LIMIT      5926    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.83sec (det. 831.76 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 268.52 ticks)


Proven optimal solution
MIP Solution:        -5571.632046    (5926 iterations, 5 nodes)
Final Solve:         -5571.632046    (3412 iterations)

Best possible:       -5571.632046
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 39
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,390
NON ZERO ELEMENTS        94,585     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    319 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 40
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -6053.2983

 RESOURCE USAGE, LIMIT          1.032      3600.000
 ITERATION COUNT, LIMIT      5877    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.73sec (det. 746.78 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 265.80 ticks)


Proven optimal solution
MIP Solution:        -6053.298307    (5877 iterations, 5 nodes)
Final Solve:         -6053.298307    (3367 iterations)

Best possible:       -6053.298307
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 41
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP26


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,011
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,393
NON ZERO ELEMENTS        94,582     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    322 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP26

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 42
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -8940.5626

 RESOURCE USAGE, LIMIT          0.968      3600.000
 ITERATION COUNT, LIMIT      6282    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.66sec (det. 712.67 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 262.92 ticks)


Proven optimal solution
MIP Solution:        -8940.562570    (6282 iterations, 6 nodes)
Final Solve:         -8940.562570    (3310 iterations)

Best possible:       -8940.562570
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 43
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP27


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,015
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,394
NON ZERO ELEMENTS        94,597     DISCRETE VARIABLES         14


GENERATION TIME      =        0.282 SECONDS    326 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP27

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 44
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -8620.9084

 RESOURCE USAGE, LIMIT          1.015      3600.000
 ITERATION COUNT, LIMIT      5771    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 763.92 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.24sec (det. 270.93 ticks)


Proven optimal solution
MIP Solution:        -8620.908354    (5771 iterations, 6 nodes)
Final Solve:         -8620.908354    (3327 iterations)

Best possible:       -8620.908354
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 45
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP28


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,393
NON ZERO ELEMENTS        94,594     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    329 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP28

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 46
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -5174.4274

 RESOURCE USAGE, LIMIT          1.031      3600.000
 ITERATION COUNT, LIMIT      6165    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 783.61 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 258.61 ticks)


Proven optimal solution
MIP Solution:        -5174.427394    (6165 iterations, 7 nodes)
Final Solve:         -5174.427394    (3535 iterations)

Best possible:       -5174.427394
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 47
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP29


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,016
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,393
NON ZERO ELEMENTS        94,600     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    332 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP29

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 48
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -4787.1398

 RESOURCE USAGE, LIMIT          1.078      3600.000
 ITERATION COUNT, LIMIT      6345    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 751.03 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.26sec (det. 267.87 ticks)


Proven optimal solution
MIP Solution:        -4787.139827    (6345 iterations, 10 nodes)
Final Solve:         -4787.139827    (3399 iterations)

Best possible:       -4787.139827
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 49
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP3


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,297     DISCRETE VARIABLES         14


GENERATION TIME      =        0.297 SECONDS    336 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP3

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 50
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -19370.3832

 RESOURCE USAGE, LIMIT          0.922      3600.000
 ITERATION COUNT, LIMIT      6122    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.61sec (det. 639.46 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 241.70 ticks)


Proven optimal solution
MIP Solution:       -19370.383157    (6122 iterations, 0 nodes)
Final Solve:        -19370.383157    (3317 iterations)

Best possible:      -19370.383157
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 51
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP30


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,016
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,393
NON ZERO ELEMENTS        94,600     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    339 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP30

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 52
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -5495.8586

 RESOURCE USAGE, LIMIT          0.906      3600.000
 ITERATION COUNT, LIMIT      6603    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.64sec (det. 761.80 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 240.44 ticks)


Proven optimal solution
MIP Solution:        -5495.858609    (6603 iterations, 6 nodes)
Final Solve:         -5495.858609    (3175 iterations)

Best possible:       -5495.858609
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 53
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP31


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,394
NON ZERO ELEMENTS        94,596     DISCRETE VARIABLES         14


GENERATION TIME      =        0.343 SECONDS    342 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP31

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 54
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -4121.6926

 RESOURCE USAGE, LIMIT          1.156      3600.000
 ITERATION COUNT, LIMIT      6065    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.83sec (det. 811.25 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 278.04 ticks)


Proven optimal solution
MIP Solution:        -4121.692612    (6065 iterations, 6 nodes)
Final Solve:         -4121.692612    (3552 iterations)

Best possible:       -4121.692612
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 55
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP32


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,017
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,394
NON ZERO ELEMENTS        94,605     DISCRETE VARIABLES         14


GENERATION TIME      =        0.312 SECONDS    346 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP32

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 56
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9061.3729

 RESOURCE USAGE, LIMIT          1.141      3600.000
 ITERATION COUNT, LIMIT      6336    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.83sec (det. 844.14 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.23sec (det. 271.72 ticks)


Proven optimal solution
MIP Solution:        -9061.372950    (6336 iterations, 6 nodes)
Final Solve:         -9061.372950    (3534 iterations)

Best possible:       -9061.372950
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 57
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP33


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,396
NON ZERO ELEMENTS        94,600     DISCRETE VARIABLES         14


GENERATION TIME      =        0.360 SECONDS    349 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP33

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 58
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9561.1569

 RESOURCE USAGE, LIMIT          1.141      3600.000
 ITERATION COUNT, LIMIT      6613    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.75sec (det. 742.07 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.28sec (det. 270.85 ticks)


Proven optimal solution
MIP Solution:        -9561.156897    (6613 iterations, 10 nodes)
Final Solve:         -9561.156897    (3405 iterations)

Best possible:       -9561.156897
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 59
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP34


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,017
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,395
NON ZERO ELEMENTS        94,606     DISCRETE VARIABLES         14


GENERATION TIME      =        0.343 SECONDS    352 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP34

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 60
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -12054.8951

 RESOURCE USAGE, LIMIT          1.078      3600.000
 ITERATION COUNT, LIMIT      5725    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 745.64 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.30sec (det. 281.10 ticks)


Proven optimal solution
MIP Solution:       -12054.895145    (5725 iterations, 6 nodes)
Final Solve:        -12054.895145    (3435 iterations)

Best possible:      -12054.895145
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 61
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP35


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,017
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,394
NON ZERO ELEMENTS        94,605     DISCRETE VARIABLES         14


GENERATION TIME      =        0.312 SECONDS    355 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP35

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 62
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9798.2514

 RESOURCE USAGE, LIMIT          0.922      3600.000
 ITERATION COUNT, LIMIT      5978    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.64sec (det. 689.46 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 270.13 ticks)


Proven optimal solution
MIP Solution:        -9798.251385    (5978 iterations, 2 nodes)
Final Solve:         -9798.251385    (3200 iterations)

Best possible:       -9798.251385
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 63
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP36


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,010
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,391
NON ZERO ELEMENTS        94,578     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    359 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP36

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 64
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -7435.6142

 RESOURCE USAGE, LIMIT          1.000      3600.000
 ITERATION COUNT, LIMIT      5984    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 785.88 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.22sec (det. 262.60 ticks)


Proven optimal solution
MIP Solution:        -7435.614191    (5984 iterations, 3 nodes)
Final Solve:         -7435.614191    (3396 iterations)

Best possible:       -7435.614191
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 65
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP37


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       32,014
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,392
NON ZERO ELEMENTS        94,591     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    362 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP37

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 66
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -7958.8148

 RESOURCE USAGE, LIMIT          1.032      3600.000
 ITERATION COUNT, LIMIT      5983    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.38 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.66sec (det. 731.58 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.27sec (det. 283.47 ticks)


Proven optimal solution
MIP Solution:        -7958.814798    (5983 iterations, 8 nodes)
Final Solve:         -7958.814798    (3571 iterations)

Best possible:       -7958.814798
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 67
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP38


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,998
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,392
NON ZERO ELEMENTS        94,543     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    365 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP38

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 68
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9084.9659

 RESOURCE USAGE, LIMIT          1.188      3600.000
 ITERATION COUNT, LIMIT      5980    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.84sec (det. 713.93 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.27sec (det. 261.35 ticks)


Proven optimal solution
MIP Solution:        -9084.965901    (5980 iterations, 7 nodes)
Final Solve:         -9084.965901    (3375 iterations)

Best possible:       -9084.965901
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 69
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP39


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,998
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,389
NON ZERO ELEMENTS        94,538     DISCRETE VARIABLES         14


GENERATION TIME      =        0.359 SECONDS    369 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP39

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 70
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9694.9741

 RESOURCE USAGE, LIMIT          1.109      3600.000
 ITERATION COUNT, LIMIT      6255    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.73sec (det. 788.31 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.28sec (det. 274.64 ticks)


Proven optimal solution
MIP Solution:        -9694.974080    (6255 iterations, 13 nodes)
Final Solve:         -9694.974080    (3603 iterations)

Best possible:       -9694.974080
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 71
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP4


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,889
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,290     DISCRETE VARIABLES         14


GENERATION TIME      =        0.312 SECONDS    372 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP4

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 72
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -14582.8425

 RESOURCE USAGE, LIMIT          0.906      3600.000
 ITERATION COUNT, LIMIT      5561    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.53sec (det. 588.25 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.26sec (det. 255.13 ticks)


Proven optimal solution
MIP Solution:       -14582.842492    (5561 iterations, 0 nodes)
Final Solve:        -14582.842492    (3400 iterations)

Best possible:      -14582.842492
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 73
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP40


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,966
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,358
NON ZERO ELEMENTS        94,455     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    375 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP40

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 74
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -10721.1203

 RESOURCE USAGE, LIMIT          1.203      3600.000
 ITERATION COUNT, LIMIT      6044    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.86sec (det. 780.68 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.26sec (det. 274.56 ticks)


Proven optimal solution
MIP Solution:       -10721.120344    (6044 iterations, 5 nodes)
Final Solve:        -10721.120344    (3462 iterations)

Best possible:      -10721.120344
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 75
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP41


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,966
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,358
NON ZERO ELEMENTS        94,391     DISCRETE VARIABLES         14


GENERATION TIME      =        0.360 SECONDS    379 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP41

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 76
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -12870.8766

 RESOURCE USAGE, LIMIT          1.047      3600.000
 ITERATION COUNT, LIMIT      6092    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.69sec (det. 704.88 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.28sec (det. 262.02 ticks)


Proven optimal solution
MIP Solution:       -12870.876580    (6092 iterations, 4 nodes)
Final Solve:        -12870.876580    (3257 iterations)

Best possible:      -12870.876580
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 77
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP42


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,966
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,360
NON ZERO ELEMENTS        94,393     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    382 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP42

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 78
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -11995.0378

 RESOURCE USAGE, LIMIT          1.094      3600.000
 ITERATION COUNT, LIMIT      6261    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.49 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.74sec (det. 701.47 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.30sec (det. 269.16 ticks)


Proven optimal solution
MIP Solution:       -11995.037760    (6261 iterations, 6 nodes)
Final Solve:        -11995.037760    (3494 iterations)

Best possible:      -11995.037760
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 79
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP43


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,965
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,362
NON ZERO ELEMENTS        94,468     DISCRETE VARIABLES         14


GENERATION TIME      =        0.391 SECONDS    385 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP43

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 80
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -14248.6044

 RESOURCE USAGE, LIMIT          1.437      3600.000
 ITERATION COUNT, LIMIT      6032    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.16 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 1.09sec (det. 1031.35 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 272.65 ticks)


Proven optimal solution
MIP Solution:       -14248.604375    (6032 iterations, 6 nodes)
Final Solve:        -14248.604375    (3634 iterations)

Best possible:      -14248.604375
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 81
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP44


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,986
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,364
NON ZERO ELEMENTS        94,533     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    389 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP44

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 82
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -11718.3469

 RESOURCE USAGE, LIMIT          0.875      3600.000
 ITERATION COUNT, LIMIT      6240    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.50sec (det. 529.07 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.26sec (det. 266.97 ticks)


Proven optimal solution
MIP Solution:       -11718.346931    (6240 iterations, 0 nodes)
Final Solve:        -11718.346931    (3584 iterations)

Best possible:      -11718.346931
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 83
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP45


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,987
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,363
NON ZERO ELEMENTS        94,538     DISCRETE VARIABLES         14


GENERATION TIME      =        0.391 SECONDS    392 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP45

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 84
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -11331.7174

 RESOURCE USAGE, LIMIT          1.031      3600.000
 ITERATION COUNT, LIMIT      6184    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 751.38 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 250.41 ticks)


Proven optimal solution
MIP Solution:       -11331.717445    (6184 iterations, 6 nodes)
Final Solve:        -11331.717445    (3229 iterations)

Best possible:      -11331.717445
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 85
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP46


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,985
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,366
NON ZERO ELEMENTS        94,538     DISCRETE VARIABLES         14


GENERATION TIME      =        0.391 SECONDS    395 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP46

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 86
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -8645.0505

 RESOURCE USAGE, LIMIT          1.078      3600.000
 ITERATION COUNT, LIMIT      6254    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.20 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.17 Mb (peak 13.50 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.37 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.72sec (det. 655.48 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.28sec (det. 288.38 ticks)


Proven optimal solution
MIP Solution:        -8645.050488    (6254 iterations, 3 nodes)
Final Solve:         -8645.050488    (3600 iterations)

Best possible:       -8645.050488
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 87
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP47


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,922
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,304
NON ZERO ELEMENTS        94,323     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    399 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP47

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 88
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -6830.1645

 RESOURCE USAGE, LIMIT          0.922      3600.000
 ITERATION COUNT, LIMIT      6609    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.36 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.64sec (det. 699.74 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.19sec (det. 246.32 ticks)


Proven optimal solution
MIP Solution:        -6830.164510    (6609 iterations, 3 nodes)
Final Solve:         -6830.164510    (3420 iterations)

Best possible:       -6830.164510
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 89
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP48


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,923
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,304
NON ZERO ELEMENTS        94,390     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    402 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP48

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 90
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -16524.0857

 RESOURCE USAGE, LIMIT          1.047      3600.000
 ITERATION COUNT, LIMIT      6232    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.19 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.36 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.72sec (det. 798.98 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 264.44 ticks)


Proven optimal solution
MIP Solution:       -16524.085680    (6232 iterations, 2 nodes)
Final Solve:        -16524.085680    (3494 iterations)

Best possible:      -16524.085680
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 91
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP5


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,296     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    405 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP5

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 92
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -9188.2820

 RESOURCE USAGE, LIMIT          1.015      3600.000
 ITERATION COUNT, LIMIT      6122    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.74sec (det. 707.79 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 254.17 ticks)


Proven optimal solution
MIP Solution:        -9188.281961    (6122 iterations, 1 nodes)
Final Solve:         -9188.281961    (3275 iterations)

Best possible:       -9188.281961
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 93
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP6


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,296     DISCRETE VARIABLES         14


GENERATION TIME      =        0.313 SECONDS    409 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP6

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 94
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -4752.7737

 RESOURCE USAGE, LIMIT          0.953      3600.000
 ITERATION COUNT, LIMIT      5899    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.59sec (det. 565.03 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.31sec (det. 277.83 ticks)


Proven optimal solution
MIP Solution:        -4752.773686    (5899 iterations, 0 nodes)
Final Solve:         -4752.773686    (3390 iterations)

Best possible:       -4752.773686
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 95
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP7


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,296     DISCRETE VARIABLES         14


GENERATION TIME      =        0.328 SECONDS    412 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP7

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 96
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -3463.4627

 RESOURCE USAGE, LIMIT          0.765      3600.000
 ITERATION COUNT, LIMIT      5736    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.49sec (det. 541.31 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 246.54 ticks)


Proven optimal solution
MIP Solution:        -3463.462699    (5736 iterations, 0 nodes)
Final Solve:         -3463.462699    (3226 iterations)

Best possible:       -3463.462699
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             3  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 97
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP8


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,296     DISCRETE VARIABLES         14


GENERATION TIME      =        0.375 SECONDS    415 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP8

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 98
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -2374.5165

 RESOURCE USAGE, LIMIT          0.782      3600.000
 ITERATION COUNT, LIMIT      5793    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.50sec (det. 585.40 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 254.48 ticks)


Proven optimal solution
MIP Solution:        -2374.516457    (5793 iterations, 0 nodes)
Final Solve:         -2374.516457    (3362 iterations)

Best possible:       -2374.516457
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 99
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 6835


LOOPS                            FOR/WHILE   1
                                        tp   TP9


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,891
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,271
NON ZERO ELEMENTS        94,296     DISCRETE VARIABLES         14


GENERATION TIME      =        0.344 SECONDS    419 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp TP9

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 100
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 6835


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  6835

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -2731.0497

 RESOURCE USAGE, LIMIT          0.766      3600.000
 ITERATION COUNT, LIMIT      5698    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\vSPD_v3.1.0\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 4.11 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.15 Mb (peak 13.48 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 7.28 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.49sec (det. 582.40 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.20sec (det. 279.96 ticks)


Proven optimal solution
MIP Solution:        -2731.049653    (5698 iterations, 0 nodes)
Final Solve:         -2731.049653    (3567 iterations)

Best possible:       -2731.049653
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 10/17/22 13:54:21 Page 101
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog C:\vSPD\vSPD_v3.1.0\Programs\ProgressReport.txt
temp C:\vSPD\vSPD_v3.1.0\Programs\temp.put
SystemResults C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_SystemResults.csv
OfferResults C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_OfferResults.csv
TraderResults C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_TraderResults.csv
SummaryResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_SummaryResults_TP.csv
IslandResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_IslandResults_TP.csv
BusResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_BusResults_TP.csv
NodeResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_NodeResults_TP.csv
OfferResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_OfferResults_TP.csv
ReserveResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_ReserveResults_TP.csv
BranchResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_BranchResults_TP.csv
BrCstrResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_BrConstraintResults_TP.csv
MnodeCstrResults_TP C:\vSPD\vSPD_v3.1.0\Output\Test_Run_All\Test_Run_All_MnodeConstraintResults_TP.csv


EXECUTION TIME       =       84.579 SECONDS    426 MB  36.2.0 r433180e WEX-WEI


USER: Single User License                            G210922|0002CO-GEN
      Electricity Authority - Te Mana Hiko,                   DC5643-S4


**** FILE SUMMARY

Restart    C:\vSPD\vSPD_v3.1.0\Programs\vSPDmodel.g00
Input      C:\vSPD\vSPD_v3.1.0\Programs\vSPDsolve.gms
Output     C:\vSPD\vSPD_v3.1.0\Programs\vSPDsolve.lst
