GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


2678  *=====================================================================================
2679  * Name:                 vSPDsolve.gms
2680  * Function:             Establish base case and override data, prepare data, and solve
2681  *                       the model
2682  * Developed by:         Electricity Authority, New Zealand
2683  * Source:               https://github.com/ElectricityAuthority/vSPD
2684  *                       http://www.emi.ea.govt.nz/Tools/vSPD
2685  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
2686  *                       Email: emi@ea.govt.nz
2687  * Modified on:          1 Oct 2019
2688  *                       New feature added: new wind offer arrangements
2689  * Modified on:          11 Nov 2020
2690  *                       Replacing invalid bus prices after SOS1 (6.1.3)
2691  * Last modified on:     11 Dec 2020
2692  *                       From 11 Dec 2020, GDX input file have i_tradePeriodBranchCapacityDirected
2693  *                       and i_tradePeriodReverseRatingsApplied symbols
2694  *                       Applying branch reverse rating  s only when i_tradePeriodReverseRatingsApplied = 1
2695  * Last modified on:     27 June 2021
2696  *                       Fixing the bug that remove HVDC because of zero  reverse rating limits
2697   
2698  *=====================================================================================
2699   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file f
        3. Manage model and data compatability
        4. Input data overrides - declare and apply (include vSPDoverrides.gms)
        5. Initialise constraint violation penalties (CVPs)
        6. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        7. vSPD scarcity pricing post-processing
        8. Write results to CSV report files and GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr            i_scarcityArea = sarea
        i_reserveType = resT                      i_reserveClass = resC
        i_riskClass = riskC                       i_constraintRHS = CstrRHS
        i_riskParameter = riskPar                 i_offerParam = offerPar
        i_dczone = z,z1,rrz,rrz1                  i_riskGroup = rg,rg1)
2738   
2739   
2740  * Include paths, settings and case name files
INCLUDE    C:\vSPD\GitHub\Programs\vSPDsettings.inc
2742  *+++ vSPD settings +++
2745   
2746  *+++ Paths +++
2750  *$setglobal inputPath                     'A:\Tuong Nguyen\vSPD_Inputs\FP\'
2753   
2755   
2756   
2757  *+++ Model +++
2758  Scalar sequentialSolve                   / 0 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2759  Scalar disconnectedNodePriceCorrection   / 1 / ;
2760  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2761   
2762   
2763  *+++ Network +++
2764  Scalar useACLossModel                    / 1 / ;
2765  Scalar useHVDCLossModel                  / 1 / ;
2766  Scalar useACBranchLimits                 / 1 / ;
2767  Scalar useHVDCBranchLimits               / 1 / ;
2768  Scalar resolveCircularBranchFlows        / 1 / ;
2769  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2770  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2771  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2772  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2773  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2774   
2775   
2776  *+++ Constraints +++
2777  Scalar useReserveModel                   / 1 / ;
2778  Scalar suppressMixedConstraint           / 0 / ;
2779  Scalar mixedMIPtolerance                 / 0.000001 / ;
2780   
2781   
2782  *+++ Solver +++
2783  Scalar LPtimeLimit                       / 3600 / ;
2784  Scalar LPiterationLimit                  / 2000000000 / ;
2785  Scalar MIPtimeLimit                      / 3600 / ;
2786  Scalar MIPiterationLimit                 / 2000000000 / ;
2787  Scalar MIPoptimality                     / 0 / ;
2790   
2791   
2792  *+++ Various switches +++
2795   
INCLUDE    C:\vSPD\GitHub\Programs\vSPDcase.inc
2800  tradePeriodReports = 1 ;
2801   
2802   
2803  * Update the runlog file
2804  File runlog "Write to a report"  / "ProgressReport.txt" /;
2805  runlog.lw = 0 ; runlog.ap = 1 ;
2806  putclose runlog / 'Case "RTD_20211202_RTP" started at: '
2807                    system.date " " system.time /;
2808  if(sequentialSolve,
2809    putclose runlog 'Vectorisation is switched OFF' /;
2810  else
2811    putclose runlog 'Vectorisation is switched ON' /;
2812  ) ;
2813   
2814  * Set the solver for the LP and MIP
2815  option lp = Cplex ;
2816  option mip = Cplex ;
2817   
2818  * Set profile status
2819  option profile = 0 ;
2820   
2821  * Set the solution print status in the lst file
2822  option solprint = off;
2823   
2824  * Set the column (variable) and row (equation) listing in the lst file
2825  option limcol = 0 ;
2826  option limrow = 0 ;
2827   
2828  * Allow empty data set declaration
2830   
2831  * Declare a temporary file
2832  File temp ;
2833   
2834  *=====================================================================================
2835  * 1. Declare symbols and initialise some of them
2836  *=====================================================================================
2837   
2838  Sets
2839  * Initialise fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2840    i_island                    / NI, SI /
2841    i_reserveClass              / FIR, SIR /
2842   
       Scarcity pricing updates --> i_reserveType
       Rather than include an additional reserve type element an additional virutal
       reserve paramter and associated variable is created. This is more efficient
       implementation in terms of the problem size as all other reserve providers
       are indexed on i_reserveType which would include an additional index on all
       these variables thus increasing the problem size. This increase would then
       need additional pre-processing to fix variables to zero. To avoid this and
       keep the problem size small the additional virtual reserve variable is included.
2853    i_reserveType               / PLSR, TWDR, ILR /
2854   
2855    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2856                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2857    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2858    i_offerType                 / energy, PLSR, TWDR, ILR /
2859    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2860                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW,
2861                                  i_IsPriceResponse, i_PotentialMW  /
2862    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2863    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2864    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2865    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2866    i_energyBidComponent        / i_bidMW, i_bidPrice /
2867    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2868    i_tradeBlock                / t1*t20 /
2869    i_lossSegment               / ls1*ls13 /
2870    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2871    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2872    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2873    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2874    i_flowDirection             / forward, backward /
2875    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2876                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2877                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2878                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2879                                  i_deficitRampRate, i_surplusRampRate
2880                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2881                                  i_deficitBranchFlow, i_surplusBranchFlow
2882                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2883                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2884                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2885   
2886  * Initialise the set called pole
2887    pole  'HVDC poles'          / pole1, pole2 /
2888   
2889  * Scarcity pricing updates
2890    i_scarcityArea              /NI, SI, National/
2891   
2892  * NMIR - HVDC flow zones for reverse reserve sharing
2893    i_dczone                    /RP, NR, RZ/
2894   
2895    ;
2896   
2897   
2898   
2899  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2900  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2901   
2902  Sets
2903    scarcityAreaIslandMap(sarea,ild)                    'Mapping of scarcity area to island'
2904    unsolvedPeriod(tp)                                  'Set of periods that are not solved yet'
2905  * Unmmaped bus defificit temporary sets
2906    unmappedDeficitBus(dt,b)                            'List of buses that have deficit generation (price) and are not mapped to any pnode'
2907    changedDeficitBus(dt,b)                             'List of buses that have deficit generation added from unmapped deficit bus'
2908  * TN - Replacing invalid prices after SOS1
2909    vSPD_SOS1_Solve(tp)                                 'Flag period that is resolved using SOS1'
2910    ;
2911   
2912  Parameters
2913  * Flag to apply corresponding vSPD model
2914    VSPDModel(tp)                                       '0=VSPD, 1=VSPD_MIP, 2=vSPD_BranchFlowMIP, 3=vSPD_MixedConstraintMIP, 4=VSPD (last solve)'
2915  * Main iteration counter
2916    iterationCount                                      'Iteration counter for the solve'
2917  * MIP logic
2918    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2919  * Introduce flag to detect circular branch flows on each HVDC pole
2920    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2921    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2922    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2923    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2924    manualBranchSegmentMWFlow(tp,br,los,fd)             'Manual calculation of the branch loss segment MW flow'
2925    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2926    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2927    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2928  * Parameters to calculate circular branch flow on each HVDC pole
2929    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2930    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2931  * Disconnected bus post-processing
2932    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2933    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2934    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2935    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2936  * Scarcity pricing processing parameters
2937    scarcitySituation(tp,sarea)                         'Flag to indicate that a scarcity situation exists (1 = Yes)'
2938    GWAPFloor(tp,sarea)                                 'Floor price for the scarcity situation in scarcity area'
2939    GWAPCeiling(tp,sarea)                               'Ceiling price for the scarcity situation in scarcity area'
2940    GWAPPastDaysAvg(tp,ild)                             'Average GWAP over past days - number of periods in GWAP count'
2941    GWAPCountForAvg(tp,ild)                             'Number of periods used for the i_gwapPastDaysAvg'
2942    GWAPThreshold(tp,ild)                               'Threshold on previous 336 trading period GWAP - cumulative price threshold'
2943    islandGWAP(tp,ild)                                  'Island GWAP calculation used to update GWAPPastDaysAvg'
2944    scarcityAreaGWAP(tp,sarea)                          'Scarcity area GWAP used to calculate the scaling factor'
2945    pastGWAPsumforCPT(tp,ild)
2946    pastTPcntforCPT(tp,ild)
2947    currentDayGWAPsumforCPT(ild)
2948    currentDayTPsumforCPT(ild)
2949    avgPriorGWAP(tp,ild)
2950    cptIslandPassed(tp,sarea)
2951    cptPassed(tp,sarea)
2952    cptIslandReq(sarea)
2953    scarcityScalingFactor(tp,sarea)
2954    scaledbusPrice(tp,b)
2955    scalednodePrice(tp,n)
2956    scaledFIRprice(tp,ild)
2957    scaledSIRprice(tp,ild)
2958    scaledislandGWAP(tp,ild)
2959    scaledscarcityAreaGWAP(tp,sarea)
2960  * Unmmaped bus defificit temporary parameters
2961    temp_busDeficit_TP(dt,b) 'Bus deficit violation for each trade period'
2962  * TN - Replacing invalid prices after SOS1
2963    busSOSinvalid(tp,b)                                 'Buses with invalid bus prices after SOS1 solve'
2964    numberofbusSOSinvalid(tp)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration) '
2965  * TN - Flag to apply branch reverse ratings
2966    reverseRatingsApplied(tp)
2967    ;
2968   
2969  Sets
2970  * Dispatch results reporting
2971    o_fromDateTime(dt)                                  'Start period for summary reports'
2972    o_dateTime(dt)                                      'Date and time for reporting'
2973    o_bus(dt,b)                                         'Set of buses for output report'
2974    o_offer(dt,o)                                       'Set of offers for output report'
2975    o_bid(dt,bd)                                        'Set of bids for output report'
2976    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2977    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2978    o_trader(trdr)                                      'Set of traders for trader summary output report'
2979    o_node(dt,n)                                        'Set of nodes for output report'
2980    o_branch(dt,br)                                     'Set of branches for output report'
2981    o_HVDClink(dt,br)                                   'HVDC links (branches) defined for the current trading period'
2982    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2983    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2984    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2985    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2986  * Audit - extra output declaration
2987    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2988    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2989    ;
2990   
2991  Parameters
2992  * Dispatch results for reporting - Trade period level - Island output
2993    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2994    o_islandLoad_TP(dt,ild)                             'Island MW fixed load for the different time periods'
2995    o_islandClrBid_TP(dt,ild)                           'Island cleared MW bid for the different time periods'
2996    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2997    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2998    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2999    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
3000    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
3001    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
3002    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
3003    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
3004    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
3005    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
3006    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
3007    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
3008    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
3009    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
3010    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
3011    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
3012    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
3013    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
3014    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
3015    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
3016    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
3017    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
3018    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
3019    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
3020    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
3021    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
3022    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
3023    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
3024    o_ACbranchTotalRentals(dt)                          'Total AC rental by trading period for reporting'
3025    o_ACbranchLossMW(dt,br,los)                         'MW element of the loss segment curve in MW'
3026    o_ACbranchLossFactor(dt,br,los)                     'Loss factor element of the loss segment curve'
3027    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
3028    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
3029    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
3030    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
3031    o_offerEnergyBlock_TP(dt,o,trdBlk)                  'Output MW cleared for each energy offer for each trade period'
3032    o_offerFIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for FIR for each trade period'
3033    o_offerSIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for SIR for each trade period'
3034    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
3035    o_bidFIR_TP(dt,bd)                                  'Output MW cleared for FIR for each trade period'
3036    o_bidSIR_TP(dt,bd)                                  'Output MW cleared for SIR for each trade period'
3037    o_ReserveReqd_TP(dt,ild,resC)                       'Output MW required for each reserve class in each trade period'
3038    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
3039    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
3040    o_ResCleared_TP(dt,ild,resC)                        'Reserve cleared from an island for each trade period'
3041    o_FIRcleared_TP(dt,ild)                             'Output - total FIR cleared by island'
3042    o_SIRcleared_TP(dt,ild)                             'Output - total SIR cleared by island'
3043    o_ResPrice_TP(dt,ild,resC)                          'Output $/MW price for each reserve classes for each trade period'
3044    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
3045    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
3046    o_ResViolation_TP(dt,ild,resC)                      'Violation MW for each reserve classes for each trade period'
3047    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
3048    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
3049    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
3050    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
3051    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
3052    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
3053    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
3054    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
3055    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
3056  * Security constraint data
3057    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
3058    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
3059    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
3060    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
3061  * Mnode constraint data
3062    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
3063    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
3064    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
3065    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
3066  * TradePeriod summary report
3067    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
3068    o_systemCost_TP(dt)                                 'System cost for summary report'
3069    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
3070    o_ofv_TP(dt)                                        'Objective function value for summary report'
3071    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
3072    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
3073    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
3074    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
3075    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
3076    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
3077    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
3078    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
3079    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
3080    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
3081    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
3082    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
3083    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
3084    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
3085    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
3086    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
3087    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
3088    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
3089  * System level
3090    o_numTradePeriods                                   'Output number of trade periods in summary'
3091    o_systemOFV                                         'System objective function value'
3092    o_systemGen                                         'Output system MWh generation'
3093    o_systemLoad                                        'Output system MWh load'
3094    o_systemLoss                                        'Output system MWh loss'
3095    o_systemViolation                                   'Output system MWh violation'
3096    o_systemFIR                                         'Output system FIR MWh reserve'
3097    o_systemSIR                                         'Output system SIR MWh reserve'
3098    o_systemEnergyRevenue                               'Output offer energy revenue $'
3099    o_systemReserveRevenue                              'Output reserve revenue $'
3100    o_systemLoadCost                                    'Output system load cost $'
3101    o_systemLoadRevenue                                 'Output system load revenue $'
3102    o_systemSurplus                                     'Output system surplus $'
3103  * Offer level
3104    o_offerGen(o)                                       'Output offer generation (MWh)'
3105    o_offerFIR(o)                                       'Output offer FIR (MWh)'
3106    o_offerSIR(o)                                       'Output offer SIR (MWh)'
3107    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
3108    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
3109    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
3110  * Trader level
3111    o_traderGen(trdr)                                   'Output trader generation (MWh)'
3112    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
3113    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
3114    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
3115    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
3116    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
3117  * Factor to prorate the deficit and surplus at the nodal level
3118    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
3119    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
3120  * Introduce i_useBusNetworkModel to account for MSP change-over date.
3121    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
3122  * Virtual reserve output
3123    o_vrResMW_TP(dt,ild,resC)                           'MW scheduled from virtual reserve resource'
3124    o_FIRvrMW_TP(dt,ild)                                'MW scheduled from virtual FIR resource'
3125    o_SIRvrMW_TP(dt,ild)                                'MW scheduled from virtual SIR resource'
3126  * Scarcity pricing output
3127    o_scarcityExists_TP(dt,ild)
3128    o_cptPassed_TP(dt,ild)
3129    o_avgPriorGWAP_TP(dt,ild)
3130    o_islandGWAPbefore_TP(dt,ild)
3131    o_islandGWAPafter_TP(dt,ild)
3132    o_scarcityGWAPbefore_TP(dt,ild)
3133    o_scarcityGWAPafter_TP(dt,ild)
3134    o_scarcityScalingFactor_TP(dt,ild)
3135    o_GWAPthreshold_TP(dt,ild)
3136    o_GWAPfloor_TP(dt,ild)
3137    o_GWAPceiling_TP(dt,ild)
3138  * Audit - extra output declaration
3139    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
3140    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
3141    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
3142    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
3143    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
3144    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
3145    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
3146    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
3147    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
3148    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
3149    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
3150    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
3151    o_generationRiskLevel(dt,ild,o,resC,riskC)                    'Audit - generation risk'
3152    o_generationRiskPrice(dt,ild,o,resC,riskC)                    'Audit - generation risk shadow price'
3153    o_HVDCriskLevel(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk'
3154    o_HVDCriskPrice(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk shadow price'
3155    o_manuRiskLevel(dt,ild,resC,riskC)                            'Audit - manual risk'
3156    o_manuRiskPrice(dt,ild,resC,riskC)                            'Audit - manual risk shadow price'
3157    o_genHVDCriskLevel(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
3158    o_genHVDCriskPrice(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk shadow price'
3159    o_manuHVDCriskLevel(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary'
3160    o_manuHVDCriskPrice(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary shadow price'
3161    o_generationRiskGroupLevel(dt,ild,rg,resC,riskC)                 'Audit - generation group risk'
3162    o_generationRiskGroupPrice(dt,ild,rg,resC,riskC)                 'Audit - generation group risk shadow price'
3163  * TN - output parameters added for NMIR project --------------------------------
3164    o_FirSent_TP(dt,ild)                        'FIR export from an island for each trade period'
3165    o_SirSent_TP(dt,ild)                        'SIR export from an island for each trade period'
3166    o_FirReceived_TP(dt,ild)                    'FIR received at an island for each trade period'
3167    o_SirReceived_TP(dt,ild)                    'SIR received at an island for each trade period'
3168    o_FirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3169    o_SirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3170    o_EffectiveRes_TP(dt,ild,resC,riskC)        'Effective reserve share to an island for each trade period'
3171    o_FirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3172    o_SirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3173  * TN - output parameters added for NMIR project end ----------------------------
3174    ;
3175   
3176  Scalars
3177    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
3178    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
3179  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
3180    useExtendedRiskClass          'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
3181  * Scarcity pricing
3182    scarcityExists                'Flag to indicate that a scarcity situation exists for at least 1 trading period in the solve'
3183    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
3184    ;
3185   
3186   
3187   
3188  *=====================================================================================
3189  * 2. Load data from GDX file
3190  *=====================================================================================
3191   
3192  * If input file does not exist then go to the next input file
3194   
3195  * Load trading period to be solved
3196  * If scarcity pricing situation exists --> load and solve all trading periods
GDXIN   C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
--- LOAD  i_tradePeriod = 1:i_TradePeriod
--- LOAD  i_dateTime = 2:i_DateTime
3202   
3203   
3204  * Call the GDX routine and load the input data:
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
3206  * Sets
--- LOAD  i_offer = 84:i_Offer
--- LOAD  i_trader = 83:i_Trader
--- LOAD  i_bid = 101:i_bid
--- LOAD  i_node = 15:i_node
--- LOAD  i_bus = 16:i_bus
--- LOAD  i_branch = 32:i_branch
--- LOAD  i_branchConstraint = 42:i_branchConstraint
--- LOAD  i_ACnodeConstraint = 45:i_ACnodeConstraint
--- LOAD  i_MnodeConstraint = 48:i_MnodeConstraint
--- LOAD  i_genericConstraint = 54:i_genericConstraint
--- LOAD  i_type1MixedConstraint = 63:i_type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 78:i_type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 7:i_dateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 90:i_tradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 91:i_tradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 104:i_tradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 105:i_tradePeriodBidNode
--- LOAD  i_tradePeriodNode = 17:i_tradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 19:i_tradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 18:i_tradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 20:i_tradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 33:i_tradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 115:i_tradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 64:i_type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 65:i_tradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 79:i_tradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 66:i_type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 55:i_tradePeriodGenericConstraint
3213  * Parameters
--- LOAD  i_day = 2:i_day
--- LOAD  i_month = 3:i_month
--- LOAD  i_year = 4:i_year
--- LOAD  i_tradingPeriodLength = 10:i_tradingPeriodLength
--- LOAD  i_AClineUnit = 9:i_AClineUnit
--- MERGE i_branchReceivingEndLossProportion = 11:i_branchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 8:i_studyTradePeriod
--- LOAD  i_CVPvalues = 13:i_CVPvalues
--- LOAD  i_tradePeriodOfferParameter = 92:i_tradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 93:i_tradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 94:i_tradePeriodSustainedPLSRoffer
--- LOAD  i_tradePeriodFastPLSRoffer = 95:i_tradePeriodFastPLSRoffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 96:i_tradePeriodSustainedTWDRoffer
--- LOAD  i_tradePeriodFastTWDRoffer = 97:i_tradePeriodFastTWDRoffer
--- LOAD  i_tradePeriodSustainedILRoffer = 98:i_tradePeriodSustainedILRoffer
--- LOAD  i_tradePeriodFastILRoffer = 99:i_tradePeriodFastILRoffer
--- LOAD  i_tradePeriodNodeDemand = 110:i_tradePeriodNodeDemand
--- LOAD  i_tradePeriodEnergyBid = 106:i_tradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 107:i_tradePeriodSustainedILRbid
--- LOAD  i_tradePeriodFastILRbid = 108:i_tradePeriodFastILRbid
--- LOAD  i_tradePeriodHVDCNode = 23:i_tradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 24:i_tradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 34:i_tradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 35:i_tradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 36:i_tradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 38:i_tradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 27:i_noLossBranch
--- LOAD  i_AClossBranch = 28:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 29:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 21:i_tradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 22:i_tradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 116:i_tradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 117:i_tradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 43:i_tradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 44:i_tradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 46:i_tradePeriodACnodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 47:i_tradePeriodACnodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 49:i_tradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 50:i_tradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 51:i_tradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 52:i_tradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 53:i_tradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 67:i_type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 69:i_type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 70:i_type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 71:i_type1MixedConstraintHVDClineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 72:i_tradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 80:i_type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 81:i_tradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 56:i_tradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 57:i_tradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 58:i_tradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 59:i_tradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 60:i_tradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 61:i_tradePeriodGenericConstraintRHS
3227   
3228  * New risk group sets
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
--- LOAD  i_riskGroup = 147:i_riskGroup
--- LOAD  riskGroupOffer = 145:i_tradePeriodRiskGroup
3234   
3235   
3236  *=====================================================================================
3237  * 3. Manage model and data compatability
3238  *=====================================================================================
3239   
3240  * This section manages the changes to model flags to ensure backward compatibility
3241  * given changes in the SPD model formulation over time:
3242  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
3243  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
3244   
3245  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
3246  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
3247   
3248  * Calculate the Gregorian date of the input data
3249  inputGDXGDate = jdate(i_year,i_month,i_day) ;
3250   
3251  * Introduce i_useBusNetworkModel to account for MSP change-over date when for
3252  * half of the day the old market node model and the other half the bus network
3253  * model was used. The old model does not have the i_tradePeriodBusElectrical
3254  * island paramter specified since it uses the market node network model.
3255  * This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter
3256  * to be used in the post-MSP solves to indentify 'dead' electrical buses.
3257  * MSP change over from mid-day on 21 Jul 2009
3258  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= jdate(2009,7,21) ) and
3259                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
3260                                 } ;
3261   
3262  * Switch off the mixed constraint based risk offset calculation after 17 October 2011
3263  useMixedConstraintRiskOffset = 1 $ { inputGDXGDate < jdate(2011,10,17) } ;
3264   
3265  * Switch off mixed constraint formulation if no data coming through
3266  * or mixed constraint is suppressed manually in vSPDsetting.inc
3267  useMixedConstraint(tp)
3268      = 1 $ { sum[t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1]
3269          and (suppressMixedConstraint = 0) } ;
3270   
3271  put_utility temp 'gdxin' / 'C:\vSPD\GitHub\Programs\..\Input\\RTD_20211202_RTP.gdx' ;
3272   
3273  * Primary secondary offer in use from 01 May 2012'
3274  if(inputGDXGDate >= jdate(2012,05,01),
3275      execute_load i_tradePeriodPrimarySecondaryOffer ;
3276  else
3277      i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
3278  ) ;
3279   
3280  * Change to demand bid on 28 Jun 2012
3281  useDSBFDemandBidModel = 1 $ { inputGDXGDate >= jdate(2012,6,28) } ;
3282   
3283  * Manual ECE risk parameters in use from 20 Sep 2012
3284  if(inputGDXGDate >= jdate(2012,9,20),
3285      execute_load i_tradePeriodManualRisk_ECE ;
3286  else
3287      i_tradePeriodManualRisk_ECE(tp,ild,resC) = 0 ;
3288  ) ;
3289   
3290  * HVDC secondary risk parameters in use from 20 Sep 2012
3291  if(inputGDXGDate >= jdate(2012,9,20),
3292      execute_load i_tradePeriodHVDCsecRiskEnabled
3293                   i_tradePeriodHVDCsecRiskSubtractor ;
3294  else
3295      i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC) = 0 ;
3296      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
3297  ) ;
3298   
3299  * Do not use the extended risk class if no data coming through
3300  useExtendedRiskClass
3301      = 1 $ { sum[ (tp,ild,resC,riskC,riskPar) $ (ord(riskC) > 4)
3302                 , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] };
3303   
3304  * HVDC round power mode in use from 20 Sep 2012
3305  if(inputGDXGDate >= jdate(2012,9,20),
3306      execute_load i_tradePeriodAllowHVDCroundpower ;
3307  else
3308      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
3309  ) ;
3310   
3311  * Additional mixed constraint parameters exist from 24 Feb 2013
3312   
3313  if(inputGDXGDate >= jdate(2013,2,24),
3314      execute_load i_type1MixedConstraintAClineWeight
3315                   i_type1MixedConstraintAClineLossWeight
3316                   i_type1MixedConstraintAClineFixedLossWeight
3317                   i_type1MixedConstraintHVDClineLossWeight
3318                   i_type1MixedConstraintHVDClineFixedLossWeight
3319                   i_type1MixedConstraintPurWeight ;
3320  else
3321      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
3322      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
3323      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
3324      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
3325      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
3326      i_type1MixedConstraintPurWeight(t1MixCstr,bd) = 0 ;
3327  ) ;
3328   
3329  *  Reserve class generation parameter in use from 24 Feb 2013
3330  if(inputGDXGDate >= jdate(2013,2,24),
3331      execute_load i_tradePeriodReserveClassGenerationMaximum ;
3332  else
3333      i_tradePeriodReserveClassGenerationMaximum(tp,o,resC) = 0 ;
3334  ) ;
3335   
3336  * Primary secondary risk model in use from 24 Feb 2013
3337  usePrimSecGenRiskModel = 1 $ { inputGDXGDate >= jdate(2013,2,24) } ;
3338   
3339  * Dispatchable Demand effective date 20 May 2014
3340  if(inputGDXGDate >= jdate(2014,5,20),
3341      execute_load i_tradePeriodDispatchableBid;
3342  else
3343      i_tradePeriodDispatchableBid(tp,bd) =  Yes $ useDSBFDemandBidModel ;
3344  ) ;
3345  * MODD modification end
3346   
3347  * Scarcity pricing scheme for reserve available from 27 May 2014
3348  if(inputGDXGDate >= jdate(2014,5,27),
3349      execute_load i_tradePeriodVROfferMax, i_tradePeriodVROfferPrice ;
3350  else
3351      i_tradePeriodVROfferMax(tp,ild,resC) = 0 ;
3352      i_tradePeriodVROfferPrice(tp,ild,resC) = 0 ;
3353  ) ;
3354   
3355   
3356  * National market for IR effective date 20 Oct 2016
3357  if (inputGDXGDate >= jdate(2016,10,20),
3358      execute_load
3359      reserveRoundPower     = i_tradePeriodReserveRoundPower
3360      reserveShareEnabled   = i_tradePeriodReserveSharing
3361      modulationRiskClass   = i_tradePeriodModulationRisk
3362      roundPower2MonoLevel  = i_tradePeriodRoundPower2Mono
3363      bipole2MonoLevel      = i_tradePeriodBipole2Mono
3364      monopoleMinimum       = i_tradePeriodReserveSharingPoleMin
3365      HVDCControlBand       = i_tradePeriodHVDCcontrolBand
3366      HVDClossScalingFactor = i_tradePeriodHVDClossScalingFactor
3367      sharedNFRfactor       = i_tradePeriodSharedNFRfactor
3368      sharedNFRLoadOffset   = i_tradePeriodSharedNFRLoadOffset
3369      effectiveFactor       = i_tradePeriodReserveEffectiveFactor
3370      RMTreserveLimitTo     = i_tradePeriodRMTreserveLimit
3371      rampingConstraint     = i_tradePeriodRampingConstraint
3372    ;
3373  else
3374      reserveRoundPower(tp,resC)         = 0    ;
3375      reserveShareEnabled(tp,resC)       = 0    ;
3376      modulationRiskClass(tp,riskC)      = 0    ;
3377      roundPower2MonoLevel(tp)           = 0    ;
3378      bipole2MonoLevel(tp)               = 0    ;
3379      MonopoleMinimum(tp)                = 0    ;
3380      HVDCControlBand(tp,fd)             = 0    ;
3381      HVDClossScalingFactor(tp)          = 0    ;
3382      sharedNFRfactor(tp)                = 0    ;
3383      sharedNFRloadOffset(tp,ild)        = 0    ;
3384      effectiveFactor(tp,ild,resC,riskC) = 0    ;
3385      RMTreserveLimitTo(tp,ild,resC)     = 0    ;
3386      rampingConstraint(tp,brCstr)       = no   ;
3387  ) ;
3388   
3389  UseShareReserve = 1 $ sum[ (tp,resC), reserveShareEnabled(tp,resC)] ;
3390   
3391  * Branch Reverse Ratings planned to go-live on 03/Feb/2021 (this will be flagged in GDX using i_tradePeriodReverseRatingsApplied)
3392  * From 11 Dec 2020, GDX file will have i_tradePeriodBranchCapacityDirected and i_tradePeriodReverseRatingsApplied symbols
3393  if (inputGDXGDate >= jdate(2020,12,11),
3394      execute_load i_tradePeriodBranchCapacityDirected;
3395      execute_load reverseRatingsApplied = i_tradePeriodReverseRatingsApplied;
3396   
3397      i_tradePeriodBranchCapacityDirected(tp,br,'backward') $ (reverseRatingsApplied(tp)=0)
3398          = i_tradePeriodBranchCapacityDirected(tp,br,'forward');
3399   
3400  else
3401      i_tradePeriodBranchCapacityDirected(tp,br,fd)
3402          = i_tradePeriodBranchCapacity(tp,br) ;
3403  ) ;
3404   
3405   
3406  * Real Time Pricing phase 2 planned to go live on 22 March 2022
3407  * From 1 March 2022, GDX file will have following symbols
3408  inputGDXGDate =  jdate(2022,4,1);
3409  if (inputGDXGDate >= jdate(2022,3,1),
3410      execute_load
3411      studyMode                   = i_studyMode
3412      useGenInitialMW             = i_useGenInitialMW
3413      runEnrgShortfallTransfer    = i_runEnrgShortfallTransfer
3414      runPriceTransfer            = i_runPriceTransfer
3415      InputInitialLoad            = i_tradePeriodInputInitialLoad
3416      LoadIsOverride              = i_tradePeriodLoadIsOverride
3417      LoadIsBad                   = i_tradePeriodLoadIsBad
3418      LoadIsNCL                   = i_tradePeriodLoadIsNCL
3419      ConformingFactor            = i_tradePeriodConformingFactor
3420      NonConformingLoad           = i_tradePeriodNonConformingLoad
3421      MaxLoad                     = i_tradePeriodMaxLoad
3422   
3423      useActualLoad               = i_useActualLoad
3424      dontScaleNegativeLoad       = i_dontScaleNegativeLoad
3425   
3426      islandMWIPS                 = i_tradePeriodIslandMWIPS
3427      islandPDS                   = i_tradePeriodIslandPDS
3428      islandLosses                = i_tradePeriodIslandLosses
3429   
3430      energyScarcityEnabled       = i_energyScarcityEnabled
3431      reserveScarcityEnabled      = i_reserveScarcityEnabled
3432      scarcityEnrgNationalFactor  = i_tradePeriodScarcityEnrgNationalFactor
3433      scarcityEnrgNationalPrice   = i_tradePeriodScarcityEnrgNationalPrice
3434      scarcityEnrgNodeFactor      = i_tradePeriodScarcityEnrgNodeFactor
3435      scarcityEnrgNodeFactorPrice = i_tradePeriodScarcityEnrgNodeFactorPrice
3436      scarcityEnrgNodeLimit       = i_tradePeriodScarcityEnrgNodeLimit
3437      scarcityEnrgNodeLimitPrice  = i_tradePeriodScarcityEnrgNodeLimitPrice
3438      scarcityResrvIslandLimit    = i_tradePeriodScarcityResrvIslandLimit
3439      scarcityResrvIslandPrice    = i_tradePeriodScarcityResrvIslandPrice
3440      ;
3441   
3442  else
3443      studyMode                                    = 111 ;
3444      useGenInitialMW                              = 0;
3445      runEnrgShortfallTransfer                     = 0;
3446      runPriceTransfer                             = 0;
3447      InputInitialLoad(tp,n)                       = 0;
3448      LoadIsOverride(tp,n)                         = 0;
3449      LoadIsBad(tp,n)                              = 0;
3450      LoadIsNCL(tp,n)                              = 0;
3451      ConformingFactor(tp,n)                       = 0;
3452      NonConformingLoad(tp,n)                      = 0;
3453      MaxLoad(tp,n)                                = 10000;
3454   
3455      useActualLoad(tp)                            = 1;
3456      dontScaleNegativeLoad(tp)                    = 1;
3457   
3458      islandMWIPS(tp,ild)                          = 0 ;
3459      islandPDS(tp,ild)                            = 0 ;
3460      islandLosses(tp,ild)                         = 0 ;
3461   
3462      energyScarcityEnabled(tp)                    = 0 ;
3463      reserveScarcityEnabled(tp)                   = 0 ;
3464      scarcityEnrgNationalFactor(tp,trdBlk)        = 0 ;
3465      scarcityEnrgNationalPrice(tp,trdBlk)         = 0 ;
3466      scarcityEnrgNodeFactor(tp,n,trdBlk)          = 0 ;
3467      scarcityEnrgNodeFactorPrice(tp,n,trdBlk)     = 0 ;
3468      scarcityEnrgNodeLimit(tp,n,trdBlk)           = 0 ;
3469      scarcityEnrgNodeLimitPrice(tp,n,trdBlk)      = 0 ;
3470      scarcityResrvIslandLimit(tp,ild,resC,trdBlk) = 0 ;
3471      scarcityResrvIslandPrice(tp,ild,resC,trdBlk) = 0 ;
3472  ) ;
3473   
3474   
3475   
3476  *=====================================================================================
3477  * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
3478  *=====================================================================================
3479   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
3493   
3495   
3496   
3497  *=====================================================================================
3498  * 5. Initialise constraint violation penalties (CVPs)
3499  *=====================================================================================
3500   
3501  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
3502  * Calculate the Gregorian date of the CE and ECE change
3503  * Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
3504  CVPchangeGDate = jdate(2010,06,24) ;
3505   
3506  * Set the flag for the application of the different CVPs for CE and ECE
3507  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
3508  diffCeECeCVP = 0 ;
3509  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
3510  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
3511  * If the user selects Yes (1), set the diffCeECeCVP flag
3512  diffCeECeCVP $ (-1 = 1) = 1 ;
3513   
3514  deficitBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
3515  surplusBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
3516  deficitReservePenalty(resC) $ (ord(resC) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3517  deficitReservePenalty(resC) $ (ord(resC) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3518  deficitBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
3519  surplusBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
3520  deficitGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
3521  surplusGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
3522  deficitRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
3523  surplusRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
3524  deficitACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
3525  surplusACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
3526  deficitBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
3527  surplusBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
3528  deficitMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
3529  surplusMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
3530  deficitT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
3531  surplusT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
3532  * Different CVPs defined for CE and ECE
3533  deficitReservePenalty_CE(resC) $ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3534  deficitReservePenalty_CE(resC) $ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3535  deficitReservePenalty_ECE(resC)$ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
3536  deficitReservePenalty_ECE(resC)$ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
3537   
3538  *=====================================================================================
3539  * 6. Initialise model mapping and inputs
3540  *=====================================================================================
3541   
3542  * Pre-dispatch schedule is solved sequentially
3543  sequentialSolve
3544      $ ( sum[ (tp,o,offerPar) $ {(ord(tp) = 2) and (ord(offerPar) = 1)}
3545                               , i_tradePeriodOfferParameter(tp,o,offerPar) ] = 0
3546        ) = 1 ;
3547   
3548  sequentialSolve $ UseShareReserve = 1;
3549   
3550  * Initialise bus, node, offer, bid for the current trade period start
3551  bus(tp,b)  $ i_tradePeriodBus(tp,b)  = yes  ;
3552  node(tp,n) $ i_tradePeriodNode(tp,n) = yes  ;
3553   
3554  * Initialise network sets for the current trade period start
3555  nodeBus(node,b)     $ i_tradePeriodNodeBus(node,b)        = yes ;
3556  HVDCnode(node)      $ i_tradePeriodHVDCnode(node)         = yes ;
3557  ACnode(node)        $ ( not HVDCnode(node))               = yes ;
3558  referenceNode(node) $ i_tradePeriodReferenceNode(node)    = yes ;
3559  DCbus(tp,b)         $ sum[ nodeBus(HVDCnode(tp,n),b), 1 ] = yes ;
3560  ACbus(tp,b)         $ ( not DCbus(tp,b) )                 = yes ;
3561   
3562  * Bus live island status
3563  busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3564   
3565  * Offer initialisation - offer must be mapped to a node that is mapped to a
3566  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3567  offer(tp,o) $ sum[ (n,b) $ { i_tradePeriodOfferNode(tp,o,n) and
3568                               nodeBus(tp,n,b) and
3569                               ( (not i_useBusNetworkModel(tp)) or
3570                                 busElectricalIsland(tp,b))
3571                             }, 1 ] = yes ;
3572   
3573  * IL offer mapped to a node that is mapped to a bus always valid
3574  * (updated on 23 July 2015 based on an email from SO Bennet Tucker on 21 July 2015))
3575  offer(tp,o)
3576      $ sum[ (n,b)
3577           $ { i_tradePeriodOfferNode(tp,o,n) and nodeBus(tp,n,b)
3578           and sum[ (trdBlk,ILofrCmpnt)
3579                  , i_tradePeriodFastILRoffer(tp,o,trdBlk,ILofrCmpnt)
3580                  + i_tradePeriodSustainedILRoffer(tp,o,trdBlk,ILofrCmpnt) ]
3581             }, 1 ] = yes ;
3582   
3583  * Bid initialisation - bid must be mapped to a node that is mapped to a bus
3584  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3585  bid(tp,bd) $ sum[ (n,b) $ { i_tradePeriodBidNode(tp,bd,n) and
3586                              nodeBus(tp,n,b) and
3587                              ( (not i_useBusNetworkModel(tp)) or
3588                                busElectricalIsland(tp,b) )
3589                            }, 1 ] = yes ;
3590   
3591  * Initialise Risk/Reserve data for the current trading period
3592  RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3593   
3594  * Mapping bus, node, offer, bid and island start for the current trade period
3595  offerNode(offer,n)   $ i_tradePeriodOfferNode(offer,n)                 = yes ;
3596  bidNode(bid,n)       $ i_tradePeriodBidNode(bid,n)                     = yes ;
3597  busIsland(bus,ild)   $ i_tradePeriodBusIsland(bus,ild)                 = yes ;
3598  nodeIsland(tp,n,ild) $ sum[ b $ { bus(tp,b) and node(tp,n)
3599                                and nodeBus(tp,n,b)
3600                                and busIsland(tp,b,ild) }, 1 ]           = yes ;
3601  offerIsland(offer(tp,o),ild)
3602      $ sum[ n $ { offerNode(tp,o,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3603  bidIsland(bid(tp,bd),ild)
3604      $ sum[ n $ { bidNode(tp,bd,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3605   
3606  IslandRiskGenerator(tp,ild,o)
3607      $ { offerIsland(tp,o,ild) and RiskGenerator(tp,o) } = yes ;
3608   
3609  * Set the primary-secondary offer combinations
3610  primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3611   
3612  * Identification of primary and secondary units
3613  hasSecondaryOffer(tp,o) = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o,o1), 1 ] ;
3614  hasPrimaryOffer(tp,o)   = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o1,o), 1 ];
3615   
3616  * Initialise offer parameters for the current trade period start
3617  generationStart(offer(tp,o))
3618      = sum[ offerPar $ ( ord(offerPar) = 1 )
3619                      , i_tradePeriodOfferParameter(tp,o,offerPar)
3620                      + sum[ o1 $ primarySecondaryOffer(tp,o,o1)
3621                                ,i_tradePeriodOfferParameter(tp,o1,offerPar) ]
3622           ];
3623   
3624  rampRateUp(offer)
3625      = sum[ offerPar $ ( ord(offerPar) = 2 )
3626                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3627  rampRateDown(offer)
3628      = sum[ offerPar $ ( ord(offerPar) = 3 )
3629                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3630  reserveGenerationMaximum(offer)
3631      = sum[ offerPar $ ( ord(offerPar) = 4 )
3632                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3633  windOffer(offer)
3634      = sum[ offerPar $ ( ord(offerPar) = 5 )
3635                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3636  FKband(offer)
3637      = sum[ offerPar $ ( ord(offerPar) = 6 )
3638                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3639   
3640  priceResponsive(offer)
3641      = sum[ offerPar $ ( ord(offerPar) = 7 )
3642                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3643   
3644  potentialMW(offer)
3645      = sum[ offerPar $ ( ord(offerPar) = 8 )
3646                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3647   
3648   
3649  * Initialise energy offer data for the current trade period start
3650  generationOfferMW(offer,trdBlk)
3651      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3652                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3653  generationOfferPrice(offer,trdBlk)
3654      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3655                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3656   
3657  * Valid generation offer blocks are defined as those with a positive block limit
3658  validGenerationOfferBlock(offer,trdBlk)
3659      $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3660   
3661  * Define set of positive energy offers
3662  positiveEnergyOffer(offer)
3663      $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3664   
3665  * Initialise reserve offer data for the current trade period start
3666  PLSRReserveType(resT) $ (ord(resT) = 1) = yes ;
3667  TWDRReserveType(resT) $ (ord(resT) = 2) = yes ;
3668  ILReserveType(resT)   $ (ord(resT) = 3) = yes ;
3669   
3670  reserveOfferProportion(offer,trdBlk,resC)
3671      $ ( ord(resC) = 1 )
3672      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3673           , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3674   
3675  reserveOfferProportion(offer,trdBlk,resC)
3676      $ ( ord(resC) = 2 )
3677      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3678           , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3679   
3680  reserveOfferMaximum(offer(tp,o),trdBlk,resC,PLSRReserveType)
3681      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3682      , i_tradePeriodFastPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3683      + i_tradePeriodSustainedPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3684   
3685  reserveOfferMaximum(offer(tp,o),trdBlk,resC,TWDRReserveType)
3686      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3687      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3688      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3689   
3690  reserveOfferMaximum(offer,trdBlk,resC,ILReserveType)
3691      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3692      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3693      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ];
3694   
3695  reserveOfferPrice(offer,trdBlk,resC,PLSRReserveType)
3696      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3697      , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3698      + i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3699   
3700   
3701  reserveOfferPrice(offer,trdBlk,resC,TWDRReserveType)
3702      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3703      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3704      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3705   
3706  reserveOfferPrice(offer,trdBlk,resC,ILReserveType)
3707      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3708      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3709      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ] ;
3710   
3711  * Only reserve offer block with a positive block limit is valid
3712  validReserveOfferBlock(offer,trdBlk,resC,resT)
3713      $ (reserveOfferMaximum(offer,trdBlk,resC,resT) > 0) = yes ;
3714   
3715  * Bid energy data
3716  purchaseBidMW(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3717      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3718           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3719   
3720  purchaseBidPrice(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3721      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3722           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3723   
3724  validPurchaseBidBlock(bid,trdBlk)
3725      $ { ( purchaseBidMW(bid,trdBlk) > 0 ) or
3726          ( useDSBFDemandBidModel * purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3727   
3728  * Bid IL data
3729  purchaseBidILRMW(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3730      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3731           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3732           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3733   
3734  purchaseBidILRPrice(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3735      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3736           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3737           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3738   
3739  validPurchaseBidILRBlock(bid,trdBlk,resC)
3740      $ ( purchaseBidILRMW(bid,trdBlk,resC) > 0 ) = yes ;
3741   
3742   
3743  * Initialise demand/bid data for the current trade period start
3744  nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3745   
3746  * If a bid is valid --> ignore the demand at the node connected to the bid
3747  * (PA suggested during v1.4 Audit)
3748  nodeDemand(node(tp,n))
3749      $ { useDSBFDemandBidModel and
3750          Sum[ bd $ { bidNode(tp,bd,n) and i_tradePeriodDispatchableBid(tp,bd) }
3751             , 1 ]
3752        } = 0;
3753   
3754  * Real Time Pricing - First RTD load calculation
3756  if studyMode = 101 then
3757   
3758  *   Calculate first target total load [3.8.5.5]
3759  *   Island-level MW load forecast. For the fist loop:
3760  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
3761      TargetTotalLoad(tp,ild) = islandMWIPS(tp,ild) + islandPDS(tp,ild) - islandLosses(tp,ild);
3762   
3763  *   Flag if estimate load is scalable [3.8.5.7]
3764  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
3765  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
3766  *   assigned directly to EstimatedInitialLoad
3767      EstLoadIsScalable(tp,n) =  1 $ { (LoadIsNCL(tp,n) = 0)
3768                                   and (ConformingFactor(tp,n) > 0) } ;
3769   
3770  *   Calculate estimate non-scalable load [3.8.5.8]
3771  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
3772  *   conforming Pnode this will be the ConformingFactor MW input if that value is
3773  *   negative, otherwise it will be zero
3774      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 1 ) = NonConformingLoad(tp,n);
3775      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 0 ) = ConformingFactor(tp,n);
3776      EstNonScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = 0;
3777   
3778  *   Calculate estimate scalable load [3.8.5.10]
3779  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
3780  *   this value will be the ConformingFactor if it is non-negative, otherwise this
3781  *   value will be zero'
3782      EstScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = ConformingFactor(tp,n);
3783   
3784   
3785  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
3786  *   in order to calculate EstimatedInitialLoad
3787      EstScalingFactor(tp,ild)
3788          = (islandMWIPS(tp,ild) - islandLosses(tp,ild)
3789            - Sum[ n $ nodeIsland(tp,n,ild), EstNonScalableLoad(tp,n) ]
3790            ) / Sum[ n $ nodeIsland(tp,n,ild), EstScalableLoad(tp,n) ]
3791   
3792          ;
3793   
3794  *   Calculate estimate initial load [3.8.5.6]
3795  *   Calculated estimate of initial MW load, available to be used as an
3796  *   alternative to InputInitialLoad
3797      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 )
3798          = ConformingFactor(tp,n) * Sum[ ild $ nodeisland(tp,n,ild)
3799                                        , EstScalingFactor(tp,ild)] ;
3800      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 0 )
3801          = NonConformingLoad(tp,n);
3802   
3803  *   Calculate initial load [3.8.5.2]
3804  *   Value that represents the Pnode load MW at the start of the solution
3805  *   interval. Depending on the inputs this value will be either actual load,
3806  *   an operator applied override or an estimated initial load
3807      InitialLoad(tp,n) = InputInitialLoad(tp,n);
3808      InitialLoad(tp,n) $ { (LoadIsOverride(tp,n) = 0)
3809                        and ( (useActualLoad(tp) = 0) or (LoadIsBad(tp,n) = 1) )
3810                          } = EstimatedInitialLoad(tp,n) ;
3811   
3812  *   Flag if load is scalable [3.8.5.4]
3813  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
3814  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
3815  *   assigned to nodedemand
3816      LoadIsScalable(tp,n) = 1 $ { (LoadIsNCL(tp,n) = 0)
3817                               and (LoadIsOverride(tp,n) = 0)
3818                               and (InitialLoad(tp,n) >= 0) } ;
3819   
3820  *   Calculate Island-level scaling factor [3.8.5.3]
3821  *   --> applied to InitialLoad in order to calculate nodedemand
3822      LoadScalingFactor(tp,ild)
3823          = ( TargetTotalLoad(tp,ild)
3824            - Sum[ n $ { nodeIsland(tp,n,ild)
3825                     and (LoadIsScalable(tp,n) = 0) }, InitialLoad(tp,n) ]
3826            ) / Sum[ n $ { nodeIsland(tp,n,ild)
3827                       and (LoadIsScalable(tp,n) = 1) }, InitialLoad(tp,n) ]
3828          ;
3829   
3830  *   Calculate nodedemand [3.8.5.1]
3831      nodedemand(tp,n) $ LoadIsScalable(tp,n)
3832          = InitialLoad(tp,n) * sum[ ild $ nodeisland(tp,n,ild)
3833                                   , LoadScalingFactor(tp,ild) ];
3834   
3835      nodedemand(tp,n) $ (LoadIsScalable(tp,n) = 0) = InitialLoad(tp,n);
3836   
3837  Endif;
3839   
3840   
3841   
3842   
3843   
3844  * Branch is defined if there is a defined terminal bus, it has a non-zero
3845  * capacity and is closed for that trade period
3846  * Update the pre-processing code that removes branches which have a limit of zero
3847  * so that it removes a branch if either direction has a limit of zero.
3848  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3849                    (not i_tradePeriodHVDCBranch(tp,br)) and
3850                    sum[ fd $ (ord(fd)=1), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3851                    sum[ fd $ (ord(fd)=2), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3852                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3853                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3854                  } = yes ;
3855   
3856  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3857                    (i_tradePeriodHVDCBranch(tp,br)) and
3858                    sum[ fd, i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3859                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3860                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3861                  } = yes ;
3862   
3863   
3864  branchBusDefn(branch,b,b1) $ i_tradePeriodBranchDefn(branch,b,b1)    = yes ;
3865  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b,b1), 1] = yes ;
3866  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b1,b), 1] = yes ;
3867   
3868  * HVDC link and AC branch definition
3869  HVDClink(branch)      $ i_tradePeriodHVDCBranch(branch)         = yes ;
3870  HVDCpoles(branch)     $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3871  HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3872  ACbranch(branch)      $ ( not HVDClink(branch) )                = yes ;
3873   
3874  * Determine sending and receiving bus sets
3875  loop((frB,toB),
3876      ACbranchSendingBus(ACbranch,frB,fd)
3877          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3878   
3879      ACbranchReceivingBus(ACbranch,toB,fd)
3880          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3881   
3882      ACbranchSendingBus(ACbranch,toB,fd)
3883          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3884   
3885      ACbranchReceivingBus(ACbranch,frB,fd)
3886          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3887  );
3888   
3889  HVDClinkSendingBus(HVDClink,frB)
3890      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3891   
3892  HVDClinkReceivingBus(HVDClink,toB)
3893      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3894   
3895  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
3896  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
3897   
3898  * Determine the HVDC inter-island pole in the northward and southward direction
3899   
3900  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 1) and HVDClink(tp,br) }
3901      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 2)
3902                                         and nodeIsland(tp,n,ild)
3903                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3904   
3905  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 2) and HVDClink(tp,br) }
3906      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 1)
3907                                         and nodeIsland(tp,n,ild)
3908                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3909   
3910  * Mapping HVDC branch to pole to account for name changes to Pole 3
3911  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3912  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3913  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3914  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3915  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3916  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3917   
3918  * Initialise network data for the current trade period start
3919  * Node-bus allocation factor
3920  nodeBusAllocationFactor(tp,n,b) $ { node(tp,n) and bus(tp,b) }
3921      = i_tradePeriodNodeBusAllocationFactor(tp,n,b) ;
3922   
3923  * Flag to allow roundpower on the HVDC link
3924  allowHVDCroundpower(tp) = i_tradePeriodAllowHVDCroundpower(tp) ;
3925   
3926  * Allocate the input branch parameters to the defined branchCapacity
3927  branchCapacity(branch,fd)
3928      = i_tradePeriodBranchCapacityDirected(branch,fd) ;
3929  * HVDC Links do not have reverse capacity
3930  branchCapacity(HVDClink,fd) $ ( ord(fd) = 2 ) = 0 ;
3931   
3932  * Allocate the input branch parameters to the defined branchResistance
3933  branchResistance(branch)
3934      = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3935           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3936   
3937  * Convert susceptance from -Bpu to B% for data post-MSP
3938  branchSusceptance(ACbranch(tp,br))
3939      = sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3940           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ]
3941      * [ 100$(not i_useBusNetworkModel(tp)) - 100$i_useBusNetworkModel(tp) ];
3942   
3943  branchLossBlocks(branch)
3944      = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3945           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3946   
3947  * Ensure fixed losses for no loss AC branches are not included
3948  branchFixedLoss(ACbranch)
3949      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3950           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3951           ] $ (branchLossBlocks(ACbranch) > 1) ;
3952   
3953  branchFixedLoss(HVDClink)
3954      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3955           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3956   
3957  * Set resistance and fixed loss to zero if do not want to use the loss model
3958  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3959  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
3960   
3961  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3962  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
3963   
3964  * Initialise loss tranches data for the current trade period start
3965  * The loss factor coefficients assume that the branch capacity is in MW
3966  * and the resistance is in p.u.
3967   
3968  * Loss branches with 0 loss blocks
3969  lossSegmentMW(branch,los,fd)
3970      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3971      = branchCapacity(branch,fd) ;
3972   
3973  LossSegmentFactor(branch,los,fd)
3974      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3975      = 0 ;
3976   
3977  * Loss branches with 1 loss blocks
3978  LossSegmentMW(branch,los,fd)
3979      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3980      = maxFlowSegment ;
3981   
3982  LossSegmentFactor(branch,los,fd)
3983      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3984      = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
3985   
3986  * Loss branches with 3 loss blocks
3987  loop( branch $ (branchLossBlocks(branch) = 3),
3988  *   Segment 1
3989      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3990          = lossCoeff_A * branchCapacity(branch,fd) ;
3991   
3992      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3993          = 0.01 * 0.75 * lossCoeff_A
3994          * branchResistance(branch) * branchCapacity(branch,fd) ;
3995   
3996  *   Segment 2
3997      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
3998          = (1-lossCoeff_A) * branchCapacity(branch,fd) ;
3999   
4000      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4001          = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
4002   
4003  *   Segment 3
4004      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4005          = maxFlowSegment ;
4006   
4007      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4008          = 0.01 * (2 - (0.75*lossCoeff_A))
4009          * branchResistance(branch) * branchCapacity(branch,fd) ;
4010  );
4011   
4012  * Loss branches with 6 loss blocks
4013  loop( branch $ (branchLossBlocks(branch) = 6),
4014  *   Segment 1
4015      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
4016          = lossCoeff_C  * branchCapacity(branch,fd) ;
4017   
4018      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
4019          = 0.01 * 0.75 * lossCoeff_C
4020          * branchResistance(branch) * branchCapacity(branch,fd) ;
4021   
4022  *   Segment 2
4023      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
4024          = lossCoeff_D * branchCapacity(branch,fd) ;
4025   
4026      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4027          = 0.01 * lossCoeff_E
4028          * branchResistance(branch) * branchCapacity(branch,fd) ;
4029   
4030  *   Segment 3
4031      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4032          = 0.5 * branchCapacity(branch,fd) ;
4033   
4034      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4035          = 0.01 * lossCoeff_F
4036          * branchResistance(branch) * branchCapacity(branch,fd) ;
4037   
4038  *   Segment 4
4039      LossSegmentMW(branch,los,fd) $ (ord(los) = 4)
4040          = (1 - lossCoeff_D) * branchCapacity(branch,fd) ;
4041   
4042      LossSegmentFactor(branch,los,fd) $ (ord(los) = 4)
4043          = 0.01 * (2 - lossCoeff_F)
4044          * branchResistance(branch) * branchCapacity(branch,fd) ;
4045   
4046  *   Segment 5
4047      LossSegmentMW(branch,los,fd) $ (ord(los) = 5)
4048          = (1 - lossCoeff_C) * branchCapacity(branch,fd) ;
4049   
4050      LossSegmentFactor(branch,los,fd) $ (ord(los) = 5)
4051          = 0.01 * (2 - lossCoeff_E)
4052          * branchResistance(branch) * branchCapacity(branch,fd) ;
4053   
4054  *   Segment 6
4055      LossSegmentMW(branch,los,fd) $ (ord(los) = 6)
4056          = maxFlowSegment ;
4057   
4058      LossSegmentFactor(branch,los,fd) $ (ord(los) = 6)
4059          = 0.01 * (2 - (0.75*lossCoeff_C))
4060          * branchResistance(branch) * branchCapacity(branch,fd) ;
4061  ) ;
4062   
4063  * HVDC does not have backward flow --> No loss segment for backward flow
4064  LossSegmentMW(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4065  LossSegmentFactor(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4066   
4067   
4068  * Valid loss segment for a branch is defined as a loss segment that
4069  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
4070  validLossSegment(branch,los,fd) = yes $ { (ord(los) = 1) or
4071                                            LossSegmentMW(branch,los,fd) or
4072                                            LossSegmentFactor(branch,los,fd) } ;
4073   
4074  * HVDC loss model requires at least two loss segments and
4075  * an additional loss block due to cumulative loss formulation
4076  validLossSegment(HVDClink,los,fd)
4077      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
4078   
4079  validLossSegment(HVDClink,los,fd)
4080      $ { (branchLossBlocks(HVDClink) > 1) and
4081          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
4082          (sum[ los1, LossSegmentMW(HVDClink,los1,fd)
4083                    + LossSegmentFactor(HVDClink,los1,fd) ] > 0)
4084        } = yes ;
4085   
4086  * branches that have non-zero loss factors
4087  LossBranch(branch) $ sum[ (los,fd), LossSegmentFactor(branch,los,fd) ] = yes ;
4088   
4089  * Create AC branch loss segments
4090  ACbranchLossMW(ACbranch,los,fd)
4091      $ { validLossSegment(ACbranch,los,fd) and (ord(los) = 1) }
4092      = LossSegmentMW(ACbranch,los,fd) ;
4093   
4094  ACbranchLossMW(ACbranch,los,fd)
4095      $ { validLossSegment(ACbranch,los,fd) and (ord(los) > 1) }
4096      = LossSegmentMW(ACbranch,los,fd) - LossSegmentMW(ACbranch,los-1,fd) ;
4097   
4098  ACbranchLossFactor(ACbranch,los,fd)
4099      $ validLossSegment(ACbranch,los,fd) = LossSegmentFactor(ACbranch,los,fd) ;
4100   
4101  * Create HVDC loss break points
4102  HVDCBreakPointMWFlow(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4103  HVDCBreakPointMWLoss(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4104   
4105  HVDCBreakPointMWFlow(HVDClink,bp,fd)
4106      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) > 1) }
4107      = LossSegmentMW(HVDClink,bp-1,fd) ;
4108   
4109  HVDCBreakPointMWLoss(HVDClink,bp,fd)
4110      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) = 2) }
4111      =  LossSegmentMW(HVDClink,bp-1,fd) * LossSegmentFactor(HVDClink,bp-1,fd) ;
4112   
4113  loop( (HVDClink(branch),bp) $ (ord(bp) > 2),
4114      HVDCBreakPointMWLoss(branch,bp,fd) $ validLossSegment(branch,bp,fd)
4115          = LossSegmentFactor(branch,bp-1,fd)
4116          * [ LossSegmentMW(branch,bp-1,fd) - LossSegmentMW(branch,bp-2,fd) ]
4117          + HVDCBreakPointMWLoss(branch,bp-1,fd) ;
4118  ) ;
4119   
4120  * Initialise branch constraint data for the current trading period
4121  branchConstraint(tp,brCstr)
4122      $ sum[ branch(tp,br)
4123           $ i_tradePeriodBranchConstraintFactors(tp,brCstr,br), 1 ] = yes ;
4124   
4125  branchConstraintFactors(branchConstraint,br)
4126      = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
4127   
4128  branchConstraintSense(branchConstraint)
4129      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4130           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4131   
4132  branchConstraintLimit(branchConstraint)
4133      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4134           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4135   
4136  * Calculate parameters for NMIR project ----------------------------------------
4137  islandRiskGroup(tp,ild,rg,riskC)
4138      = yes $ sum[ o $ { offerIsland(tp,o,ild)
4139                     and riskGroupOffer(tp,rg,o,riskC) }, 1 ] ;
4140   
4141  modulationRisk(tp) = smax[ riskC, modulationRiskClass(tp,RiskC) ];
4142   
4143  reserveShareEnabledOverall(tp) = smax[ resC, reserveShareEnabled(tp,resC) ];
4144   
4145  roPwrZoneExit(tp,resC)
4146      = [ roundPower2MonoLevel(tp) - modulationRisk(tp) ]$(ord(resC)=1)
4147      + bipole2MonoLevel(tp)$(ord(resC)=2) ;
4148   
4149  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition by SPD pre-processing (same as for SIR),
            a change from the existing where the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone for FIR will be removed by SPD pre-processing (same as for SIR),
            a change from the existing where the InNoReverseZone for FIR is never removed by SPD pre-processing.
4157   
4158  if (inputGDXGDate >= jdate(2019,03,28),
4159      roPwrZoneExit(tp,resC) = bipole2MonoLevel(tp) ;
4160  ) ;
4161   
4162  * National market refinement end
4163   
4164   
4165  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
4166  sharedNFRLoad(tp,ild)
4167      = sum[ nodeIsland(tp,n,ild), nodeDemand(tp,n)]
4168      + sum[ (bd,trdBlk) $ bidIsland(tp,bd,ild), purchaseBidMW(tp,bd,trdBlk) ]
4169      - sharedNFRLoadOffset(tp,ild) ;
4170   
4171  sharedNFRMax(tp,ild) = Min{ RMTReserveLimitTo(tp,ild,'FIR'),
4172                              sharedNFRFactor(tp)*sharedNFRLoad(tp,ild) } ;
4173   
4174  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
4175  * TN on 22 May 2017: Usually a branch group constraint that limits the HVDC flow only involves
4176  * the HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017, the
4177  * constraint HAY_BEN_High_Frequency_limit involved all four branches in the form:
4178  *   HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
4179  * This method of formulating the constraint prevented the previous formulation of monopoleConstraint
4180  * and bipoleConstraintfrom working properly. Those constraints have been reformulated (see below)
4181  * in order to cope with the formulation observed on 18 May 2017.
4182  monopoleConstraint(tp,ild,brCstr,br)
4183      $ { HVDCpoles(tp,br)
4184      and ( not rampingConstraint(tp,brCstr) )
4185      and ( branchConstraintSense(tp,brCstr) = -1 )
4186      and (Sum[ (br1,b) $ {HVDClinkSendingBus(tp,br1,b) and busIsland(tp,b,ild)}
4187                        , branchConstraintFactors(tp,brCstr,br1)    ] = 1)
4188      and (Sum[ b $ {HVDClinkSendingBus(tp,br,b) and busIsland(tp,b,ild)}
4189                   , branchConstraintFactors(tp,brCstr,br)      ] = 1)
4190         } = yes ;
4191   
4192  bipoleConstraint(tp,ild,brCstr)
4193      $ { ( not rampingConstraint(tp,brCstr) )
4194      and ( branchConstraintSense(tp,brCstr) = -1 )
4195      and (Sum[ (br,b) $ { HVDCpoles(tp,br)
4196                       and HVDClinkSendingBus(tp,br,b)
4197                       and busIsland(tp,b,ild) }
4198                      , branchConstraintFactors(tp,brCstr,br)  ] = 2)
4199                         } = yes ;
4200   
4201  monoPoleCapacity(tp,ild,br)
4202      = Sum[ (b,fd) $ { BusIsland(tp,b,ild)
4203                    and HVDCPoles(tp,br)
4204                    and HVDClinkSendingBus(tp,br,b)
4205                    and ( ord(fd) = 1 )
4206                      }, branchCapacity(tp,br,fd) ] ;
4207   
4208  monoPoleCapacity(tp,ild,br)
4209      $ Sum[ brCstr $ monopoleConstraint(tp,ild,brCstr,br), 1]
4210      = Smin[ brCstr $ monopoleConstraint(tp,ild,brCstr,br)
4211            , branchConstraintLimit(tp,brCstr) ];
4212   
4213  monoPoleCapacity(tp,ild,br)
4214      = Min( monoPoleCapacity(tp,ild,br),
4215             sum[ fd $ ( ord(fd) = 1 ), branchCapacity(tp,br,fd) ] );
4216   
4217  biPoleCapacity(tp,ild)
4218      $ Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1]
4219      = Smin[ brCstr $ bipoleConstraint(tp,ild,brCstr)
4220            , branchConstraintLimit(tp,brCstr) ];
4221   
4222  biPoleCapacity(tp,ild)
4223      $ { Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1] = 0 }
4224      = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4225                       and HVDClinkSendingBus(tp,br,b)
4226                       and ( ord(fd) = 1 )
4227                         }, branchCapacity(tp,br,fd) ] ;
4228   
4229  HVDCMax(tp,ild)
4230      = Min( biPoleCapacity(tp,ild), Sum[ br, monoPoleCapacity(tp,ild,br) ] ) ;
4231   
4232  * Calculate HVDC HVDC Loss segment applied for NMIR
4233   
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
4239  if (inputGDXGDate >= jdate(2016,11,22),
4240        HVDCCapacity(tp,ild)
4241            = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4242                             and HVDClinkSendingBus(tp,br,b)
4243                             and ( ord(fd) = 1 )
4244                               }, branchCapacity(tp,br,fd) ] ;
4245   
4246        numberOfPoles(tp,ild)
4247            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4248                          and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
4249   
4250        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4251            = Prod[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4252                           and HVDClinkSendingBus(tp,br,b)
4253                             }, branchResistance(tp,br) ]
4254            / Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4255                          and HVDClinkSendingBus(tp,br,b)
4256                            }, branchResistance(tp,br) ] ;
4257   
4258        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 1)
4259            = Sum[ br $ monoPoleCapacity(tp,ild,br), branchResistance(tp,br) ] ;
4260  else
4261      HVDCCapacity(tp,ild)
4262          = Sum[ (br,b,b1,fd) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4263                              and i_tradePeriodBusIsland(tp,b,ild)
4264                              and i_tradePeriodBranchDefn(tp,br,b,b1)
4265                              and ( ord(fd) = 1 )
4266                                }, i_tradePeriodBranchCapacityDirected(tp,br,fd) ] ;
4267   
4268      numberOfPoles(tp,ild)
4269          =Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4270                        and i_tradePeriodBusIsland(tp,b,ild)
4271                        and i_tradePeriodBranchDefn(tp,br,b,b1)
4272                        and sum[ fd $ ( ord(fd) = 1 )
4273                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4274                          }, 1 ] ;
4275   
4276      HVDCResistance(tp,ild)
4277          =  Sum[ (br,b,b1,i_branchParameter)
4278                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4279                and i_tradePeriodBusIsland(tp,b,ild)
4280                and i_tradePeriodBranchDefn(tp,br,b,b1)
4281                and (ord(i_branchParameter) = 1)
4282                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter) ] ;
4283   
4284      HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4285          = Prod[ (br,b,b1,i_branchParameter)
4286                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4287                and i_tradePeriodBusIsland(tp,b,ild)
4288                and i_tradePeriodBranchDefn(tp,br,b,b1)
4289                and sum[ fd $ ( ord(fd) = 1 )
4290                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4291                and (ord(i_branchParameter) = 1)
4292                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter)
4293                ] / HVDCResistance(tp,ild) ;
4294  ) ;
4295   
4296  * Segment 1
4297  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 1)
4298      = HVDCCapacity(tp,ild) * lossCoeff_C ;
4299   
4300  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 1)
4301      = 0.01 * 0.75 * lossCoeff_C
4302      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4303   
4304  * Segment 2
4305  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 2)
4306      = HVDCCapacity(tp,ild) * lossCoeff_D ;
4307   
4308  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 2)
4309      = 0.01 * lossCoeff_E
4310      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4311   
4312  * Segment 3
4313  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 3)
4314      = HVDCCapacity(tp,ild) * 0.5 ;
4315   
4316  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 3)
4317      = 0.01 * lossCoeff_F
4318      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4319   
4320  * Segment 4
4321  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 4)
4322      = HVDCCapacity(tp,ild) * (1 - lossCoeff_D) ;
4323   
4324  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 4)
4325      = 0.01 * (2 - lossCoeff_F)
4326      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4327   
4328  * Segment 5
4329  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 5)
4330      = HVDCCapacity(tp,ild) * (1 - lossCoeff_C) ;
4331   
4332  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 5)
4333      = 0.01 * (2 - lossCoeff_E)
4334      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4335   
4336  * Segment 6
4337  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 6)
4338      = HVDCCapacity(tp,ild) ;
4339   
4340  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 6)
4341      = 0.01 * (2 - (0.75*lossCoeff_C))
4342      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4343   
4344  * Parameter for energy lambda loss model
4345  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4346  HVDCSentBreakPointMWLoss(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4347   
4348  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) > 1)
4349      = HVDCLossSegmentMW(tp,ild,bp-1) ;
4350   
4351  loop( (tp,ild,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)},
4352      HVDCSentBreakPointMWLoss(tp,ild,bp)
4353          = HVDClossScalingFactor(tp)
4354          * HVDCLossSegmentFactor(tp,ild,bp-1)
4355          * [ HVDCLossSegmentMW(tp,ild,bp-1)
4356            - HVDCSentBreakPointMWFlow(tp,ild,bp-1) ]
4357          + HVDCSentBreakPointMWLoss(tp,ild,bp-1) ;
4358  ) ;
4359   
4360  * Parameter for energy+reserve lambda loss model
4361   
4362  * Ideally SO should use asymmetric loss curve
4363  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4364      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4365                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4366           , -HVDCSentBreakPointMWFlow(tp,ild1,rsbp1) ];
4367   
4368  * SO decide to use symmetric loss curve instead
4369  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4370      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4371           , -HVDCSentBreakPointMWFlow(tp,ild,rsbp1) ];
4372   
4373  HVDCReserveBreakPointMWFlow(tp,ild,rsbp)
4374      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4375      = HVDCSentBreakPointMWFlow(tp,ild,rsbp-6) ;
4376   
4377   
4378  * Ideally SO should use asymmetric loss curve
4379  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4380      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4381                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4382           , HVDCSentBreakPointMWLoss(tp,ild1,rsbp1) ];
4383   
4384  * SO decide to use symmetric loss curve instead
4385  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4386      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4387           , HVDCSentBreakPointMWLoss(tp,ild,rsbp1) ];
4388   
4389  HVDCReserveBreakPointMWLoss(tp,ild,rsbp)
4390      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4391      = HVDCSentBreakPointMWLoss(tp,ild,rsbp-6);
4392   
4393  * Parameter for lambda loss model  end
4394   
4395  * Initialze parameters for NMIR project end ----------------------------------
4396   
4397   
4398  * Initialise risk/reserve data for the current trade period start
4399   
4400  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
4401  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
4402  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
4403  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
4404  GenRisk(riskC)     $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4405  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4406  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4407  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4408   
4409  * Define the CE and ECE risk class set to support the different CE and ECE CVP
4410  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
4411  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
4412  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
4413  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
4414  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4415  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4416  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4417  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4418   
4419  * Risk parameters
4420  FreeReserve(tp,ild,resC,riskC)
4421      = sum[ riskPar $ (ord(riskPar) = 1)
4422                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ]
4423  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4424      - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(tp,ild1)
4425           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4426             and (inputGDXGDate >= jdate(2016,10,20)) }
4427      ;
4428   
4429  IslandRiskAdjustmentFactor(tp,ild,resC,riskC) $ useReserveModel
4430      = sum[ riskPar $ (ord(riskPar) = 2)
4431                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4432   
4433  * HVDC rampup max - (3.4.1.3) - SPD version 11
4434  HVDCpoleRampUp(tp,ild,resC,riskC)
4435      = sum[ riskPar $ (ord(riskPar) = 3)
4436                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4437   
4438  * Index IslandMinimumRisk to cater for CE and ECE minimum risk
4439  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 4)
4440      = i_tradePeriodManualRisk(tp,ild,resC) ;
4441   
4442  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 6)
4443      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4444   
4445  * HVDC secondary risk parameters
4446  HVDCsecRiskEnabled(tp,ild,riskC)= i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC);
4447  HVDCsecRiskSubtractor(tp,ild)   = i_tradePeriodHVDCsecRiskSubtractor(tp,ild) ;
4448   
4449  * Min risks for the HVDC secondary risk are the same as the island min risk
4450  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 7)
4451      = i_tradePeriodManualRisk(tp,ild,resC) ;
4452   
4453  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 8)
4454      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4455   
4456  * The MW combined maximum capability for generation and reserve of class.
4457  reserveClassGenerationMaximum(offer,resC) = ReserveGenerationMaximum(offer) ;
4458   
4459  reserveClassGenerationMaximum(offer,resC)
4460      $ i_tradePeriodReserveClassGenerationMaximum(offer,resC)
4461      = i_tradePeriodReserveClassGenerationMaximum(offer,resC) ;
4462   
4463  * Calculation of reserve maximum factor - 5.2.1.1
4464  ReserveMaximumFactor(offer,resC) = 1 ;
4465  ReserveMaximumFactor(offer,resC)
4466      $ (ReserveClassGenerationMaximum(offer,resC)>0)
4467      = ReserveGenerationMaximum(offer)
4468      / reserveClassGenerationMaximum(offer,resC) ;
4469   
4470  * Virtual reserve
4471  virtualReserveMax(tp,ild,resC) = i_tradePeriodVROfferMax(tp,ild,resC) ;
4472  virtualReservePrice(tp,ild,resC) = i_tradePeriodVROfferPrice(tp,ild,resC) ;
4473   
4474  * Initialise AC node constraint data for the current trading period
4475  ACnodeConstraint(tp,ACnodeCstr)
4476      $ sum[ ACnode(tp,n)
4477           $ i_tradePeriodACnodeConstraintFactors(tp,ACnodeCstr,n), 1 ] = yes ;
4478   
4479  ACnodeConstraintFactors(ACnodeConstraint,n)
4480      = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
4481   
4482  ACnodeConstraintSense(ACnodeConstraint)
4483      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4484           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4485   
4486  ACnodeConstraintLimit(ACnodeConstraint)
4487      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4488           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4489   
4490  * Initialise market node constraint data for the current trading period
4491  MnodeConstraint(tp,MnodeCstr)
4492      $ { sum[ (offer(tp,o),resT,resC)
4493             $ { i_tradePeriodMnodeEnergyOfferConstraintFactors(tp,MnodeCstr,o) or
4494                 i_tradePeriodMnodeReserveOfferConstraintFactors(tp,MnodeCstr,o,resC,resT)
4495               }, 1
4496             ]
4497        or
4498          sum[ (bid(tp,bd),resC)
4499             $ { i_tradePeriodMnodeEnergyBidConstraintFactors(tp,MnodeCstr,bd) or
4500                 i_tradePeriodMnodeILReserveBidConstraintFactors(tp,MnodeCstr,bd,resC)
4501               }, 1
4502             ]
4503        } = yes ;
4504   
4505  MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
4506      = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
4507   
4508  MnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT)
4509      = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT) ;
4510   
4511  MnodeEnergyBidConstraintFactors(MnodeConstraint,bd)
4512      = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,bd) ;
4513   
4514  MnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC)
4515      = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC) ;
4516   
4517  MnodeConstraintSense(MnodeConstraint)
4518      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4519           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4520   
4521  MnodeConstraintLimit(MnodeConstraint)
4522      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4523           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4524   
4525  * Initialise mixed constraint data for the current trading period
4526  Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC)
4527      = i_type1MixedConstraintReserveMap(t1MixCstr,ild,resC,riskC) ;
4528   
4529  Type1MixedConstraint(tp,t1MixCstr)
4530      = i_tradePeriodType1MixedConstraint(tp,t1MixCstr) ;
4531   
4532  Type2MixedConstraint(tp,t2MixCstr)
4533      = i_tradePeriodType2MixedConstraint(tp,t2MixCstr) ;
4534   
4535  Type1MixedConstraintSense(tp,t1MixCstr)
4536      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
4537           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4538   
4539  Type1MixedConstraintLimit1(tp,t1MixCstr)
4540      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
4541           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4542   
4543  Type1MixedConstraintLimit2(tp,t1MixCstr)
4544      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
4545           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4546   
4547  Type2MixedConstraintSense(tp,t2MixCstr)
4548      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4549           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4550   
4551  Type2MixedConstraintLimit(tp,t2MixCstr)
4552      = sum[ CstrRHS$(ord(CstrRHS) = 2)
4553           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4554   
4555  Type1MixedConstraintCondition(tp,t1MixCstr)
4556      $ sum[ br $ { HVDChalfPoles(tp,br) and
4557                    i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4558                  }, 1
4559           ] = yes ;
4560   
4561  * Initialise generic constraint data for the current trading period
4562  GenericConstraint(tp,gnrcCstr) = i_tradePeriodGenericConstraint(tp,gnrcCstr) ;
4563   
4564  GenericEnergyOfferConstraintFactors(GenericConstraint,o)
4565      = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
4566   
4567  GenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT)
4568      = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT) ;
4569   
4570  GenericEnergyBidConstraintFactors(GenericConstraint,bd)
4571      = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,bd) ;
4572   
4573  GenericILReserveBidConstraintFactors(GenericConstraint,bd,resC)
4574      = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,bd,resC) ;
4575   
4576  GenericBranchConstraintFactors(GenericConstraint,br)
4577      = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
4578   
4579  GenericConstraintSense(GenericConstraint)
4580      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4581           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4582   
4583  GenericConstraintLimit(GenericConstraint)
4584      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4585           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4586   
4587   
4588  * Additional pre-processing on parameters --------------------------------------
4589   
4590  * Calculation of generation upper limits due to ramp rate limits
4591   
4592  * Only primary offers are considered (5.3.1.1)
4593  generationMaximum(tp,o) $ (not hasPrimaryOffer(tp,o))
4594      = sum[ validGenerationOfferBlock(tp,o,trdBlk)
4595           , generationOfferMW(tp,o,trdBlk) ]
4596      + sum[ (o1,trdBlk) $ { primarySecondaryOffer(tp,o,o1) and
4597                             validGenerationOfferBlock(tp,o1,trdBlk) }
4598           , generationOfferMW(tp,o1,trdBlk)
4599           ] ;
4600   
4601  * Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4602  * initial MW and ramp rate is used - Reference: Transpower Market Services
4603  rampTimeUp(offer) $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4604      = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4605                                     - generationStart(offer)
4606                                     ) / rampRateUp(offer)
4607           ] ;
4608   
4609  * Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4610  * initial MW and ramp rate is used - Reference: Transpower Market Services
4611  generationEndUp(offer) $ (not hasPrimaryOffer(offer))
4612      = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4613   
4614   
4615  * Calculation of generation lower limits due to ramp rate limits
4616   
4617  * Only primary offers are considered (5.3.2.1)
4618  * Negative prices for generation offers are not allowed? (5.3.2.1)
4619  generationMinimum(offer) = 0;
4620   
4621  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4622  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4623  rampTimeDown(offer) $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4624      = Min[ i_tradingPeriodLength, ( generationStart(offer)
4625                                    - generationMinimum(offer)
4626                                    ) / rampRateDown(offer)
4627           ] ;
4628   
4629  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4630  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4631  generationEndDown(offer) $ (not hasPrimaryOffer(offer))
4632      = Max[ 0, generationStart(offer) - rampRateDown(offer)*rampTimeDown(offer) ] ;
4633   
4634  o_offerEnergy_TP(dt,o) = 0;
4635  *   Additional pre-processing on parameters end
4636   
4637   
4638   
4639  * TN - Pivot or demand analysis begin
4642  * TN - Pivot or demand analysis begin end
4643   
4644  *=====================================================================================
4645  * 7. The vSPD solve loop
4646  *=====================================================================================
4647   
4648  unsolvedPeriod(tp) = yes;
4649  VSPDModel(tp) = 0 ;
4650  option clear = useBranchFlowMIP ;
4651  option clear = useMixedConstraintMIP ;
4652   
4653  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
4654    exitLoop = 0;
4655    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
4656   
4657  *   7a. Reset all sets, parameters and variables -------------------------------
4658      option clear = currTP ;
4659  *   Generation variables
4660      option clear = GENERATION ;
4661      option clear = GENERATIONBLOCK ;
4662  *   Purchase variables
4663      option clear = PURCHASE ;
4664      option clear = PURCHASEBLOCK ;
4665      option clear = PURCHASEILR ;
4666      option clear = PURCHASEILRBLOCK ;
4667  *   Network variables
4668      option clear = ACNODENETINJECTION ;
4669      option clear = ACNODEANGLE ;
4670      option clear = ACBRANCHFLOW ;
4671      option clear = ACBRANCHFLOWDIRECTED ;
4672      option clear = ACBRANCHLOSSESDIRECTED ;
4673      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4674      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4675      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4676      option clear = HVDCLINKFLOW ;
4677      option clear = HVDCLINKLOSSES ;
4678      option clear = LAMBDA ;
4679      option clear = LAMBDAINTEGER ;
4680      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
4681      option clear = HVDCPOLEFLOW_INTEGER ;
4682  *   Risk/Reserve variables
4683      option clear = RISKOFFSET ;
4684      option clear = HVDCREC ;
4685      option clear = ISLANDRISK ;
4686      option clear = RESERVEBLOCK ;
4687      option clear = RESERVE ;
4688      option clear = ISLANDRESERVE;
4689  *   NMIR variables
4690      option clear = SHAREDNFR ;
4691      option clear = SHAREDRESERVE ;
4692      option clear = HVDCSENT ;
4693      option clear = RESERVESHAREEFFECTIVE ;
4694      option clear = RESERVESHARERECEIVED ;
4695      option clear = RESERVESHARESENT ;
4696      option clear = HVDCSENDING ;
4697      option clear = INZONE ;
4698      option clear = HVDCSENTINSEGMENT ;
4699      option clear = HVDCRESERVESENT ;
4700      option clear = HVDCSENTLOSS ;
4701      option clear = HVDCRESERVELOSS ;
4702      option clear = LAMBDAHVDCENERGY ;
4703      option clear = LAMBDAHVDCRESERVE ;
4704      option clear = RESERVESHAREPENALTY ;
4705  *   Mixed constraint variables
4706      option clear = MIXEDCONSTRAINTVARIABLE ;
4707      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
4708  *   Objective
4709      option clear = NETBENEFIT ;
4710  *   Violation variables
4711      option clear = TOTALPENALTYCOST ;
4712      option clear = DEFICITBUSGENERATION ;
4713      option clear = SURPLUSBUSGENERATION ;
4714      option clear = DEFICITRESERVE ;
4715      option clear = DEFICITRESERVE_CE ;
4716      option clear = DEFICITRESERVE_ECE ;
4717      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4718      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4719      option clear = DEFICITRAMPRATE ;
4720      option clear = SURPLUSRAMPRATE ;
4721      option clear = DEFICITACnodeCONSTRAINT ;
4722      option clear = SURPLUSACnodeCONSTRAINT ;
4723      option clear = DEFICITBRANCHFLOW ;
4724      option clear = SURPLUSBRANCHFLOW ;
4725      option clear = DEFICITMNODECONSTRAINT ;
4726      option clear = SURPLUSMNODECONSTRAINT ;
4727      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
4728      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
4729      option clear = DEFICITGENERICCONSTRAINT ;
4730      option clear = SURPLUSGENERICCONSTRAINT ;
4731   
4732  *   Clear the pole circular branch flow flag
4733      option clear = circularBranchFlowExist ;
4734      option clear = poleCircularBranchFlowExist ;
4735      option clear = northHVDC ;
4736      option clear = southHVDC ;
4737      option clear = manualBranchSegmentMWFlow ;
4738      option clear = manualLossCalculation ;
4739      option clear = nonPhysicalLossExist ;
4740      option clear = modelSolved ;
4741      option clear = LPmodelSolved ;
4742  *   Disconnected bus post-processing
4743      option clear = busGeneration ;
4744      option clear = busLoad ;
4745      option clear = busDisconnected ;
4746      option clear = busPrice ;
4747   
4748   
4749  *   End reset
4750   
4751   
4752  *   7b. Initialise current trade period and model data -------------------------
4753      currTP(tp)  $ sequentialSolve       = yes;
4754      currTP(tp1) $ (not sequentialSolve) = yes;
4755   
4756  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4757      generationStart(offer(currTP(tp),o))
4758          $ (sum[ o1, generationStart(currTP,o1)] = 0)
4759          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
4760  *   Calculation of generation upper limits due to ramp rate limits
4761  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4762  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4763      rampTimeUp(offer(currTP(tp),o))
4764          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4765          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4766                                         - generationStart(offer)
4767                                         ) / rampRateUp(offer)
4768               ] ;
4769   
4770  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4771  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4772      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4773          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4774   
4775   
4776  *   Calculation of generation lower limits due to ramp rate limits
4777   
4778  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4779  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4780      rampTimeDown(offer(currTP(tp),o))
4781          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4782          = Min[ i_tradingPeriodLength, ( generationStart(offer)
4783                                        - generationMinimum(offer)
4784                                        ) / rampRateDown(offer)
4785               ] ;
4786   
4787  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4788  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4789      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4790          = Max[ 0, generationStart(offer)
4791                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
4792   
4793  *   Additional pre-processing on parameters end
4794   
4795   
4796  *   7c. Updating the variable bounds before model solve ------------------------
4797   
4798  * TN - Pivot or Demand Analysis - revise input data
4801  * TN - Pivot or Demand Analysis - revise input data end
4802   
4803  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4804   
4805  *   Offer blocks - Constraint 3.1.1.1
4806      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
4807          = generationOfferMW(validGenerationOfferBlock) ;
4808   
4809      GENERATIONBLOCK.fx(currTP,o,trdBlk)
4810          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
4811   
4812  *   Constraint 3.1.1.2 - Fix the generation variable for generators
4813  *   that are not connected or do not have a non-zero energy offer
4814      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
4815   
4816  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
4817      GENERATION.up(offer(currTP,o))
4818          $ { windOffer(offer) and priceResponsive(offer) }
4819          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4820   
4821  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
4822      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4823          $ (not UseDSBFDemandBidModel)
4824          = purchaseBidMW(validPurchaseBidBlock) ;
4825   
4826      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4827          $ (not UseDSBFDemandBidModel)
4828          = 0 ;
4829   
4830      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4831          $ UseDSBFDemandBidModel
4832          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
4833   
4834      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4835          $ UseDSBFDemandBidModel
4836          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
4837   
4838      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
4839          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
4840          = 0 ;
4841   
4842  *   Fix the purchase variable for purchasers that are not connected
4843  *   or do not have a non-zero purchase bid
4844      PURCHASE.fx(currTP,bd)
4845          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
4846   
4847  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4848   
4849   
4850  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4851   
4852  *   Ensure that variables used to specify flow and losses on HVDC link are
4853  *   zero for AC branches and for open HVDC links.
4854      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
4855      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
4856   
4857  *   Apply an upper bound on the weighting parameter based on its definition
4858      LAMBDA.up(branch,bp) = 1 ;
4859   
4860  *   Ensure that the weighting factor value is zero for AC branches and for
4861  *   invalid loss segments on HVDC links
4862      LAMBDA.fx(HVDClink,bp)
4863          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
4864      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
4865   
4866  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4867   
4868   
4869  *======= AC TRANSMISSION EQUATIONS =============================================
4870   
4871  *   Ensure that variables used to specify flow and losses on AC branches are
4872  *   zero for HVDC links branches and for open AC branches
4873      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
4874      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
4875      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
4876   
4877  *   Ensure directed block flow and loss block variables are zero for
4878  *   non-AC branches and invalid loss segments on AC branches
4879     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
4880         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4881   
4882     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
4883         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4884   
4885   
4886  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
4887  *   corresponding to the reference nodes and the HVDC nodes are set to zero
4888      ACNODEANGLE.fx(currTP,b)
4889         $ sum[ n $ { NodeBus(currTP,n,b) and
4890                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
4891   
4892  *======= AC TRANSMISSION EQUATIONS END =========================================
4893   
4894   
4895  *======= RISK & RESERVE EQUATIONS ==============================================
4896   
4897  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4898      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
4899          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
4900   
4901      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
4902          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
4903   
4904  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
4905      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
4906          = reserveOfferMaximum(validReserveOfferBlock) ;
4907   
4908      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
4909          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4910   
4911  *   Fix the reserve variable for invalid reserve offers. These are offers that
4912  *   are either not connected to the grid or have no reserve quantity offered.
4913      RESERVE.fx(currTP,o,resC,resT)
4914          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
4915   
4916  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
4917  *   offers that are either not connected to the grid or have no reserve quantity offered.
4918      PURCHASEILR.fx(currTP,bd,resC)
4919          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
4920   
4921  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4922      RISKOFFSET.fx(currTP,ild,resC,riskC)
4923          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
4924              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
4925            } = 0 ;
4926   
4927  *   Fix the appropriate deficit variable to zero depending on
4928  *   whether the different CE and ECE CVP flag is set
4929      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
4930      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4931      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4932   
4933  *   Virtual reserve
4934      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
4935   
4936  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
4951  *   NMIR project variables
4952      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4953      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4954   
4955  *   (3.4.2.3) - SPD version 11.0
4956      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
4957   
4958  *   No forward reserve sharing if HVDC capacity is zero
4959      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4960          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
4961   
4962  *   No forward reserve sharing if reserve sharing is disabled
4963      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4964          $ (reserveShareEnabled(currTP,resC)=0) = 0;
4965   
4966  *   No reserve sharing to cover HVDC risk
4967      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
4968      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
4969   
4970  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4971      INZONE.fx(currTP,ild,resC,z)
4972          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
4973   
4974  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
4975      INZONE.fx(currTP,ild,resC,z)
4976          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
4977   
4978  *   Fixing Lambda integer variable for energy sent
4979      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
4980                                          and (ord(bp) = 1) } = 1 ;
4981   
4982      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
4983   
4984  * To be reviewed NMIR
4985      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
4986          $ { (HVDCCapacity(currTP,ild) = 0)
4987          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
4988   
4989      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
4990          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
4991          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
4992  ;
4993   
4994   
4995  *======= RISK & RESERVE EQUATIONS END ==========================================
4996   
4997   
4998  *======= MIXED CONSTRAINTS =====================================================
4999   
5000  *   Mixed constraint
5001      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
5002          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
5003   
5004  *======= MIXED CONSTRAINTS END =================================================
5005   
5006  *   Updating the variable bounds before model solve end
5007   
5008   
5009  *   7d. Solve Models
5010   
INCLUDE    C:\vSPD\GitHub\Programs\vSPDsolve_RTP.gms
5012  *=====================================================================================
5013  * Name:                 vSPDsolve_RTP.gms
5014  * Function:             First RTD solve to update island loss in order to
5015  *                       adjust node demand
5016  *                       A new development for Rea
5017  * Developed by:         Electricity Authority, New Zealand
5018  * Source:               https://github.com/ElectricityAuthority/vSPD
5019  *                       http://www.emi.ea.govt.nz/Tools/vSPD
5020  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
5021  *                       Email: emi@ea.govt.nz
5022  * Created on:           14 Jan 2022
5023   
5024  *=====================================================================================
5025   
5026  *   7d. Solve Models First Time For Real Time Pricing
5027   
5028  if (studyMode = 101,
5029  *   Solve the LP model ---------------------------------------------------------
5030      if( (Sum[currTP, VSPDModel(currTP)] = 0),
5031   
5032          if( UseShareReserve,
5033              option bratio = 1 ;
5034              vSPD_NMIR.Optfile = 1 ;
5035              vSPD_NMIR.optcr = MIPOptimality ;
5036              vSPD_NMIR.reslim = MIPTimeLimit ;
5037              vSPD_NMIR.iterlim = MIPIterationLimit ;
5038              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5039  *           Set the model solve status
5040              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5041                                 or (vSPD_NMIR.modelstat = 8) )
5042                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5043          else
5044              option bratio = 1 ;
5045              vSPD.reslim = LPTimeLimit ;
5046              vSPD.iterlim = LPIterationLimit ;
5047              solve vSPD using lp maximizing NETBENEFIT ;
5048  *           Set the model solve status
5049              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5050          )
5051   
5052  *       Post a progress message to the console and for use by EMI.
5053          if((ModelSolved = 1) and (sequentialSolve = 0),
5054              putclose runlog 'The case: RTD_20211202_RTP '
5055                              'is solved successfully.'/
5056                              'Objective function value: '
5057                              NETBENEFIT.l:<12:1 /
5058                              'Violation Cost          : '
5059                              TOTALPENALTYCOST.l:<12:1 /
5060          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
5061              putclose runlog 'The case: RTD_20211202_RTP '
5062                              'is solved unsuccessfully.'/
5063          ) ;
5064   
5065          if((ModelSolved = 1) and (sequentialSolve = 1),
5066              loop(currTP,
5067                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5068                                  'is solved successfully.'/
5069                                  'Objective function value: '
5070                                  NETBENEFIT.l:<12:1 /
5071                                  'Violations cost         : '
5072                                  TOTALPENALTYCOST.l:<12:1 /
5073              ) ;
5074          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
5075              loop(currTP,
5076                  unsolvedPeriod(currTP) = no;
5077                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5078                                  'is solved unsuccessfully.'/
5079              ) ;
5080   
5081          ) ;
5082  *   Solve the LP model end -----------------------------------------------------
5083   
5084   
5085  *   Solve the VSPD_MIP model ---------------------------------------------------
5086      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
5087  *       Fix the values of the integer variables that are not needed
5088          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5089              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5090   
5091  *       Fix the integer AC branch flow variable to zero for invalid branches
5092          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5093              $ (not branch(currTP,br)) = 0 ;
5094   
5095  *       Apply an upper bound on the integer weighting parameter
5096          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5097   
5098  *       Ensure that the weighting factor value is zero for AC branches
5099  *       and for invalid loss segments on HVDC links
5100          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5101              $ { ACbranch(branch)
5102              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5103                } = 0 ;
5104   
5105  *       Fix the lambda integer variable to zero for invalid branches
5106          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5107   
5108  *       Fix the value of some binary variables used in the mixed constraints
5109  *       that have no alternate limit
5110          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5111              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5112   
5113          option bratio = 1 ;
5114          vSPD_MIP.Optfile = 1 ;
5115          vSPD_MIP.optcr = MIPOptimality ;
5116          vSPD_MIP.reslim = MIPTimeLimit ;
5117          vSPD_MIP.iterlim = MIPIterationLimit ;
5118          solve vSPD_MIP using mip maximizing NETBENEFIT ;
5119  *       Set the model solve status
5120          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
5121                                (vSPD_MIP.modelstat = 8)
5122                              ]
5123                              and
5124                              [ vSPD_MIP.solvestat = 1 ]
5125                            } ;
5126   
5127  *       Post a progress message for use by EMI.
5128          if(ModelSolved = 1,
5129              loop(currTP,
5130                  unsolvedPeriod(currTP) = no;
5131                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5132                                  'is solved successfully for FULL integer.'/
5133                                  'Objective function value: '
5134                                  NETBENEFIT.l:<12:1 /
5135                                  'Violations              : '
5136                                  TOTALPENALTYCOST.l:<12:1 /
5137              ) ;
5138          else
5139              loop(currTP,
5140                  unsolvedPeriod(currTP) = yes;
5141                  VSPDModel(currTP) = 4;
5142                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5143                                  'is solved unsuccessfully for FULL integer.'/
5144              ) ;
5145          ) ;
5146  *   Solve the vSPD_MIP model end -----------------------------------------------
5147   
5148   
5149  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5150      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5151  *       Fix the values of these integer variables that are not needed
5152          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5153              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5154   
5155  *       Fix the integer AC branch flow variable to zero for invalid branches
5156          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5157              $ (not branch(currTP,br)) = 0 ;
5158   
5159  *       Apply an upper bound on the integer weighting parameter
5160          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5161   
5162  *       Ensure that the weighting factor value is zero for AC branches
5163  *       and for invalid loss segments on HVDC links
5164          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5165              $ { ACbranch(branch)
5166              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5167                } = 0 ;
5168   
5169  *       Fix the lambda integer variable to zero for invalid branches
5170          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5171   
5172          option bratio = 1 ;
5173          vSPD_BranchFlowMIP.Optfile = 1 ;
5174          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5175          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5176          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5177          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5178  *       Set the model solve status
5179          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5180                                (vSPD_BranchFlowMIP.modelstat = 8)
5181                              ]
5182                              and
5183                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5184                            } ;
5185   
5186  *       Post a progress message for use by EMI.
5187          if(ModelSolved = 1,
5188   
5189  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5190              vSPD_SOS1_Solve(currTP)  = yes;
5191   
5192              loop(currTP,
5193                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5194                                  'is solved successfully for branch integer.'/
5195                                  'Objective function value: '
5196                                  NETBENEFIT.l:<12:1 /
5197                                  'Violations cost         : '
5198                                  TOTALPENALTYCOST.l:<12:1 /
5199              ) ;
5200          else
5201              loop(currTP,
5202                  unsolvedPeriod(currTP) = yes;
5203                  VSPDModel(currTP) = 4;
5204                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5205                                  'is solved unsuccessfully for branch integer.'/
5206              ) ;
5207          ) ;
5208  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5209   
5210   
5211  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5212      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5213  *       Fix the value of some binary variables used in the mixed constraints
5214  *       that have no alternate limit
5215          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5216              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5217   
5218  *       Use the advanced basis here
5219          option bratio = 0.25 ;
5220          vSPD_MixedConstraintMIP.Optfile = 1 ;
5221  *       Set the optimality criteria for the MIP
5222          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5223          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5224          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5225  *       Solve the model
5226          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5227  *       Set the model solve status
5228          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5229                                (vSPD_MixedConstraintMIP.modelstat = 8)
5230                              ]
5231                              and
5232                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5233                            } ;
5234   
5235  *       Post a progress message for use by EMI.
5236          if(ModelSolved = 1,
5237              loop(currTP,
5238                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5239                                  'is solved successfully for '
5240                                  'mixed constraint integer.'/
5241                                  'Objective function value: '
5242                                  NETBENEFIT.l:<12:1 /
5243                                  'Violations cost         : '
5244                                  TOTALPENALTYCOST.l:<12:1 /
5245              ) ;
5246          else
5247              loop(currTP,
5248                  unsolvedPeriod(currTP) = yes;
5249                  VSPDModel(currTP) = 1;
5250                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5251                                  'is solved unsuccessfully for '
5252                                  'mixed constraint integer.'/
5253              ) ;
5254          ) ;
5255  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5256   
5257   
5258  *   Solve the LP model and stop ------------------------------------------------
5259      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5260   
5261          if( UseShareReserve,
5262              option bratio = 1 ;
5263              vSPD_NMIR.Optfile = 1 ;
5264              vSPD_NMIR.optcr = MIPOptimality ;
5265              vSPD_NMIR.reslim = MIPTimeLimit ;
5266              vSPD_NMIR.iterlim = MIPIterationLimit ;
5267              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5268  *           Set the model solve status
5269              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5270                                 or (vSPD_NMIR.modelstat = 8) )
5271                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5272          else
5273              option bratio = 1 ;
5274              vSPD.reslim = LPTimeLimit ;
5275              vSPD.iterlim = LPIterationLimit ;
5276              solve vSPD using lp maximizing NETBENEFIT ;
5277  *           Set the model solve status
5278              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5279          )
5280   
5281  *       Post a progress message for use by EMI.
5282          if( ModelSolved = 1,
5283              loop(currTP,
5284                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ')'
5285                                  ' integer resolve was unsuccessful.' /
5286                                  'Reverting back to linear solve and '
5287                                  'solve successfully. ' /
5288                                  'Objective function value: '
5289                                  NETBENEFIT.l:<12:1 /
5290                                  'Violations cost         : '
5291                                  TOTALPENALTYCOST.l:<12:1 /
5292                                  'Solution may have circulating flows '
5293                                  'and/or non-physical losses.' /
5294              ) ;
5295          else
5296              loop(currTP,
5297                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl
5298                                  ') integer solve was unsuccessful. '
5299                                  'Reverting back to linear solve. '
5300                                  'Linear solve unsuccessful.' /
5301              ) ;
5302          ) ;
5303   
5304          unsolvedPeriod(currTP) = no;
5305   
5306  *   Solve the LP model and stop end --------------------------------------------
5307   
5308      ) ;
5309  *   Solve the models end
5310   
5311   
5312  * Real Time Pricing - Second RTD load calculation
5313   
5314  *   Calculate Island-level MW losses used to calculate the Island-level load
5315  *   forecast from the InputIPS and the IslandPSD.
5316  *   2nd solve loop --> SystemLosses as calculated in section 6.3'
5317      LoadCalcLosses(currTP,ild)
5318          = Sum[ (br,frB,toB)
5319               $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
5320               and branchBusDefn(currTP,br,frB,toB)
5321                 }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
5322                  + branchFixedLoss(currTP,br)
5323               ]
5324          + Sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5325                                  branchBusDefn(currTP,br,frB,toB) and
5326                                  busIsland(currTP,toB,ild) and
5327                                  busIsland(currTP,frB,ild)
5328                                }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
5329                                 + HVDCLINKLOSSES.l(currTP,br)
5330                                 + branchFixedLoss(currTP,br)
5331               ]
5332          + Sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5333                                  branchBusDefn(currTP,br,frB,toB) and
5334                                  ( busIsland(currTP,toB,ild) or
5335                                    busIsland(currTP,frB,ild)
5336                                  )
5337                                }, 0.5 * branchFixedLoss(currTP,br)
5338               ]
5339          + Sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
5340                                  branchBusDefn(currTP,br,frB,toB) and
5341                                  busIsland(currTP,toB,ild) and
5342                                  (not (busIsland(currTP,frB,ild)))
5343                                }, HVDCLINKLOSSES.l(currTP,br)
5344               ]
5345            ;
5346   
5347   
5348  *   Calculate first target total load [3.8.5.5]
5349  *   Island-level MW load forecast. For the fist loop:
5350  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
5351      TargetTotalLoad(currTP,ild) = islandMWIPS(currTP,ild) + islandPDS(currTP,ild) - LoadCalcLosses(currTP,ild) ;
5352   
5353  *   Flag if estimate load is scalable [3.8.5.7]
5354  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
5355  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
5356  *   assigned directly to EstimatedInitialLoad
5357      EstLoadIsScalable(currTP,n) =  1 $ { (LoadIsNCL(currTP,n) = 0)
5358                                       and (ConformingFactor(currTP,n) > 0) } ;
5359   
5360  *   Calculate estimate non-scalable load [3.8.5.8]
5361  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
5362  *   conforming Pnode this will be the ConformingFactor MW input if that value is
5363  *   negative, otherwise it will be zero
5364      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 1 ) = NonConformingLoad(currTP,n);
5365      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 0 ) = ConformingFactor(currTP,n);
5366      EstNonScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = 0;
5367   
5368  *   Calculate estimate scalable load [3.8.5.10]
5369  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
5370  *   this value will be the ConformingFactor if it is non-negative, otherwise this
5371  *   value will be zero'
5372      EstScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = ConformingFactor(currTP,n);
5373   
5374   
5375  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
5376  *   in order to calculate EstimatedInitialLoad
5377      EstScalingFactor(currTP,ild)
5378          = (islandMWIPS(currTP,ild) - LoadCalcLosses(currTP,ild)
5379            - Sum[ n $ nodeIsland(currTP,n,ild), EstNonScalableLoad(currTP,n) ]
5380            ) / Sum[ n $ nodeIsland(currTP,n,ild), EstScalableLoad(currTP,n) ]
5381   
5382          ;
5383   
5384  *   Calculate estimate initial load [3.8.5.6]
5385  *   Calculated estimate of initial MW load, available to be used as an
5386  *   alternative to InputInitialLoad
5387      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 )
5388          = ConformingFactor(currTP,n) * Sum[ ild $ nodeisland(currTP,n,ild)
5389                                            , EstScalingFactor(currTP,ild)] ;
5390      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 0 )
5391          = NonConformingLoad(currTP,n);
5392   
5393  *   Calculate initial load [3.8.5.2]
5394  *   Value that represents the Pnode load MW at the start of the solution
5395  *   interval. Depending on the inputs this value will be either actual load,
5396  *   an operator applied override or an estimated initial load
5397      InitialLoad(currTP,n) = InputInitialLoad(currTP,n);
5398      InitialLoad(currTP,n) $ { (LoadIsOverride(currTP,n) = 0)
5399                            and ( (useActualLoad(currTP) = 0)
5400                               or (LoadIsBad(currTP,n) = 1) )
5401                              } = EstimatedInitialLoad(currTP,n) ;
5402   
5403  *   Flag if load is scalable [3.8.5.4]
5404  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
5405  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
5406  *   assigned to nodedemand
5407      LoadIsScalable(currTP,n) = 1 $ { (LoadIsNCL(currTP,n) = 0)
5408                                   and (LoadIsOverride(currTP,n) = 0)
5409                                   and (InitialLoad(currTP,n) >= 0) } ;
5410   
5411  *   Calculate Island-level scaling factor [3.8.5.3]
5412  *   --> applied to InitialLoad in order to calculate nodedemand
5413      LoadScalingFactor(currTP,ild)
5414          = ( TargetTotalLoad(currTP,ild)
5415            - Sum[ n $ { nodeIsland(currTP,n,ild)
5416                     and (LoadIsScalable(currTP,n) = 0) }, InitialLoad(currTP,n) ]
5417            ) / Sum[ n $ { nodeIsland(currTP,n,ild)
5418                       and (LoadIsScalable(currTP,n) = 1) }, InitialLoad(currTP,n) ]
5419          ;
5420   
5421  *   Calculate nodedemand [3.8.5.1]
5422      nodedemand(currTP,n) $ LoadIsScalable(currTP,n)
5423          = InitialLoad(currTP,n) * sum[ ild $ nodeisland(currTP,n,ild)
5424                                   , LoadScalingFactor(currTP,ild) ];
5425   
5426      nodedemand(currTP,n) $ (LoadIsScalable(currTP,n) = 0) = InitialLoad(currTP,n);
5427   
5428  );
5429   
5430   
5431   
5432   
5433  *   Solve the LP model ---------------------------------------------------------
5434      if( (Sum[currTP, VSPDModel(currTP)] = 0),
5435   
5436          if( UseShareReserve,
5437              option bratio = 1 ;
5438              vSPD_NMIR.Optfile = 1 ;
5439              vSPD_NMIR.optcr = MIPOptimality ;
5440              vSPD_NMIR.reslim = MIPTimeLimit ;
5441              vSPD_NMIR.iterlim = MIPIterationLimit ;
5442              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5443  *           Set the model solve status
5444              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5445                                 or (vSPD_NMIR.modelstat = 8) )
5446                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5447          else
5448              option bratio = 1 ;
5449              vSPD.reslim = LPTimeLimit ;
5450              vSPD.iterlim = LPIterationLimit ;
5451              solve vSPD using lp maximizing NETBENEFIT ;
5452  *           Set the model solve status
5453              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5454          )
5455   
5456  *       Post a progress message to the console and for use by EMI.
5457          if((ModelSolved = 1) and (sequentialSolve = 0),
5458              putclose runlog 'The case: RTD_20211202_RTP '
5459                              'is solved successfully.'/
5460                              'Objective function value: '
5461                              NETBENEFIT.l:<12:1 /
5462                              'Violation Cost          : '
5463                              TOTALPENALTYCOST.l:<12:1 /
5464          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
5465              putclose runlog 'The case: RTD_20211202_RTP '
5466                              'is solved unsuccessfully.'/
5467          ) ;
5468   
5469          if((ModelSolved = 1) and (sequentialSolve = 1),
5470              loop(currTP,
5471                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5472                                  'is solved successfully.'/
5473                                  'Objective function value: '
5474                                  NETBENEFIT.l:<12:1 /
5475                                  'Violations cost         : '
5476                                  TOTALPENALTYCOST.l:<12:1 /
5477              ) ;
5478          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
5479              loop(currTP,
5480                  unsolvedPeriod(currTP) = no;
5481                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5482                                  'is solved unsuccessfully.'/
5483              ) ;
5484   
5485          ) ;
5486  *   Solve the LP model end -----------------------------------------------------
5487   
5488   
5489  *   Solve the VSPD_MIP model ---------------------------------------------------
5490      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
5491  *       Fix the values of the integer variables that are not needed
5492          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5493              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5494   
5495  *       Fix the integer AC branch flow variable to zero for invalid branches
5496          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5497              $ (not branch(currTP,br)) = 0 ;
5498   
5499  *       Apply an upper bound on the integer weighting parameter
5500          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5501   
5502  *       Ensure that the weighting factor value is zero for AC branches
5503  *       and for invalid loss segments on HVDC links
5504          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5505              $ { ACbranch(branch)
5506              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5507                } = 0 ;
5508   
5509  *       Fix the lambda integer variable to zero for invalid branches
5510          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5511   
5512  *       Fix the value of some binary variables used in the mixed constraints
5513  *       that have no alternate limit
5514          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5515              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5516   
5517          option bratio = 1 ;
5518          vSPD_MIP.Optfile = 1 ;
5519          vSPD_MIP.optcr = MIPOptimality ;
5520          vSPD_MIP.reslim = MIPTimeLimit ;
5521          vSPD_MIP.iterlim = MIPIterationLimit ;
5522          solve vSPD_MIP using mip maximizing NETBENEFIT ;
5523  *       Set the model solve status
5524          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
5525                                (vSPD_MIP.modelstat = 8)
5526                              ]
5527                              and
5528                              [ vSPD_MIP.solvestat = 1 ]
5529                            } ;
5530   
5531  *       Post a progress message for use by EMI.
5532          if(ModelSolved = 1,
5533              loop(currTP,
5534                  unsolvedPeriod(currTP) = no;
5535                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5536                                  'is solved successfully for FULL integer.'/
5537                                  'Objective function value: '
5538                                  NETBENEFIT.l:<12:1 /
5539                                  'Violations              : '
5540                                  TOTALPENALTYCOST.l:<12:1 /
5541              ) ;
5542          else
5543              loop(currTP,
5544                  unsolvedPeriod(currTP) = yes;
5545                  VSPDModel(currTP) = 4;
5546                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5547                                  'is solved unsuccessfully for FULL integer.'/
5548              ) ;
5549          ) ;
5550  *   Solve the vSPD_MIP model end -----------------------------------------------
5551   
5552   
5553  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5554      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5555  *       Fix the values of these integer variables that are not needed
5556          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5557              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5558   
5559  *       Fix the integer AC branch flow variable to zero for invalid branches
5560          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5561              $ (not branch(currTP,br)) = 0 ;
5562   
5563  *       Apply an upper bound on the integer weighting parameter
5564          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5565   
5566  *       Ensure that the weighting factor value is zero for AC branches
5567  *       and for invalid loss segments on HVDC links
5568          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5569              $ { ACbranch(branch)
5570              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5571                } = 0 ;
5572   
5573  *       Fix the lambda integer variable to zero for invalid branches
5574          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5575   
5576          option bratio = 1 ;
5577          vSPD_BranchFlowMIP.Optfile = 1 ;
5578          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5579          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5580          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5581          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5582  *       Set the model solve status
5583          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5584                                (vSPD_BranchFlowMIP.modelstat = 8)
5585                              ]
5586                              and
5587                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5588                            } ;
5589   
5590  *       Post a progress message for use by EMI.
5591          if(ModelSolved = 1,
5592   
5593  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5594              vSPD_SOS1_Solve(currTP)  = yes;
5595   
5596              loop(currTP,
5597                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5598                                  'is solved successfully for branch integer.'/
5599                                  'Objective function value: '
5600                                  NETBENEFIT.l:<12:1 /
5601                                  'Violations cost         : '
5602                                  TOTALPENALTYCOST.l:<12:1 /
5603              ) ;
5604          else
5605              loop(currTP,
5606                  unsolvedPeriod(currTP) = yes;
5607                  VSPDModel(currTP) = 4;
5608                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5609                                  'is solved unsuccessfully for branch integer.'/
5610              ) ;
5611          ) ;
5612  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5613   
5614   
5615  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5616      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5617  *       Fix the value of some binary variables used in the mixed constraints
5618  *       that have no alternate limit
5619          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5620              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5621   
5622  *       Use the advanced basis here
5623          option bratio = 0.25 ;
5624          vSPD_MixedConstraintMIP.Optfile = 1 ;
5625  *       Set the optimality criteria for the MIP
5626          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5627          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5628          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5629  *       Solve the model
5630          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5631  *       Set the model solve status
5632          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5633                                (vSPD_MixedConstraintMIP.modelstat = 8)
5634                              ]
5635                              and
5636                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5637                            } ;
5638   
5639  *       Post a progress message for use by EMI.
5640          if(ModelSolved = 1,
5641              loop(currTP,
5642                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5643                                  'is solved successfully for '
5644                                  'mixed constraint integer.'/
5645                                  'Objective function value: '
5646                                  NETBENEFIT.l:<12:1 /
5647                                  'Violations cost         : '
5648                                  TOTALPENALTYCOST.l:<12:1 /
5649              ) ;
5650          else
5651              loop(currTP,
5652                  unsolvedPeriod(currTP) = yes;
5653                  VSPDModel(currTP) = 1;
5654                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5655                                  'is solved unsuccessfully for '
5656                                  'mixed constraint integer.'/
5657              ) ;
5658          ) ;
5659  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5660   
5661   
5662  *   Solve the LP model and stop ------------------------------------------------
5663      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5664   
5665          if( UseShareReserve,
5666              option bratio = 1 ;
5667              vSPD_NMIR.Optfile = 1 ;
5668              vSPD_NMIR.optcr = MIPOptimality ;
5669              vSPD_NMIR.reslim = MIPTimeLimit ;
5670              vSPD_NMIR.iterlim = MIPIterationLimit ;
5671              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5672  *           Set the model solve status
5673              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5674                                 or (vSPD_NMIR.modelstat = 8) )
5675                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5676          else
5677              option bratio = 1 ;
5678              vSPD.reslim = LPTimeLimit ;
5679              vSPD.iterlim = LPIterationLimit ;
5680              solve vSPD using lp maximizing NETBENEFIT ;
5681  *           Set the model solve status
5682              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5683          )
5684   
5685  *       Post a progress message for use by EMI.
5686          if( ModelSolved = 1,
5687              loop(currTP,
5688                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ')'
5689                                  ' integer resolve was unsuccessful.' /
5690                                  'Reverting back to linear solve and '
5691                                  'solve successfully. ' /
5692                                  'Objective function value: '
5693                                  NETBENEFIT.l:<12:1 /
5694                                  'Violations cost         : '
5695                                  TOTALPENALTYCOST.l:<12:1 /
5696                                  'Solution may have circulating flows '
5697                                  'and/or non-physical losses.' /
5698              ) ;
5699          else
5700              loop(currTP,
5701                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl
5702                                  ') integer solve was unsuccessful. '
5703                                  'Reverting back to linear solve. '
5704                                  'Linear solve unsuccessful.' /
5705              ) ;
5706          ) ;
5707   
5708          unsolvedPeriod(currTP) = no;
5709   
5710  *   Solve the LP model and stop end --------------------------------------------
5711   
5712      ) ;
5713  *   Solve the models end
5714   
5715   
5716   
5717  *   6e. Check if the LP results are valid --------------------------------------
5718      if((ModelSolved = 1),
5719          useBranchFlowMIP(currTP) = 0 ;
5720          useMixedConstraintMIP(currTP) = 0 ;
5721  *       Check if there is no branch circular flow and non-physical losses
5722          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
5723   
5724  *           Check if there are circulating branch flows on loss AC branches
5725              circularBranchFlowExist(ACbranch(currTP,br))
5726                  $ { LossBranch(ACbranch) and
5727                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
5728                        - abs(ACBRANCHFLOW.l(ACbranch))
5729                        ) > circularBranchFlowTolerance
5730                      ]
5731                    } = 1 ;
5732   
5733  *           Determine the circular branch flow flag on each HVDC pole
5734              TotalHVDCpoleFlow(currTP,pole)
5735                  = sum[ br $ HVDCpoleBranchMap(pole,br)
5736                       , HVDCLINKFLOW.l(currTP,br) ] ;
5737   
5738              MaxHVDCpoleFlow(currTP,pole)
5739                  = smax[ br $ HVDCpoleBranchMap(pole,br)
5740                        , HVDCLINKFLOW.l(currTP,br) ] ;
5741   
5742              poleCircularBranchFlowExist(currTP,pole)
5743                  $ { ( TotalHVDCpoleFlow(currTP,pole)
5744                      - MaxHVDCpoleFlow(currTP,pole)
5745                      ) > circularBranchFlowTolerance
5746                    } = 1 ;
5747   
5748  *           Check if there are circulating branch flows on HVDC
5749              NorthHVDC(currTP)
5750                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
5751                                        i_tradePeriodBusIsland(currTP,b,ild) and
5752                                        HVDClinkSendingBus(currTP,br,b) and
5753                                        HVDCpoles(currTP,br)
5754                                      }, HVDCLINKFLOW.l(currTP,br)
5755                       ] ;
5756   
5757              SouthHVDC(currTP)
5758                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
5759                                        i_tradePeriodBusIsland(currTP,b,ild) and
5760                                        HVDClinkSendingBus(currTP,br,b) and
5761                                        HVDCpoles(currTP,br)
5762                                      }, HVDCLINKFLOW.l(currTP,br)
5763                       ] ;
5764   
5765              circularBranchFlowExist(currTP,br)
5766                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
5767                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
5768                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
5769                    } = 1 ;
5770   
5771  *           Check if there are non-physical losses on HVDC links
5772              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
5773                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5774                  and validLossSegment(currTP,br,los,fd) }
5775                  = Min[ Max( 0,
5776                              [ abs(HVDCLINKFLOW.l(HVDClink))
5777                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5778                              ]
5779                            ),
5780                         ( LossSegmentMW(HVDClink,los,fd)
5781                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5782                         )
5783                       ] ;
5784   
5785              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
5786                  = sum[ (los,fd) $ validLossSegment(currTP,br,los,fd)
5787                                  , LossSegmentFactor(HVDClink,los,fd)
5788                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
5789                       ] ;
5790   
5791              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
5792                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
5793                         - ManualLossCalculation(HVDClink)
5794                         ) > NonPhysicalLossTolerance
5795                    } = 1 ;
5796   
5797  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
5798  *           and non-physical loss branches exceeds the specified tolerance
5799              useBranchFlowMIP(currTP)
5800                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
5801                                , resolveCircularBranchFlows
5802                                * circularBranchFlowExist(currTP,br)
5803                           ]
5804                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
5805                                , (1 - AllowHVDCroundpower(currTP))
5806                                * resolveCircularBranchFlows
5807                                * circularBranchFlowExist(currTP,br)
5808                                + resolveHVDCnonPhysicalLosses
5809                                * NonPhysicalLossExist(currTP,br)
5810                           ]
5811                      + sum[ pole, resolveCircularBranchFlows
5812                                 * poleCircularBranchFlowExist(currTP,pole)
5813                           ]
5814                       ) > UseBranchFlowMIPTolerance
5815                                         } = 1 ;
5816   
5817  *       Check if there is no branch circular flow and non-physical losses end
5818          );
5819   
5820   
5821  *       Check if there is mixed constraint integer is required
5822          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
5823   
5824  *           Check if integer variables are needed for mixed constraint
5825              if( useMixedConstraintRiskOffset,
5826                  HVDChalfPoleSouthFlow(currTP)
5827                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
5828                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
5829                             ] > MixedMIPTolerance
5830                        } = 1 ;
5831   
5832  *               Only calculate violation if the constraint limit is non-zero
5833                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
5834                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
5835                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
5836                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5837                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
5838                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5839                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
5840                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
5841                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
5842                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5843                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
5844   
5845  *               Integer constraints are needed if southward flow on half-poles AND
5846  *               constraint level exceeds the mixed constraint limit2 value
5847                  useMixedConstraintMIP(currTP)
5848                      $ { HVDChalfPoleSouthFlow(currTP) and
5849                          sum[ t1MixCstr
5850                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
5851                                 > MixedMIPTolerance }, 1
5852                             ]
5853                        } = 1 ;
5854              ) ;
5855   
5856  *       Check if there is mixed constraint integer is required end
5857          );
5858   
5859  *       A period is unsolved if MILP model is required
5860          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
5861                                         + UseMixedConstraintMIP(currTP)
5862                                         ] ;
5863   
5864  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
5865          loop( unsolvedPeriod(currTP),
5866              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
5867                  VSPDModel(currTP) = 1;
5868                  putclose runlog 'The case: RTD_20211202_RTP requires a'
5869                                  'VSPD_MIP resolve for period ' currTP.tl
5870                                  '. Switching Vectorisation OFF.' /
5871   
5872              elseif UseBranchFlowMIP(currTP) >= 1,
5873                  if( VSPDModel(currTP) = 0,
5874                      VSPDModel(currTP) = 2;
5875                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5876                                      'vSPD_BranchFlowMIP resolve for period '
5877                                      currTP.tl '. Switching Vectorisation OFF.'/
5878                  elseif VSPDModel(currTP) = 3,
5879                      VSPDModel(currTP) = 1;
5880                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5881                                      'VSPD_MIP resolve for period ' currTP.tl
5882                                      '. Switching Vectorisation OFF.' /
5883                  );
5884   
5885              elseif UseMixedConstraintMIP(currTP) >= 1,
5886                  if( VSPDModel(currTP) = 0,
5887                      VSPDModel(currTP) = 3;
5888                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5889                                      'vSPD_MixedConstraintMIP resolve for period '
5890                                      currTP.tl '. Switching Vectorisation OFF.' /
5891                  elseif VSPDModel(currTP) = 2,
5892                      VSPDModel(currTP) = 1;
5893                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5894                                      'VSPD_MIP resolve for period ' currTP.tl
5895                                      '. Switching Vectorisation OFF.' /
5896                  );
5897   
5898              ) ;
5899   
5900          ) ;
5901   
5902          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
5903          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
5904   
5905  *   Check if the LP results are valid end
5906      ) ;
5907   
5908   
5909   
5910  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
5911   
5912  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
5913  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
5938   
5939      busGeneration(bus(currTP,b))
5940          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
5941               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
5942               ] ;
5943   
5944      busLoad(bus(currTP,b))
5945          = sum[ NodeBus(currTP,n,b)
5946               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
5947               ] ;
5948   
5949      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
5950          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
5951   
5952      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
5953          = DCNodeNetInjection.m(currTP,b) ;
5954   
5955      if((disconnectedNodePriceCorrection = 1),
5956  *       Pre-MSP case
5957          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
5958              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
5959                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
5960                                        branch(currTP,br)
5961                                      }, 1 ]
5962                      )
5963                    } ;
5964   
5965  *       Post-MSP cases
5966  *       Scenario C/F/G/H/I:
5967          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
5968                                         and (busLoad(bus) = 0)
5969                                         and (busElectricalIsland(bus) = 0)
5970                                           } = 1 ;
5971  *       Scenario E:
5972          busDisconnected(bus(currTP,b))
5973              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5974                              = busElectricalIsland(bus) }
5975                       , busLoad(currTP,b1) ] = 0
5976                  ) and
5977                  ( busElectricalIsland(bus) > 0 ) and
5978                  ( i_useBusNetworkModel(currTP) = 1 )
5979                } = 1 ;
5980  *       Set prices at dead buses with non-zero load
5981          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5982                                      (busLoad(bus) > 0) and
5983                                      (busElectricalIsland(bus)= 0)
5984                                    } = DeficitBusGenerationPenalty ;
5985   
5986          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5987                                      (busLoad(bus) < 0) and
5988                                      (busElectricalIsland(bus)= 0)
5989                                    } = -SurplusBusGenerationPenalty ;
5990   
5991  *       Set price at identified disconnected buses to 0
5992          busPrice(bus)$busDisconnected(bus) = 0 ;
5993      ) ;
5994   
5995  * End Check for disconnected nodes and adjust prices accordingly
5996   
5997  * TN - Replacing invalid prices after SOS1
5998  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
5999      if ( vSPD_SOS1_Solve(tp),
6000           busSOSinvalid(tp,b)
6001             = 1 $ { [ ( busPrice(tp,b) = 0 )
6002                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
6003                      or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
6004                       ]
6005                   and bus(tp,b)
6006                   and [ not busDisconnected(tp,b) ]
6007  *                 and [ busLoad(tp,b) = 0 ]
6008  *                 and [ busGeneration(tp,b) = 0 ]
6009                   and [ busLoad(tp,b) = busGeneration(tp,b) ]
6010                   and [ sum[(br,fd)
6011                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6012                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
6013                            ] = 0
6014                       ]
6015                   and [ sum[ br
6016                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6017                            , 1
6018                            ] > 0
6019                       ]
6020                     };
6021          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
6022          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
6023              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
6024              busPrice(tp,b)
6025                $ { busSOSinvalid(tp,b)
6026                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6027                              and sum[ br $ { branch(tp,br)
6028                                          and BranchBusConnect(tp,br,b)
6029                                          and BranchBusConnect(tp,br,b1)
6030                                            }, 1
6031                                     ]
6032                               }, 1
6033                         ] > 0
6034                    )
6035                  }
6036                = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6037                          and sum[ br $ { branch(tp,br)
6038                                      and BranchBusConnect(tp,br,b)
6039                                      and BranchBusConnect(tp,br,b1)
6040                                        }, 1 ]
6041                            }, busPrice(tp,b1)
6042                     ]
6043                / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6044                          and sum[ br $ { branch(tp,br)
6045                                      and BranchBusConnect(tp,br,b)
6046                                      and BranchBusConnect(tp,br,b1)
6047                                        }, 1 ]
6048                            }, 1
6049                     ];
6050   
6051              busSOSinvalid(tp,b)
6052                = 1 $ { [ ( busPrice(tp,b) = 0 )
6053                       or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
6054                       or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
6055                        ]
6056                    and bus(tp,b)
6057                    and [ not busDisconnected(tp,b) ]
6058  *                  and [ busLoad(tp,b) = 0 ]
6059  *                  and [ busGeneration(tp,b) = 0 ]
6060                    and [ busLoad(tp,b) = busGeneration(tp,b) ]
6061                    and [ sum[(br,fd)
6062                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6063                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
6064                             ] = 0
6065                        ]
6066                    and [ sum[ br
6067                             $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6068                             , 1
6069                             ] > 0
6070                        ]
6071                      };
6072           );
6073      );
6074  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
6075   
6076   
6077  *   6g. Collect and store results of solved periods into output parameters -----
6078  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
6079   
6081  *   Normal vSPD run post processing for reporting
6083      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
6084  *   Reporting at trading period start
6085  *       Node level output
6086          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
6087   
6088          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
6089              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
6090   
6091          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
6092             = NodeDemand(currTP,n)
6093             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
6094   
6095          o_nodePrice_TP(dt,n) $ Node(currTP,n)
6096              = sum[ b $ NodeBus(currTP,n,b)
6097                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
6098                    ] ;
6099   
6100  *       Offer output
6101          o_offer(dt,o) $ offer(currTP,o) = yes ;
6102   
6103          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
6104   
6105          o_offerFIR_TP(dt,o) $ offer(currTP,o)
6106              = sum[ (resC,resT)$(ord(resC) = 1)
6107                   , RESERVE.l(currTP,o,resC,resT) ] ;
6108   
6109          o_offerSIR_TP(dt,o) $ offer(currTP,o)
6110              = sum[ (resC,resT)$(ord(resC) = 2)
6111                   , RESERVE.l(currTP,o,resC,resT) ] ;
6112   
6113  *       Bus level output
6114          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
6115   
6116          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
6117   
6118          o_busLoad_TP(dt,b) $ bus(currTP,b)
6119              = busLoad(currTP,b)
6120              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
6121                   , PURCHASE.l(currTP,bd) ];
6122   
6123          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
6124   
6125          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
6126   
6127          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
6128   
6129  *       Node level output
6130   
6131          totalBusAllocation(dt,b) $ bus(currTP,b)
6132              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
6133   
6134          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
6135              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
6136   
6137  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
6151          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
6152              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
6153   
6154          changedDeficitBus(dt,b) = no;
6155   
6156          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
6157   
6158              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
6159   
6160              Loop b $ unmappedDeficitBus(dt,b) do
6161                  o_busDeficit_TP(dt,b1)
6162                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
6163                                and ( branchBusDefn(tp,br,b1,b)
6164                                   or branchBusDefn(tp,br,b,b1) )
6165                                  }, 1 ]
6166                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
6167   
6168                  changedDeficitBus(dt,b1)
6169                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
6170                              and ( branchBusDefn(tp,br,b1,b)
6171                                 or branchBusDefn(tp,br,b,b1) )
6172                                }, 1 ] = yes;
6173   
6174                  unmappedDeficitBus(dt,b) = no;
6175                  changedDeficitBus(dt,b) = no;
6176                  o_busDeficit_TP(dt,b) = 0;
6177              EndLoop;
6178   
6179              Loop n $ sum[ b $ changedDeficitBus(dt,b)
6180                          , busNodeAllocationFactor(dt,b,n)] do
6181                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
6182                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
6183                                                    busNodeAllocationFactor(dt,b,n)
6184                                                  * o_busDeficit_TP(dt,b) ] ;
6185              EndLoop;
6186   
6187              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
6188          Endif;
6189  * TN - post processing unmapped generation deficit buses end
6190   
6191          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
6192              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
6193                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
6194   
6195          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
6196              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
6197                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
6198   
6199  *       branch output
6200          o_branch(dt,br) $ branch(currTP,br) = yes ;
6201   
6202          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
6203   
6204          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
6205   
6206          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
6207              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
6208   
6209          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
6210              = HVDCLINKLOSSES.l(currTP,br) ;
6211   
6212          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
6213              = branchFixedLoss(currTP,br) ;
6214   
6215          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
6216              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
6217   
6218          o_branchFromBus_TP(dt,br,frB)
6219              $ { branch(currTP,br) and
6220                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
6221                } = yes ;
6222   
6223          o_branchToBus_TP(dt,br,toB)
6224              $ { branch(currTP,br) and
6225                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
6226                } = yes ;
6227   
6228          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
6229              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
6230   
6231          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
6232              = HVDClinkMaximumFlow.m(currTP,br) ;
6233   
6234          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
6235              = sum[ fd $ ( ord(fd) = 1 )
6236                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
6237                   ] $  { o_branchFlow_TP(dt,br) >= 0 }
6238              + sum[ fd $ ( ord(fd) = 2 )
6239                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
6240                   ] $  { o_branchFlow_TP(dt,br) < 0 } ;
6241   
6242   
6243  *       Offer output
6244          o_offerEnergyBlock_TP(dt,o,trdBlk)
6245              = GENERATIONBLOCK.l(currTP,o,trdBlk);
6246   
6247          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
6248              = sum[ resC $ (ord(resC) = 1)
6249              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
6250   
6251          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
6252              = sum[ resC $ (ord(resC) = 2)
6253              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
6254   
6255  *       bid output
6256          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
6257   
6258          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
6259   
6260          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
6261              = sum[ resC $ (ord(resC) = 1)
6262                   , PURCHASEILR.l(currTP,bd,resC) ] ;
6263   
6264          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
6265              = sum[ resC $ (ord(resC) = 2)
6266                   , PURCHASEILR.l(currTP,bd,resC) ] ;
6267   
6268          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
6269              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
6270   
6271  *       Violation reporting based on the CE and ECE
6272          o_ResViolation_TP(dt,ild,resC)
6273              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
6274              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
6275              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
6276   
6277          o_FIRviolation_TP(dt,ild)
6278              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
6279   
6280          o_SIRviolation_TP(dt,ild)
6281              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
6282   
6283  *       Security constraint data
6284          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
6285   
6286          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6287              = branchConstraintSense(currTP,brCstr) ;
6288   
6289          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6290              = [ branchSecurityConstraintLE.l(currTP,brCstr)
6291                $ (branchConstraintSense(currTP,brCstr) = -1) ]
6292              + [ branchSecurityConstraintGE.l(currTP,brCstr)
6293                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
6294              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
6295                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
6296   
6297          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6298              = branchConstraintLimit(currTP,brCstr) ;
6299   
6300          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6301              = [ branchSecurityConstraintLE.m(currTP,brCstr)
6302                $ (branchConstraintSense(currTP,brCstr) = -1) ]
6303              + [ branchSecurityConstraintGE.m(currTP,brCstr)
6304                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
6305              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
6306                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
6307   
6308  *       Mnode constraint data
6309          o_MnodeConstraint_TP(dt,MnodeCstr)
6310              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
6311   
6312          o_MnodeConstraintSense_TP(dt,MnodeCstr)
6313              $ MnodeConstraint(currTP,MnodeCstr)
6314              = MnodeConstraintSense(currTP,MnodeCstr) ;
6315   
6316          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
6317              $ MnodeConstraint(currTP,MnodeCstr)
6318              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
6319                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
6320              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
6321                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
6322              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
6323                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
6324   
6325          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
6326              $ MnodeConstraint(currTP,MnodeCstr)
6327              = MnodeConstraintLimit(currTP,MnodeCstr) ;
6328   
6329          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
6330              $ MnodeConstraint(currTP,MnodeCstr)
6331              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
6332                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
6333              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
6334                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
6335              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
6336                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
6337   
6338  *       Island output
6339          o_island(dt,ild) = yes ;
6340   
6341          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
6342   
6343          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6344                                            , o_ResPrice_TP(dt,ild,resC) ];
6345   
6346          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6347                                            , o_ResPrice_TP(dt,ild,resC) ];
6348   
6349          o_islandGen_TP(dt,ild)
6350              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
6351   
6352          o_islandClrBid_TP(dt,ild)
6353              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
6354   
6355          o_islandLoad_TP(dt,ild)
6356              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
6357              + o_islandClrBid_TP(dt,ild) ;
6358   
6359          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
6360   
6361          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
6362                                              , o_ResCleared_TP(dt,ild,resC) ];
6363   
6364          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
6365                                              , o_ResCleared_TP(dt,ild,resC) ];
6366   
6367          o_islandBranchLoss_TP(dt,ild)
6368              = sum[ (br,frB,toB)
6369                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
6370                   and branchBusDefn(currTP,br,frB,toB)
6371                     }, o_branchTotalLoss_TP(dt,br) ] ;
6372   
6373          o_HVDCflow_TP(dt,ild)
6374              = sum[ (br,frB,toB)
6375                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
6376                   and branchBusDefn(currTP,br,frB,toB)
6377                     }, o_branchFlow_TP(dt,br) ] ;
6378   
6379          o_HVDChalfPoleLoss_TP(dt,ild)
6380              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
6381                                      branchBusDefn(currTP,br,frB,toB) and
6382                                      busIsland(currTP,toB,ild) and
6383                                      busIsland(currTP,frB,ild)
6384                                        }, o_branchTotalLoss_TP(dt,br)
6385                   ] ;
6386   
6387          o_HVDCpoleFixedLoss_TP(dt,ild)
6388              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
6389                                      branchBusDefn(currTP,br,frB,toB) and
6390                                      ( busIsland(currTP,toB,ild) or
6391                                        busIsland(currTP,frB,ild)
6392                                      )
6393                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
6394                   ] ;
6395   
6396          o_HVDCloss_TP(dt,ild)
6397              = o_HVDChalfPoleLoss_TP(dt,ild)
6398              + o_HVDCpoleFixedLoss_TP(dt,ild)
6399              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
6400                                      branchBusDefn(currTP,br,frB,toB) and
6401                                      busIsland(currTP,toB,ild) and
6402                                      (not (busIsland(currTP,frB,ild)))
6403                                    }, o_branchDynamicLoss_TP(dt,br)
6404                   ] ;
6405   
6406  * TN - The code below is added for NMIR project ================================
6407          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
6408              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
6409   
6410          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
6411   
6412              o_FirSent_TP(dt,ild)
6413                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6414                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
6415   
6416              o_FirReceived_TP(dt,ild)
6417                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6418                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
6419   
6420              o_FirEffective_TP(dt,ild,riskC)
6421                  = Sum[ resC $ (ord(resC) = 1),
6422                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6423   
6424              o_FirEffReport_TP(dt,ild)
6425                  = Smax[ (resC,riskC) $ (ord(resC)=1)
6426                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6427   
6428          Endif;
6429   
6430          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
6431   
6432              o_SirSent_TP(dt,ild)
6433                  = Sum[ (rd,resC) $ (ord(resC) = 2),
6434                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
6435   
6436              o_SirReceived_TP(dt,ild)
6437                  = Sum[ (fd,resC) $ (ord(resC) = 2),
6438                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
6439   
6440              o_SirEffective_TP(dt,ild,riskC)
6441                  = Sum[ resC $ (ord(resC) = 2),
6442                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6443   
6444              o_SirEffReport_TP(dt,ild)
6445                  = Smax[ (resC,riskC) $ (ord(resC)=2)
6446                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6447          Endif;
6448   
6449   
6450  * TN - The code for NMIR project end ===========================================
6451   
6452  *       Additional output for audit reporting
6453          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
6454   
6455  *       Check if there are non-physical losses on AC branches
6456          ManualBranchSegmentMWFlow(LossBranch(ACbranch(currTP,br)),los,fd)
6457                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
6458                  and validLossSegment(ACbranch,los,fd)
6459                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
6460                    }
6461                  = Min[ Max( 0,
6462                              [ abs(o_branchFlow_TP(dt,br))
6463                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6464                              ]
6465                            ),
6466                         ( LossSegmentMW(ACbranch,los,fd)
6467                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6468                         )
6469                       ] ;
6470   
6471          ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
6472                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
6473                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
6474                    }
6475                  = Min[ Max( 0,
6476                              [ abs(o_branchFlow_TP(dt,br))
6477                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6478                              ]
6479                            ),
6480                         ( LossSegmentMW(HVDClink,los,fd)
6481                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6482                         )
6483                       ] ;
6484   
6485          ManualLossCalculation(LossBranch(branch(currTP,br)))
6486              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
6487                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
6488   
6489          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
6490                                   - ManualLossCalculation(currTP,br) ;
6491   
6492          o_lossSegmentBreakPoint(dt,br,los)
6493              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6494                         and (ord(fd) = 1)
6495                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6496              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6497                         and (ord(fd) = 2)
6498                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6499          ;
6500   
6501          o_lossSegmentFactor(dt,br,los)
6502              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6503                         and (ord(fd) = 1)
6504                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6505              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6506                         and (ord(fd) = 2)
6507                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6508          ;
6509   
6510          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
6511   
6512          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
6513              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
6514                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
6515   
6516          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
6517              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
6518                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
6519   
6520          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
6521              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
6522                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6523   
6524          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
6525              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
6526                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6527   
6528          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
6529              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
6530                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6531   
6532          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
6533              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
6534                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6535   
6536          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6537                                                offerNode(currTP,o,n)
6538                                              }, o_ILRO_FIR_TP(dt,o) ] ;
6539   
6540          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6541                                                offerNode(currTP,o,n)
6542                                              }, o_ILRO_SIR_TP(dt,o) ] ;
6543   
6544          o_marketNodeIsland_TP(dt,o,ild)
6545              $ sum[ n $ { offerIsland(currTP,o,ild) and
6546                           offerNode(currTP,o,n) and
6547                           (o_nodeLoad_TP(dt,n)  = 0)
6548                         },1
6549                   ] = yes ;
6550   
6551          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
6552              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
6553              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6554              ;
6555   
6556          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
6557              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
6558   
6559          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6560              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
6561   
6562          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
6563              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
6564   
6565          o_manuRiskLevel(dt,ild,resC,ManualRisk)
6566              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
6567              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
6568              ;
6569   
6570          o_manuRiskPrice(dt,ild,resC,ManualRisk)
6571              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
6572   
6573          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
6574              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
6575   
6576          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
6577              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
6578   
6579          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
6580              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
6581   
6582          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
6583              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
6584   
6585          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
6586              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6587              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
6588              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6589              ;
6590   
6591          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
6592              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6593              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
6594   
6595  *       FIR and SIR required based on calculations of the island risk to
6596  *       overcome reporting issues of the risk setter under degenerate
6597  *       conditions when reserve price = 0 - See below
6598   
6599          o_ReserveReqd_TP(dt,ild,resC)
6600              = Max[ 0,
6601                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
6602                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
6603                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
6604                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
6605                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
6606                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
6607                   ] ;
6608   
6609          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
6610          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
6611   
6612  *       Summary reporting by trading period
6613          o_solveOK_TP(dt) = ModelSolved ;
6614   
6615          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
6616   
6617          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
6618   
6619          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
6620   
6621          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
6622                       - o_systemCost_TP(dt)
6623                       - o_penaltyCost_TP(dt);
6624   
6625   
6626  *       Separete violation reporting at trade period level
6627          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
6628   
6629          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
6630   
6631          o_surpBranchFlow_TP(dt)
6632              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
6633   
6634          o_defRampRate_TP(dt)
6635              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
6636   
6637          o_surpRampRate_TP(dt)
6638              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
6639   
6640          o_surpBranchGroupConst_TP(dt)
6641              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6642                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6643   
6644          o_defBranchGroupConst_TP(dt)
6645              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6646                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6647   
6648          o_defMnodeConst_TP(dt)
6649              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6650                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6651   
6652          o_surpMnodeConst_TP(dt)
6653              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6654                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6655   
6656          o_defACnodeConst_TP(dt)
6657              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6658                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6659   
6660          o_surpACnodeConst_TP(dt)
6661              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6662                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6663   
6664          o_defT1MixedConst_TP(dt)
6665              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6666                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6667   
6668          o_surpT1MixedConst_TP(dt)
6669              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6670                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6671   
6672          o_defGenericConst_TP(dt)
6673              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6674                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6675   
6676          o_surpGenericConst_TP(dt)
6677              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6678                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6679   
6680          o_defResv_TP(dt)
6681              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
6682   
6683          o_totalViolation_TP(dt)
6684              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
6685              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
6686              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
6687              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
6688              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
6689              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
6690              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
6691              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
6692   
6693  *       Virtual reserve
6694          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
6695   
6696          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6697                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6698   
6699          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6700                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6701   
6702  *   Reporting at trading period end
6703      EndLoop;
6705   
6707   
6708  * End of the solve vSPD loop
6709    ] ;
6710  * End of the While loop
6711  );
6712   
6713   
6714  *   Summary reports - only applied for normal and audit vSPD run.
6716   
6717  *   System level
6718      o_numTradePeriods = card(tp) ;
6719   
6720      o_systemOFV = sum[ dt, o_ofv_TP(dt) ] ;
6721   
6722      o_systemGen = sum[ (dt,ild), o_islandGen_TP(dt,ild) ] ;
6723   
6724      o_systemLoad = sum[ (dt,ild), o_islandLoad_TP(dt,ild)
6725                                  - o_islandClrBid_TP(dt,ild) ] ;
6726   
6727      o_systemLoss = sum[ (dt,ild), o_islandBranchLoss_TP(dt,ild)
6728                                  + o_HVDCloss_TP(dt,ild) ] ;
6729   
6730      o_systemViolation = sum[ dt, o_totalViolation_TP(dt) ] ;
6731   
6732      o_systemFIR = sum[ (dt,ild), o_FIRcleared_TP(dt,ild) ] ;
6733   
6734      o_systemSIR = sum[ (dt,ild), o_SIRcleared_TP(dt,ild) ] ;
6735   
6736   
6737  *   Offer level - This does not include revenue from wind generators for
6738  *   final pricing because the wind generation is netted off against load
6739  *   at the particular bus for the final pricing solves
6740   
6741      o_offerTrader(o,trdr)
6742          $ sum[ tp $ i_tradePeriodOfferTrader(tp,o,trdr), 1 ] = yes ;
6743   
6744      o_offerGen(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerEnergy_TP(dt,o)] ;
6745   
6746      o_offerFIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerFIR_TP(dt,o)] ;
6747   
6748      o_offerSIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerSIR_TP(dt,o)] ;
6749   
6751   
6752   
6753  *=====================================================================================
6754  * 8. vSPD scarcity pricing post-processing
6755  *=====================================================================================
6757   
6758  * Mapping scarcity area to islands
6759  scarcityAreaIslandMap(sarea,ild)      = no ;
6760  scarcityAreaIslandMap('NI','NI')      = yes ;
6761  scarcityAreaIslandMap('SI','SI')      = yes ;
6762  scarcityAreaIslandMap('National',ild) = yes ;
6763   
6765   
6766   
6767  * 8b. Calculating price-relating outputs --------------------------------------
6768   
6770  loop(i_dateTimeTradePeriodMap(dt,tp),
6771   
6772  *   bus output update
6773      o_busRevenue_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6774                                        * o_busGeneration_TP(dt,b)
6775                                        * o_busPrice_TP(dt,b) ;
6776   
6777      o_busCost_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6778                                     * o_busLoad_TP(dt,b)
6779                                     * o_busPrice_TP(dt,b);
6780   
6781  *   node output update
6782      o_nodeRevenue_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6783                                          * o_nodeGeneration_TP(dt,n)
6784                                          * o_nodePrice_TP(dt,n) ;
6785   
6786      o_nodeCost_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6787                                       * o_nodeLoad_TP(dt,n)
6788                                       * o_nodePrice_TP(dt,n) ;
6789   
6790  *   branch output update
6791      o_branchFromBusPrice_TP(dt,br) $ branch(tp,br)
6792          = sum[ b $ o_branchFromBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6793   
6794      o_branchToBusPrice_TP(dt,br) $ branch(tp,br)
6795          = sum[ b $ o_branchToBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6796   
6797      o_branchTotalRentals_TP(dt,br)
6798          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) >= 0) }
6799          = (i_tradingPeriodLength/60)
6800          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6801            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
6802            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6803            ] ;
6804   
6805      o_branchTotalRentals_TP(dt,br)
6806          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) < 0) }
6807          = (i_tradingPeriodLength/60)
6808          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6809            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6810            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
6811            ] ;
6812   
6813  *   Island output
6814      o_islandRefPrice_TP(dt,ild)
6815          = sum[ n $ { referenceNode(tp,n)
6816                   and nodeIsland(tp,n,ild) } , o_nodePrice_TP(dt,n) ] ;
6817   
6818      o_islandEnergyRevenue_TP(dt,ild)
6819          = sum[ n $ nodeIsland(tp,n,ild), o_nodeRevenue_TP(dt,n)] ;
6820   
6821      o_islandReserveRevenue_TP(dt,ild) = sum[ resC, o_ResCleared_TP(dt,ild,resC)
6822                                                   * o_ResPrice_TP(dt,ild,resC)
6823                                                   * i_tradingPeriodLength/60 ];
6824   
6825      o_islandLoadCost_TP(dt,ild)
6826          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
6827               , o_nodeCost_TP(dt,n) ] ;
6828   
6829      o_islandLoadRevenue_TP(dt,ild)
6830          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
6831               , - o_nodeCost_TP(dt,n) ] ;
6832   
6834  ) ;
6835   
6836  * System level
6837  o_systemEnergyRevenue  = sum[ (dt,ild), o_islandEnergyRevenue_TP(dt,ild) ] ;
6838   
6839  o_systemReserveRevenue = sum[ (dt,ild), o_islandReserveRevenue_TP(dt,ild) ];
6840   
6841  o_systemLoadCost       = sum[ (dt,ild), o_islandLoadCost_TP(dt,ild) ];
6842   
6843  o_systemLoadRevenue    = sum[ (dt,ild), o_islandLoadRevenue_TP(dt,ild) ];
6844   
6845  * Offer level
6846  o_offerGenRevenue(o)
6847      = sum[ (dt,tp,n) $ { i_dateTimeTradePeriodMap(dt,tp) and offerNode(tp,o,n) }
6848           , (i_tradingPeriodLength/60)
6849           * o_offerEnergy_TP(dt,o) * o_nodePrice_TP(dt,n) ] ;
6850   
6851  o_offerFIRrevenue(o)
6852      = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6853                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6854           , (i_tradingPeriodLength/60)
6855           * o_offerFIR_TP(dt,o) * o_FIRprice_TP(dt,ild) ] ;
6856   
6857  o_offerSIRrevenue(o)
6858     = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6859                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6860           , (i_tradingPeriodLength/60)
6861           * o_offerSIR_TP(dt,o) * o_SIRprice_TP(dt,ild) ] ;
6862   
6864  *   Calculating price-relating outputs end -------------------------------------
6865   
6866   
6868   
6869  *=====================================================================================
6870  * 9. Write results to CSV report files and GDX files
6871  *=====================================================================================
6872  * TN - Pivot analysis end
INCLUDE    C:\vSPD\GitHub\Programs\vSPDreport.gms
6874  *=====================================================================================
6875  * Name:                 vSPDreport.gms
6876  * Function:             Creates the detailed reports for normal SPD mode
6877  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
6878  * Source:               https://github.com/ElectricityAuthority/vSPD
6879  *                       https://www.emi.ea.govt.nz/Tools/vSPD
6880  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
6881  *                       Email: emi@ea.govt.nz
6882  * Last modified on:     1 Oct 2019
6883  *
6884  *=====================================================================================
6885   
6886  * Normal vSPD run output
6887  o_FromDateTime(dt)$( ord(dt) = 1 ) = yes ;
6888   
6889  * System surplus needs to be calculated outside the main loop
6890  o_systemSurplus = o_systemLoadCost-o_systemLoadRevenue-o_systemEnergyRevenue ;
6891   
6892  * Trader level - Currently this does not include revenue from wind generators
6893  * since wind generation in FP is represented as negative load
6894  o_trader(trdr) = yes ;
6895  o_traderGen(trdr) = sum(o_offerTrader(o,trdr), o_offerGen(o)) ;
6896  o_traderFIR(trdr) = sum(o_offerTrader(o,trdr), o_offerFIR(o)) ;
6897  o_traderSIR(trdr) = sum(o_offerTrader(o,trdr), o_offerSIR(o)) ;
6898  o_traderGenRevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerGenRevenue(o));
6899  o_traderFIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerFIRrevenue(o));
6900  o_traderSIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerSIRrevenue(o));
6901   
6902   
6903  *=====================================================================================
6904  * Writing data in to CSV result files
6905  *=====================================================================================
6906   
6907  * System level summary
6908  File SystemResults    / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_SystemResults.csv" / ;
6909  SystemResults.pc = 5 ;     SystemResults.lw = 0 ;
6910  SystemResults.pw = 9999 ;  SystemResults.ap = 1 ;
6911  put SystemResults ;
6912  loop( dt $ o_FromDateTime(dt),
6913      put dt.tl, o_NumTradePeriods, o_systemOFV, o_systemGen, o_systemLoad
6914          o_systemLoss, o_systemViolation, o_systemFIR, o_systemSIR
6915          o_systemEnergyRevenue, o_systemLoadCost, o_systemLoadRevenue
6916          o_systemSurplus / ;
6917  ) ;
6918   
6919  * Offer level summary
6920  File  OfferResults     / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_OfferResults.csv" / ;
6921  OfferResults.pc = 5 ;      OfferResults.lw = 0 ;
6922  OfferResults.pw = 9999 ;   OfferResults.ap = 1 ;
6923  put OfferResults ;
6924  loop( (dt,o,trdr)
6925      $ { o_FromDateTime(dt) and o_offerTrader(o,trdr) and
6926          [ o_offerGen(o) or o_offerFIR(o) or o_offerSIR(o) ]
6927        },
6928      put dt.tl, o_NumTradePeriods, o.tl, trdr.tl
6929          o_offerGen(o), o_offerFIR(o), o_offerSIR(o) / ;
6930  ) ;
6931   
6932  * Trader level summary
6933  File  TraderResults   / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_TraderResults.csv" / ;
6934  TraderResults.pc = 5 ;     TraderResults.lw = 0 ;
6935  TraderResults.pw = 9999 ;  TraderResults.ap = 1 ;
6936  put TraderResults ;
6937  loop( (dt,trdr)
6938      $ { o_FromDateTime(dt) and o_trader(trdr) and
6939          [ o_traderGen(trdr) or o_traderFIR(trdr) or o_traderSIR(trdr) ]
6940        },
6941      put dt.tl, o_NumTradePeriods, trdr.tl
6942          o_traderGen(trdr), o_traderFIR(trdr), o_traderSIR(trdr) / ;
6943  ) ;
6944   
6945   
6946  * Trading period level report
6948   
6949  * Trading period summary result
6950  File
6951  SummaryResults_TP / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_SummaryResults_TP.csv" / ;
6952  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
6953  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
6954  SummaryResults_TP.nd = 5 ;
6955  put SummaryResults_TP ;
6956  loop( dt,
6957      put dt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
6958          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
6959          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
6960          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
6961          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
6962          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
6963          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt)
6964          o_DefACNodeConst_TP(dt), o_SurpACNodeConst_TP(dt)
6965          o_DefT1MixedConst_TP(dt), o_SurpT1MixedConst_TP(dt)
6966          o_DefGenericConst_TP(dt), o_SurpGenericConst_TP(dt) / ;
6967  ) ;
6968   
6969  * Trading period island result
6970  File IslandResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_IslandResults_TP.csv"/;
6971  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
6972  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
6973  IslandResults_TP.nd = 5 ;
6974  put IslandResults_TP ;
6975  loop( (dt,ild) $ o_island(dt,ild),
6976      put dt.tl, ild.tl, o_islandGen_TP(dt,ild), o_islandLoad_TP(dt,ild)
6977          o_islandClrBid_TP(dt,ild), o_islandBranchLoss_TP(dt,ild)
6978          o_HVDCFlow_TP(dt,ild), o_HVDCLoss_TP(dt,ild)
6979          o_islandRefPrice_TP(dt,ild), o_FIRReqd_TP(dt,ild)
6980          o_SIRReqd_TP(dt,ild), o_FIRPrice_TP(dt,ild)
6981          o_SIRPrice_TP(dt,ild), o_islandEnergyRevenue_TP(dt,ild)
6982          o_islandLoadCost_TP(dt,ild), o_islandLoadRevenue_TP(dt,ild)
6983  * NIRM output
6984      o_FirCleared_TP(dt,ild), o_SirCleared_TP(dt,ild)
6985      o_FirSent_TP(dt,ild), o_SirSent_TP(dt,ild)
6986      o_FirReceived_TP(dt,ild), o_SirReceived_TP(dt,ild)
6987      o_FirEffReport_TP(dt,ild), o_SirEffReport_TP(dt,ild)
6988  *NIRM output end
6989      / ;
6990  ) ;
6991   
6993   
6994  * Trading period bus result
6995  File BusResults_TP   / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_BusResults_TP.csv" / ;
6996  BusResults_TP.pc = 5 ;
6997  BusResults_TP.lw = 0 ;
6998  BusResults_TP.pw = 9999 ;
6999  BusResults_TP.ap = 1 ;
7000  BusResults_TP.nd = 3
7001  put BusResults_TP ;
7002  loop( o_bus(dt,b),
7003      put dt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
7004          o_busPrice_TP(dt,b), o_busRevenue_TP(dt,b), o_busCost_TP(dt,b)
7005          o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
7006  ) ;
7007   
7008  * Trading period node result
7009  File NodeResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_NodeResults_TP.csv" / ;
7010  NodeResults_TP.pc = 5 ;
7011  NodeResults_TP.lw = 0 ;
7012  NodeResults_TP.pw = 9999 ;
7013  NodeResults_TP.ap = 1 ;
7014  NodeResults_TP.nd = 3 ;
7015  put NodeResults_TP ;
7016  loop( (dt,n) $ o_node(dt,n),
7017      put dt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
7018          o_nodePrice_TP(dt,n), o_nodeRevenue_TP(dt,n), o_nodeCost_TP(dt,n)
7019          o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
7020  ) ;
7021   
7022  * Trading period offer result
7023  File OfferResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_OfferResults_TP.csv"/ ;
7024  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
7025  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
7026  OfferResults_TP.nd = 3 ;
7027  put OfferResults_TP ;
7028  loop( (dt,o) $ o_offer(dt,o),
7029      put dt.tl, o.tl, o_offerEnergy_TP(dt,o)
7030          o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
7031  ) ;
7032   
7033  * Trading period bid result
7034  File BidResults_TP    / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_BidResults_TP.csv" / ;
7035  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
7036  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
7037  BidResults_TP.nd = 3 ;
7038  put BidResults_TP ;
7039  loop( (dt,bd) $ o_bid(dt,bd),
7040      put dt.tl, bd.tl, o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd)
7041      o_bidFIR_TP(dt,bd), o_bidSIR_TP(dt,bd) / ;
7042  ) ;
7043   
7044  * Trading period reserve result
7045  File
7046  ReserveResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_ReserveResults_TP.csv" / ;
7047  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
7048  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
7049  ReserveResults_TP.nd = 3 ;
7050  put ReserveResults_TP ;
7051  loop( (dt,ild) $ o_island(dt,ild),
7052      put dt.tl, ild.tl, o_FIRReqd_TP(dt,ild), o_SIRReqd_TP(dt,ild)
7053          o_FIRPrice_TP(dt,ild), o_SIRPrice_TP(dt,ild)
7054          o_FIRViolation_TP(dt,ild), o_SIRViolation_TP(dt,ild)
7055          o_FIRvrMW_TP(dt,ild), o_SIRvrMW_TP(dt,ild) / ;
7056  ) ;
7057   
7058  * Trading period branch result
7059  File
7060  BranchResults_TP  / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_BranchResults_TP.csv" / ;
7061  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
7062  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
7063  BranchResults_TP.nd = 5 ;
7064  put BranchResults_TP ;
7065  loop( (dt,br,frB,toB)
7066      $ { o_branchToBus_TP(dt,br,toB) and
7067          o_branchFromBus_TP(dt,br,frB) and o_branch(dt,br)
7068        },
7069      put dt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
7070          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
7071          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
7072          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
7073          o_branchTotalRentals_TP(dt,br) / ;
7074  ) ;
7075   
7076  * Trading period branch constraint result
7077  File BrCstrResults_TP
7078  / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_BrConstraintResults_TP.csv" / ;
7079  BrCstrResults_TP.pc = 5 ;
7080  BrCstrResults_TP.lw = 0 ;
7081  BrCstrResults_TP.pw = 9999 ;
7082  BrCstrResults_TP.ap = 1 ;
7083  BrCstrResults_TP.nd = 5 ;
7084  put BrCstrResults_TP ;
7085  loop( (dt,brCstr) $ o_brConstraint_TP(dt,brCstr),
7086      put dt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
7087          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
7088          o_brConstraintPrice_TP(dt,brCstr) / ;
7089  ) ;
7090   
7091  * Trading period market node constraint result
7092  File MnodeCstrResults_TP
7093  / "C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_MnodeConstraintResults_TP.csv" / ;
7094  MnodeCstrResults_TP.pc = 5 ;
7095  MnodeCstrResults_TP.lw = 0 ;
7096  MnodeCstrResults_TP.pw = 9999 ;
7097  MnodeCstrResults_TP.ap = 1 ;
7098  MnodeCstrResults_TP.nd = 5 ;
7099  put MnodeCstrResults_TP ;
7100  loop( (dt,MnodeCstr) $ o_MnodeConstraint_TP(dt,MnodeCstr),
7101      put dt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
7102          o_MnodeConstraintSense_TP(dt,MnodeCstr)
7103          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
7104          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
7105  ) ;
7106   
7108  *===============================================================================
7109   
7110   
7111   
7112  *===============================================================================
7113  * Audit mode reporting process
7114  *===============================================================================
7116   
7117  * Introduce zero tolerance to detect risk setter due to rounding issues
7118  Scalar zeroTolerance / 0.000001 / ;
7119   
7120   
7121  * Audit - branch loss result
7122  File branchLoss_Audit /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_BranchLoss.csv"/;
7123  branchLoss_Audit.pc = 5 ;
7124  branchLoss_Audit.lw = 0 ;
7125  branchLoss_Audit.pw = 9999 ;
7126  BranchLoss_Audit.ap = 1 ;
7127  BranchLoss_Audit.nd = 9 ;
7128  put BranchLoss_Audit ;
7129  loop( (dt,br) $ o_branch(dt,br),
7130      put dt.tl, br.tl ;
7131      loop(los $ o_LossSegmentBreakPoint(dt,br,los),
7132          put o_LossSegmentBreakPoint(dt,br,los)
7133              o_LossSegmentFactor(dt,br,los) ;
7134      )
7135      put / ;
7136  ) ;
7137   
7138  * Audit - bus result
7139  File busResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_BusResults.csv"/;
7140  busResults_Audit.pc = 5 ;
7141  busResults_Audit.lw = 0 ;
7142  busResults_Audit.pw = 9999 ;
7143  BusResults_Audit.ap = 1 ;
7144  BusResults_Audit.nd = 5 ;
7145  put BusResults_Audit ;
7146  loop( (dt,b,ild) $ { o_bus(dt,b) and o_busIsland_TP(dt,b,ild) },
7147      put dt.tl, ild.tl, b.tl, o_ACBusAngle(dt,b)
7148          o_busPrice_TP(dt,b), o_busLoad_TP(dt,b)
7149          o_ILBus_FIR_TP(dt,b), o_ILBus_SIR_TP(dt,b) / ;
7150  ) ;
7151   
7152  * Audit - market node result
7153  File
7154  MNodeResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_MNodeResults.csv"/;
7155  MNodeResults_Audit.pc = 5 ;
7156  MNodeResults_Audit.lw = 0 ;
7157  MNodeResults_Audit.pw = 9999 ;
7158  MNodeResults_Audit.ap = 1 ;
7159  MNodeResults_Audit.nd = 5 ;
7160  put MNodeResults_Audit ;
7161  loop( (dt,o,ild) $ {o_offer(dt,o) and o_MarketNodeIsland_TP(dt,o,ild) },
7162      put dt.tl, ild.tl, o.tl, o_offerEnergy_TP(dt,o)
7163          o_PLRO_FIR_TP(dt,o), o_PLRO_SIR_TP(dt,o)
7164          o_TWRO_FIR_TP(dt,o), o_TWRO_SIR_TP(dt,o) / ;
7165  ) ;
7166   
7167  * Audit - branch result
7168  File
7169  brchResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_BranchResults.csv"/;
7170  brchResults_Audit.pc = 5 ;
7171  brchResults_Audit.lw = 0 ;
7172  brchResults_Audit.pw = 9999 ;
7173  brchResults_Audit.ap = 1 ;
7174  brchResults_Audit.nd = 9 ;
7175  put brchResults_Audit ;
7176  loop( (dt,br) $ o_branch(dt,br),
7177      put dt.tl, br.tl, o_branchFlow_TP(dt,br)
7178          o_branchDynamicLoss_TP(dt,br), o_branchFixedLoss_TP(dt,br)
7179          [o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br)] ;
7180      if ( o_branchMarginalPrice_TP(dt,br) <> 0,  put 'Y' ;
7181      else                                        put 'N' ;
7182      ) ;
7183   
7184      put o_branchMarginalPrice_TP(dt,br) ;
7185   
7186      if( o_NonPhysicalLoss(dt,br) > NonPhysicalLossTolerance, put 'Y' / ;
7187      else                                                     put 'N' / ;
7188      ) ;
7189  ) ;
7190   
7191  * Audit - risk result
7192  File
7193  riskResults_Audit    /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_RiskResults.csv"/;
7194  riskResults_Audit.pc = 5 ;
7195  riskResults_Audit.lw = 0 ;
7196  riskResults_Audit.pw = 9999 ;
7197  RiskResults_Audit.ap = 1 ;
7198  RiskResults_Audit.nd = 5 ;
7199  put RiskResults_Audit ;
7200  loop( (dt,ild,resC) $ o_island(dt,ild),
7201      loop( (o,GenRisk) $ { ( o_generationRiskLevel(dt,ild,o,resC,GenRisk) > 0 )
7202                        and ( abs[ o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
7203                                 - o_ReserveReqd_TP(dt,ild,resC)
7204                                 ] <= ZeroTolerance )
7205                           },
7206          put dt.tl, ild.tl, resC.tl, o.tl, GenRisk.tl
7207              o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
7208              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,GenRisk)
7209              o_ResViolation_TP(dt,ild,resC)
7210              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7211   
7212      ) ;
7213   
7214      loop( HVDCrisk $ { (o_HVDCriskLevel(dt,ild,resC,HVDCrisk) > 0)
7215                     and ( abs[  o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
7216                               - o_ReserveReqd_TP(dt,ild,resC)
7217                              ] <= ZeroTolerance )
7218                       },
7219          put dt.tl, ild.tl, resC.tl, 'HVDC', HVDCrisk.tl
7220              o_HVDCriskLevel(dt,ild,resC,HVDCrisk), o_ResCleared_TP(dt,ild,resC)
7221              o_EffectiveRes_TP(dt,ild,resC,HVDCRisk)
7222              o_ResViolation_TP(dt,ild,resC)
7223              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7224      ) ;
7225   
7226      loop( manualRisk $ { ( o_manuRiskLevel(dt,ild,resC,ManualRisk) > 0 )
7227                       and ( abs[ o_manuRiskLevel(dt,ild,resC,manualRisk)
7228                                - o_ReserveReqd_TP(dt,ild,resC)
7229                                ] <= ZeroTolerance )
7230                         },
7231          put dt.tl, ild.tl, resC.tl, 'Manual', manualRisk.tl
7232              o_manuRiskLevel(dt,ild,resC,manualRisk),o_ResCleared_TP(dt,ild,resC)
7233              o_EffectiveRes_TP(dt,ild,resC,manualRisk)
7234              o_ResViolation_TP(dt,ild,resC)
7235              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7236      ) ;
7237   
7238      loop( (o,riskC) $ { HVDCsecRisk(riskC)
7239                      and ( o_genHVDCriskLevel(dt,ild,o,resC,riskC) > 0 )
7240                      and ( abs[ o_genHVDCriskLevel(dt,ild,o,resC,riskC)
7241                               - o_ReserveReqd_TP(dt,ild,resC)
7242                               ] <= ZeroTolerance )
7243                        },
7244          put dt.tl, ild.tl, resC.tl, o.tl, riskC.tl
7245              o_GenHVDCRiskLevel(dt,ild,o, resC,riskC)
7246              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
7247              o_ResViolation_TP(dt,ild,resC)
7248              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7249      ) ;
7250   
7251      loop( (o,riskC) $ { HVDCsecRisk(riskC)
7252                      and ( o_manuHVDCriskLevel(dt,ild,resC,riskC) > 0 )
7253                      and ( abs[ o_manuHVDCriskLevel(dt,ild,resC,riskC)
7254                               - o_ReserveReqd_TP(dt,ild,resC)
7255                               ] <= ZeroTolerance )
7256                        },
7257          put dt.tl, ild.tl, resC.tl, 'Manual', riskC.tl
7258              o_manuHVDCriskLevel(dt,ild,resC,riskC)
7259              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
7260              o_ResViolation_TP(dt,ild,resC)
7261              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7262          ) ;
7263   
7264  *   Ensure still reporting for conditions with zero FIR and/or SIR required
7265      if( (o_ReserveReqd_TP(dt,ild,resC) = 0) ,
7266          put dt.tl, ild.tl, resC.tl, ' ', ' ', ' '
7267              o_ResCleared_TP(dt,ild,resC), o_ResViolation_TP(dt,ild,resC)
7268              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7269      ) ;
7270  ) ;
7271   
7272  * Audit - objective result
7273  File objResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\Test_All_RTP_Audit_ObjResults.csv"/;
7274  objResults_Audit.pc = 5 ;
7275  objResults_Audit.lw = 0 ;
7276  objResults_Audit.pw = 9999 ;
7277  objResults_Audit.ap = 1 ;
7278  objResults_Audit.nd = 5 ;
7279  objResults_Audit.nw = 20 ;
7280  put objResults_Audit
7281  loop( dt,
7282      put dt.tl, o_ofv_TP(dt) /
7283  ) ;
7284   
7285   
7286  execute_unload 'C:\vSPD\GitHub\Programs\..\Output\\Test_All_RTP\RTD_20211202_RTP_AllData.gdx' ;
7288  *===============================================================================
7289  *execute_unload '%outputPath%\%runName%\%vSPDinputData%_AllData.gdx' ;
7290   
7291   
7292   
7293   
7295   
7296   
7297  * Post a progress message for use by EMI.
7298  putclose runlog 'Case: RTD_20211202_RTP is complete in ',timeExec,'(secs)'/ ;
7299  putclose runlog 'Case: RTD_20211202_RTP is finished in ',timeElapsed,'(secs)'/ ;
7300   
7301  * Go to the next input file
7303   
7304  * Post a progress message for use by EMI.
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\vSPD\GitHub\Programs\vSPDsolve.gms
     2     2741 INCLUDE        1      64  .C:\vSPD\GitHub\Programs\vSPDsettings.inc
     3     2796 INCLUDE        1      65  .C:\vSPD\GitHub\Programs\vSPDcase.inc
     4     3193 IF EXIST       1     459  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     5     3199 GDXIN          1     465  C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
     6     3205 GDXIN          1     471  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     7     3229 GDXIN          1     495  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     8     3494 IF EXIST       1     760  C:\vSPD\GitHub\Override\.gdx
     9     5011 INCLUDE        1    2277  .C:\vSPD\GitHub\Programs\vSPDsolve_RTP.gms
    10     6873 INCLUDE        1    3931  .C:\vSPD\GitHub\Programs\vSPDreport.gms
    11     6947 IF EXIST      10      74  .C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_BusResults_TP.csv
    12     7305 IF EXIST       1    3943  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx


COMPILATION TIME     =        0.047 SECONDS      4 MB  36.2.0 r433180e WEX-WEI
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 5038


LOOPS                            FOR/WHILE   1
                                        tp   02-DEC-2021 13:25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,844
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,141
NON ZERO ELEMENTS        93,793     DISCRETE VARIABLES         14


GENERATION TIME      =        0.094 SECONDS     24 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 02-DEC-2021 13:25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 5038


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  5038

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -26196.2749

 RESOURCE USAGE, LIMIT          1.063      3600.000
 ITERATION COUNT, LIMIT      6874    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\GitHub\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\GitHub\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 5.25 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.12 Mb (peak 13.45 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 8.40 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.75sec (det. 860.60 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.22sec (det. 285.63 ticks)


Proven optimal solution
MIP Solution:       -26196.274950    (6874 iterations, 23 nodes)
Final Solve:        -26196.274950    (3534 iterations)

Best possible:      -26196.274950
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 5442


LOOPS                            FOR/WHILE   1
                                        tp   02-DEC-2021 13:25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,844
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,141
NON ZERO ELEMENTS        93,793     DISCRETE VARIABLES         14


GENERATION TIME      =        0.109 SECONDS     29 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 02-DEC-2021 13:25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 8
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 5442


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  5442

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -25716.1962

 RESOURCE USAGE, LIMIT          1.016      3600.000
 ITERATION COUNT, LIMIT      6837    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\GitHub\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\GitHub\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 5.25 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.12 Mb (peak 13.45 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 8.40 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 860.73 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.24sec (det. 303.50 ticks)


Proven optimal solution
MIP Solution:       -25716.196161    (6837 iterations, 20 nodes)
Final Solve:        -25716.196161    (3609 iterations)

Best possible:      -25716.196161
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/17/22 15:41:38 Page 9
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog C:\vSPD\GitHub\Programs\ProgressReport.txt
temp C:\vSPD\GitHub\Programs\temp.put
SystemResults C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_SystemResults.csv
OfferResults C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_OfferResults.csv
TraderResults C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_TraderResults.csv
SummaryResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_SummaryResults_TP.csv
IslandResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_IslandResults_TP.csv
BusResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_BusResults_TP.csv
NodeResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_NodeResults_TP.csv
OfferResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_OfferResults_TP.csv
ReserveResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_ReserveResults_TP.csv
BranchResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_BranchResults_TP.csv
BrCstrResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_BrConstraintResults_TP.csv
MnodeCstrResults_TP C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_MnodeConstraintResults_TP.csv
branchLoss_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_BranchLoss.csv
busResults_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_BusResults.csv
MNodeResults_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_MNodeResults.csv
brchResults_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_BranchResults.csv
riskResults_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_RiskResults.csv
objResults_Audit C:\vSPD\GitHub\Output\Test_All_RTP\Test_All_RTP_Audit_ObjResults.csv


EXECUTION TIME       =        3.234 SECONDS     35 MB  36.2.0 r433180e WEX-WEI


USER: Single User License, Phil Bishop               G200929/0001CS-WIN
      Electricity Authority - Te Mana Hiko                    DC5643-S1


**** FILE SUMMARY

Restart    C:\vSPD\GitHub\Programs\vSPDmodel.g00
Input      C:\vSPD\GitHub\Programs\vSPDsolve.gms
Output     C:\vSPD\GitHub\Programs\vSPDsolve.lst
