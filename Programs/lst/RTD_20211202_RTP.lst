GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


2678  *=====================================================================================
2679  * Name:                 vSPDsolve.gms
2680  * Function:             Establish base case and override data, prepare data, and solve
2681  *                       the model
2682  * Developed by:         Electricity Authority, New Zealand
2683  * Source:               https://github.com/ElectricityAuthority/vSPD
2684  *                       http://www.emi.ea.govt.nz/Tools/vSPD
2685  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
2686  *                       Email: emi@ea.govt.nz
2687  * Modified on:          1 Oct 2019
2688  *                       New feature added: new wind offer arrangements
2689  * Modified on:          11 Nov 2020
2690  *                       Replacing invalid bus prices after SOS1 (6.1.3)
2691  * Last modified on:     11 Dec 2020
2692  *                       From 11 Dec 2020, GDX input file have i_tradePeriodBranchCapacityDirected
2693  *                       and i_tradePeriodReverseRatingsApplied symbols
2694  *                       Applying branch reverse rating  s only when i_tradePeriodReverseRatingsApplied = 1
2695  * Last modified on:     27 June 2021
2696  *                       Fixing the bug that remove HVDC because of zero  reverse rating limits
2697   
2698  *=====================================================================================
2699   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file f
        3. Manage model and data compatability
        4. Input data overrides - declare and apply (include vSPDoverrides.gms)
        5. Initialise constraint violation penalties (CVPs)
        6. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        7. vSPD scarcity pricing post-processing
        8. Write results to CSV report files and GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr            i_scarcityArea = sarea
        i_reserveType = resT                      i_reserveClass = resC
        i_riskClass = riskC                       i_constraintRHS = CstrRHS
        i_riskParameter = riskPar                 i_offerParam = offerPar
        i_dczone = z,z1,rrz,rrz1                  i_riskGroup = rg,rg1)
2738   
2739   
2740  * Include paths, settings and case name files
INCLUDE    C:\vSPD\GitHub\Programs\vSPDsettings.inc
2742  *+++ vSPD settings +++
2745   
2746  *+++ Paths +++
2750  *$setglobal inputPath                     'A:\Tuong Nguyen\vSPD_Inputs\FP\'
2753   
2755   
2756   
2757  *+++ Model +++
2758  Scalar sequentialSolve                   / 0 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2759  Scalar disconnectedNodePriceCorrection   / 1 / ;
2760  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2761   
2762   
2763  *+++ Network +++
2764  Scalar useACLossModel                    / 1 / ;
2765  Scalar useHVDCLossModel                  / 1 / ;
2766  Scalar useACBranchLimits                 / 1 / ;
2767  Scalar useHVDCBranchLimits               / 1 / ;
2768  Scalar resolveCircularBranchFlows        / 1 / ;
2769  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2770  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2771  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2772  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2773  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2774   
2775   
2776  *+++ Constraints +++
2777  Scalar useReserveModel                   / 1 / ;
2778  Scalar suppressMixedConstraint           / 0 / ;
2779  Scalar mixedMIPtolerance                 / 0.000001 / ;
2780   
2781   
2782  *+++ Solver +++
2783  Scalar LPtimeLimit                       / 3600 / ;
2784  Scalar LPiterationLimit                  / 2000000000 / ;
2785  Scalar MIPtimeLimit                      / 3600 / ;
2786  Scalar MIPiterationLimit                 / 2000000000 / ;
2787  Scalar MIPoptimality                     / 0 / ;
2790   
2791   
2792  *+++ Various switches +++
2795   
INCLUDE    C:\vSPD\GitHub\Programs\vSPDcase.inc
2800  tradePeriodReports = 1 ;
2801   
2802   
2803  * Update the runlog file
2804  File runlog "Write to a report"  / "ProgressReport.txt" /;
2805  runlog.lw = 0 ; runlog.ap = 1 ;
2806  putclose runlog / 'Case "RTD_20211202_RTP" started at: '
2807                    system.date " " system.time /;
2808  if(sequentialSolve,
2809    putclose runlog 'Vectorisation is switched OFF' /;
2810  else
2811    putclose runlog 'Vectorisation is switched ON' /;
2812  ) ;
2813   
2814  * Set the solver for the LP and MIP
2815  option lp = Cplex ;
2816  option mip = Cplex ;
2817   
2818  * Set profile status
2819  option profile = 0 ;
2820   
2821  * Set the solution print status in the lst file
2822  option solprint = off;
2823   
2824  * Set the column (variable) and row (equation) listing in the lst file
2825  option limcol = 0 ;
2826  option limrow = 0 ;
2827   
2828  * Allow empty data set declaration
2830   
2831  * Declare a temporary file
2832  File temp ;
2833   
2834  *=====================================================================================
2835  * 1. Declare symbols and initialise some of them
2836  *=====================================================================================
2837   
2838  Sets
2839  * Initialise fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2840    i_island                    / NI, SI /
2841    i_reserveClass              / FIR, SIR /
2842   
       Scarcity pricing updates --> i_reserveType
       Rather than include an additional reserve type element an additional virutal
       reserve paramter and associated variable is created. This is more efficient
       implementation in terms of the problem size as all other reserve providers
       are indexed on i_reserveType which would include an additional index on all
       these variables thus increasing the problem size. This increase would then
       need additional pre-processing to fix variables to zero. To avoid this and
       keep the problem size small the additional virtual reserve variable is included.
2853    i_reserveType               / PLSR, TWDR, ILR /
2854   
2855    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2856                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2857    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2858    i_offerType                 / energy, PLSR, TWDR, ILR /
2859    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2860                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW,
2861                                  i_IsPriceResponse, i_PotentialMW  /
2862    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2863    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2864    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2865    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2866    i_energyBidComponent        / i_bidMW, i_bidPrice /
2867    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2868    i_tradeBlock                / t1*t20 /
2869    i_lossSegment               / ls1*ls13 /
2870    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2871    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2872    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2873    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2874    i_flowDirection             / forward, backward /
2875    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2876                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2877                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2878                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2879                                  i_deficitRampRate, i_surplusRampRate
2880                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2881                                  i_deficitBranchFlow, i_surplusBranchFlow
2882                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2883                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2884                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2885   
2886  * Initialise the set called pole
2887    pole  'HVDC poles'          / pole1, pole2 /
2888   
2889  * Scarcity pricing updates
2890    i_scarcityArea              /NI, SI, National/
2891   
2892  * NMIR - HVDC flow zones for reverse reserve sharing
2893    i_dczone                    /RP, NR, RZ/
2894   
2895    ;
2896   
2897   
2898   
2899  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2900  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2901   
2902  Sets
2903    scarcityAreaIslandMap(sarea,ild)                    'Mapping of scarcity area to island'
2904    unsolvedPeriod(tp)                                  'Set of periods that are not solved yet'
2905  * Unmmaped bus defificit temporary sets
2906    unmappedDeficitBus(dt,b)                            'List of buses that have deficit generation (price) and are not mapped to any pnode'
2907    changedDeficitBus(dt,b)                             'List of buses that have deficit generation added from unmapped deficit bus'
2908  * TN - Replacing invalid prices after SOS1
2909    vSPD_SOS1_Solve(tp)                                 'Flag period that is resolved using SOS1'
2910    ;
2911   
2912  Parameters
2913  * Flag to apply corresponding vSPD model
2914    VSPDModel(tp)                                       '0=VSPD, 1=VSPD_MIP, 2=vSPD_BranchFlowMIP, 3=vSPD_MixedConstraintMIP, 4=VSPD (last solve)'
2915  * Main iteration counter
2916    iterationCount                                      'Iteration counter for the solve'
2917  * MIP logic
2918    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2919  * Introduce flag to detect circular branch flows on each HVDC pole
2920    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2921    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2922    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2923    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2924    manualBranchSegmentMWFlow(tp,br,los,fd)             'Manual calculation of the branch loss segment MW flow'
2925    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2926    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2927    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2928  * Parameters to calculate circular branch flow on each HVDC pole
2929    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2930    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2931  * Disconnected bus post-processing
2932    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2933    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2934    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2935    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2936  * Scarcity pricing processing parameters
2937    scarcitySituation(tp,sarea)                         'Flag to indicate that a scarcity situation exists (1 = Yes)'
2938    GWAPFloor(tp,sarea)                                 'Floor price for the scarcity situation in scarcity area'
2939    GWAPCeiling(tp,sarea)                               'Ceiling price for the scarcity situation in scarcity area'
2940    GWAPPastDaysAvg(tp,ild)                             'Average GWAP over past days - number of periods in GWAP count'
2941    GWAPCountForAvg(tp,ild)                             'Number of periods used for the i_gwapPastDaysAvg'
2942    GWAPThreshold(tp,ild)                               'Threshold on previous 336 trading period GWAP - cumulative price threshold'
2943    islandGWAP(tp,ild)                                  'Island GWAP calculation used to update GWAPPastDaysAvg'
2944    scarcityAreaGWAP(tp,sarea)                          'Scarcity area GWAP used to calculate the scaling factor'
2945    pastGWAPsumforCPT(tp,ild)
2946    pastTPcntforCPT(tp,ild)
2947    currentDayGWAPsumforCPT(ild)
2948    currentDayTPsumforCPT(ild)
2949    avgPriorGWAP(tp,ild)
2950    cptIslandPassed(tp,sarea)
2951    cptPassed(tp,sarea)
2952    cptIslandReq(sarea)
2953    scarcityScalingFactor(tp,sarea)
2954    scaledbusPrice(tp,b)
2955    scalednodePrice(tp,n)
2956    scaledFIRprice(tp,ild)
2957    scaledSIRprice(tp,ild)
2958    scaledislandGWAP(tp,ild)
2959    scaledscarcityAreaGWAP(tp,sarea)
2960  * Unmmaped bus defificit temporary parameters
2961    temp_busDeficit_TP(dt,b) 'Bus deficit violation for each trade period'
2962  * TN - Replacing invalid prices after SOS1
2963    busSOSinvalid(tp,b)                                 'Buses with invalid bus prices after SOS1 solve'
2964    numberofbusSOSinvalid(tp)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration) '
2965  * TN - Flag to apply branch reverse ratings
2966    reverseRatingsApplied(tp)
2967    ;
2968   
2969  Sets
2970  * Dispatch results reporting
2971    o_fromDateTime(dt)                                  'Start period for summary reports'
2972    o_dateTime(dt)                                      'Date and time for reporting'
2973    o_bus(dt,b)                                         'Set of buses for output report'
2974    o_offer(dt,o)                                       'Set of offers for output report'
2975    o_bid(dt,bd)                                        'Set of bids for output report'
2976    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2977    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2978    o_trader(trdr)                                      'Set of traders for trader summary output report'
2979    o_node(dt,n)                                        'Set of nodes for output report'
2980    o_branch(dt,br)                                     'Set of branches for output report'
2981    o_HVDClink(dt,br)                                   'HVDC links (branches) defined for the current trading period'
2982    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2983    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2984    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2985    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2986  * Audit - extra output declaration
2987    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2988    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2989    ;
2990   
2991  Parameters
2992  * Dispatch results for reporting - Trade period level - Island output
2993    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2994    o_islandLoad_TP(dt,ild)                             'Island MW fixed load for the different time periods'
2995    o_islandClrBid_TP(dt,ild)                           'Island cleared MW bid for the different time periods'
2996    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2997    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2998    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2999    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
3000    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
3001    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
3002    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
3003    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
3004    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
3005    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
3006    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
3007    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
3008    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
3009    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
3010    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
3011    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
3012    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
3013    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
3014    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
3015    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
3016    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
3017    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
3018    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
3019    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
3020    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
3021    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
3022    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
3023    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
3024    o_ACbranchTotalRentals(dt)                          'Total AC rental by trading period for reporting'
3025    o_ACbranchLossMW(dt,br,los)                         'MW element of the loss segment curve in MW'
3026    o_ACbranchLossFactor(dt,br,los)                     'Loss factor element of the loss segment curve'
3027    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
3028    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
3029    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
3030    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
3031    o_offerEnergyBlock_TP(dt,o,trdBlk)                  'Output MW cleared for each energy offer for each trade period'
3032    o_offerFIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for FIR for each trade period'
3033    o_offerSIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for SIR for each trade period'
3034    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
3035    o_bidFIR_TP(dt,bd)                                  'Output MW cleared for FIR for each trade period'
3036    o_bidSIR_TP(dt,bd)                                  'Output MW cleared for SIR for each trade period'
3037    o_ReserveReqd_TP(dt,ild,resC)                       'Output MW required for each reserve class in each trade period'
3038    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
3039    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
3040    o_ResCleared_TP(dt,ild,resC)                        'Reserve cleared from an island for each trade period'
3041    o_FIRcleared_TP(dt,ild)                             'Output - total FIR cleared by island'
3042    o_SIRcleared_TP(dt,ild)                             'Output - total SIR cleared by island'
3043    o_ResPrice_TP(dt,ild,resC)                          'Output $/MW price for each reserve classes for each trade period'
3044    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
3045    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
3046    o_ResViolation_TP(dt,ild,resC)                      'Violation MW for each reserve classes for each trade period'
3047    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
3048    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
3049    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
3050    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
3051    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
3052    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
3053    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
3054    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
3055    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
3056  * Security constraint data
3057    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
3058    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
3059    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
3060    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
3061  * Mnode constraint data
3062    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
3063    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
3064    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
3065    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
3066  * TradePeriod summary report
3067    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
3068    o_systemCost_TP(dt)                                 'System cost for summary report'
3069    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
3070    o_ofv_TP(dt)                                        'Objective function value for summary report'
3071    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
3072    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
3073    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
3074    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
3075    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
3076    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
3077    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
3078    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
3079    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
3080    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
3081    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
3082    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
3083    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
3084    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
3085    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
3086    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
3087    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
3088    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
3089  * System level
3090    o_numTradePeriods                                   'Output number of trade periods in summary'
3091    o_systemOFV                                         'System objective function value'
3092    o_systemGen                                         'Output system MWh generation'
3093    o_systemLoad                                        'Output system MWh load'
3094    o_systemLoss                                        'Output system MWh loss'
3095    o_systemViolation                                   'Output system MWh violation'
3096    o_systemFIR                                         'Output system FIR MWh reserve'
3097    o_systemSIR                                         'Output system SIR MWh reserve'
3098    o_systemEnergyRevenue                               'Output offer energy revenue $'
3099    o_systemReserveRevenue                              'Output reserve revenue $'
3100    o_systemLoadCost                                    'Output system load cost $'
3101    o_systemLoadRevenue                                 'Output system load revenue $'
3102    o_systemSurplus                                     'Output system surplus $'
3103  * Offer level
3104    o_offerGen(o)                                       'Output offer generation (MWh)'
3105    o_offerFIR(o)                                       'Output offer FIR (MWh)'
3106    o_offerSIR(o)                                       'Output offer SIR (MWh)'
3107    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
3108    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
3109    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
3110  * Trader level
3111    o_traderGen(trdr)                                   'Output trader generation (MWh)'
3112    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
3113    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
3114    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
3115    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
3116    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
3117  * Factor to prorate the deficit and surplus at the nodal level
3118    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
3119    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
3120  * Introduce i_useBusNetworkModel to account for MSP change-over date.
3121    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
3122  * Virtual reserve output
3123    o_vrResMW_TP(dt,ild,resC)                           'MW scheduled from virtual reserve resource'
3124    o_FIRvrMW_TP(dt,ild)                                'MW scheduled from virtual FIR resource'
3125    o_SIRvrMW_TP(dt,ild)                                'MW scheduled from virtual SIR resource'
3126  * Scarcity pricing output
3127    o_scarcityExists_TP(dt,ild)
3128    o_cptPassed_TP(dt,ild)
3129    o_avgPriorGWAP_TP(dt,ild)
3130    o_islandGWAPbefore_TP(dt,ild)
3131    o_islandGWAPafter_TP(dt,ild)
3132    o_scarcityGWAPbefore_TP(dt,ild)
3133    o_scarcityGWAPafter_TP(dt,ild)
3134    o_scarcityScalingFactor_TP(dt,ild)
3135    o_GWAPthreshold_TP(dt,ild)
3136    o_GWAPfloor_TP(dt,ild)
3137    o_GWAPceiling_TP(dt,ild)
3138  * Audit - extra output declaration
3139    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
3140    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
3141    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
3142    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
3143    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
3144    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
3145    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
3146    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
3147    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
3148    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
3149    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
3150    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
3151    o_generationRiskLevel(dt,ild,o,resC,riskC)                    'Audit - generation risk'
3152    o_generationRiskPrice(dt,ild,o,resC,riskC)                    'Audit - generation risk shadow price'
3153    o_HVDCriskLevel(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk'
3154    o_HVDCriskPrice(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk shadow price'
3155    o_manuRiskLevel(dt,ild,resC,riskC)                            'Audit - manual risk'
3156    o_manuRiskPrice(dt,ild,resC,riskC)                            'Audit - manual risk shadow price'
3157    o_genHVDCriskLevel(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
3158    o_genHVDCriskPrice(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk shadow price'
3159    o_manuHVDCriskLevel(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary'
3160    o_manuHVDCriskPrice(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary shadow price'
3161    o_generationRiskGroupLevel(dt,ild,rg,resC,riskC)                 'Audit - generation group risk'
3162    o_generationRiskGroupPrice(dt,ild,rg,resC,riskC)                 'Audit - generation group risk shadow price'
3163  * TN - output parameters added for NMIR project --------------------------------
3164    o_FirSent_TP(dt,ild)                        'FIR export from an island for each trade period'
3165    o_SirSent_TP(dt,ild)                        'SIR export from an island for each trade period'
3166    o_FirReceived_TP(dt,ild)                    'FIR received at an island for each trade period'
3167    o_SirReceived_TP(dt,ild)                    'SIR received at an island for each trade period'
3168    o_FirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3169    o_SirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3170    o_EffectiveRes_TP(dt,ild,resC,riskC)        'Effective reserve share to an island for each trade period'
3171    o_FirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3172    o_SirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3173  * TN - output parameters added for NMIR project end ----------------------------
3174    ;
3175   
3176  Scalars
3177    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
3178    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
3179  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
3180    useExtendedRiskClass          'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
3181  * Scarcity pricing
3182    scarcityExists                'Flag to indicate that a scarcity situation exists for at least 1 trading period in the solve'
3183    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
3184    ;
3185   
3186   
3187   
3188  *=====================================================================================
3189  * 2. Load data from GDX file
3190  *=====================================================================================
3191   
3192  * If input file does not exist then go to the next input file
3194   
3195  * Load trading period to be solved
3196  * If scarcity pricing situation exists --> load and solve all trading periods
GDXIN   C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
--- LOAD  i_tradePeriod = 1:i_TradePeriod
--- LOAD  i_dateTime = 2:i_DateTime
3202   
3203   
3204  * Call the GDX routine and load the input data:
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
3206  * Sets
--- LOAD  i_offer = 84:i_Offer
--- LOAD  i_trader = 83:i_Trader
--- LOAD  i_bid = 101:i_bid
--- LOAD  i_node = 15:i_node
--- LOAD  i_bus = 16:i_bus
--- LOAD  i_branch = 32:i_branch
--- LOAD  i_branchConstraint = 42:i_branchConstraint
--- LOAD  i_ACnodeConstraint = 45:i_ACnodeConstraint
--- LOAD  i_MnodeConstraint = 48:i_MnodeConstraint
--- LOAD  i_genericConstraint = 54:i_genericConstraint
--- LOAD  i_type1MixedConstraint = 63:i_type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 78:i_type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 7:i_dateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 90:i_tradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 91:i_tradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 104:i_tradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 105:i_tradePeriodBidNode
--- LOAD  i_tradePeriodNode = 17:i_tradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 19:i_tradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 18:i_tradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 20:i_tradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 33:i_tradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 115:i_tradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 64:i_type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 65:i_tradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 79:i_tradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 66:i_type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 55:i_tradePeriodGenericConstraint
3213  * Parameters
--- LOAD  i_day = 2:i_day
--- LOAD  i_month = 3:i_month
--- LOAD  i_year = 4:i_year
--- LOAD  i_tradingPeriodLength = 10:i_tradingPeriodLength
--- LOAD  i_AClineUnit = 9:i_AClineUnit
--- MERGE i_branchReceivingEndLossProportion = 11:i_branchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 8:i_studyTradePeriod
--- LOAD  i_CVPvalues = 13:i_CVPvalues
--- LOAD  i_tradePeriodOfferParameter = 92:i_tradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 93:i_tradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 94:i_tradePeriodSustainedPLSRoffer
--- LOAD  i_tradePeriodFastPLSRoffer = 95:i_tradePeriodFastPLSRoffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 96:i_tradePeriodSustainedTWDRoffer
--- LOAD  i_tradePeriodFastTWDRoffer = 97:i_tradePeriodFastTWDRoffer
--- LOAD  i_tradePeriodSustainedILRoffer = 98:i_tradePeriodSustainedILRoffer
--- LOAD  i_tradePeriodFastILRoffer = 99:i_tradePeriodFastILRoffer
--- LOAD  i_tradePeriodEnergyBid = 106:i_tradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 107:i_tradePeriodSustainedILRbid
--- LOAD  i_tradePeriodFastILRbid = 108:i_tradePeriodFastILRbid
--- LOAD  i_tradePeriodHVDCNode = 23:i_tradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 24:i_tradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 34:i_tradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 35:i_tradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 36:i_tradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 38:i_tradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 27:i_noLossBranch
--- LOAD  i_AClossBranch = 28:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 29:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 21:i_tradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 22:i_tradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 116:i_tradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 117:i_tradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 43:i_tradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 44:i_tradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 46:i_tradePeriodACnodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 47:i_tradePeriodACnodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 49:i_tradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 50:i_tradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 51:i_tradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 52:i_tradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 53:i_tradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 67:i_type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 69:i_type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 70:i_type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 71:i_type1MixedConstraintHVDClineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 72:i_tradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 80:i_type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 81:i_tradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 56:i_tradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 57:i_tradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 58:i_tradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 59:i_tradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 60:i_tradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 61:i_tradePeriodGenericConstraintRHS
3227   
3228  * New risk group sets
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
--- LOAD  i_riskGroup = 147:i_riskGroup
--- LOAD  riskGroupOffer = 145:i_tradePeriodRiskGroup
3234   
3235   
3236  *=====================================================================================
3237  * 3. Manage model and data compatability
3238  *=====================================================================================
3239   
3240  * This section manages the changes to model flags to ensure backward compatibility
3241  * given changes in the SPD model formulation over time:
3242  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
3243  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
3244   
3245  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
3246  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
3247   
3248  * Calculate the Gregorian date of the input data
3249  inputGDXGDate = jdate(i_year,i_month,i_day) ;
3250   
3251  * Introduce i_useBusNetworkModel to account for MSP change-over date when for
3252  * half of the day the old market node model and the other half the bus network
3253  * model was used. The old model does not have the i_tradePeriodBusElectrical
3254  * island paramter specified since it uses the market node network model.
3255  * This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter
3256  * to be used in the post-MSP solves to indentify 'dead' electrical buses.
3257  * MSP change over from mid-day on 21 Jul 2009
3258  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= jdate(2009,7,21) ) and
3259                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
3260                                 } ;
3261   
3262  * Switch off the mixed constraint based risk offset calculation after 17 October 2011
3263  useMixedConstraintRiskOffset = 1 $ { inputGDXGDate < jdate(2011,10,17) } ;
3264   
3265  * Switch off mixed constraint formulation if no data coming through
3266  * or mixed constraint is suppressed manually in vSPDsetting.inc
3267  useMixedConstraint(tp)
3268      = 1 $ { sum[t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1]
3269          and (suppressMixedConstraint = 0) } ;
3270   
3271  put_utility temp 'gdxin' / 'C:\vSPD\GitHub\Programs\..\Input\\RTD_20211202_RTP.gdx' ;
3272   
3273  * Primary secondary offer in use from 01 May 2012'
3274  if(inputGDXGDate >= jdate(2012,05,01),
3275      execute_load i_tradePeriodPrimarySecondaryOffer ;
3276  else
3277      i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
3278  ) ;
3279   
3280  * Change to demand bid on 28 Jun 2012
3281  useDSBFDemandBidModel = 1 $ { inputGDXGDate >= jdate(2012,6,28) } ;
3282   
3283  * Manual ECE risk parameters in use from 20 Sep 2012
3284  if(inputGDXGDate >= jdate(2012,9,20),
3285      execute_load i_tradePeriodManualRisk_ECE ;
3286  else
3287      i_tradePeriodManualRisk_ECE(tp,ild,resC) = 0 ;
3288  ) ;
3289   
3290  * HVDC secondary risk parameters in use from 20 Sep 2012
3291  if(inputGDXGDate >= jdate(2012,9,20),
3292      execute_load i_tradePeriodHVDCsecRiskEnabled
3293                   i_tradePeriodHVDCsecRiskSubtractor ;
3294  else
3295      i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC) = 0 ;
3296      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
3297  ) ;
3298   
3299  * Do not use the extended risk class if no data coming through
3300  useExtendedRiskClass
3301      = 1 $ { sum[ (tp,ild,resC,riskC,riskPar) $ (ord(riskC) > 4)
3302                 , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] };
3303   
3304  * HVDC round power mode in use from 20 Sep 2012
3305  if(inputGDXGDate >= jdate(2012,9,20),
3306      execute_load i_tradePeriodAllowHVDCroundpower ;
3307  else
3308      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
3309  ) ;
3310   
3311  * Additional mixed constraint parameters exist from 24 Feb 2013
3312   
3313  if(inputGDXGDate >= jdate(2013,2,24),
3314      execute_load i_type1MixedConstraintAClineWeight
3315                   i_type1MixedConstraintAClineLossWeight
3316                   i_type1MixedConstraintAClineFixedLossWeight
3317                   i_type1MixedConstraintHVDClineLossWeight
3318                   i_type1MixedConstraintHVDClineFixedLossWeight
3319                   i_type1MixedConstraintPurWeight ;
3320  else
3321      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
3322      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
3323      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
3324      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
3325      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
3326      i_type1MixedConstraintPurWeight(t1MixCstr,bd) = 0 ;
3327  ) ;
3328   
3329  *  Reserve class generation parameter in use from 24 Feb 2013
3330  if(inputGDXGDate >= jdate(2013,2,24),
3331      execute_load i_tradePeriodReserveClassGenerationMaximum ;
3332  else
3333      i_tradePeriodReserveClassGenerationMaximum(tp,o,resC) = 0 ;
3334  ) ;
3335   
3336  * Primary secondary risk model in use from 24 Feb 2013
3337  usePrimSecGenRiskModel = 1 $ { inputGDXGDate >= jdate(2013,2,24) } ;
3338   
3339  * Dispatchable Demand effective date 20 May 2014
3340  if(inputGDXGDate >= jdate(2014,5,20),
3341      execute_load i_tradePeriodDispatchableBid;
3342  else
3343      i_tradePeriodDispatchableBid(tp,bd) =  Yes $ useDSBFDemandBidModel ;
3344  ) ;
3345  * MODD modification end
3346   
3347  * Scarcity pricing scheme for reserve available from 27 May 2014
3348  if(inputGDXGDate >= jdate(2014,5,27),
3349      execute_load i_tradePeriodVROfferMax, i_tradePeriodVROfferPrice ;
3350  else
3351      i_tradePeriodVROfferMax(tp,ild,resC) = 0 ;
3352      i_tradePeriodVROfferPrice(tp,ild,resC) = 0 ;
3353  ) ;
3354   
3355   
3356  * National market for IR effective date 20 Oct 2016
3357  if (inputGDXGDate >= jdate(2016,10,20),
3358      execute_load
3359      reserveRoundPower     = i_tradePeriodReserveRoundPower
3360      reserveShareEnabled   = i_tradePeriodReserveSharing
3361      modulationRiskClass   = i_tradePeriodModulationRisk
3362      roundPower2MonoLevel  = i_tradePeriodRoundPower2Mono
3363      bipole2MonoLevel      = i_tradePeriodBipole2Mono
3364      monopoleMinimum       = i_tradePeriodReserveSharingPoleMin
3365      HVDCControlBand       = i_tradePeriodHVDCcontrolBand
3366      HVDClossScalingFactor = i_tradePeriodHVDClossScalingFactor
3367      sharedNFRfactor       = i_tradePeriodSharedNFRfactor
3368      sharedNFRLoadOffset   = i_tradePeriodSharedNFRLoadOffset
3369      effectiveFactor       = i_tradePeriodReserveEffectiveFactor
3370      RMTreserveLimitTo     = i_tradePeriodRMTreserveLimit
3371      rampingConstraint     = i_tradePeriodRampingConstraint
3372    ;
3373  else
3374      reserveRoundPower(tp,resC)         = 0    ;
3375      reserveShareEnabled(tp,resC)       = 0    ;
3376      modulationRiskClass(tp,riskC)      = 0    ;
3377      roundPower2MonoLevel(tp)           = 0    ;
3378      bipole2MonoLevel(tp)               = 0    ;
3379      MonopoleMinimum(tp)                = 0    ;
3380      HVDCControlBand(tp,fd)             = 0    ;
3381      HVDClossScalingFactor(tp)          = 0    ;
3382      sharedNFRfactor(tp)                = 0    ;
3383      sharedNFRloadOffset(tp,ild)        = 0    ;
3384      effectiveFactor(tp,ild,resC,riskC) = 0    ;
3385      RMTreserveLimitTo(tp,ild,resC)     = 0    ;
3386      rampingConstraint(tp,brCstr)       = no   ;
3387  ) ;
3388   
3389  UseShareReserve = 1 $ sum[ (tp,resC), reserveShareEnabled(tp,resC)] ;
3390   
3391  * Branch Reverse Ratings planned to go-live on 03/Feb/2021 (this will be flagged in GDX using i_tradePeriodReverseRatingsApplied)
3392  * From 11 Dec 2020, GDX file will have i_tradePeriodBranchCapacityDirected and i_tradePeriodReverseRatingsApplied symbols
3393  if (inputGDXGDate >= jdate(2020,12,11),
3394      execute_load i_tradePeriodBranchCapacityDirected;
3395      execute_load reverseRatingsApplied = i_tradePeriodReverseRatingsApplied;
3396   
3397      i_tradePeriodBranchCapacityDirected(tp,br,'backward') $ (reverseRatingsApplied(tp)=0)
3398          = i_tradePeriodBranchCapacityDirected(tp,br,'forward');
3399   
3400  else
3401      i_tradePeriodBranchCapacityDirected(tp,br,fd)
3402          = i_tradePeriodBranchCapacity(tp,br) ;
3403  ) ;
3404   
3405   
3406  * Real Time Pricing phase 2 planned to go live on 22 March 2022
3407  * From 1 March 2022, GDX file will have following symbols
3408  inputGDXGDate =  jdate(2022,4,1);
3409  if (inputGDXGDate >= jdate(2022,3,1),
3410      execute_load
3411      studyMode                   = i_studyMode
3412      useGenInitialMW             = i_useGenInitialMW
3413      runEnrgShortfallTransfer    = i_runEnrgShortfallTransfer
3414      runPriceTransfer            = i_runPriceTransfer
3415      InputInitialLoad            = i_tradePeriodInputInitialLoad
3416      LoadIsOverride              = i_tradePeriodLoadIsOverride
3417      LoadIsBad                   = i_tradePeriodLoadIsBad
3418      LoadIsNCL                   = i_tradePeriodLoadIsNCL
3419      ConformingFactor            = i_tradePeriodConformingFactor
3420      NonConformingLoad           = i_tradePeriodNonConformingLoad
3421      MaxLoad                     = i_tradePeriodMaxLoad
3422   
3423      useActualLoad               = i_useActualLoad
3424      dontScaleNegativeLoad       = i_dontScaleNegativeLoad
3425   
3426      islandMWIPS                 = i_tradePeriodIslandMWIPS
3427      islandPDS                   = i_tradePeriodIslandPDS
3428      islandLosses                = i_tradePeriodIslandLosses
3429   
3430      energyScarcityEnabled       = i_energyScarcityEnabled
3431      reserveScarcityEnabled      = i_reserveScarcityEnabled
3432      scarcityEnrgNationalFactor  = i_tradePeriodScarcityEnrgNationalFactor
3433      scarcityEnrgNationalPrice   = i_tradePeriodScarcityEnrgNationalPrice
3434      scarcityEnrgNodeFactor      = i_tradePeriodScarcityEnrgNodeFactor
3435      scarcityEnrgNodeFactorPrice = i_tradePeriodScarcityEnrgNodeFactorPrice
3436      scarcityEnrgNodeLimit       = i_tradePeriodScarcityEnrgNodeLimit
3437      scarcityEnrgNodeLimitPrice  = i_tradePeriodScarcityEnrgNodeLimitPrice
3438      scarcityResrvIslandLimit    = i_tradePeriodScarcityResrvIslandLimit
3439      scarcityResrvIslandPrice    = i_tradePeriodScarcityResrvIslandPrice
3440      ;
3441   
3442      i_tradePeriodNodeDemand(tp,n) = InputInitialLoad(tp,n);
3443      i_tradePeriodNodeDemand(tp,n) $ LoadIsBad(tp,n) = ConformingFactor(tp,n);
3444  else
3445      studyMode                                    = 111 ;
3446      useGenInitialMW                              = 0;
3447      runEnrgShortfallTransfer                     = 0;
3448      runPriceTransfer                             = 0;
3449      InputInitialLoad(tp,n)                       = 0;
3450      LoadIsOverride(tp,n)                         = 0;
3451      LoadIsBad(tp,n)                              = 0;
3452      LoadIsNCL(tp,n)                              = 0;
3453      ConformingFactor(tp,n)                       = 0;
3454      NonConformingLoad(tp,n)                      = 0;
3455      MaxLoad(tp,n)                                = 10000;
3456   
3457      useActualLoad(tp)                            = 1;
3458      dontScaleNegativeLoad(tp)                    = 1;
3459   
3460      islandMWIPS(tp,ild)                          = 0 ;
3461      islandPDS(tp,ild)                            = 0 ;
3462      islandLosses(tp,ild)                         = 0 ;
3463   
3464      energyScarcityEnabled(tp)                    = 0 ;
3465      reserveScarcityEnabled(tp)                   = 0 ;
3466      scarcityEnrgNationalFactor(tp,trdBlk)        = 0 ;
3467      scarcityEnrgNationalPrice(tp,trdBlk)         = 0 ;
3468      scarcityEnrgNodeFactor(tp,n,trdBlk)          = 0 ;
3469      scarcityEnrgNodeFactorPrice(tp,n,trdBlk)     = 0 ;
3470      scarcityEnrgNodeLimit(tp,n,trdBlk)           = 0 ;
3471      scarcityEnrgNodeLimitPrice(tp,n,trdBlk)      = 0 ;
3472      scarcityResrvIslandLimit(tp,ild,resC,trdBlk) = 0 ;
3473      scarcityResrvIslandPrice(tp,ild,resC,trdBlk) = 0 ;
3474  ) ;
3475   
3476   
3477   
3478  *=====================================================================================
3479  * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
3480  *=====================================================================================
3481   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
3495   
3497   
3498   
3499  *=====================================================================================
3500  * 5. Initialise constraint violation penalties (CVPs)
3501  *=====================================================================================
3502   
3503  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
3504  * Calculate the Gregorian date of the CE and ECE change
3505  * Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
3506  CVPchangeGDate = jdate(2010,06,24) ;
3507   
3508  * Set the flag for the application of the different CVPs for CE and ECE
3509  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
3510  diffCeECeCVP = 0 ;
3511  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
3512  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
3513  * If the user selects Yes (1), set the diffCeECeCVP flag
3514  diffCeECeCVP $ (-1 = 1) = 1 ;
3515   
3516  deficitBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
3517  surplusBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
3518  deficitReservePenalty(resC) $ (ord(resC) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3519  deficitReservePenalty(resC) $ (ord(resC) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3520  deficitBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
3521  surplusBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
3522  deficitGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
3523  surplusGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
3524  deficitRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
3525  surplusRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
3526  deficitACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
3527  surplusACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
3528  deficitBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
3529  surplusBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
3530  deficitMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
3531  surplusMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
3532  deficitT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
3533  surplusT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
3534  * Different CVPs defined for CE and ECE
3535  deficitReservePenalty_CE(resC) $ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3536  deficitReservePenalty_CE(resC) $ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3537  deficitReservePenalty_ECE(resC)$ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
3538  deficitReservePenalty_ECE(resC)$ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
3539   
3540  *=====================================================================================
3541  * 6. Initialise model mapping and inputs
3542  *=====================================================================================
3543   
3544  * Pre-dispatch schedule is solved sequentially
3545  sequentialSolve
3546      $ ( sum[ (tp,o,offerPar) $ {(ord(tp) = 2) and (ord(offerPar) = 1)}
3547                               , i_tradePeriodOfferParameter(tp,o,offerPar) ] = 0
3548        ) = 1 ;
3549   
3550  sequentialSolve $ UseShareReserve = 1;
3551   
3552  * Initialise bus, node, offer, bid for the current trade period start
3553  bus(tp,b)  $ i_tradePeriodBus(tp,b)  = yes  ;
3554  node(tp,n) $ i_tradePeriodNode(tp,n) = yes  ;
3555   
3556  * Initialise network sets for the current trade period start
3557  nodeBus(node,b)     $ i_tradePeriodNodeBus(node,b)        = yes ;
3558  HVDCnode(node)      $ i_tradePeriodHVDCnode(node)         = yes ;
3559  ACnode(node)        $ ( not HVDCnode(node))               = yes ;
3560  referenceNode(node) $ i_tradePeriodReferenceNode(node)    = yes ;
3561  DCbus(tp,b)         $ sum[ nodeBus(HVDCnode(tp,n),b), 1 ] = yes ;
3562  ACbus(tp,b)         $ ( not DCbus(tp,b) )                 = yes ;
3563   
3564  * Bus live island status
3565  busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3566   
3567  * Offer initialisation - offer must be mapped to a node that is mapped to a
3568  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3569  offer(tp,o) $ sum[ (n,b) $ { i_tradePeriodOfferNode(tp,o,n) and
3570                               nodeBus(tp,n,b) and
3571                               ( (not i_useBusNetworkModel(tp)) or
3572                                 busElectricalIsland(tp,b))
3573                             }, 1 ] = yes ;
3574   
3575  * IL offer mapped to a node that is mapped to a bus always valid
3576  * (updated on 23 July 2015 based on an email from SO Bennet Tucker on 21 July 2015))
3577  offer(tp,o)
3578      $ sum[ (n,b)
3579           $ { i_tradePeriodOfferNode(tp,o,n) and nodeBus(tp,n,b)
3580           and sum[ (trdBlk,ILofrCmpnt)
3581                  , i_tradePeriodFastILRoffer(tp,o,trdBlk,ILofrCmpnt)
3582                  + i_tradePeriodSustainedILRoffer(tp,o,trdBlk,ILofrCmpnt) ]
3583             }, 1 ] = yes ;
3584   
3585  * Bid initialisation - bid must be mapped to a node that is mapped to a bus
3586  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3587  bid(tp,bd) $ sum[ (n,b) $ { i_tradePeriodBidNode(tp,bd,n) and
3588                              nodeBus(tp,n,b) and
3589                              ( (not i_useBusNetworkModel(tp)) or
3590                                busElectricalIsland(tp,b) )
3591                            }, 1 ] = yes ;
3592   
3593  * Initialise Risk/Reserve data for the current trading period
3594  RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3595   
3596  * Mapping bus, node, offer, bid and island start for the current trade period
3597  offerNode(offer,n)   $ i_tradePeriodOfferNode(offer,n)                 = yes ;
3598  bidNode(bid,n)       $ i_tradePeriodBidNode(bid,n)                     = yes ;
3599  busIsland(bus,ild)   $ i_tradePeriodBusIsland(bus,ild)                 = yes ;
3600  nodeIsland(tp,n,ild) $ sum[ b $ { bus(tp,b) and node(tp,n)
3601                                and nodeBus(tp,n,b)
3602                                and busIsland(tp,b,ild) }, 1 ]           = yes ;
3603  offerIsland(offer(tp,o),ild)
3604      $ sum[ n $ { offerNode(tp,o,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3605  bidIsland(bid(tp,bd),ild)
3606      $ sum[ n $ { bidNode(tp,bd,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3607   
3608  IslandRiskGenerator(tp,ild,o)
3609      $ { offerIsland(tp,o,ild) and RiskGenerator(tp,o) } = yes ;
3610   
3611  * Set the primary-secondary offer combinations
3612  primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3613   
3614  * Identification of primary and secondary units
3615  hasSecondaryOffer(tp,o) = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o,o1), 1 ] ;
3616  hasPrimaryOffer(tp,o)   = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o1,o), 1 ];
3617   
3618  * Initialise offer parameters for the current trade period start
3619  generationStart(offer(tp,o))
3620      = sum[ offerPar $ ( ord(offerPar) = 1 )
3621                      , i_tradePeriodOfferParameter(tp,o,offerPar)
3622                      + sum[ o1 $ primarySecondaryOffer(tp,o,o1)
3623                                ,i_tradePeriodOfferParameter(tp,o1,offerPar) ]
3624           ];
3625   
3626  rampRateUp(offer)
3627      = sum[ offerPar $ ( ord(offerPar) = 2 )
3628                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3629  rampRateDown(offer)
3630      = sum[ offerPar $ ( ord(offerPar) = 3 )
3631                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3632  reserveGenerationMaximum(offer)
3633      = sum[ offerPar $ ( ord(offerPar) = 4 )
3634                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3635  windOffer(offer)
3636      = sum[ offerPar $ ( ord(offerPar) = 5 )
3637                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3638  FKband(offer)
3639      = sum[ offerPar $ ( ord(offerPar) = 6 )
3640                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3641   
3642  priceResponsive(offer)
3643      = sum[ offerPar $ ( ord(offerPar) = 7 )
3644                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3645   
3646  potentialMW(offer)
3647      = sum[ offerPar $ ( ord(offerPar) = 8 )
3648                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3649   
3650   
3651  * Initialise energy offer data for the current trade period start
3652  generationOfferMW(offer,trdBlk)
3653      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3654                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3655  generationOfferPrice(offer,trdBlk)
3656      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3657                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3658   
3659  * Valid generation offer blocks are defined as those with a positive block limit
3660  validGenerationOfferBlock(offer,trdBlk)
3661      $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3662   
3663  * Define set of positive energy offers
3664  positiveEnergyOffer(offer)
3665      $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3666   
3667  * Initialise reserve offer data for the current trade period start
3668  PLSRReserveType(resT) $ (ord(resT) = 1) = yes ;
3669  TWDRReserveType(resT) $ (ord(resT) = 2) = yes ;
3670  ILReserveType(resT)   $ (ord(resT) = 3) = yes ;
3671   
3672  reserveOfferProportion(offer,trdBlk,resC)
3673      $ ( ord(resC) = 1 )
3674      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3675           , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3676   
3677  reserveOfferProportion(offer,trdBlk,resC)
3678      $ ( ord(resC) = 2 )
3679      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3680           , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3681   
3682  reserveOfferMaximum(offer(tp,o),trdBlk,resC,PLSRReserveType)
3683      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3684      , i_tradePeriodFastPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3685      + i_tradePeriodSustainedPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3686   
3687  reserveOfferMaximum(offer(tp,o),trdBlk,resC,TWDRReserveType)
3688      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3689      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3690      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3691   
3692  reserveOfferMaximum(offer,trdBlk,resC,ILReserveType)
3693      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3694      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3695      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ];
3696   
3697  reserveOfferPrice(offer,trdBlk,resC,PLSRReserveType)
3698      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3699      , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3700      + i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3701   
3702   
3703  reserveOfferPrice(offer,trdBlk,resC,TWDRReserveType)
3704      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3705      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3706      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3707   
3708  reserveOfferPrice(offer,trdBlk,resC,ILReserveType)
3709      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3710      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3711      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ] ;
3712   
3713  * Only reserve offer block with a positive block limit is valid
3714  validReserveOfferBlock(offer,trdBlk,resC,resT)
3715      $ (reserveOfferMaximum(offer,trdBlk,resC,resT) > 0) = yes ;
3716   
3717  * Bid energy data
3718  purchaseBidMW(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3719      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3720           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3721   
3722  purchaseBidPrice(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3723      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3724           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3725   
3726  validPurchaseBidBlock(bid,trdBlk)
3727      $ { ( purchaseBidMW(bid,trdBlk) > 0 ) or
3728          ( useDSBFDemandBidModel * purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3729   
3730  * Bid IL data
3731  purchaseBidILRMW(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3732      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3733           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3734           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3735   
3736  purchaseBidILRPrice(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3737      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3738           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3739           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3740   
3741  validPurchaseBidILRBlock(bid,trdBlk,resC)
3742      $ ( purchaseBidILRMW(bid,trdBlk,resC) > 0 ) = yes ;
3743   
3744   
3745  * Initialise demand/bid data for the current trade period start
3746  nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3747   
3748  * If a bid is valid --> ignore the demand at the node connected to the bid
3749  * (PA suggested during v1.4 Audit)
3750  nodeDemand(node(tp,n))
3751      $ { useDSBFDemandBidModel and
3752          Sum[ bd $ { bidNode(tp,bd,n) and i_tradePeriodDispatchableBid(tp,bd) }
3753             , 1 ]
3754        } = 0;
3755   
3756  * Real Time Pricing - First RTD load calculation
3758  if studyMode = 101 then
3759   
3760  *   Calculate first target total load [3.8.5.5]
3761  *   Island-level MW load forecast. For the fist loop:
3762  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
3763      TargetTotalLoad(tp,ild) = islandMWIPS(tp,ild) + islandPDS(tp,ild) - islandLosses(tp,ild);
3764   
3765  *   Flag if estimate load is scalable [3.8.5.7]
3766  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
3767  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
3768  *   assigned directly to EstimatedInitialLoad
3769      EstLoadIsScalable(tp,n) =  1 $ { (LoadIsNCL(tp,n) = 0)
3770                                   and (ConformingFactor(tp,n) > 0) } ;
3771   
3772  *   Calculate estimate non-scalable load [3.8.5.8]
3773  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
3774  *   conforming Pnode this will be the ConformingFactor MW input if that value is
3775  *   negative, otherwise it will be zero
3776      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 1 ) = NonConformingLoad(tp,n);
3777      EstNonScalableLoad(tp,n) $ ( LoadIsNCL(tp,n) = 0 ) = ConformingFactor(tp,n);
3778      EstNonScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = 0;
3779   
3780  *   Calculate estimate scalable load [3.8.5.10]
3781  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
3782  *   this value will be the ConformingFactor if it is non-negative, otherwise this
3783  *   value will be zero'
3784      EstScalableLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 ) = ConformingFactor(tp,n);
3785   
3786   
3787  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
3788  *   in order to calculate EstimatedInitialLoad
3789      EstScalingFactor(tp,ild)
3790          = (islandMWIPS(tp,ild) - islandLosses(tp,ild)
3791            - Sum[ n $ nodeIsland(tp,n,ild), EstNonScalableLoad(tp,n) ]
3792            ) / Sum[ n $ nodeIsland(tp,n,ild), EstScalableLoad(tp,n) ]
3793   
3794          ;
3795   
3796  *   Calculate estimate initial load [3.8.5.6]
3797  *   Calculated estimate of initial MW load, available to be used as an
3798  *   alternative to InputInitialLoad
3799      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 1 )
3800          = ConformingFactor(tp,n) * Sum[ ild $ nodeisland(tp,n,ild)
3801                                        , EstScalingFactor(tp,ild)] ;
3802      EstimatedInitialLoad(tp,n) $ ( EstLoadIsScalable(tp,n) = 0 )
3803          = NonConformingLoad(tp,n);
3804   
3805  *   Calculate initial load [3.8.5.2]
3806  *   Value that represents the Pnode load MW at the start of the solution
3807  *   interval. Depending on the inputs this value will be either actual load,
3808  *   an operator applied override or an estimated initial load
3809      InitialLoad(tp,n) = InputInitialLoad(tp,n);
3810      InitialLoad(tp,n) $ { (LoadIsOverride(tp,n) = 0)
3811                        and ( (useActualLoad(tp) = 0) or (LoadIsBad(tp,n) = 1) )
3812                          } = EstimatedInitialLoad(tp,n) ;
3813   
3814  *   Flag if load is scalable [3.8.5.4]
3815  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
3816  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
3817  *   assigned to nodedemand
3818      LoadIsScalable(tp,n) = 1 $ { (LoadIsNCL(tp,n) = 0)
3819                               and (LoadIsOverride(tp,n) = 0)
3820                               and (InitialLoad(tp,n) >= 0) } ;
3821   
3822  *   Calculate Island-level scaling factor [3.8.5.3]
3823  *   --> applied to InitialLoad in order to calculate nodedemand
3824      LoadScalingFactor(tp,ild)
3825          = ( TargetTotalLoad(tp,ild)
3826            - Sum[ n $ { nodeIsland(tp,n,ild)
3827                     and (LoadIsScalable(tp,n) = 0) }, InitialLoad(tp,n) ]
3828            ) / Sum[ n $ { nodeIsland(tp,n,ild)
3829                       and (LoadIsScalable(tp,n) = 1) }, InitialLoad(tp,n) ]
3830          ;
3831   
3832  *   Calculate nodedemand [3.8.5.1]
3833      nodedemand(tp,n) $ LoadIsScalable(tp,n)
3834          = InitialLoad(tp,n) * sum[ ild $ nodeisland(tp,n,ild)
3835                                   , LoadScalingFactor(tp,ild) ];
3836   
3837      nodedemand(tp,n) $ (LoadIsScalable(tp,n) = 0) = InitialLoad(tp,n);
3838   
3839  Endif;
3841   
3842   
3843   
3844   
3845   
3846  * Branch is defined if there is a defined terminal bus, it has a non-zero
3847  * capacity and is closed for that trade period
3848  * Update the pre-processing code that removes branches which have a limit of zero
3849  * so that it removes a branch if either direction has a limit of zero.
3850  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3851                    (not i_tradePeriodHVDCBranch(tp,br)) and
3852                    sum[ fd $ (ord(fd)=1), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3853                    sum[ fd $ (ord(fd)=2), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3854                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3855                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3856                  } = yes ;
3857   
3858  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3859                    (i_tradePeriodHVDCBranch(tp,br)) and
3860                    sum[ fd, i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3861                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3862                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3863                  } = yes ;
3864   
3865   
3866  branchBusDefn(branch,b,b1) $ i_tradePeriodBranchDefn(branch,b,b1)    = yes ;
3867  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b,b1), 1] = yes ;
3868  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b1,b), 1] = yes ;
3869   
3870  * HVDC link and AC branch definition
3871  HVDClink(branch)      $ i_tradePeriodHVDCBranch(branch)         = yes ;
3872  HVDCpoles(branch)     $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3873  HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3874  ACbranch(branch)      $ ( not HVDClink(branch) )                = yes ;
3875   
3876  * Determine sending and receiving bus sets
3877  loop((frB,toB),
3878      ACbranchSendingBus(ACbranch,frB,fd)
3879          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3880   
3881      ACbranchReceivingBus(ACbranch,toB,fd)
3882          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3883   
3884      ACbranchSendingBus(ACbranch,toB,fd)
3885          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3886   
3887      ACbranchReceivingBus(ACbranch,frB,fd)
3888          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3889  );
3890   
3891  HVDClinkSendingBus(HVDClink,frB)
3892      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3893   
3894  HVDClinkReceivingBus(HVDClink,toB)
3895      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3896   
3897  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
3898  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
3899   
3900  * Determine the HVDC inter-island pole in the northward and southward direction
3901   
3902  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 1) and HVDClink(tp,br) }
3903      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 2)
3904                                         and nodeIsland(tp,n,ild)
3905                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3906   
3907  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 2) and HVDClink(tp,br) }
3908      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 1)
3909                                         and nodeIsland(tp,n,ild)
3910                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3911   
3912  * Mapping HVDC branch to pole to account for name changes to Pole 3
3913  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3914  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3915  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3916  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3917  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3918  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3919   
3920  * Initialise network data for the current trade period start
3921  * Node-bus allocation factor
3922  nodeBusAllocationFactor(tp,n,b) $ { node(tp,n) and bus(tp,b) }
3923      = i_tradePeriodNodeBusAllocationFactor(tp,n,b) ;
3924   
3925  * Flag to allow roundpower on the HVDC link
3926  allowHVDCroundpower(tp) = i_tradePeriodAllowHVDCroundpower(tp) ;
3927   
3928  * Allocate the input branch parameters to the defined branchCapacity
3929  branchCapacity(branch,fd)
3930      = i_tradePeriodBranchCapacityDirected(branch,fd) ;
3931  * HVDC Links do not have reverse capacity
3932  branchCapacity(HVDClink,fd) $ ( ord(fd) = 2 ) = 0 ;
3933   
3934  * Allocate the input branch parameters to the defined branchResistance
3935  branchResistance(branch)
3936      = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3937           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3938   
3939  * Convert susceptance from -Bpu to B% for data post-MSP
3940  branchSusceptance(ACbranch(tp,br))
3941      = sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3942           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ]
3943      * [ 100$(not i_useBusNetworkModel(tp)) - 100$i_useBusNetworkModel(tp) ];
3944   
3945  branchLossBlocks(branch)
3946      = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3947           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3948   
3949  * Ensure fixed losses for no loss AC branches are not included
3950  branchFixedLoss(ACbranch)
3951      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3952           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3953           ] $ (branchLossBlocks(ACbranch) > 1) ;
3954   
3955  branchFixedLoss(HVDClink)
3956      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3957           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3958   
3959  * Set resistance and fixed loss to zero if do not want to use the loss model
3960  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3961  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
3962   
3963  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3964  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
3965   
3966  * Initialise loss tranches data for the current trade period start
3967  * The loss factor coefficients assume that the branch capacity is in MW
3968  * and the resistance is in p.u.
3969   
3970  * Loss branches with 0 loss blocks
3971  lossSegmentMW(branch,los,fd)
3972      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3973      = branchCapacity(branch,fd) ;
3974   
3975  LossSegmentFactor(branch,los,fd)
3976      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3977      = 0 ;
3978   
3979  * Loss branches with 1 loss blocks
3980  LossSegmentMW(branch,los,fd)
3981      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3982      = maxFlowSegment ;
3983   
3984  LossSegmentFactor(branch,los,fd)
3985      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3986      = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
3987   
3988  * Loss branches with 3 loss blocks
3989  loop( branch $ (branchLossBlocks(branch) = 3),
3990  *   Segment 1
3991      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3992          = lossCoeff_A * branchCapacity(branch,fd) ;
3993   
3994      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3995          = 0.01 * 0.75 * lossCoeff_A
3996          * branchResistance(branch) * branchCapacity(branch,fd) ;
3997   
3998  *   Segment 2
3999      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
4000          = (1-lossCoeff_A) * branchCapacity(branch,fd) ;
4001   
4002      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4003          = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
4004   
4005  *   Segment 3
4006      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4007          = maxFlowSegment ;
4008   
4009      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4010          = 0.01 * (2 - (0.75*lossCoeff_A))
4011          * branchResistance(branch) * branchCapacity(branch,fd) ;
4012  );
4013   
4014  * Loss branches with 6 loss blocks
4015  loop( branch $ (branchLossBlocks(branch) = 6),
4016  *   Segment 1
4017      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
4018          = lossCoeff_C  * branchCapacity(branch,fd) ;
4019   
4020      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
4021          = 0.01 * 0.75 * lossCoeff_C
4022          * branchResistance(branch) * branchCapacity(branch,fd) ;
4023   
4024  *   Segment 2
4025      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
4026          = lossCoeff_D * branchCapacity(branch,fd) ;
4027   
4028      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
4029          = 0.01 * lossCoeff_E
4030          * branchResistance(branch) * branchCapacity(branch,fd) ;
4031   
4032  *   Segment 3
4033      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
4034          = 0.5 * branchCapacity(branch,fd) ;
4035   
4036      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
4037          = 0.01 * lossCoeff_F
4038          * branchResistance(branch) * branchCapacity(branch,fd) ;
4039   
4040  *   Segment 4
4041      LossSegmentMW(branch,los,fd) $ (ord(los) = 4)
4042          = (1 - lossCoeff_D) * branchCapacity(branch,fd) ;
4043   
4044      LossSegmentFactor(branch,los,fd) $ (ord(los) = 4)
4045          = 0.01 * (2 - lossCoeff_F)
4046          * branchResistance(branch) * branchCapacity(branch,fd) ;
4047   
4048  *   Segment 5
4049      LossSegmentMW(branch,los,fd) $ (ord(los) = 5)
4050          = (1 - lossCoeff_C) * branchCapacity(branch,fd) ;
4051   
4052      LossSegmentFactor(branch,los,fd) $ (ord(los) = 5)
4053          = 0.01 * (2 - lossCoeff_E)
4054          * branchResistance(branch) * branchCapacity(branch,fd) ;
4055   
4056  *   Segment 6
4057      LossSegmentMW(branch,los,fd) $ (ord(los) = 6)
4058          = maxFlowSegment ;
4059   
4060      LossSegmentFactor(branch,los,fd) $ (ord(los) = 6)
4061          = 0.01 * (2 - (0.75*lossCoeff_C))
4062          * branchResistance(branch) * branchCapacity(branch,fd) ;
4063  ) ;
4064   
4065  * HVDC does not have backward flow --> No loss segment for backward flow
4066  LossSegmentMW(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4067  LossSegmentFactor(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
4068   
4069   
4070  * Valid loss segment for a branch is defined as a loss segment that
4071  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
4072  validLossSegment(branch,los,fd) = yes $ { (ord(los) = 1) or
4073                                            LossSegmentMW(branch,los,fd) or
4074                                            LossSegmentFactor(branch,los,fd) } ;
4075   
4076  * HVDC loss model requires at least two loss segments and
4077  * an additional loss block due to cumulative loss formulation
4078  validLossSegment(HVDClink,los,fd)
4079      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
4080   
4081  validLossSegment(HVDClink,los,fd)
4082      $ { (branchLossBlocks(HVDClink) > 1) and
4083          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
4084          (sum[ los1, LossSegmentMW(HVDClink,los1,fd)
4085                    + LossSegmentFactor(HVDClink,los1,fd) ] > 0)
4086        } = yes ;
4087   
4088  * branches that have non-zero loss factors
4089  LossBranch(branch) $ sum[ (los,fd), LossSegmentFactor(branch,los,fd) ] = yes ;
4090   
4091  * Create AC branch loss segments
4092  ACbranchLossMW(ACbranch,los,fd)
4093      $ { validLossSegment(ACbranch,los,fd) and (ord(los) = 1) }
4094      = LossSegmentMW(ACbranch,los,fd) ;
4095   
4096  ACbranchLossMW(ACbranch,los,fd)
4097      $ { validLossSegment(ACbranch,los,fd) and (ord(los) > 1) }
4098      = LossSegmentMW(ACbranch,los,fd) - LossSegmentMW(ACbranch,los-1,fd) ;
4099   
4100  ACbranchLossFactor(ACbranch,los,fd)
4101      $ validLossSegment(ACbranch,los,fd) = LossSegmentFactor(ACbranch,los,fd) ;
4102   
4103  * Create HVDC loss break points
4104  HVDCBreakPointMWFlow(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4105  HVDCBreakPointMWLoss(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
4106   
4107  HVDCBreakPointMWFlow(HVDClink,bp,fd)
4108      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) > 1) }
4109      = LossSegmentMW(HVDClink,bp-1,fd) ;
4110   
4111  HVDCBreakPointMWLoss(HVDClink,bp,fd)
4112      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) = 2) }
4113      =  LossSegmentMW(HVDClink,bp-1,fd) * LossSegmentFactor(HVDClink,bp-1,fd) ;
4114   
4115  loop( (HVDClink(branch),bp) $ (ord(bp) > 2),
4116      HVDCBreakPointMWLoss(branch,bp,fd) $ validLossSegment(branch,bp,fd)
4117          = LossSegmentFactor(branch,bp-1,fd)
4118          * [ LossSegmentMW(branch,bp-1,fd) - LossSegmentMW(branch,bp-2,fd) ]
4119          + HVDCBreakPointMWLoss(branch,bp-1,fd) ;
4120  ) ;
4121   
4122  * Initialise branch constraint data for the current trading period
4123  branchConstraint(tp,brCstr)
4124      $ sum[ branch(tp,br)
4125           $ i_tradePeriodBranchConstraintFactors(tp,brCstr,br), 1 ] = yes ;
4126   
4127  branchConstraintFactors(branchConstraint,br)
4128      = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
4129   
4130  branchConstraintSense(branchConstraint)
4131      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4132           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4133   
4134  branchConstraintLimit(branchConstraint)
4135      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4136           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4137   
4138  * Calculate parameters for NMIR project ----------------------------------------
4139  islandRiskGroup(tp,ild,rg,riskC)
4140      = yes $ sum[ o $ { offerIsland(tp,o,ild)
4141                     and riskGroupOffer(tp,rg,o,riskC) }, 1 ] ;
4142   
4143  modulationRisk(tp) = smax[ riskC, modulationRiskClass(tp,RiskC) ];
4144   
4145  reserveShareEnabledOverall(tp) = smax[ resC, reserveShareEnabled(tp,resC) ];
4146   
4147  roPwrZoneExit(tp,resC)
4148      = [ roundPower2MonoLevel(tp) - modulationRisk(tp) ]$(ord(resC)=1)
4149      + bipole2MonoLevel(tp)$(ord(resC)=2) ;
4150   
4151  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition by SPD pre-processing (same as for SIR),
            a change from the existing where the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone for FIR will be removed by SPD pre-processing (same as for SIR),
            a change from the existing where the InNoReverseZone for FIR is never removed by SPD pre-processing.
4159   
4160  if (inputGDXGDate >= jdate(2019,03,28),
4161      roPwrZoneExit(tp,resC) = bipole2MonoLevel(tp) ;
4162  ) ;
4163   
4164  * National market refinement end
4165   
4166   
4167  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
4168  sharedNFRLoad(tp,ild)
4169      = sum[ nodeIsland(tp,n,ild), nodeDemand(tp,n)]
4170      + sum[ (bd,trdBlk) $ bidIsland(tp,bd,ild), purchaseBidMW(tp,bd,trdBlk) ]
4171      - sharedNFRLoadOffset(tp,ild) ;
4172   
4173  sharedNFRMax(tp,ild) = Min{ RMTReserveLimitTo(tp,ild,'FIR'),
4174                              sharedNFRFactor(tp)*sharedNFRLoad(tp,ild) } ;
4175   
4176  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
4177  * TN on 22 May 2017: Usually a branch group constraint that limits the HVDC flow only involves
4178  * the HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017, the
4179  * constraint HAY_BEN_High_Frequency_limit involved all four branches in the form:
4180  *   HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
4181  * This method of formulating the constraint prevented the previous formulation of monopoleConstraint
4182  * and bipoleConstraintfrom working properly. Those constraints have been reformulated (see below)
4183  * in order to cope with the formulation observed on 18 May 2017.
4184  monopoleConstraint(tp,ild,brCstr,br)
4185      $ { HVDCpoles(tp,br)
4186      and ( not rampingConstraint(tp,brCstr) )
4187      and ( branchConstraintSense(tp,brCstr) = -1 )
4188      and (Sum[ (br1,b) $ {HVDClinkSendingBus(tp,br1,b) and busIsland(tp,b,ild)}
4189                        , branchConstraintFactors(tp,brCstr,br1)    ] = 1)
4190      and (Sum[ b $ {HVDClinkSendingBus(tp,br,b) and busIsland(tp,b,ild)}
4191                   , branchConstraintFactors(tp,brCstr,br)      ] = 1)
4192         } = yes ;
4193   
4194  bipoleConstraint(tp,ild,brCstr)
4195      $ { ( not rampingConstraint(tp,brCstr) )
4196      and ( branchConstraintSense(tp,brCstr) = -1 )
4197      and (Sum[ (br,b) $ { HVDCpoles(tp,br)
4198                       and HVDClinkSendingBus(tp,br,b)
4199                       and busIsland(tp,b,ild) }
4200                      , branchConstraintFactors(tp,brCstr,br)  ] = 2)
4201                         } = yes ;
4202   
4203  monoPoleCapacity(tp,ild,br)
4204      = Sum[ (b,fd) $ { BusIsland(tp,b,ild)
4205                    and HVDCPoles(tp,br)
4206                    and HVDClinkSendingBus(tp,br,b)
4207                    and ( ord(fd) = 1 )
4208                      }, branchCapacity(tp,br,fd) ] ;
4209   
4210  monoPoleCapacity(tp,ild,br)
4211      $ Sum[ brCstr $ monopoleConstraint(tp,ild,brCstr,br), 1]
4212      = Smin[ brCstr $ monopoleConstraint(tp,ild,brCstr,br)
4213            , branchConstraintLimit(tp,brCstr) ];
4214   
4215  monoPoleCapacity(tp,ild,br)
4216      = Min( monoPoleCapacity(tp,ild,br),
4217             sum[ fd $ ( ord(fd) = 1 ), branchCapacity(tp,br,fd) ] );
4218   
4219  biPoleCapacity(tp,ild)
4220      $ Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1]
4221      = Smin[ brCstr $ bipoleConstraint(tp,ild,brCstr)
4222            , branchConstraintLimit(tp,brCstr) ];
4223   
4224  biPoleCapacity(tp,ild)
4225      $ { Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1] = 0 }
4226      = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4227                       and HVDClinkSendingBus(tp,br,b)
4228                       and ( ord(fd) = 1 )
4229                         }, branchCapacity(tp,br,fd) ] ;
4230   
4231  HVDCMax(tp,ild)
4232      = Min( biPoleCapacity(tp,ild), Sum[ br, monoPoleCapacity(tp,ild,br) ] ) ;
4233   
4234  * Calculate HVDC HVDC Loss segment applied for NMIR
4235   
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
4241  if (inputGDXGDate >= jdate(2016,11,22),
4242        HVDCCapacity(tp,ild)
4243            = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4244                             and HVDClinkSendingBus(tp,br,b)
4245                             and ( ord(fd) = 1 )
4246                               }, branchCapacity(tp,br,fd) ] ;
4247   
4248        numberOfPoles(tp,ild)
4249            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4250                          and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
4251   
4252        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4253            = Prod[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4254                           and HVDClinkSendingBus(tp,br,b)
4255                             }, branchResistance(tp,br) ]
4256            / Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4257                          and HVDClinkSendingBus(tp,br,b)
4258                            }, branchResistance(tp,br) ] ;
4259   
4260        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 1)
4261            = Sum[ br $ monoPoleCapacity(tp,ild,br), branchResistance(tp,br) ] ;
4262  else
4263      HVDCCapacity(tp,ild)
4264          = Sum[ (br,b,b1,fd) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4265                              and i_tradePeriodBusIsland(tp,b,ild)
4266                              and i_tradePeriodBranchDefn(tp,br,b,b1)
4267                              and ( ord(fd) = 1 )
4268                                }, i_tradePeriodBranchCapacityDirected(tp,br,fd) ] ;
4269   
4270      numberOfPoles(tp,ild)
4271          =Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4272                        and i_tradePeriodBusIsland(tp,b,ild)
4273                        and i_tradePeriodBranchDefn(tp,br,b,b1)
4274                        and sum[ fd $ ( ord(fd) = 1 )
4275                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4276                          }, 1 ] ;
4277   
4278      HVDCResistance(tp,ild)
4279          =  Sum[ (br,b,b1,i_branchParameter)
4280                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4281                and i_tradePeriodBusIsland(tp,b,ild)
4282                and i_tradePeriodBranchDefn(tp,br,b,b1)
4283                and (ord(i_branchParameter) = 1)
4284                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter) ] ;
4285   
4286      HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4287          = Prod[ (br,b,b1,i_branchParameter)
4288                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4289                and i_tradePeriodBusIsland(tp,b,ild)
4290                and i_tradePeriodBranchDefn(tp,br,b,b1)
4291                and sum[ fd $ ( ord(fd) = 1 )
4292                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4293                and (ord(i_branchParameter) = 1)
4294                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter)
4295                ] / HVDCResistance(tp,ild) ;
4296  ) ;
4297   
4298  * Segment 1
4299  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 1)
4300      = HVDCCapacity(tp,ild) * lossCoeff_C ;
4301   
4302  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 1)
4303      = 0.01 * 0.75 * lossCoeff_C
4304      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4305   
4306  * Segment 2
4307  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 2)
4308      = HVDCCapacity(tp,ild) * lossCoeff_D ;
4309   
4310  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 2)
4311      = 0.01 * lossCoeff_E
4312      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4313   
4314  * Segment 3
4315  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 3)
4316      = HVDCCapacity(tp,ild) * 0.5 ;
4317   
4318  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 3)
4319      = 0.01 * lossCoeff_F
4320      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4321   
4322  * Segment 4
4323  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 4)
4324      = HVDCCapacity(tp,ild) * (1 - lossCoeff_D) ;
4325   
4326  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 4)
4327      = 0.01 * (2 - lossCoeff_F)
4328      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4329   
4330  * Segment 5
4331  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 5)
4332      = HVDCCapacity(tp,ild) * (1 - lossCoeff_C) ;
4333   
4334  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 5)
4335      = 0.01 * (2 - lossCoeff_E)
4336      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4337   
4338  * Segment 6
4339  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 6)
4340      = HVDCCapacity(tp,ild) ;
4341   
4342  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 6)
4343      = 0.01 * (2 - (0.75*lossCoeff_C))
4344      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4345   
4346  * Parameter for energy lambda loss model
4347  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4348  HVDCSentBreakPointMWLoss(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4349   
4350  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) > 1)
4351      = HVDCLossSegmentMW(tp,ild,bp-1) ;
4352   
4353  loop( (tp,ild,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)},
4354      HVDCSentBreakPointMWLoss(tp,ild,bp)
4355          = HVDClossScalingFactor(tp)
4356          * HVDCLossSegmentFactor(tp,ild,bp-1)
4357          * [ HVDCLossSegmentMW(tp,ild,bp-1)
4358            - HVDCSentBreakPointMWFlow(tp,ild,bp-1) ]
4359          + HVDCSentBreakPointMWLoss(tp,ild,bp-1) ;
4360  ) ;
4361   
4362  * Parameter for energy+reserve lambda loss model
4363   
4364  * Ideally SO should use asymmetric loss curve
4365  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4366      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4367                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4368           , -HVDCSentBreakPointMWFlow(tp,ild1,rsbp1) ];
4369   
4370  * SO decide to use symmetric loss curve instead
4371  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4372      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4373           , -HVDCSentBreakPointMWFlow(tp,ild,rsbp1) ];
4374   
4375  HVDCReserveBreakPointMWFlow(tp,ild,rsbp)
4376      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4377      = HVDCSentBreakPointMWFlow(tp,ild,rsbp-6) ;
4378   
4379   
4380  * Ideally SO should use asymmetric loss curve
4381  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4382      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4383                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4384           , HVDCSentBreakPointMWLoss(tp,ild1,rsbp1) ];
4385   
4386  * SO decide to use symmetric loss curve instead
4387  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4388      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4389           , HVDCSentBreakPointMWLoss(tp,ild,rsbp1) ];
4390   
4391  HVDCReserveBreakPointMWLoss(tp,ild,rsbp)
4392      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4393      = HVDCSentBreakPointMWLoss(tp,ild,rsbp-6);
4394   
4395  * Parameter for lambda loss model  end
4396   
4397  * Initialze parameters for NMIR project end ----------------------------------
4398   
4399   
4400  * Initialise risk/reserve data for the current trade period start
4401   
4402  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
4403  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
4404  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
4405  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
4406  GenRisk(riskC)     $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4407  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4408  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4409  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4410   
4411  * Define the CE and ECE risk class set to support the different CE and ECE CVP
4412  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
4413  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
4414  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
4415  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
4416  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4417  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4418  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4419  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4420   
4421  * Risk parameters
4422  FreeReserve(tp,ild,resC,riskC)
4423      = sum[ riskPar $ (ord(riskPar) = 1)
4424                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ]
4425  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4426      - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(tp,ild1)
4427           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4428             and (inputGDXGDate >= jdate(2016,10,20)) }
4429      ;
4430   
4431  IslandRiskAdjustmentFactor(tp,ild,resC,riskC) $ useReserveModel
4432      = sum[ riskPar $ (ord(riskPar) = 2)
4433                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4434   
4435  * HVDC rampup max - (3.4.1.3) - SPD version 11
4436  HVDCpoleRampUp(tp,ild,resC,riskC)
4437      = sum[ riskPar $ (ord(riskPar) = 3)
4438                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4439   
4440  * Index IslandMinimumRisk to cater for CE and ECE minimum risk
4441  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 4)
4442      = i_tradePeriodManualRisk(tp,ild,resC) ;
4443   
4444  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 6)
4445      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4446   
4447  * HVDC secondary risk parameters
4448  HVDCsecRiskEnabled(tp,ild,riskC)= i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC);
4449  HVDCsecRiskSubtractor(tp,ild)   = i_tradePeriodHVDCsecRiskSubtractor(tp,ild) ;
4450   
4451  * Min risks for the HVDC secondary risk are the same as the island min risk
4452  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 7)
4453      = i_tradePeriodManualRisk(tp,ild,resC) ;
4454   
4455  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 8)
4456      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4457   
4458  * The MW combined maximum capability for generation and reserve of class.
4459  reserveClassGenerationMaximum(offer,resC) = ReserveGenerationMaximum(offer) ;
4460   
4461  reserveClassGenerationMaximum(offer,resC)
4462      $ i_tradePeriodReserveClassGenerationMaximum(offer,resC)
4463      = i_tradePeriodReserveClassGenerationMaximum(offer,resC) ;
4464   
4465  * Calculation of reserve maximum factor - 5.2.1.1
4466  ReserveMaximumFactor(offer,resC) = 1 ;
4467  ReserveMaximumFactor(offer,resC)
4468      $ (ReserveClassGenerationMaximum(offer,resC)>0)
4469      = ReserveGenerationMaximum(offer)
4470      / reserveClassGenerationMaximum(offer,resC) ;
4471   
4472  * Virtual reserve
4473  virtualReserveMax(tp,ild,resC) = i_tradePeriodVROfferMax(tp,ild,resC) ;
4474  virtualReservePrice(tp,ild,resC) = i_tradePeriodVROfferPrice(tp,ild,resC) ;
4475   
4476  * Initialise AC node constraint data for the current trading period
4477  ACnodeConstraint(tp,ACnodeCstr)
4478      $ sum[ ACnode(tp,n)
4479           $ i_tradePeriodACnodeConstraintFactors(tp,ACnodeCstr,n), 1 ] = yes ;
4480   
4481  ACnodeConstraintFactors(ACnodeConstraint,n)
4482      = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
4483   
4484  ACnodeConstraintSense(ACnodeConstraint)
4485      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4486           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4487   
4488  ACnodeConstraintLimit(ACnodeConstraint)
4489      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4490           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4491   
4492  * Initialise market node constraint data for the current trading period
4493  MnodeConstraint(tp,MnodeCstr)
4494      $ { sum[ (offer(tp,o),resT,resC)
4495             $ { i_tradePeriodMnodeEnergyOfferConstraintFactors(tp,MnodeCstr,o) or
4496                 i_tradePeriodMnodeReserveOfferConstraintFactors(tp,MnodeCstr,o,resC,resT)
4497               }, 1
4498             ]
4499        or
4500          sum[ (bid(tp,bd),resC)
4501             $ { i_tradePeriodMnodeEnergyBidConstraintFactors(tp,MnodeCstr,bd) or
4502                 i_tradePeriodMnodeILReserveBidConstraintFactors(tp,MnodeCstr,bd,resC)
4503               }, 1
4504             ]
4505        } = yes ;
4506   
4507  MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
4508      = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
4509   
4510  MnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT)
4511      = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT) ;
4512   
4513  MnodeEnergyBidConstraintFactors(MnodeConstraint,bd)
4514      = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,bd) ;
4515   
4516  MnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC)
4517      = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC) ;
4518   
4519  MnodeConstraintSense(MnodeConstraint)
4520      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4521           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4522   
4523  MnodeConstraintLimit(MnodeConstraint)
4524      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4525           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4526   
4527  * Initialise mixed constraint data for the current trading period
4528  Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC)
4529      = i_type1MixedConstraintReserveMap(t1MixCstr,ild,resC,riskC) ;
4530   
4531  Type1MixedConstraint(tp,t1MixCstr)
4532      = i_tradePeriodType1MixedConstraint(tp,t1MixCstr) ;
4533   
4534  Type2MixedConstraint(tp,t2MixCstr)
4535      = i_tradePeriodType2MixedConstraint(tp,t2MixCstr) ;
4536   
4537  Type1MixedConstraintSense(tp,t1MixCstr)
4538      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
4539           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4540   
4541  Type1MixedConstraintLimit1(tp,t1MixCstr)
4542      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
4543           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4544   
4545  Type1MixedConstraintLimit2(tp,t1MixCstr)
4546      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
4547           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4548   
4549  Type2MixedConstraintSense(tp,t2MixCstr)
4550      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4551           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4552   
4553  Type2MixedConstraintLimit(tp,t2MixCstr)
4554      = sum[ CstrRHS$(ord(CstrRHS) = 2)
4555           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4556   
4557  Type1MixedConstraintCondition(tp,t1MixCstr)
4558      $ sum[ br $ { HVDChalfPoles(tp,br) and
4559                    i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4560                  }, 1
4561           ] = yes ;
4562   
4563  * Initialise generic constraint data for the current trading period
4564  GenericConstraint(tp,gnrcCstr) = i_tradePeriodGenericConstraint(tp,gnrcCstr) ;
4565   
4566  GenericEnergyOfferConstraintFactors(GenericConstraint,o)
4567      = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
4568   
4569  GenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT)
4570      = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT) ;
4571   
4572  GenericEnergyBidConstraintFactors(GenericConstraint,bd)
4573      = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,bd) ;
4574   
4575  GenericILReserveBidConstraintFactors(GenericConstraint,bd,resC)
4576      = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,bd,resC) ;
4577   
4578  GenericBranchConstraintFactors(GenericConstraint,br)
4579      = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
4580   
4581  GenericConstraintSense(GenericConstraint)
4582      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4583           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4584   
4585  GenericConstraintLimit(GenericConstraint)
4586      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4587           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4588   
4589   
4590  * Additional pre-processing on parameters --------------------------------------
4591   
4592  * Calculation of generation upper limits due to ramp rate limits
4593   
4594  * Only primary offers are considered (5.3.1.1)
4595  generationMaximum(tp,o) $ (not hasPrimaryOffer(tp,o))
4596      = sum[ validGenerationOfferBlock(tp,o,trdBlk)
4597           , generationOfferMW(tp,o,trdBlk) ]
4598      + sum[ (o1,trdBlk) $ { primarySecondaryOffer(tp,o,o1) and
4599                             validGenerationOfferBlock(tp,o1,trdBlk) }
4600           , generationOfferMW(tp,o1,trdBlk)
4601           ] ;
4602   
4603  * Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4604  * initial MW and ramp rate is used - Reference: Transpower Market Services
4605  rampTimeUp(offer) $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4606      = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4607                                     - generationStart(offer)
4608                                     ) / rampRateUp(offer)
4609           ] ;
4610   
4611  * Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4612  * initial MW and ramp rate is used - Reference: Transpower Market Services
4613  generationEndUp(offer) $ (not hasPrimaryOffer(offer))
4614      = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4615   
4616   
4617  * Calculation of generation lower limits due to ramp rate limits
4618   
4619  * Only primary offers are considered (5.3.2.1)
4620  * Negative prices for generation offers are not allowed? (5.3.2.1)
4621  generationMinimum(offer) = 0;
4622   
4623  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4624  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4625  rampTimeDown(offer) $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4626      = Min[ i_tradingPeriodLength, ( generationStart(offer)
4627                                    - generationMinimum(offer)
4628                                    ) / rampRateDown(offer)
4629           ] ;
4630   
4631  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4632  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4633  generationEndDown(offer) $ (not hasPrimaryOffer(offer))
4634      = Max[ 0, generationStart(offer) - rampRateDown(offer)*rampTimeDown(offer) ] ;
4635   
4636  o_offerEnergy_TP(dt,o) = 0;
4637  *   Additional pre-processing on parameters end
4638   
4639   
4640   
4641  * TN - Pivot or demand analysis begin
4644  * TN - Pivot or demand analysis begin end
4645   
4646  *=====================================================================================
4647  * 7. The vSPD solve loop
4648  *=====================================================================================
4649   
4650  unsolvedPeriod(tp) = yes;
4651  VSPDModel(tp) = 0 ;
4652  option clear = useBranchFlowMIP ;
4653  option clear = useMixedConstraintMIP ;
4654   
4655  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
4656    exitLoop = 0;
4657    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
4658   
4659  *   7a. Reset all sets, parameters and variables -------------------------------
4660      option clear = currTP ;
4661  *   Generation variables
4662      option clear = GENERATION ;
4663      option clear = GENERATIONBLOCK ;
4664  *   Purchase variables
4665      option clear = PURCHASE ;
4666      option clear = PURCHASEBLOCK ;
4667      option clear = PURCHASEILR ;
4668      option clear = PURCHASEILRBLOCK ;
4669  *   Network variables
4670      option clear = ACNODENETINJECTION ;
4671      option clear = ACNODEANGLE ;
4672      option clear = ACBRANCHFLOW ;
4673      option clear = ACBRANCHFLOWDIRECTED ;
4674      option clear = ACBRANCHLOSSESDIRECTED ;
4675      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4676      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4677      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4678      option clear = HVDCLINKFLOW ;
4679      option clear = HVDCLINKLOSSES ;
4680      option clear = LAMBDA ;
4681      option clear = LAMBDAINTEGER ;
4682      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
4683      option clear = HVDCPOLEFLOW_INTEGER ;
4684  *   Risk/Reserve variables
4685      option clear = RISKOFFSET ;
4686      option clear = HVDCREC ;
4687      option clear = ISLANDRISK ;
4688      option clear = RESERVEBLOCK ;
4689      option clear = RESERVE ;
4690      option clear = ISLANDRESERVE;
4691  *   NMIR variables
4692      option clear = SHAREDNFR ;
4693      option clear = SHAREDRESERVE ;
4694      option clear = HVDCSENT ;
4695      option clear = RESERVESHAREEFFECTIVE ;
4696      option clear = RESERVESHARERECEIVED ;
4697      option clear = RESERVESHARESENT ;
4698      option clear = HVDCSENDING ;
4699      option clear = INZONE ;
4700      option clear = HVDCSENTINSEGMENT ;
4701      option clear = HVDCRESERVESENT ;
4702      option clear = HVDCSENTLOSS ;
4703      option clear = HVDCRESERVELOSS ;
4704      option clear = LAMBDAHVDCENERGY ;
4705      option clear = LAMBDAHVDCRESERVE ;
4706      option clear = RESERVESHAREPENALTY ;
4707  *   Mixed constraint variables
4708      option clear = MIXEDCONSTRAINTVARIABLE ;
4709      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
4710  *   Objective
4711      option clear = NETBENEFIT ;
4712  *   Violation variables
4713      option clear = TOTALPENALTYCOST ;
4714      option clear = DEFICITBUSGENERATION ;
4715      option clear = SURPLUSBUSGENERATION ;
4716      option clear = DEFICITRESERVE ;
4717      option clear = DEFICITRESERVE_CE ;
4718      option clear = DEFICITRESERVE_ECE ;
4719      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4720      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4721      option clear = DEFICITRAMPRATE ;
4722      option clear = SURPLUSRAMPRATE ;
4723      option clear = DEFICITACnodeCONSTRAINT ;
4724      option clear = SURPLUSACnodeCONSTRAINT ;
4725      option clear = DEFICITBRANCHFLOW ;
4726      option clear = SURPLUSBRANCHFLOW ;
4727      option clear = DEFICITMNODECONSTRAINT ;
4728      option clear = SURPLUSMNODECONSTRAINT ;
4729      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
4730      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
4731      option clear = DEFICITGENERICCONSTRAINT ;
4732      option clear = SURPLUSGENERICCONSTRAINT ;
4733   
4734  *   Clear the pole circular branch flow flag
4735      option clear = circularBranchFlowExist ;
4736      option clear = poleCircularBranchFlowExist ;
4737      option clear = northHVDC ;
4738      option clear = southHVDC ;
4739      option clear = manualBranchSegmentMWFlow ;
4740      option clear = manualLossCalculation ;
4741      option clear = nonPhysicalLossExist ;
4742      option clear = modelSolved ;
4743      option clear = LPmodelSolved ;
4744  *   Disconnected bus post-processing
4745      option clear = busGeneration ;
4746      option clear = busLoad ;
4747      option clear = busDisconnected ;
4748      option clear = busPrice ;
4749   
4750   
4751  *   End reset
4752   
4753   
4754  *   7b. Initialise current trade period and model data -------------------------
4755      currTP(tp)  $ sequentialSolve       = yes;
4756      currTP(tp1) $ (not sequentialSolve) = yes;
4757   
4758  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4759      generationStart(offer(currTP(tp),o))
4760          $ (sum[ o1, generationStart(currTP,o1)] = 0)
4761          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
4762  *   Calculation of generation upper limits due to ramp rate limits
4763  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4764  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4765      rampTimeUp(offer(currTP(tp),o))
4766          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4767          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4768                                         - generationStart(offer)
4769                                         ) / rampRateUp(offer)
4770               ] ;
4771   
4772  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4773  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4774      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4775          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4776   
4777   
4778  *   Calculation of generation lower limits due to ramp rate limits
4779   
4780  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4781  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4782      rampTimeDown(offer(currTP(tp),o))
4783          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4784          = Min[ i_tradingPeriodLength, ( generationStart(offer)
4785                                        - generationMinimum(offer)
4786                                        ) / rampRateDown(offer)
4787               ] ;
4788   
4789  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4790  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4791      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4792          = Max[ 0, generationStart(offer)
4793                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
4794   
4795  *   Additional pre-processing on parameters end
4796   
4797   
4798  *   7c. Updating the variable bounds before model solve ------------------------
4799   
4800  * TN - Pivot or Demand Analysis - revise input data
4803  * TN - Pivot or Demand Analysis - revise input data end
4804   
4805  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4806   
4807  *   Offer blocks - Constraint 3.1.1.1
4808      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
4809          = generationOfferMW(validGenerationOfferBlock) ;
4810   
4811      GENERATIONBLOCK.fx(currTP,o,trdBlk)
4812          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
4813   
4814  *   Constraint 3.1.1.2 - Fix the generation variable for generators
4815  *   that are not connected or do not have a non-zero energy offer
4816      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
4817   
4818  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
4819      GENERATION.up(offer(currTP,o))
4820          $ { windOffer(offer) and priceResponsive(offer) }
4821          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4822   
4823  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
4824      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4825          $ (not UseDSBFDemandBidModel)
4826          = purchaseBidMW(validPurchaseBidBlock) ;
4827   
4828      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4829          $ (not UseDSBFDemandBidModel)
4830          = 0 ;
4831   
4832      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4833          $ UseDSBFDemandBidModel
4834          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
4835   
4836      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4837          $ UseDSBFDemandBidModel
4838          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
4839   
4840      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
4841          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
4842          = 0 ;
4843   
4844  *   Fix the purchase variable for purchasers that are not connected
4845  *   or do not have a non-zero purchase bid
4846      PURCHASE.fx(currTP,bd)
4847          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
4848   
4849  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4850   
4851   
4852  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4853   
4854  *   Ensure that variables used to specify flow and losses on HVDC link are
4855  *   zero for AC branches and for open HVDC links.
4856      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
4857      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
4858   
4859  *   Apply an upper bound on the weighting parameter based on its definition
4860      LAMBDA.up(branch,bp) = 1 ;
4861   
4862  *   Ensure that the weighting factor value is zero for AC branches and for
4863  *   invalid loss segments on HVDC links
4864      LAMBDA.fx(HVDClink,bp)
4865          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
4866      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
4867   
4868  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4869   
4870   
4871  *======= AC TRANSMISSION EQUATIONS =============================================
4872   
4873  *   Ensure that variables used to specify flow and losses on AC branches are
4874  *   zero for HVDC links branches and for open AC branches
4875      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
4876      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
4877      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
4878   
4879  *   Ensure directed block flow and loss block variables are zero for
4880  *   non-AC branches and invalid loss segments on AC branches
4881     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
4882         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4883   
4884     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
4885         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4886   
4887   
4888  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
4889  *   corresponding to the reference nodes and the HVDC nodes are set to zero
4890      ACNODEANGLE.fx(currTP,b)
4891         $ sum[ n $ { NodeBus(currTP,n,b) and
4892                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
4893   
4894  *======= AC TRANSMISSION EQUATIONS END =========================================
4895   
4896   
4897  *======= RISK & RESERVE EQUATIONS ==============================================
4898   
4899  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4900      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
4901          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
4902   
4903      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
4904          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
4905   
4906  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
4907      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
4908          = reserveOfferMaximum(validReserveOfferBlock) ;
4909   
4910      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
4911          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4912   
4913  *   Fix the reserve variable for invalid reserve offers. These are offers that
4914  *   are either not connected to the grid or have no reserve quantity offered.
4915      RESERVE.fx(currTP,o,resC,resT)
4916          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
4917   
4918  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
4919  *   offers that are either not connected to the grid or have no reserve quantity offered.
4920      PURCHASEILR.fx(currTP,bd,resC)
4921          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
4922   
4923  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4924      RISKOFFSET.fx(currTP,ild,resC,riskC)
4925          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
4926              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
4927            } = 0 ;
4928   
4929  *   Fix the appropriate deficit variable to zero depending on
4930  *   whether the different CE and ECE CVP flag is set
4931      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
4932      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4933      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4934   
4935  *   Virtual reserve
4936      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
4937   
4938  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
4953  *   NMIR project variables
4954      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4955      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4956   
4957  *   (3.4.2.3) - SPD version 11.0
4958      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
4959   
4960  *   No forward reserve sharing if HVDC capacity is zero
4961      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4962          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
4963   
4964  *   No forward reserve sharing if reserve sharing is disabled
4965      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4966          $ (reserveShareEnabled(currTP,resC)=0) = 0;
4967   
4968  *   No reserve sharing to cover HVDC risk
4969      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
4970      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
4971   
4972  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4973      INZONE.fx(currTP,ild,resC,z)
4974          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
4975   
4976  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
4977      INZONE.fx(currTP,ild,resC,z)
4978          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
4979   
4980  *   Fixing Lambda integer variable for energy sent
4981      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
4982                                          and (ord(bp) = 1) } = 1 ;
4983   
4984      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
4985   
4986  * To be reviewed NMIR
4987      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
4988          $ { (HVDCCapacity(currTP,ild) = 0)
4989          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
4990   
4991      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
4992          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
4993          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
4994  ;
4995   
4996   
4997  *======= RISK & RESERVE EQUATIONS END ==========================================
4998   
4999   
5000  *======= MIXED CONSTRAINTS =====================================================
5001   
5002  *   Mixed constraint
5003      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
5004          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
5005   
5006  *======= MIXED CONSTRAINTS END =================================================
5007   
5008  *   Updating the variable bounds before model solve end
5009   
5010   
5011  *   7d. Solve Models
5012   
INCLUDE    C:\vSPD\GitHub\Programs\vSPDsolve_RTP.gms
5014  *=====================================================================================
5015  * Name:                 vSPDsolve_RTP.gms
5016  * Function:             First RTD solve to update island loss in order to
5017  *                       adjust node demand
5018  *                       A new development for Rea
5019  * Developed by:         Electricity Authority, New Zealand
5020  * Source:               https://github.com/ElectricityAuthority/vSPD
5021  *                       http://www.emi.ea.govt.nz/Tools/vSPD
5022  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
5023  *                       Email: emi@ea.govt.nz
5024  * Created on:           14 Jan 2022
5025   
5026  *=====================================================================================
5027   
5028  *   7d. Solve Models First Time For Real Time Pricing
5029   
5030  if (studyMode = 101,
5031  *   Solve the LP model ---------------------------------------------------------
5032      if( (Sum[currTP, VSPDModel(currTP)] = 0),
5033   
5034          if( UseShareReserve,
5035              option bratio = 1 ;
5036              vSPD_NMIR.Optfile = 1 ;
5037              vSPD_NMIR.optcr = MIPOptimality ;
5038              vSPD_NMIR.reslim = MIPTimeLimit ;
5039              vSPD_NMIR.iterlim = MIPIterationLimit ;
5040              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5041  *           Set the model solve status
5042              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5043                                 or (vSPD_NMIR.modelstat = 8) )
5044                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5045          else
5046              option bratio = 1 ;
5047              vSPD.reslim = LPTimeLimit ;
5048              vSPD.iterlim = LPIterationLimit ;
5049              solve vSPD using lp maximizing NETBENEFIT ;
5050  *           Set the model solve status
5051              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5052          )
5053   
5054  *       Post a progress message to the console and for use by EMI.
5055          if((ModelSolved = 1) and (sequentialSolve = 0),
5056              putclose runlog 'The case: RTD_20211202_RTP '
5057                              'is solved successfully.'/
5058                              'Objective function value: '
5059                              NETBENEFIT.l:<12:1 /
5060                              'Violation Cost          : '
5061                              TOTALPENALTYCOST.l:<12:1 /
5062          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
5063              putclose runlog 'The case: RTD_20211202_RTP '
5064                              'is solved unsuccessfully.'/
5065          ) ;
5066   
5067          if((ModelSolved = 1) and (sequentialSolve = 1),
5068              loop(currTP,
5069                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5070                                  'is solved successfully.'/
5071                                  'Objective function value: '
5072                                  NETBENEFIT.l:<12:1 /
5073                                  'Violations cost         : '
5074                                  TOTALPENALTYCOST.l:<12:1 /
5075              ) ;
5076          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
5077              loop(currTP,
5078                  unsolvedPeriod(currTP) = no;
5079                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5080                                  'is solved unsuccessfully.'/
5081              ) ;
5082   
5083          ) ;
5084  *   Solve the LP model end -----------------------------------------------------
5085   
5086   
5087  *   Solve the VSPD_MIP model ---------------------------------------------------
5088      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
5089  *       Fix the values of the integer variables that are not needed
5090          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5091              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5092   
5093  *       Fix the integer AC branch flow variable to zero for invalid branches
5094          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5095              $ (not branch(currTP,br)) = 0 ;
5096   
5097  *       Apply an upper bound on the integer weighting parameter
5098          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5099   
5100  *       Ensure that the weighting factor value is zero for AC branches
5101  *       and for invalid loss segments on HVDC links
5102          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5103              $ { ACbranch(branch)
5104              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5105                } = 0 ;
5106   
5107  *       Fix the lambda integer variable to zero for invalid branches
5108          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5109   
5110  *       Fix the value of some binary variables used in the mixed constraints
5111  *       that have no alternate limit
5112          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5113              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5114   
5115          option bratio = 1 ;
5116          vSPD_MIP.Optfile = 1 ;
5117          vSPD_MIP.optcr = MIPOptimality ;
5118          vSPD_MIP.reslim = MIPTimeLimit ;
5119          vSPD_MIP.iterlim = MIPIterationLimit ;
5120          solve vSPD_MIP using mip maximizing NETBENEFIT ;
5121  *       Set the model solve status
5122          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
5123                                (vSPD_MIP.modelstat = 8)
5124                              ]
5125                              and
5126                              [ vSPD_MIP.solvestat = 1 ]
5127                            } ;
5128   
5129  *       Post a progress message for use by EMI.
5130          if(ModelSolved = 1,
5131              loop(currTP,
5132                  unsolvedPeriod(currTP) = no;
5133                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5134                                  'is solved successfully for FULL integer.'/
5135                                  'Objective function value: '
5136                                  NETBENEFIT.l:<12:1 /
5137                                  'Violations              : '
5138                                  TOTALPENALTYCOST.l:<12:1 /
5139              ) ;
5140          else
5141              loop(currTP,
5142                  unsolvedPeriod(currTP) = yes;
5143                  VSPDModel(currTP) = 4;
5144                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5145                                  'is solved unsuccessfully for FULL integer.'/
5146              ) ;
5147          ) ;
5148  *   Solve the vSPD_MIP model end -----------------------------------------------
5149   
5150   
5151  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5152      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5153  *       Fix the values of these integer variables that are not needed
5154          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5155              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5156   
5157  *       Fix the integer AC branch flow variable to zero for invalid branches
5158          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5159              $ (not branch(currTP,br)) = 0 ;
5160   
5161  *       Apply an upper bound on the integer weighting parameter
5162          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5163   
5164  *       Ensure that the weighting factor value is zero for AC branches
5165  *       and for invalid loss segments on HVDC links
5166          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5167              $ { ACbranch(branch)
5168              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5169                } = 0 ;
5170   
5171  *       Fix the lambda integer variable to zero for invalid branches
5172          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5173   
5174          option bratio = 1 ;
5175          vSPD_BranchFlowMIP.Optfile = 1 ;
5176          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5177          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5178          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5179          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5180  *       Set the model solve status
5181          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5182                                (vSPD_BranchFlowMIP.modelstat = 8)
5183                              ]
5184                              and
5185                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5186                            } ;
5187   
5188  *       Post a progress message for use by EMI.
5189          if(ModelSolved = 1,
5190   
5191  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5192              vSPD_SOS1_Solve(currTP)  = yes;
5193   
5194              loop(currTP,
5195                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5196                                  'is solved successfully for branch integer.'/
5197                                  'Objective function value: '
5198                                  NETBENEFIT.l:<12:1 /
5199                                  'Violations cost         : '
5200                                  TOTALPENALTYCOST.l:<12:1 /
5201              ) ;
5202          else
5203              loop(currTP,
5204                  unsolvedPeriod(currTP) = yes;
5205                  VSPDModel(currTP) = 4;
5206                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5207                                  'is solved unsuccessfully for branch integer.'/
5208              ) ;
5209          ) ;
5210  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5211   
5212   
5213  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5214      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5215  *       Fix the value of some binary variables used in the mixed constraints
5216  *       that have no alternate limit
5217          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5218              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5219   
5220  *       Use the advanced basis here
5221          option bratio = 0.25 ;
5222          vSPD_MixedConstraintMIP.Optfile = 1 ;
5223  *       Set the optimality criteria for the MIP
5224          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5225          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5226          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5227  *       Solve the model
5228          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5229  *       Set the model solve status
5230          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5231                                (vSPD_MixedConstraintMIP.modelstat = 8)
5232                              ]
5233                              and
5234                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5235                            } ;
5236   
5237  *       Post a progress message for use by EMI.
5238          if(ModelSolved = 1,
5239              loop(currTP,
5240                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5241                                  'is solved successfully for '
5242                                  'mixed constraint integer.'/
5243                                  'Objective function value: '
5244                                  NETBENEFIT.l:<12:1 /
5245                                  'Violations cost         : '
5246                                  TOTALPENALTYCOST.l:<12:1 /
5247              ) ;
5248          else
5249              loop(currTP,
5250                  unsolvedPeriod(currTP) = yes;
5251                  VSPDModel(currTP) = 1;
5252                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5253                                  'is solved unsuccessfully for '
5254                                  'mixed constraint integer.'/
5255              ) ;
5256          ) ;
5257  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5258   
5259   
5260  *   Solve the LP model and stop ------------------------------------------------
5261      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5262   
5263          if( UseShareReserve,
5264              option bratio = 1 ;
5265              vSPD_NMIR.Optfile = 1 ;
5266              vSPD_NMIR.optcr = MIPOptimality ;
5267              vSPD_NMIR.reslim = MIPTimeLimit ;
5268              vSPD_NMIR.iterlim = MIPIterationLimit ;
5269              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5270  *           Set the model solve status
5271              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5272                                 or (vSPD_NMIR.modelstat = 8) )
5273                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5274          else
5275              option bratio = 1 ;
5276              vSPD.reslim = LPTimeLimit ;
5277              vSPD.iterlim = LPIterationLimit ;
5278              solve vSPD using lp maximizing NETBENEFIT ;
5279  *           Set the model solve status
5280              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5281          )
5282   
5283  *       Post a progress message for use by EMI.
5284          if( ModelSolved = 1,
5285              loop(currTP,
5286                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ')'
5287                                  ' integer resolve was unsuccessful.' /
5288                                  'Reverting back to linear solve and '
5289                                  'solve successfully. ' /
5290                                  'Objective function value: '
5291                                  NETBENEFIT.l:<12:1 /
5292                                  'Violations cost         : '
5293                                  TOTALPENALTYCOST.l:<12:1 /
5294                                  'Solution may have circulating flows '
5295                                  'and/or non-physical losses.' /
5296              ) ;
5297          else
5298              loop(currTP,
5299                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl
5300                                  ') integer solve was unsuccessful. '
5301                                  'Reverting back to linear solve. '
5302                                  'Linear solve unsuccessful.' /
5303              ) ;
5304          ) ;
5305   
5306          unsolvedPeriod(currTP) = no;
5307   
5308  *   Solve the LP model and stop end --------------------------------------------
5309   
5310      ) ;
5311  *   Solve the models end
5312   
5313   
5314  * Real Time Pricing - Second RTD load calculation
5315   
5316  *   Calculate Island-level MW losses used to calculate the Island-level load
5317  *   forecast from the InputIPS and the IslandPSD.
5318  *   2nd solve loop --> SystemLosses as calculated in section 6.3'
5319      LoadCalcLosses(currTP,ild)
5320          = Sum[ (br,frB,toB)
5321               $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
5322               and branchBusDefn(currTP,br,frB,toB)
5323                 }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
5324                  + branchFixedLoss(currTP,br)
5325               ]
5326          + Sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5327                                  branchBusDefn(currTP,br,frB,toB) and
5328                                  busIsland(currTP,toB,ild) and
5329                                  busIsland(currTP,frB,ild)
5330                                }, sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ]
5331                                 + HVDCLINKLOSSES.l(currTP,br)
5332                                 + branchFixedLoss(currTP,br)
5333               ]
5334          + Sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5335                                  branchBusDefn(currTP,br,frB,toB) and
5336                                  ( busIsland(currTP,toB,ild) or
5337                                    busIsland(currTP,frB,ild)
5338                                  )
5339                                }, 0.5 * branchFixedLoss(currTP,br)
5340               ]
5341          + Sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
5342                                  branchBusDefn(currTP,br,frB,toB) and
5343                                  busIsland(currTP,toB,ild) and
5344                                  (not (busIsland(currTP,frB,ild)))
5345                                }, HVDCLINKLOSSES.l(currTP,br)
5346               ]
5347            ;
5348   
5349   
5350  *   Calculate first target total load [3.8.5.5]
5351  *   Island-level MW load forecast. For the fist loop:
5352  *   replace LoadCalcLosses(tp,ild) = islandLosses(tp,ild);
5353      TargetTotalLoad(currTP,ild) = islandMWIPS(currTP,ild) + islandPDS(currTP,ild) - LoadCalcLosses(currTP,ild) ;
5354   
5355  *   Flag if estimate load is scalable [3.8.5.7]
5356  *   Binary value. If True then ConformingFactor load MW will be scaled in order to
5357  *   calculate EstimatedInitialLoad. If False then EstNonScalableLoad will be
5358  *   assigned directly to EstimatedInitialLoad
5359      EstLoadIsScalable(currTP,n) =  1 $ { (LoadIsNCL(currTP,n) = 0)
5360                                       and (ConformingFactor(currTP,n) > 0) } ;
5361   
5362  *   Calculate estimate non-scalable load [3.8.5.8]
5363  *   For a non-conforming Pnode this will be the NonConformingLoad MW input, for a
5364  *   conforming Pnode this will be the ConformingFactor MW input if that value is
5365  *   negative, otherwise it will be zero
5366      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 1 ) = NonConformingLoad(currTP,n);
5367      EstNonScalableLoad(currTP,n) $ ( LoadIsNCL(currTP,n) = 0 ) = ConformingFactor(currTP,n);
5368      EstNonScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = 0;
5369   
5370  *   Calculate estimate scalable load [3.8.5.10]
5371  *   For a non-conforming Pnode this value will be zero. For a conforming Pnode
5372  *   this value will be the ConformingFactor if it is non-negative, otherwise this
5373  *   value will be zero'
5374      EstScalableLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 ) = ConformingFactor(currTP,n);
5375   
5376   
5377  *   Calculate Scaling applied to ConformingFactor load MW [3.8.5.9]
5378  *   in order to calculate EstimatedInitialLoad
5379      EstScalingFactor(currTP,ild)
5380          = (islandMWIPS(currTP,ild) - LoadCalcLosses(currTP,ild)
5381            - Sum[ n $ nodeIsland(currTP,n,ild), EstNonScalableLoad(currTP,n) ]
5382            ) / Sum[ n $ nodeIsland(currTP,n,ild), EstScalableLoad(currTP,n) ]
5383   
5384          ;
5385   
5386  *   Calculate estimate initial load [3.8.5.6]
5387  *   Calculated estimate of initial MW load, available to be used as an
5388  *   alternative to InputInitialLoad
5389      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 1 )
5390          = ConformingFactor(currTP,n) * Sum[ ild $ nodeisland(currTP,n,ild)
5391                                            , EstScalingFactor(currTP,ild)] ;
5392      EstimatedInitialLoad(currTP,n) $ ( EstLoadIsScalable(currTP,n) = 0 )
5393          = NonConformingLoad(currTP,n);
5394   
5395  *   Calculate initial load [3.8.5.2]
5396  *   Value that represents the Pnode load MW at the start of the solution
5397  *   interval. Depending on the inputs this value will be either actual load,
5398  *   an operator applied override or an estimated initial load
5399      InitialLoad(currTP,n) = InputInitialLoad(currTP,n);
5400      InitialLoad(currTP,n) $ { (LoadIsOverride(currTP,n) = 0)
5401                            and ( (useActualLoad(currTP) = 0)
5402                               or (LoadIsBad(currTP,n) = 1) )
5403                              } = EstimatedInitialLoad(currTP,n) ;
5404   
5405  *   Flag if load is scalable [3.8.5.4]
5406  *   Binary value. If True then the Pnode InitialLoad will be scaled in order to
5407  *   calculate nodedemand, if False then Pnode InitialLoad will be directly
5408  *   assigned to nodedemand
5409      LoadIsScalable(currTP,n) = 1 $ { (LoadIsNCL(currTP,n) = 0)
5410                                   and (LoadIsOverride(currTP,n) = 0)
5411                                   and (InitialLoad(currTP,n) >= 0) } ;
5412   
5413  *   Calculate Island-level scaling factor [3.8.5.3]
5414  *   --> applied to InitialLoad in order to calculate nodedemand
5415      LoadScalingFactor(currTP,ild)
5416          = ( TargetTotalLoad(currTP,ild)
5417            - Sum[ n $ { nodeIsland(currTP,n,ild)
5418                     and (LoadIsScalable(currTP,n) = 0) }, InitialLoad(currTP,n) ]
5419            ) / Sum[ n $ { nodeIsland(currTP,n,ild)
5420                       and (LoadIsScalable(currTP,n) = 1) }, InitialLoad(currTP,n) ]
5421          ;
5422   
5423  *   Calculate nodedemand [3.8.5.1]
5424      nodedemand(currTP,n) $ LoadIsScalable(currTP,n)
5425          = InitialLoad(currTP,n) * sum[ ild $ nodeisland(currTP,n,ild)
5426                                   , LoadScalingFactor(currTP,ild) ];
5427   
5428      nodedemand(currTP,n) $ (LoadIsScalable(currTP,n) = 0) = InitialLoad(currTP,n);
5429   
5430  );
5431   
5432   
5433   
5434   
5435  *   Solve the LP model ---------------------------------------------------------
5436      if( (Sum[currTP, VSPDModel(currTP)] = 0),
5437   
5438          if( UseShareReserve,
5439              option bratio = 1 ;
5440              vSPD_NMIR.Optfile = 1 ;
5441              vSPD_NMIR.optcr = MIPOptimality ;
5442              vSPD_NMIR.reslim = MIPTimeLimit ;
5443              vSPD_NMIR.iterlim = MIPIterationLimit ;
5444              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5445  *           Set the model solve status
5446              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5447                                 or (vSPD_NMIR.modelstat = 8) )
5448                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5449          else
5450              option bratio = 1 ;
5451              vSPD.reslim = LPTimeLimit ;
5452              vSPD.iterlim = LPIterationLimit ;
5453              solve vSPD using lp maximizing NETBENEFIT ;
5454  *           Set the model solve status
5455              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5456          )
5457   
5458  *       Post a progress message to the console and for use by EMI.
5459          if((ModelSolved = 1) and (sequentialSolve = 0),
5460              putclose runlog 'The case: RTD_20211202_RTP '
5461                              'is solved successfully.'/
5462                              'Objective function value: '
5463                              NETBENEFIT.l:<12:1 /
5464                              'Violation Cost          : '
5465                              TOTALPENALTYCOST.l:<12:1 /
5466          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
5467              putclose runlog 'The case: RTD_20211202_RTP '
5468                              'is solved unsuccessfully.'/
5469          ) ;
5470   
5471          if((ModelSolved = 1) and (sequentialSolve = 1),
5472              loop(currTP,
5473                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5474                                  'is solved successfully.'/
5475                                  'Objective function value: '
5476                                  NETBENEFIT.l:<12:1 /
5477                                  'Violations cost         : '
5478                                  TOTALPENALTYCOST.l:<12:1 /
5479              ) ;
5480          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
5481              loop(currTP,
5482                  unsolvedPeriod(currTP) = no;
5483                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5484                                  'is solved unsuccessfully.'/
5485              ) ;
5486   
5487          ) ;
5488  *   Solve the LP model end -----------------------------------------------------
5489   
5490   
5491  *   Solve the VSPD_MIP model ---------------------------------------------------
5492      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
5493  *       Fix the values of the integer variables that are not needed
5494          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5495              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5496   
5497  *       Fix the integer AC branch flow variable to zero for invalid branches
5498          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5499              $ (not branch(currTP,br)) = 0 ;
5500   
5501  *       Apply an upper bound on the integer weighting parameter
5502          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5503   
5504  *       Ensure that the weighting factor value is zero for AC branches
5505  *       and for invalid loss segments on HVDC links
5506          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5507              $ { ACbranch(branch)
5508              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5509                } = 0 ;
5510   
5511  *       Fix the lambda integer variable to zero for invalid branches
5512          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5513   
5514  *       Fix the value of some binary variables used in the mixed constraints
5515  *       that have no alternate limit
5516          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5517              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5518   
5519          option bratio = 1 ;
5520          vSPD_MIP.Optfile = 1 ;
5521          vSPD_MIP.optcr = MIPOptimality ;
5522          vSPD_MIP.reslim = MIPTimeLimit ;
5523          vSPD_MIP.iterlim = MIPIterationLimit ;
5524          solve vSPD_MIP using mip maximizing NETBENEFIT ;
5525  *       Set the model solve status
5526          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
5527                                (vSPD_MIP.modelstat = 8)
5528                              ]
5529                              and
5530                              [ vSPD_MIP.solvestat = 1 ]
5531                            } ;
5532   
5533  *       Post a progress message for use by EMI.
5534          if(ModelSolved = 1,
5535              loop(currTP,
5536                  unsolvedPeriod(currTP) = no;
5537                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5538                                  'is solved successfully for FULL integer.'/
5539                                  'Objective function value: '
5540                                  NETBENEFIT.l:<12:1 /
5541                                  'Violations              : '
5542                                  TOTALPENALTYCOST.l:<12:1 /
5543              ) ;
5544          else
5545              loop(currTP,
5546                  unsolvedPeriod(currTP) = yes;
5547                  VSPDModel(currTP) = 4;
5548                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5549                                  'is solved unsuccessfully for FULL integer.'/
5550              ) ;
5551          ) ;
5552  *   Solve the vSPD_MIP model end -----------------------------------------------
5553   
5554   
5555  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5556      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5557  *       Fix the values of these integer variables that are not needed
5558          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5559              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5560   
5561  *       Fix the integer AC branch flow variable to zero for invalid branches
5562          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5563              $ (not branch(currTP,br)) = 0 ;
5564   
5565  *       Apply an upper bound on the integer weighting parameter
5566          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5567   
5568  *       Ensure that the weighting factor value is zero for AC branches
5569  *       and for invalid loss segments on HVDC links
5570          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5571              $ { ACbranch(branch)
5572              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5573                } = 0 ;
5574   
5575  *       Fix the lambda integer variable to zero for invalid branches
5576          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5577   
5578          option bratio = 1 ;
5579          vSPD_BranchFlowMIP.Optfile = 1 ;
5580          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5581          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5582          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5583          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5584  *       Set the model solve status
5585          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5586                                (vSPD_BranchFlowMIP.modelstat = 8)
5587                              ]
5588                              and
5589                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5590                            } ;
5591   
5592  *       Post a progress message for use by EMI.
5593          if(ModelSolved = 1,
5594   
5595  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5596              vSPD_SOS1_Solve(currTP)  = yes;
5597   
5598              loop(currTP,
5599                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5600                                  'is solved successfully for branch integer.'/
5601                                  'Objective function value: '
5602                                  NETBENEFIT.l:<12:1 /
5603                                  'Violations cost         : '
5604                                  TOTALPENALTYCOST.l:<12:1 /
5605              ) ;
5606          else
5607              loop(currTP,
5608                  unsolvedPeriod(currTP) = yes;
5609                  VSPDModel(currTP) = 4;
5610                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5611                                  'is solved unsuccessfully for branch integer.'/
5612              ) ;
5613          ) ;
5614  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5615   
5616   
5617  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5618      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5619  *       Fix the value of some binary variables used in the mixed constraints
5620  *       that have no alternate limit
5621          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5622              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5623   
5624  *       Use the advanced basis here
5625          option bratio = 0.25 ;
5626          vSPD_MixedConstraintMIP.Optfile = 1 ;
5627  *       Set the optimality criteria for the MIP
5628          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5629          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5630          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5631  *       Solve the model
5632          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5633  *       Set the model solve status
5634          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5635                                (vSPD_MixedConstraintMIP.modelstat = 8)
5636                              ]
5637                              and
5638                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5639                            } ;
5640   
5641  *       Post a progress message for use by EMI.
5642          if(ModelSolved = 1,
5643              loop(currTP,
5644                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5645                                  'is solved successfully for '
5646                                  'mixed constraint integer.'/
5647                                  'Objective function value: '
5648                                  NETBENEFIT.l:<12:1 /
5649                                  'Violations cost         : '
5650                                  TOTALPENALTYCOST.l:<12:1 /
5651              ) ;
5652          else
5653              loop(currTP,
5654                  unsolvedPeriod(currTP) = yes;
5655                  VSPDModel(currTP) = 1;
5656                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5657                                  'is solved unsuccessfully for '
5658                                  'mixed constraint integer.'/
5659              ) ;
5660          ) ;
5661  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5662   
5663   
5664  *   Solve the LP model and stop ------------------------------------------------
5665      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5666   
5667          if( UseShareReserve,
5668              option bratio = 1 ;
5669              vSPD_NMIR.Optfile = 1 ;
5670              vSPD_NMIR.optcr = MIPOptimality ;
5671              vSPD_NMIR.reslim = MIPTimeLimit ;
5672              vSPD_NMIR.iterlim = MIPIterationLimit ;
5673              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5674  *           Set the model solve status
5675              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5676                                 or (vSPD_NMIR.modelstat = 8) )
5677                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5678          else
5679              option bratio = 1 ;
5680              vSPD.reslim = LPTimeLimit ;
5681              vSPD.iterlim = LPIterationLimit ;
5682              solve vSPD using lp maximizing NETBENEFIT ;
5683  *           Set the model solve status
5684              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5685          )
5686   
5687  *       Post a progress message for use by EMI.
5688          if( ModelSolved = 1,
5689              loop(currTP,
5690                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ')'
5691                                  ' integer resolve was unsuccessful.' /
5692                                  'Reverting back to linear solve and '
5693                                  'solve successfully. ' /
5694                                  'Objective function value: '
5695                                  NETBENEFIT.l:<12:1 /
5696                                  'Violations cost         : '
5697                                  TOTALPENALTYCOST.l:<12:1 /
5698                                  'Solution may have circulating flows '
5699                                  'and/or non-physical losses.' /
5700              ) ;
5701          else
5702              loop(currTP,
5703                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl
5704                                  ') integer solve was unsuccessful. '
5705                                  'Reverting back to linear solve. '
5706                                  'Linear solve unsuccessful.' /
5707              ) ;
5708          ) ;
5709   
5710          unsolvedPeriod(currTP) = no;
5711   
5712  *   Solve the LP model and stop end --------------------------------------------
5713   
5714      ) ;
5715  *   Solve the models end
5716   
5717   
5718   
5719  *   6e. Check if the LP results are valid --------------------------------------
5720      if((ModelSolved = 1),
5721          useBranchFlowMIP(currTP) = 0 ;
5722          useMixedConstraintMIP(currTP) = 0 ;
5723  *       Check if there is no branch circular flow and non-physical losses
5724          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
5725   
5726  *           Check if there are circulating branch flows on loss AC branches
5727              circularBranchFlowExist(ACbranch(currTP,br))
5728                  $ { LossBranch(ACbranch) and
5729                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
5730                        - abs(ACBRANCHFLOW.l(ACbranch))
5731                        ) > circularBranchFlowTolerance
5732                      ]
5733                    } = 1 ;
5734   
5735  *           Determine the circular branch flow flag on each HVDC pole
5736              TotalHVDCpoleFlow(currTP,pole)
5737                  = sum[ br $ HVDCpoleBranchMap(pole,br)
5738                       , HVDCLINKFLOW.l(currTP,br) ] ;
5739   
5740              MaxHVDCpoleFlow(currTP,pole)
5741                  = smax[ br $ HVDCpoleBranchMap(pole,br)
5742                        , HVDCLINKFLOW.l(currTP,br) ] ;
5743   
5744              poleCircularBranchFlowExist(currTP,pole)
5745                  $ { ( TotalHVDCpoleFlow(currTP,pole)
5746                      - MaxHVDCpoleFlow(currTP,pole)
5747                      ) > circularBranchFlowTolerance
5748                    } = 1 ;
5749   
5750  *           Check if there are circulating branch flows on HVDC
5751              NorthHVDC(currTP)
5752                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
5753                                        i_tradePeriodBusIsland(currTP,b,ild) and
5754                                        HVDClinkSendingBus(currTP,br,b) and
5755                                        HVDCpoles(currTP,br)
5756                                      }, HVDCLINKFLOW.l(currTP,br)
5757                       ] ;
5758   
5759              SouthHVDC(currTP)
5760                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
5761                                        i_tradePeriodBusIsland(currTP,b,ild) and
5762                                        HVDClinkSendingBus(currTP,br,b) and
5763                                        HVDCpoles(currTP,br)
5764                                      }, HVDCLINKFLOW.l(currTP,br)
5765                       ] ;
5766   
5767              circularBranchFlowExist(currTP,br)
5768                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
5769                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
5770                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
5771                    } = 1 ;
5772   
5773  *           Check if there are non-physical losses on HVDC links
5774              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
5775                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5776                  and validLossSegment(currTP,br,los,fd) }
5777                  = Min[ Max( 0,
5778                              [ abs(HVDCLINKFLOW.l(HVDClink))
5779                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5780                              ]
5781                            ),
5782                         ( LossSegmentMW(HVDClink,los,fd)
5783                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5784                         )
5785                       ] ;
5786   
5787              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
5788                  = sum[ (los,fd) $ validLossSegment(currTP,br,los,fd)
5789                                  , LossSegmentFactor(HVDClink,los,fd)
5790                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
5791                       ] ;
5792   
5793              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
5794                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
5795                         - ManualLossCalculation(HVDClink)
5796                         ) > NonPhysicalLossTolerance
5797                    } = 1 ;
5798   
5799  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
5800  *           and non-physical loss branches exceeds the specified tolerance
5801              useBranchFlowMIP(currTP)
5802                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
5803                                , resolveCircularBranchFlows
5804                                * circularBranchFlowExist(currTP,br)
5805                           ]
5806                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
5807                                , (1 - AllowHVDCroundpower(currTP))
5808                                * resolveCircularBranchFlows
5809                                * circularBranchFlowExist(currTP,br)
5810                                + resolveHVDCnonPhysicalLosses
5811                                * NonPhysicalLossExist(currTP,br)
5812                           ]
5813                      + sum[ pole, resolveCircularBranchFlows
5814                                 * poleCircularBranchFlowExist(currTP,pole)
5815                           ]
5816                       ) > UseBranchFlowMIPTolerance
5817                                         } = 1 ;
5818   
5819  *       Check if there is no branch circular flow and non-physical losses end
5820          );
5821   
5822   
5823  *       Check if there is mixed constraint integer is required
5824          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
5825   
5826  *           Check if integer variables are needed for mixed constraint
5827              if( useMixedConstraintRiskOffset,
5828                  HVDChalfPoleSouthFlow(currTP)
5829                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
5830                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
5831                             ] > MixedMIPTolerance
5832                        } = 1 ;
5833   
5834  *               Only calculate violation if the constraint limit is non-zero
5835                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
5836                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
5837                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
5838                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5839                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
5840                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5841                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
5842                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
5843                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
5844                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5845                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
5846   
5847  *               Integer constraints are needed if southward flow on half-poles AND
5848  *               constraint level exceeds the mixed constraint limit2 value
5849                  useMixedConstraintMIP(currTP)
5850                      $ { HVDChalfPoleSouthFlow(currTP) and
5851                          sum[ t1MixCstr
5852                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
5853                                 > MixedMIPTolerance }, 1
5854                             ]
5855                        } = 1 ;
5856              ) ;
5857   
5858  *       Check if there is mixed constraint integer is required end
5859          );
5860   
5861  *       A period is unsolved if MILP model is required
5862          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
5863                                         + UseMixedConstraintMIP(currTP)
5864                                         ] ;
5865   
5866  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
5867          loop( unsolvedPeriod(currTP),
5868              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
5869                  VSPDModel(currTP) = 1;
5870                  putclose runlog 'The case: RTD_20211202_RTP requires a'
5871                                  'VSPD_MIP resolve for period ' currTP.tl
5872                                  '. Switching Vectorisation OFF.' /
5873   
5874              elseif UseBranchFlowMIP(currTP) >= 1,
5875                  if( VSPDModel(currTP) = 0,
5876                      VSPDModel(currTP) = 2;
5877                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5878                                      'vSPD_BranchFlowMIP resolve for period '
5879                                      currTP.tl '. Switching Vectorisation OFF.'/
5880                  elseif VSPDModel(currTP) = 3,
5881                      VSPDModel(currTP) = 1;
5882                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5883                                      'VSPD_MIP resolve for period ' currTP.tl
5884                                      '. Switching Vectorisation OFF.' /
5885                  );
5886   
5887              elseif UseMixedConstraintMIP(currTP) >= 1,
5888                  if( VSPDModel(currTP) = 0,
5889                      VSPDModel(currTP) = 3;
5890                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5891                                      'vSPD_MixedConstraintMIP resolve for period '
5892                                      currTP.tl '. Switching Vectorisation OFF.' /
5893                  elseif VSPDModel(currTP) = 2,
5894                      VSPDModel(currTP) = 1;
5895                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5896                                      'VSPD_MIP resolve for period ' currTP.tl
5897                                      '. Switching Vectorisation OFF.' /
5898                  );
5899   
5900              ) ;
5901   
5902          ) ;
5903   
5904          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
5905          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
5906   
5907  *   Check if the LP results are valid end
5908      ) ;
5909   
5910   
5911   
5912  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
5913   
5914  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
5915  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
5940   
5941      busGeneration(bus(currTP,b))
5942          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
5943               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
5944               ] ;
5945   
5946      busLoad(bus(currTP,b))
5947          = sum[ NodeBus(currTP,n,b)
5948               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
5949               ] ;
5950   
5951      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
5952          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
5953   
5954      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
5955          = DCNodeNetInjection.m(currTP,b) ;
5956   
5957      if((disconnectedNodePriceCorrection = 1),
5958  *       Pre-MSP case
5959          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
5960              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
5961                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
5962                                        branch(currTP,br)
5963                                      }, 1 ]
5964                      )
5965                    } ;
5966   
5967  *       Post-MSP cases
5968  *       Scenario C/F/G/H/I:
5969          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
5970                                         and (busLoad(bus) = 0)
5971                                         and (busElectricalIsland(bus) = 0)
5972                                           } = 1 ;
5973  *       Scenario E:
5974          busDisconnected(bus(currTP,b))
5975              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5976                              = busElectricalIsland(bus) }
5977                       , busLoad(currTP,b1) ] = 0
5978                  ) and
5979                  ( busElectricalIsland(bus) > 0 ) and
5980                  ( i_useBusNetworkModel(currTP) = 1 )
5981                } = 1 ;
5982  *       Set prices at dead buses with non-zero load
5983          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5984                                      (busLoad(bus) > 0) and
5985                                      (busElectricalIsland(bus)= 0)
5986                                    } = DeficitBusGenerationPenalty ;
5987   
5988          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5989                                      (busLoad(bus) < 0) and
5990                                      (busElectricalIsland(bus)= 0)
5991                                    } = -SurplusBusGenerationPenalty ;
5992   
5993  *       Set price at identified disconnected buses to 0
5994          busPrice(bus)$busDisconnected(bus) = 0 ;
5995      ) ;
5996   
5997  * End Check for disconnected nodes and adjust prices accordingly
5998   
5999  * TN - Replacing invalid prices after SOS1
6000  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
6001      if ( vSPD_SOS1_Solve(tp),
6002           busSOSinvalid(tp,b)
6003             = 1 $ { [ ( busPrice(tp,b) = 0 )
6004                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
6005                      or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
6006                       ]
6007                   and bus(tp,b)
6008                   and [ not busDisconnected(tp,b) ]
6009  *                 and [ busLoad(tp,b) = 0 ]
6010  *                 and [ busGeneration(tp,b) = 0 ]
6011                   and [ busLoad(tp,b) = busGeneration(tp,b) ]
6012                   and [ sum[(br,fd)
6013                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6014                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
6015                            ] = 0
6016                       ]
6017                   and [ sum[ br
6018                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6019                            , 1
6020                            ] > 0
6021                       ]
6022                     };
6023          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
6024          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
6025              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
6026              busPrice(tp,b)
6027                $ { busSOSinvalid(tp,b)
6028                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6029                              and sum[ br $ { branch(tp,br)
6030                                          and BranchBusConnect(tp,br,b)
6031                                          and BranchBusConnect(tp,br,b1)
6032                                            }, 1
6033                                     ]
6034                               }, 1
6035                         ] > 0
6036                    )
6037                  }
6038                = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6039                          and sum[ br $ { branch(tp,br)
6040                                      and BranchBusConnect(tp,br,b)
6041                                      and BranchBusConnect(tp,br,b1)
6042                                        }, 1 ]
6043                            }, busPrice(tp,b1)
6044                     ]
6045                / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
6046                          and sum[ br $ { branch(tp,br)
6047                                      and BranchBusConnect(tp,br,b)
6048                                      and BranchBusConnect(tp,br,b1)
6049                                        }, 1 ]
6050                            }, 1
6051                     ];
6052   
6053              busSOSinvalid(tp,b)
6054                = 1 $ { [ ( busPrice(tp,b) = 0 )
6055                       or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
6056                       or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
6057                        ]
6058                    and bus(tp,b)
6059                    and [ not busDisconnected(tp,b) ]
6060  *                  and [ busLoad(tp,b) = 0 ]
6061  *                  and [ busGeneration(tp,b) = 0 ]
6062                    and [ busLoad(tp,b) = busGeneration(tp,b) ]
6063                    and [ sum[(br,fd)
6064                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6065                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
6066                             ] = 0
6067                        ]
6068                    and [ sum[ br
6069                             $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
6070                             , 1
6071                             ] > 0
6072                        ]
6073                      };
6074           );
6075      );
6076  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
6077   
6078   
6079  *   6g. Collect and store results of solved periods into output parameters -----
6080  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
6081   
6083  *   Normal vSPD run post processing for reporting
6085      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
6086  *   Reporting at trading period start
6087  *       Node level output
6088          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
6089   
6090          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
6091              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
6092   
6093          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
6094             = NodeDemand(currTP,n)
6095             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
6096   
6097          o_nodePrice_TP(dt,n) $ Node(currTP,n)
6098              = sum[ b $ NodeBus(currTP,n,b)
6099                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
6100                    ] ;
6101   
6102  *       Offer output
6103          o_offer(dt,o) $ offer(currTP,o) = yes ;
6104   
6105          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
6106   
6107          o_offerFIR_TP(dt,o) $ offer(currTP,o)
6108              = sum[ (resC,resT)$(ord(resC) = 1)
6109                   , RESERVE.l(currTP,o,resC,resT) ] ;
6110   
6111          o_offerSIR_TP(dt,o) $ offer(currTP,o)
6112              = sum[ (resC,resT)$(ord(resC) = 2)
6113                   , RESERVE.l(currTP,o,resC,resT) ] ;
6114   
6115  *       Bus level output
6116          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
6117   
6118          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
6119   
6120          o_busLoad_TP(dt,b) $ bus(currTP,b)
6121              = busLoad(currTP,b)
6122              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
6123                   , PURCHASE.l(currTP,bd) ];
6124   
6125          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
6126   
6127          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
6128   
6129          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
6130   
6131  *       Node level output
6132   
6133          totalBusAllocation(dt,b) $ bus(currTP,b)
6134              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
6135   
6136          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
6137              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
6138   
6139  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
6153          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
6154              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
6155   
6156          changedDeficitBus(dt,b) = no;
6157   
6158          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
6159   
6160              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
6161   
6162              Loop b $ unmappedDeficitBus(dt,b) do
6163                  o_busDeficit_TP(dt,b1)
6164                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
6165                                and ( branchBusDefn(tp,br,b1,b)
6166                                   or branchBusDefn(tp,br,b,b1) )
6167                                  }, 1 ]
6168                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
6169   
6170                  changedDeficitBus(dt,b1)
6171                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
6172                              and ( branchBusDefn(tp,br,b1,b)
6173                                 or branchBusDefn(tp,br,b,b1) )
6174                                }, 1 ] = yes;
6175   
6176                  unmappedDeficitBus(dt,b) = no;
6177                  changedDeficitBus(dt,b) = no;
6178                  o_busDeficit_TP(dt,b) = 0;
6179              EndLoop;
6180   
6181              Loop n $ sum[ b $ changedDeficitBus(dt,b)
6182                          , busNodeAllocationFactor(dt,b,n)] do
6183                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
6184                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
6185                                                    busNodeAllocationFactor(dt,b,n)
6186                                                  * o_busDeficit_TP(dt,b) ] ;
6187              EndLoop;
6188   
6189              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
6190          Endif;
6191  * TN - post processing unmapped generation deficit buses end
6192   
6193          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
6194              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
6195                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
6196   
6197          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
6198              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
6199                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
6200   
6201  *       branch output
6202          o_branch(dt,br) $ branch(currTP,br) = yes ;
6203   
6204          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
6205   
6206          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
6207   
6208          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
6209              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
6210   
6211          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
6212              = HVDCLINKLOSSES.l(currTP,br) ;
6213   
6214          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
6215              = branchFixedLoss(currTP,br) ;
6216   
6217          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
6218              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
6219   
6220          o_branchFromBus_TP(dt,br,frB)
6221              $ { branch(currTP,br) and
6222                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
6223                } = yes ;
6224   
6225          o_branchToBus_TP(dt,br,toB)
6226              $ { branch(currTP,br) and
6227                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
6228                } = yes ;
6229   
6230          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
6231              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
6232   
6233          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
6234              = HVDClinkMaximumFlow.m(currTP,br) ;
6235   
6236          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
6237              = sum[ fd $ ( ord(fd) = 1 )
6238                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
6239                   ] $  { o_branchFlow_TP(dt,br) >= 0 }
6240              + sum[ fd $ ( ord(fd) = 2 )
6241                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
6242                   ] $  { o_branchFlow_TP(dt,br) < 0 } ;
6243   
6244   
6245  *       Offer output
6246          o_offerEnergyBlock_TP(dt,o,trdBlk)
6247              = GENERATIONBLOCK.l(currTP,o,trdBlk);
6248   
6249          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
6250              = sum[ resC $ (ord(resC) = 1)
6251              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
6252   
6253          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
6254              = sum[ resC $ (ord(resC) = 2)
6255              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
6256   
6257  *       bid output
6258          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
6259   
6260          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
6261   
6262          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
6263              = sum[ resC $ (ord(resC) = 1)
6264                   , PURCHASEILR.l(currTP,bd,resC) ] ;
6265   
6266          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
6267              = sum[ resC $ (ord(resC) = 2)
6268                   , PURCHASEILR.l(currTP,bd,resC) ] ;
6269   
6270          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
6271              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
6272   
6273  *       Violation reporting based on the CE and ECE
6274          o_ResViolation_TP(dt,ild,resC)
6275              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
6276              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
6277              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
6278   
6279          o_FIRviolation_TP(dt,ild)
6280              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
6281   
6282          o_SIRviolation_TP(dt,ild)
6283              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
6284   
6285  *       Security constraint data
6286          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
6287   
6288          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6289              = branchConstraintSense(currTP,brCstr) ;
6290   
6291          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6292              = [ branchSecurityConstraintLE.l(currTP,brCstr)
6293                $ (branchConstraintSense(currTP,brCstr) = -1) ]
6294              + [ branchSecurityConstraintGE.l(currTP,brCstr)
6295                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
6296              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
6297                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
6298   
6299          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6300              = branchConstraintLimit(currTP,brCstr) ;
6301   
6302          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
6303              = [ branchSecurityConstraintLE.m(currTP,brCstr)
6304                $ (branchConstraintSense(currTP,brCstr) = -1) ]
6305              + [ branchSecurityConstraintGE.m(currTP,brCstr)
6306                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
6307              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
6308                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
6309   
6310  *       Mnode constraint data
6311          o_MnodeConstraint_TP(dt,MnodeCstr)
6312              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
6313   
6314          o_MnodeConstraintSense_TP(dt,MnodeCstr)
6315              $ MnodeConstraint(currTP,MnodeCstr)
6316              = MnodeConstraintSense(currTP,MnodeCstr) ;
6317   
6318          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
6319              $ MnodeConstraint(currTP,MnodeCstr)
6320              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
6321                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
6322              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
6323                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
6324              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
6325                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
6326   
6327          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
6328              $ MnodeConstraint(currTP,MnodeCstr)
6329              = MnodeConstraintLimit(currTP,MnodeCstr) ;
6330   
6331          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
6332              $ MnodeConstraint(currTP,MnodeCstr)
6333              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
6334                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
6335              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
6336                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
6337              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
6338                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
6339   
6340  *       Island output
6341          o_island(dt,ild) = yes ;
6342   
6343          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
6344   
6345          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6346                                            , o_ResPrice_TP(dt,ild,resC) ];
6347   
6348          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6349                                            , o_ResPrice_TP(dt,ild,resC) ];
6350   
6351          o_islandGen_TP(dt,ild)
6352              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
6353   
6354          o_islandClrBid_TP(dt,ild)
6355              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
6356   
6357          o_islandLoad_TP(dt,ild)
6358              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
6359              + o_islandClrBid_TP(dt,ild) ;
6360   
6361          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
6362   
6363          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
6364                                              , o_ResCleared_TP(dt,ild,resC) ];
6365   
6366          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
6367                                              , o_ResCleared_TP(dt,ild,resC) ];
6368   
6369          o_islandBranchLoss_TP(dt,ild)
6370              = sum[ (br,frB,toB)
6371                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
6372                   and branchBusDefn(currTP,br,frB,toB)
6373                     }, o_branchTotalLoss_TP(dt,br) ] ;
6374   
6375          o_HVDCflow_TP(dt,ild)
6376              = sum[ (br,frB,toB)
6377                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
6378                   and branchBusDefn(currTP,br,frB,toB)
6379                     }, o_branchFlow_TP(dt,br) ] ;
6380   
6381          o_HVDChalfPoleLoss_TP(dt,ild)
6382              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
6383                                      branchBusDefn(currTP,br,frB,toB) and
6384                                      busIsland(currTP,toB,ild) and
6385                                      busIsland(currTP,frB,ild)
6386                                        }, o_branchTotalLoss_TP(dt,br)
6387                   ] ;
6388   
6389          o_HVDCpoleFixedLoss_TP(dt,ild)
6390              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
6391                                      branchBusDefn(currTP,br,frB,toB) and
6392                                      ( busIsland(currTP,toB,ild) or
6393                                        busIsland(currTP,frB,ild)
6394                                      )
6395                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
6396                   ] ;
6397   
6398          o_HVDCloss_TP(dt,ild)
6399              = o_HVDChalfPoleLoss_TP(dt,ild)
6400              + o_HVDCpoleFixedLoss_TP(dt,ild)
6401              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
6402                                      branchBusDefn(currTP,br,frB,toB) and
6403                                      busIsland(currTP,toB,ild) and
6404                                      (not (busIsland(currTP,frB,ild)))
6405                                    }, o_branchDynamicLoss_TP(dt,br)
6406                   ] ;
6407   
6408  * TN - The code below is added for NMIR project ================================
6409          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
6410              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
6411   
6412          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
6413   
6414              o_FirSent_TP(dt,ild)
6415                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6416                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
6417   
6418              o_FirReceived_TP(dt,ild)
6419                  = Sum[ (rd,resC) $ (ord(resC) = 1)
6420                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
6421   
6422              o_FirEffective_TP(dt,ild,riskC)
6423                  = Sum[ resC $ (ord(resC) = 1),
6424                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6425   
6426              o_FirEffReport_TP(dt,ild)
6427                  = Smax[ (resC,riskC) $ (ord(resC)=1)
6428                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6429   
6430          Endif;
6431   
6432          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
6433   
6434              o_SirSent_TP(dt,ild)
6435                  = Sum[ (rd,resC) $ (ord(resC) = 2),
6436                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
6437   
6438              o_SirReceived_TP(dt,ild)
6439                  = Sum[ (fd,resC) $ (ord(resC) = 2),
6440                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
6441   
6442              o_SirEffective_TP(dt,ild,riskC)
6443                  = Sum[ resC $ (ord(resC) = 2),
6444                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6445   
6446              o_SirEffReport_TP(dt,ild)
6447                  = Smax[ (resC,riskC) $ (ord(resC)=2)
6448                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
6449          Endif;
6450   
6451   
6452  * TN - The code for NMIR project end ===========================================
6453   
6454  *       Additional output for audit reporting
6455          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
6456   
6457  *       Check if there are non-physical losses on AC branches
6458          ManualBranchSegmentMWFlow(LossBranch(ACbranch(currTP,br)),los,fd)
6459                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
6460                  and validLossSegment(ACbranch,los,fd)
6461                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
6462                    }
6463                  = Min[ Max( 0,
6464                              [ abs(o_branchFlow_TP(dt,br))
6465                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6466                              ]
6467                            ),
6468                         ( LossSegmentMW(ACbranch,los,fd)
6469                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
6470                         )
6471                       ] ;
6472   
6473          ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
6474                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
6475                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
6476                    }
6477                  = Min[ Max( 0,
6478                              [ abs(o_branchFlow_TP(dt,br))
6479                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6480                              ]
6481                            ),
6482                         ( LossSegmentMW(HVDClink,los,fd)
6483                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
6484                         )
6485                       ] ;
6486   
6487          ManualLossCalculation(LossBranch(branch(currTP,br)))
6488              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
6489                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
6490   
6491          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
6492                                   - ManualLossCalculation(currTP,br) ;
6493   
6494          o_lossSegmentBreakPoint(dt,br,los)
6495              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6496                         and (ord(fd) = 1)
6497                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6498              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6499                         and (ord(fd) = 2)
6500                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6501          ;
6502   
6503          o_lossSegmentFactor(dt,br,los)
6504              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
6505                         and (ord(fd) = 1)
6506                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
6507              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
6508                         and (ord(fd) = 2)
6509                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
6510          ;
6511   
6512          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
6513   
6514          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
6515              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
6516                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
6517   
6518          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
6519              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
6520                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
6521   
6522          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
6523              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
6524                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6525   
6526          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
6527              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
6528                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
6529   
6530          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
6531              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
6532                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6533   
6534          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
6535              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
6536                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
6537   
6538          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6539                                                offerNode(currTP,o,n)
6540                                              }, o_ILRO_FIR_TP(dt,o) ] ;
6541   
6542          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6543                                                offerNode(currTP,o,n)
6544                                              }, o_ILRO_SIR_TP(dt,o) ] ;
6545   
6546          o_marketNodeIsland_TP(dt,o,ild)
6547              $ sum[ n $ { offerIsland(currTP,o,ild) and
6548                           offerNode(currTP,o,n) and
6549                           (o_nodeLoad_TP(dt,n)  = 0)
6550                         },1
6551                   ] = yes ;
6552   
6553          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
6554              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
6555              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6556              ;
6557   
6558          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
6559              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
6560   
6561          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6562              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
6563   
6564          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
6565              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
6566   
6567          o_manuRiskLevel(dt,ild,resC,ManualRisk)
6568              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
6569              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
6570              ;
6571   
6572          o_manuRiskPrice(dt,ild,resC,ManualRisk)
6573              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
6574   
6575          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
6576              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
6577   
6578          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
6579              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
6580   
6581          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
6582              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
6583   
6584          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
6585              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
6586   
6587          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
6588              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6589              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
6590              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6591              ;
6592   
6593          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
6594              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6595              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
6596   
6597  *       FIR and SIR required based on calculations of the island risk to
6598  *       overcome reporting issues of the risk setter under degenerate
6599  *       conditions when reserve price = 0 - See below
6600   
6601          o_ReserveReqd_TP(dt,ild,resC)
6602              = Max[ 0,
6603                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
6604                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
6605                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
6606                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
6607                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
6608                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
6609                   ] ;
6610   
6611          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
6612          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
6613   
6614  *       Summary reporting by trading period
6615          o_solveOK_TP(dt) = ModelSolved ;
6616   
6617          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
6618   
6619          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
6620   
6621          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
6622   
6623          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
6624                       - o_systemCost_TP(dt)
6625                       - o_penaltyCost_TP(dt);
6626   
6627   
6628  *       Separete violation reporting at trade period level
6629          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
6630   
6631          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
6632   
6633          o_surpBranchFlow_TP(dt)
6634              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
6635   
6636          o_defRampRate_TP(dt)
6637              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
6638   
6639          o_surpRampRate_TP(dt)
6640              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
6641   
6642          o_surpBranchGroupConst_TP(dt)
6643              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6644                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6645   
6646          o_defBranchGroupConst_TP(dt)
6647              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6648                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6649   
6650          o_defMnodeConst_TP(dt)
6651              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6652                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6653   
6654          o_surpMnodeConst_TP(dt)
6655              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6656                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6657   
6658          o_defACnodeConst_TP(dt)
6659              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6660                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6661   
6662          o_surpACnodeConst_TP(dt)
6663              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6664                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6665   
6666          o_defT1MixedConst_TP(dt)
6667              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6668                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6669   
6670          o_surpT1MixedConst_TP(dt)
6671              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6672                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6673   
6674          o_defGenericConst_TP(dt)
6675              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6676                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6677   
6678          o_surpGenericConst_TP(dt)
6679              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6680                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6681   
6682          o_defResv_TP(dt)
6683              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
6684   
6685          o_totalViolation_TP(dt)
6686              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
6687              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
6688              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
6689              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
6690              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
6691              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
6692              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
6693              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
6694   
6695  *       Virtual reserve
6696          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
6697   
6698          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6699                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6700   
6701          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6702                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6703   
6704  *   Reporting at trading period end
6705      EndLoop;
6707   
6709   
6710  * End of the solve vSPD loop
6711    ] ;
6712  * End of the While loop
6713  );
6714   
6715   
6716  *   Summary reports - only applied for normal and audit vSPD run.
6718   
6719  *   System level
6720      o_numTradePeriods = card(tp) ;
6721   
6722      o_systemOFV = sum[ dt, o_ofv_TP(dt) ] ;
6723   
6724      o_systemGen = sum[ (dt,ild), o_islandGen_TP(dt,ild) ] ;
6725   
6726      o_systemLoad = sum[ (dt,ild), o_islandLoad_TP(dt,ild)
6727                                  - o_islandClrBid_TP(dt,ild) ] ;
6728   
6729      o_systemLoss = sum[ (dt,ild), o_islandBranchLoss_TP(dt,ild)
6730                                  + o_HVDCloss_TP(dt,ild) ] ;
6731   
6732      o_systemViolation = sum[ dt, o_totalViolation_TP(dt) ] ;
6733   
6734      o_systemFIR = sum[ (dt,ild), o_FIRcleared_TP(dt,ild) ] ;
6735   
6736      o_systemSIR = sum[ (dt,ild), o_SIRcleared_TP(dt,ild) ] ;
6737   
6738   
6739  *   Offer level - This does not include revenue from wind generators for
6740  *   final pricing because the wind generation is netted off against load
6741  *   at the particular bus for the final pricing solves
6742   
6743      o_offerTrader(o,trdr)
6744          $ sum[ tp $ i_tradePeriodOfferTrader(tp,o,trdr), 1 ] = yes ;
6745   
6746      o_offerGen(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerEnergy_TP(dt,o)] ;
6747   
6748      o_offerFIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerFIR_TP(dt,o)] ;
6749   
6750      o_offerSIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerSIR_TP(dt,o)] ;
6751   
6753   
6754   
6755  *=====================================================================================
6756  * 8. vSPD scarcity pricing post-processing
6757  *=====================================================================================
6759   
6760  * Mapping scarcity area to islands
6761  scarcityAreaIslandMap(sarea,ild)      = no ;
6762  scarcityAreaIslandMap('NI','NI')      = yes ;
6763  scarcityAreaIslandMap('SI','SI')      = yes ;
6764  scarcityAreaIslandMap('National',ild) = yes ;
6765   
6767   
6768   
6769  * 8b. Calculating price-relating outputs --------------------------------------
6770   
6772  loop(i_dateTimeTradePeriodMap(dt,tp),
6773   
6774  *   bus output update
6775      o_busRevenue_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6776                                        * o_busGeneration_TP(dt,b)
6777                                        * o_busPrice_TP(dt,b) ;
6778   
6779      o_busCost_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6780                                     * o_busLoad_TP(dt,b)
6781                                     * o_busPrice_TP(dt,b);
6782   
6783  *   node output update
6784      o_nodeRevenue_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6785                                          * o_nodeGeneration_TP(dt,n)
6786                                          * o_nodePrice_TP(dt,n) ;
6787   
6788      o_nodeCost_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6789                                       * o_nodeLoad_TP(dt,n)
6790                                       * o_nodePrice_TP(dt,n) ;
6791   
6792  *   branch output update
6793      o_branchFromBusPrice_TP(dt,br) $ branch(tp,br)
6794          = sum[ b $ o_branchFromBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6795   
6796      o_branchToBusPrice_TP(dt,br) $ branch(tp,br)
6797          = sum[ b $ o_branchToBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6798   
6799      o_branchTotalRentals_TP(dt,br)
6800          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) >= 0) }
6801          = (i_tradingPeriodLength/60)
6802          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6803            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
6804            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6805            ] ;
6806   
6807      o_branchTotalRentals_TP(dt,br)
6808          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) < 0) }
6809          = (i_tradingPeriodLength/60)
6810          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6811            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6812            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
6813            ] ;
6814   
6815  *   Island output
6816      o_islandRefPrice_TP(dt,ild)
6817          = sum[ n $ { referenceNode(tp,n)
6818                   and nodeIsland(tp,n,ild) } , o_nodePrice_TP(dt,n) ] ;
6819   
6820      o_islandEnergyRevenue_TP(dt,ild)
6821          = sum[ n $ nodeIsland(tp,n,ild), o_nodeRevenue_TP(dt,n)] ;
6822   
6823      o_islandReserveRevenue_TP(dt,ild) = sum[ resC, o_ResCleared_TP(dt,ild,resC)
6824                                                   * o_ResPrice_TP(dt,ild,resC)
6825                                                   * i_tradingPeriodLength/60 ];
6826   
6827      o_islandLoadCost_TP(dt,ild)
6828          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
6829               , o_nodeCost_TP(dt,n) ] ;
6830   
6831      o_islandLoadRevenue_TP(dt,ild)
6832          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
6833               , - o_nodeCost_TP(dt,n) ] ;
6834   
6836  ) ;
6837   
6838  * System level
6839  o_systemEnergyRevenue  = sum[ (dt,ild), o_islandEnergyRevenue_TP(dt,ild) ] ;
6840   
6841  o_systemReserveRevenue = sum[ (dt,ild), o_islandReserveRevenue_TP(dt,ild) ];
6842   
6843  o_systemLoadCost       = sum[ (dt,ild), o_islandLoadCost_TP(dt,ild) ];
6844   
6845  o_systemLoadRevenue    = sum[ (dt,ild), o_islandLoadRevenue_TP(dt,ild) ];
6846   
6847  * Offer level
6848  o_offerGenRevenue(o)
6849      = sum[ (dt,tp,n) $ { i_dateTimeTradePeriodMap(dt,tp) and offerNode(tp,o,n) }
6850           , (i_tradingPeriodLength/60)
6851           * o_offerEnergy_TP(dt,o) * o_nodePrice_TP(dt,n) ] ;
6852   
6853  o_offerFIRrevenue(o)
6854      = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6855                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6856           , (i_tradingPeriodLength/60)
6857           * o_offerFIR_TP(dt,o) * o_FIRprice_TP(dt,ild) ] ;
6858   
6859  o_offerSIRrevenue(o)
6860     = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6861                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6862           , (i_tradingPeriodLength/60)
6863           * o_offerSIR_TP(dt,o) * o_SIRprice_TP(dt,ild) ] ;
6864   
6866  *   Calculating price-relating outputs end -------------------------------------
6867   
6868   
6870   
6871  *=====================================================================================
6872  * 9. Write results to CSV report files and GDX files
6873  *=====================================================================================
6874  * TN - Pivot analysis end
INCLUDE    C:\vSPD\GitHub\Programs\vSPDreport.gms
6876  *=====================================================================================
6877  * Name:                 vSPDreport.gms
6878  * Function:             Creates the detailed reports for normal SPD mode
6879  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
6880  * Source:               https://github.com/ElectricityAuthority/vSPD
6881  *                       https://www.emi.ea.govt.nz/Tools/vSPD
6882  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
6883  *                       Email: emi@ea.govt.nz
6884  * Last modified on:     1 Oct 2019
6885  *
6886  *=====================================================================================
6887   
6888  * Normal vSPD run output
6889  o_FromDateTime(dt)$( ord(dt) = 1 ) = yes ;
6890   
6891  * System surplus needs to be calculated outside the main loop
6892  o_systemSurplus = o_systemLoadCost-o_systemLoadRevenue-o_systemEnergyRevenue ;
6893   
6894  * Trader level - Currently this does not include revenue from wind generators
6895  * since wind generation in FP is represented as negative load
6896  o_trader(trdr) = yes ;
6897  o_traderGen(trdr) = sum(o_offerTrader(o,trdr), o_offerGen(o)) ;
6898  o_traderFIR(trdr) = sum(o_offerTrader(o,trdr), o_offerFIR(o)) ;
6899  o_traderSIR(trdr) = sum(o_offerTrader(o,trdr), o_offerSIR(o)) ;
6900  o_traderGenRevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerGenRevenue(o));
6901  o_traderFIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerFIRrevenue(o));
6902  o_traderSIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerSIRrevenue(o));
6903   
6904   
6905  *=====================================================================================
6906  * Writing data in to CSV result files
6907  *=====================================================================================
6908   
6909  * System level summary
6910  File SystemResults    / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_SystemResults.csv" / ;
6911  SystemResults.pc = 5 ;     SystemResults.lw = 0 ;
6912  SystemResults.pw = 9999 ;  SystemResults.ap = 1 ;
6913  put SystemResults ;
6914  loop( dt $ o_FromDateTime(dt),
6915      put dt.tl, o_NumTradePeriods, o_systemOFV, o_systemGen, o_systemLoad
6916          o_systemLoss, o_systemViolation, o_systemFIR, o_systemSIR
6917          o_systemEnergyRevenue, o_systemLoadCost, o_systemLoadRevenue
6918          o_systemSurplus / ;
6919  ) ;
6920   
6921  * Offer level summary
6922  File  OfferResults     / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults.csv" / ;
6923  OfferResults.pc = 5 ;      OfferResults.lw = 0 ;
6924  OfferResults.pw = 9999 ;   OfferResults.ap = 1 ;
6925  put OfferResults ;
6926  loop( (dt,o,trdr)
6927      $ { o_FromDateTime(dt) and o_offerTrader(o,trdr) and
6928          [ o_offerGen(o) or o_offerFIR(o) or o_offerSIR(o) ]
6929        },
6930      put dt.tl, o_NumTradePeriods, o.tl, trdr.tl
6931          o_offerGen(o), o_offerFIR(o), o_offerSIR(o) / ;
6932  ) ;
6933   
6934  * Trader level summary
6935  File  TraderResults   / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_TraderResults.csv" / ;
6936  TraderResults.pc = 5 ;     TraderResults.lw = 0 ;
6937  TraderResults.pw = 9999 ;  TraderResults.ap = 1 ;
6938  put TraderResults ;
6939  loop( (dt,trdr)
6940      $ { o_FromDateTime(dt) and o_trader(trdr) and
6941          [ o_traderGen(trdr) or o_traderFIR(trdr) or o_traderSIR(trdr) ]
6942        },
6943      put dt.tl, o_NumTradePeriods, trdr.tl
6944          o_traderGen(trdr), o_traderFIR(trdr), o_traderSIR(trdr) / ;
6945  ) ;
6946   
6947   
6948  * Trading period level report
6950   
6951  * Trading period summary result
6952  File
6953  SummaryResults_TP / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_SummaryResults_TP.csv" / ;
6954  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
6955  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
6956  SummaryResults_TP.nd = 5 ;
6957  put SummaryResults_TP ;
6958  loop( dt,
6959      put dt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
6960          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
6961          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
6962          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
6963          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
6964          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
6965          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt)
6966          o_DefACNodeConst_TP(dt), o_SurpACNodeConst_TP(dt)
6967          o_DefT1MixedConst_TP(dt), o_SurpT1MixedConst_TP(dt)
6968          o_DefGenericConst_TP(dt), o_SurpGenericConst_TP(dt) / ;
6969  ) ;
6970   
6971  * Trading period island result
6972  File IslandResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_IslandResults_TP.csv"/;
6973  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
6974  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
6975  IslandResults_TP.nd = 5 ;
6976  put IslandResults_TP ;
6977  loop( (dt,ild) $ o_island(dt,ild),
6978      put dt.tl, ild.tl, o_islandGen_TP(dt,ild), o_islandLoad_TP(dt,ild)
6979          o_islandClrBid_TP(dt,ild), o_islandBranchLoss_TP(dt,ild)
6980          o_HVDCFlow_TP(dt,ild), o_HVDCLoss_TP(dt,ild)
6981          o_islandRefPrice_TP(dt,ild), o_FIRReqd_TP(dt,ild)
6982          o_SIRReqd_TP(dt,ild), o_FIRPrice_TP(dt,ild)
6983          o_SIRPrice_TP(dt,ild), o_islandEnergyRevenue_TP(dt,ild)
6984          o_islandLoadCost_TP(dt,ild), o_islandLoadRevenue_TP(dt,ild)
6985  * NIRM output
6986      o_FirCleared_TP(dt,ild), o_SirCleared_TP(dt,ild)
6987      o_FirSent_TP(dt,ild), o_SirSent_TP(dt,ild)
6988      o_FirReceived_TP(dt,ild), o_SirReceived_TP(dt,ild)
6989      o_FirEffReport_TP(dt,ild), o_SirEffReport_TP(dt,ild)
6990  *NIRM output end
6991      / ;
6992  ) ;
6993   
6995   
6996  * Trading period bus result
6997  File BusResults_TP   / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv" / ;
6998  BusResults_TP.pc = 5 ;
6999  BusResults_TP.lw = 0 ;
7000  BusResults_TP.pw = 9999 ;
7001  BusResults_TP.ap = 1 ;
7002  BusResults_TP.nd = 3
7003  put BusResults_TP ;
7004  loop( o_bus(dt,b),
7005      put dt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
7006          o_busPrice_TP(dt,b), o_busRevenue_TP(dt,b), o_busCost_TP(dt,b)
7007          o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
7008  ) ;
7009   
7010  * Trading period node result
7011  File NodeResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_NodeResults_TP.csv" / ;
7012  NodeResults_TP.pc = 5 ;
7013  NodeResults_TP.lw = 0 ;
7014  NodeResults_TP.pw = 9999 ;
7015  NodeResults_TP.ap = 1 ;
7016  NodeResults_TP.nd = 3 ;
7017  put NodeResults_TP ;
7018  loop( (dt,n) $ o_node(dt,n),
7019      put dt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
7020          o_nodePrice_TP(dt,n), o_nodeRevenue_TP(dt,n), o_nodeCost_TP(dt,n)
7021          o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
7022  ) ;
7023   
7024  * Trading period offer result
7025  File OfferResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults_TP.csv"/ ;
7026  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
7027  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
7028  OfferResults_TP.nd = 3 ;
7029  put OfferResults_TP ;
7030  loop( (dt,o) $ o_offer(dt,o),
7031      put dt.tl, o.tl, o_offerEnergy_TP(dt,o)
7032          o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
7033  ) ;
7034   
7035  * Trading period bid result
7036  File BidResults_TP    / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BidResults_TP.csv" / ;
7037  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
7038  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
7039  BidResults_TP.nd = 3 ;
7040  put BidResults_TP ;
7041  loop( (dt,bd) $ o_bid(dt,bd),
7042      put dt.tl, bd.tl, o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd)
7043      o_bidFIR_TP(dt,bd), o_bidSIR_TP(dt,bd) / ;
7044  ) ;
7045   
7046  * Trading period reserve result
7047  File
7048  ReserveResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_ReserveResults_TP.csv" / ;
7049  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
7050  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
7051  ReserveResults_TP.nd = 3 ;
7052  put ReserveResults_TP ;
7053  loop( (dt,ild) $ o_island(dt,ild),
7054      put dt.tl, ild.tl, o_FIRReqd_TP(dt,ild), o_SIRReqd_TP(dt,ild)
7055          o_FIRPrice_TP(dt,ild), o_SIRPrice_TP(dt,ild)
7056          o_FIRViolation_TP(dt,ild), o_SIRViolation_TP(dt,ild)
7057          o_FIRvrMW_TP(dt,ild), o_SIRvrMW_TP(dt,ild) / ;
7058  ) ;
7059   
7060  * Trading period branch result
7061  File
7062  BranchResults_TP  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BranchResults_TP.csv" / ;
7063  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
7064  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
7065  BranchResults_TP.nd = 5 ;
7066  put BranchResults_TP ;
7067  loop( (dt,br,frB,toB)
7068      $ { o_branchToBus_TP(dt,br,toB) and
7069          o_branchFromBus_TP(dt,br,frB) and o_branch(dt,br)
7070        },
7071      put dt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
7072          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
7073          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
7074          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
7075          o_branchTotalRentals_TP(dt,br) / ;
7076  ) ;
7077   
7078  * Trading period branch constraint result
7079  File BrCstrResults_TP
7080  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BrConstraintResults_TP.csv" / ;
7081  BrCstrResults_TP.pc = 5 ;
7082  BrCstrResults_TP.lw = 0 ;
7083  BrCstrResults_TP.pw = 9999 ;
7084  BrCstrResults_TP.ap = 1 ;
7085  BrCstrResults_TP.nd = 5 ;
7086  put BrCstrResults_TP ;
7087  loop( (dt,brCstr) $ o_brConstraint_TP(dt,brCstr),
7088      put dt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
7089          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
7090          o_brConstraintPrice_TP(dt,brCstr) / ;
7091  ) ;
7092   
7093  * Trading period market node constraint result
7094  File MnodeCstrResults_TP
7095  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_MnodeConstraintResults_TP.csv" / ;
7096  MnodeCstrResults_TP.pc = 5 ;
7097  MnodeCstrResults_TP.lw = 0 ;
7098  MnodeCstrResults_TP.pw = 9999 ;
7099  MnodeCstrResults_TP.ap = 1 ;
7100  MnodeCstrResults_TP.nd = 5 ;
7101  put MnodeCstrResults_TP ;
7102  loop( (dt,MnodeCstr) $ o_MnodeConstraint_TP(dt,MnodeCstr),
7103      put dt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
7104          o_MnodeConstraintSense_TP(dt,MnodeCstr)
7105          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
7106          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
7107  ) ;
7108   
7110  *===============================================================================
7111   
7112   
7113   
7114  *===============================================================================
7115  * Audit mode reporting process
7116  *===============================================================================
7118   
7119  * Introduce zero tolerance to detect risk setter due to rounding issues
7120  Scalar zeroTolerance / 0.000001 / ;
7121   
7122   
7123  * Audit - branch loss result
7124  File branchLoss_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchLoss.csv"/;
7125  branchLoss_Audit.pc = 5 ;
7126  branchLoss_Audit.lw = 0 ;
7127  branchLoss_Audit.pw = 9999 ;
7128  BranchLoss_Audit.ap = 1 ;
7129  BranchLoss_Audit.nd = 9 ;
7130  put BranchLoss_Audit ;
7131  loop( (dt,br) $ o_branch(dt,br),
7132      put dt.tl, br.tl ;
7133      loop(los $ o_LossSegmentBreakPoint(dt,br,los),
7134          put o_LossSegmentBreakPoint(dt,br,los)
7135              o_LossSegmentFactor(dt,br,los) ;
7136      )
7137      put / ;
7138  ) ;
7139   
7140  * Audit - bus result
7141  File busResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BusResults.csv"/;
7142  busResults_Audit.pc = 5 ;
7143  busResults_Audit.lw = 0 ;
7144  busResults_Audit.pw = 9999 ;
7145  BusResults_Audit.ap = 1 ;
7146  BusResults_Audit.nd = 5 ;
7147  put BusResults_Audit ;
7148  loop( (dt,b,ild) $ { o_bus(dt,b) and o_busIsland_TP(dt,b,ild) },
7149      put dt.tl, ild.tl, b.tl, o_ACBusAngle(dt,b)
7150          o_busPrice_TP(dt,b), o_busLoad_TP(dt,b)
7151          o_ILBus_FIR_TP(dt,b), o_ILBus_SIR_TP(dt,b) / ;
7152  ) ;
7153   
7154  * Audit - market node result
7155  File
7156  MNodeResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_MNodeResults.csv"/;
7157  MNodeResults_Audit.pc = 5 ;
7158  MNodeResults_Audit.lw = 0 ;
7159  MNodeResults_Audit.pw = 9999 ;
7160  MNodeResults_Audit.ap = 1 ;
7161  MNodeResults_Audit.nd = 5 ;
7162  put MNodeResults_Audit ;
7163  loop( (dt,o,ild) $ {o_offer(dt,o) and o_MarketNodeIsland_TP(dt,o,ild) },
7164      put dt.tl, ild.tl, o.tl, o_offerEnergy_TP(dt,o)
7165          o_PLRO_FIR_TP(dt,o), o_PLRO_SIR_TP(dt,o)
7166          o_TWRO_FIR_TP(dt,o), o_TWRO_SIR_TP(dt,o) / ;
7167  ) ;
7168   
7169  * Audit - branch result
7170  File
7171  brchResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchResults.csv"/;
7172  brchResults_Audit.pc = 5 ;
7173  brchResults_Audit.lw = 0 ;
7174  brchResults_Audit.pw = 9999 ;
7175  brchResults_Audit.ap = 1 ;
7176  brchResults_Audit.nd = 9 ;
7177  put brchResults_Audit ;
7178  loop( (dt,br) $ o_branch(dt,br),
7179      put dt.tl, br.tl, o_branchFlow_TP(dt,br)
7180          o_branchDynamicLoss_TP(dt,br), o_branchFixedLoss_TP(dt,br)
7181          [o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br)] ;
7182      if ( o_branchMarginalPrice_TP(dt,br) <> 0,  put 'Y' ;
7183      else                                        put 'N' ;
7184      ) ;
7185   
7186      put o_branchMarginalPrice_TP(dt,br) ;
7187   
7188      if( o_NonPhysicalLoss(dt,br) > NonPhysicalLossTolerance, put 'Y' / ;
7189      else                                                     put 'N' / ;
7190      ) ;
7191  ) ;
7192   
7193  * Audit - risk result
7194  File
7195  riskResults_Audit    /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_RiskResults.csv"/;
7196  riskResults_Audit.pc = 5 ;
7197  riskResults_Audit.lw = 0 ;
7198  riskResults_Audit.pw = 9999 ;
7199  RiskResults_Audit.ap = 1 ;
7200  RiskResults_Audit.nd = 5 ;
7201  put RiskResults_Audit ;
7202  loop( (dt,ild,resC) $ o_island(dt,ild),
7203      loop( (o,GenRisk) $ { ( o_generationRiskLevel(dt,ild,o,resC,GenRisk) > 0 )
7204                        and ( abs[ o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
7205                                 - o_ReserveReqd_TP(dt,ild,resC)
7206                                 ] <= ZeroTolerance )
7207                           },
7208          put dt.tl, ild.tl, resC.tl, o.tl, GenRisk.tl
7209              o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
7210              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,GenRisk)
7211              o_ResViolation_TP(dt,ild,resC)
7212              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7213   
7214      ) ;
7215   
7216      loop( HVDCrisk $ { (o_HVDCriskLevel(dt,ild,resC,HVDCrisk) > 0)
7217                     and ( abs[  o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
7218                               - o_ReserveReqd_TP(dt,ild,resC)
7219                              ] <= ZeroTolerance )
7220                       },
7221          put dt.tl, ild.tl, resC.tl, 'HVDC', HVDCrisk.tl
7222              o_HVDCriskLevel(dt,ild,resC,HVDCrisk), o_ResCleared_TP(dt,ild,resC)
7223              o_EffectiveRes_TP(dt,ild,resC,HVDCRisk)
7224              o_ResViolation_TP(dt,ild,resC)
7225              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7226      ) ;
7227   
7228      loop( manualRisk $ { ( o_manuRiskLevel(dt,ild,resC,ManualRisk) > 0 )
7229                       and ( abs[ o_manuRiskLevel(dt,ild,resC,manualRisk)
7230                                - o_ReserveReqd_TP(dt,ild,resC)
7231                                ] <= ZeroTolerance )
7232                         },
7233          put dt.tl, ild.tl, resC.tl, 'Manual', manualRisk.tl
7234              o_manuRiskLevel(dt,ild,resC,manualRisk),o_ResCleared_TP(dt,ild,resC)
7235              o_EffectiveRes_TP(dt,ild,resC,manualRisk)
7236              o_ResViolation_TP(dt,ild,resC)
7237              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7238      ) ;
7239   
7240      loop( (o,riskC) $ { HVDCsecRisk(riskC)
7241                      and ( o_genHVDCriskLevel(dt,ild,o,resC,riskC) > 0 )
7242                      and ( abs[ o_genHVDCriskLevel(dt,ild,o,resC,riskC)
7243                               - o_ReserveReqd_TP(dt,ild,resC)
7244                               ] <= ZeroTolerance )
7245                        },
7246          put dt.tl, ild.tl, resC.tl, o.tl, riskC.tl
7247              o_GenHVDCRiskLevel(dt,ild,o, resC,riskC)
7248              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
7249              o_ResViolation_TP(dt,ild,resC)
7250              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7251      ) ;
7252   
7253      loop( (o,riskC) $ { HVDCsecRisk(riskC)
7254                      and ( o_manuHVDCriskLevel(dt,ild,resC,riskC) > 0 )
7255                      and ( abs[ o_manuHVDCriskLevel(dt,ild,resC,riskC)
7256                               - o_ReserveReqd_TP(dt,ild,resC)
7257                               ] <= ZeroTolerance )
7258                        },
7259          put dt.tl, ild.tl, resC.tl, 'Manual', riskC.tl
7260              o_manuHVDCriskLevel(dt,ild,resC,riskC)
7261              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
7262              o_ResViolation_TP(dt,ild,resC)
7263              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7264          ) ;
7265   
7266  *   Ensure still reporting for conditions with zero FIR and/or SIR required
7267      if( (o_ReserveReqd_TP(dt,ild,resC) = 0) ,
7268          put dt.tl, ild.tl, resC.tl, ' ', ' ', ' '
7269              o_ResCleared_TP(dt,ild,resC), o_ResViolation_TP(dt,ild,resC)
7270              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
7271      ) ;
7272  ) ;
7273   
7274  * Audit - objective result
7275  File objResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_ObjResults.csv"/;
7276  objResults_Audit.pc = 5 ;
7277  objResults_Audit.lw = 0 ;
7278  objResults_Audit.pw = 9999 ;
7279  objResults_Audit.ap = 1 ;
7280  objResults_Audit.nd = 5 ;
7281  objResults_Audit.nw = 20 ;
7282  put objResults_Audit
7283  loop( dt,
7284      put dt.tl, o_ofv_TP(dt) /
7285  ) ;
7286   
7287   
7288  execute_unload 'C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_AllData.gdx' ;
7290  *===============================================================================
7291  *execute_unload '%outputPath%\%runName%\%vSPDinputData%_AllData.gdx' ;
7292   
7293   
7294   
7295   
7297   
7298   
7299  * Post a progress message for use by EMI.
7300  putclose runlog 'Case: RTD_20211202_RTP is complete in ',timeExec,'(secs)'/ ;
7301  putclose runlog 'Case: RTD_20211202_RTP is finished in ',timeElapsed,'(secs)'/ ;
7302   
7303  * Go to the next input file
7305   
7306  * Post a progress message for use by EMI.
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\vSPD\GitHub\Programs\vSPDsolve.gms
     2     2741 INCLUDE        1      64  .C:\vSPD\GitHub\Programs\vSPDsettings.inc
     3     2796 INCLUDE        1      65  .C:\vSPD\GitHub\Programs\vSPDcase.inc
     4     3193 IF EXIST       1     459  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     5     3199 GDXIN          1     465  C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
     6     3205 GDXIN          1     471  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     7     3229 GDXIN          1     495  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     8     3496 IF EXIST       1     762  C:\vSPD\GitHub\Override\.gdx
     9     5013 INCLUDE        1    2279  .C:\vSPD\GitHub\Programs\vSPDsolve_RTP.gms
    10     6875 INCLUDE        1    3933  .C:\vSPD\GitHub\Programs\vSPDreport.gms
    11     6949 IF EXIST      10      74  .C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv
    12     7307 IF EXIST       1    3945  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx


COMPILATION TIME     =        0.031 SECONDS      4 MB  36.2.0 r433180e WEX-WEI
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 5040


LOOPS                            FOR/WHILE   1
                                        tp   02-DEC-2021 13:25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,844
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,141
NON ZERO ELEMENTS        93,793     DISCRETE VARIABLES         14


GENERATION TIME      =        0.078 SECONDS     24 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 02-DEC-2021 13:25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 5040


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  5040

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -26196.2749

 RESOURCE USAGE, LIMIT          1.219      3600.000
 ITERATION COUNT, LIMIT      6874    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\GitHub\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\GitHub\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 5.25 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.12 Mb (peak 13.45 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 8.40 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.84sec (det. 860.60 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 285.63 ticks)


Proven optimal solution
MIP Solution:       -26196.274950    (6874 iterations, 23 nodes)
Final Solve:        -26196.274950    (3534 iterations)

Best possible:      -26196.274950
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 5444


LOOPS                            FOR/WHILE   1
                                        tp   02-DEC-2021 13:25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,844
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,141
NON ZERO ELEMENTS        93,793     DISCRETE VARIABLES         14


GENERATION TIME      =        0.109 SECONDS     29 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 02-DEC-2021 13:25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 8
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 5444


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  5444

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE           -25716.1962

 RESOURCE USAGE, LIMIT          1.141      3600.000
 ITERATION COUNT, LIMIT      6837    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\GitHub\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\GitHub\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 5.25 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.12 Mb (peak 13.45 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 8.40 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.81sec (det. 860.73 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 303.50 ticks)


Proven optimal solution
MIP Solution:       -25716.196161    (6837 iterations, 20 nodes)
Final Solve:        -25716.196161    (3609 iterations)

Best possible:      -25716.196161
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/14/22 16:10:03 Page 9
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog C:\vSPD\GitHub\Programs\ProgressReport.txt
temp C:\vSPD\GitHub\Programs\temp.put
SystemResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_SystemResults.csv
OfferResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults.csv
TraderResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_TraderResults.csv
SummaryResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_SummaryResults_TP.csv
IslandResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_IslandResults_TP.csv
BusResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv
NodeResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_NodeResults_TP.csv
OfferResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults_TP.csv
ReserveResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_ReserveResults_TP.csv
BranchResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BranchResults_TP.csv
BrCstrResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BrConstraintResults_TP.csv
MnodeCstrResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_MnodeConstraintResults_TP.csv
branchLoss_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchLoss.csv
busResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BusResults.csv
MNodeResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_MNodeResults.csv
brchResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchResults.csv
riskResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_RiskResults.csv
objResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_ObjResults.csv


EXECUTION TIME       =        3.563 SECONDS     35 MB  36.2.0 r433180e WEX-WEI


USER: Single User License, Phil Bishop               G200929/0001CS-WIN
      Electricity Authority - Te Mana Hiko                    DC5643-S1


**** FILE SUMMARY

Restart    C:\vSPD\GitHub\Programs\vSPDmodel.g00
Input      C:\vSPD\GitHub\Programs\vSPDsolve.gms
Output     C:\vSPD\GitHub\Programs\vSPDsolve.lst
