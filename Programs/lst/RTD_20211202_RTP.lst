GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/13/22 18:06:25 Page 3
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


2665  *=====================================================================================
2666  * Name:                 vSPDsolve.gms
2667  * Function:             Establish base case and override data, prepare data, and solve
2668  *                       the model
2669  * Developed by:         Electricity Authority, New Zealand
2670  * Source:               https://github.com/ElectricityAuthority/vSPD
2671  *                       http://www.emi.ea.govt.nz/Tools/vSPD
2672  * Contact:              Forum: http://www.emi.ea.govt.nz/forum/
2673  *                       Email: emi@ea.govt.nz
2674  * Modified on:          1 Oct 2019
2675  *                       New feature added: new wind offer arrangements
2676  * Modified on:          11 Nov 2020
2677  *                       Replacing invalid bus prices after SOS1 (6.1.3)
2678  * Last modified on:     11 Dec 2020
2679  *                       From 11 Dec 2020, GDX input file have i_tradePeriodBranchCapacityDirected
2680  *                       and i_tradePeriodReverseRatingsApplied symbols
2681  *                       Applying branch reverse rating  s only when i_tradePeriodReverseRatingsApplied = 1
2682  * Last modified on:     27 June 2021
2683  *                       Fixing the bug that remove HVDC because of zero  reverse rating limits
2684   
2685  *=====================================================================================
2686   
        Directory of code sections in vSPDsolve.gms:
        1. Declare symbols and initialise some of them
        2. Load data from GDX file f
        3. Manage model and data compatability
        4. Input data overrides - declare and apply (include vSPDoverrides.gms)
        5. Initialise constraint violation penalties (CVPs)
        6. The vSPD solve loop
           a) Reset all sets, parameters and variables before proceeding with the next study trade period
           b) Initialise current trade period and model data for the current trade period
           c) Additional pre-processing on parameters and variables before model solve
           d) Solve the model
           e) Check if the LP results are valid
           f) Resolve the model if required
           g) Check for disconnected nodes and adjust prices accordingly
           h) Collect and store results from the current model solve in the output (o_xxx) parameters
           i) End of the solve vSPD loop
        7. vSPD scarcity pricing post-processing
        8. Write results to CSV report files and GDX files
       
      Aliases to be aware of:
        i_island = ild, ild1                      i_dateTime = dt
        i_tradePeriod = tp                        i_node = n
        i_offer = o, o1                           i_trader = trdr
        i_tradeBlock = trdBlk                     i_bus = b, b1, frB, toB
        i_branch = br, br1                        i_lossSegment = los, los1
        i_branchConstraint = brCstr               i_ACnodeConstraint = ACnodeCstr
        i_MnodeConstraint = MnodeCstr             i_energyOfferComponent = NRGofrCmpnt
        i_PLSRofferComponent = PLSofrCmpnt        i_TWDRofferComponent = TWDofrCmpnt
        i_ILRofferComponent = ILofrCmpnt          i_energyBidComponent = NRGbidCmpnt
        i_ILRbidComponent = ILbidCmpnt            i_type1MixedConstraint = t1MixCstr
        i_type2MixedConstraint = t2MixCstr        i_type1MixedConstraintRHS = t1MixCstrRHS
        i_genericConstraint = gnrcCstr            i_scarcityArea = sarea
        i_reserveType = resT                      i_reserveClass = resC
        i_riskClass = riskC                       i_constraintRHS = CstrRHS
        i_riskParameter = riskPar                 i_offerParam = offerPar
        i_dczone = z,z1,rrz,rrz1                  i_riskGroup = rg,rg1)
2725   
2726   
2727  * Include paths, settings and case name files
INCLUDE    C:\vSPD\GitHub\Programs\vSPDsettings.inc
2729  *+++ vSPD settings +++
2732   
2733  *+++ Paths +++
2737  *$setglobal inputPath                     'A:\Tuong Nguyen\vSPD_Inputs\FP\'
2740   
2742   
2743   
2744  *+++ Model +++
2745  Scalar sequentialSolve                   / 0 / ;   ! Vectorisation: Yes <-> i_SequentialSolve: 0
2746  Scalar disconnectedNodePriceCorrection   / 1 / ;
2747  Scalar tradePeriodReports                / 1 / ;   ! Specify 1 for reports at trading period level, 0 otherwise
2748   
2749   
2750  *+++ Network +++
2751  Scalar useACLossModel                    / 1 / ;
2752  Scalar useHVDCLossModel                  / 1 / ;
2753  Scalar useACBranchLimits                 / 1 / ;
2754  Scalar useHVDCBranchLimits               / 1 / ;
2755  Scalar resolveCircularBranchFlows        / 1 / ;
2756  Scalar resolveHVDCNonPhysicalLosses      / 1 / ;
2757  Scalar resolveACNonPhysicalLosses        / 0 / ;   ! Placeholder for future code development
2758  Scalar circularBranchFlowTolerance       / 0.000001 / ;
2759  Scalar nonPhysicalLossTolerance          / 0.000001 / ;
2760  Scalar useBranchFlowMIPTolerance         / 0.000001 / ;
2761   
2762   
2763  *+++ Constraints +++
2764  Scalar useReserveModel                   / 1 / ;
2765  Scalar suppressMixedConstraint           / 0 / ;
2766  Scalar mixedMIPtolerance                 / 0.000001 / ;
2767   
2768   
2769  *+++ Solver +++
2770  Scalar LPtimeLimit                       / 3600 / ;
2771  Scalar LPiterationLimit                  / 2000000000 / ;
2772  Scalar MIPtimeLimit                      / 3600 / ;
2773  Scalar MIPiterationLimit                 / 2000000000 / ;
2774  Scalar MIPoptimality                     / 0 / ;
2777   
2778   
2779  *+++ Various switches +++
2782   
INCLUDE    C:\vSPD\GitHub\Programs\vSPDcase.inc
2787  tradePeriodReports = 1 ;
2788   
2789   
2790  * Update the runlog file
2791  File runlog "Write to a report"  / "ProgressReport.txt" /;
2792  runlog.lw = 0 ; runlog.ap = 1 ;
2793  putclose runlog / 'Case "RTD_20211202_RTP" started at: '
2794                    system.date " " system.time /;
2795  if(sequentialSolve,
2796    putclose runlog 'Vectorisation is switched OFF' /;
2797  else
2798    putclose runlog 'Vectorisation is switched ON' /;
2799  ) ;
2800   
2801  * Set the solver for the LP and MIP
2802  option lp = Cplex ;
2803  option mip = Cplex ;
2804   
2805  * Set profile status
2806  option profile = 0 ;
2807   
2808  * Set the solution print status in the lst file
2809  option solprint = off;
2810   
2811  * Set the column (variable) and row (equation) listing in the lst file
2812  option limcol = 0 ;
2813  option limrow = 0 ;
2814   
2815  * Allow empty data set declaration
2817   
2818  * Declare a temporary file
2819  File temp ;
2820   
2821  *=====================================================================================
2822  * 1. Declare symbols and initialise some of them
2823  *=====================================================================================
2824   
2825  Sets
2826  * Initialise fundamental sets by hard-coding (these sets can also be found in the daily GDX files)
2827    i_island                    / NI, SI /
2828    i_reserveClass              / FIR, SIR /
2829   
       Scarcity pricing updates --> i_reserveType
       Rather than include an additional reserve type element an additional virutal
       reserve paramter and associated variable is created. This is more efficient
       implementation in terms of the problem size as all other reserve providers
       are indexed on i_reserveType which would include an additional index on all
       these variables thus increasing the problem size. This increase would then
       need additional pre-processing to fix variables to zero. To avoid this and
       keep the problem size small the additional virtual reserve variable is included.
2840    i_reserveType               / PLSR, TWDR, ILR /
2841   
2842    i_riskClass                 / genRisk, DCCE, DCECE, manual, genRisk_ECE
2843                                  manual_ECE, HVDCsecRisk_CE, HVDCsecRisk_ECE /
2844    i_riskParameter             / i_freeReserve, i_riskAdjustmentFactor, i_HVDCpoleRampUp /
2845    i_offerType                 / energy, PLSR, TWDR, ILR /
2846    i_offerParam                / i_initialMW, i_rampUpRate, i_rampDnRate
2847                                  i_reserveGenerationMaximum, i_windOffer, i_FKbandMW,
2848                                  i_IsPriceResponse, i_PotentialMW  /
2849    i_energyOfferComponent      / i_generationMWoffer, i_generationMWofferPrice /
2850    i_PLSRofferComponent        / i_PLSRofferPercentage, i_PLSRofferMax, i_PLSRofferPrice /
2851    i_TWDRofferComponent        / i_TWDRofferMax, i_TWDRofferPrice /
2852    i_ILRofferComponent         / i_ILRofferMax, i_ILRofferPrice /
2853    i_energyBidComponent        / i_bidMW, i_bidPrice /
2854    i_ILRbidComponent           / i_ILRbidMax, i_ILRbidPrice /
2855    i_tradeBlock                / t1*t20 /
2856    i_lossSegment               / ls1*ls13 /
2857    i_lossParameter             / i_MWbreakPoint, i_lossCoefficient /
2858    i_branchParameter           / i_branchResistance, i_branchSusceptance, i_branchFixedLosses, i_numLossTranches /
2859    i_constraintRHS             / i_constraintSense, i_constraintLimit /
2860    i_type1MixedConstraintRHS   / i_mixedConstraintSense, i_mixedConstraintLimit1, i_mixedConstraintLimit2 /
2861    i_flowDirection             / forward, backward /
2862    i_CVP                       / i_deficitBusGeneration, i_surplusBusGeneration
2863                                  i_deficit6sReserve_CE, i_deficit60sReserve_CE
2864                                  i_deficitBranchGroupConstraint, i_surplusBranchGroupConstraint
2865                                  i_deficitGenericConstraint, i_surplusGenericConstraint
2866                                  i_deficitRampRate, i_surplusRampRate
2867                                  i_deficitACnodeConstraint, i_surplusACnodeConstraint
2868                                  i_deficitBranchFlow, i_surplusBranchFlow
2869                                  i_deficitMnodeConstraint, i_surplusMnodeConstraint
2870                                  i_type1DeficitMixedConstraint, i_type1SurplusMixedConstraint
2871                                  i_deficit6sReserve_ECE, i_deficit60sReserve_ECE /
2872   
2873  * Initialise the set called pole
2874    pole  'HVDC poles'          / pole1, pole2 /
2875   
2876  * Scarcity pricing updates
2877    i_scarcityArea              /NI, SI, National/
2878   
2879  * NMIR - HVDC flow zones for reverse reserve sharing
2880    i_dczone                    /RP, NR, RZ/
2881   
2882    ;
2883   
2884   
2885   
2886  * 'startyear' must be modified if you ever decide it is clever to change the first element of i_yearnum.
2887  Scalar startYear 'Start year - used in computing Gregorian date for override years'  / 1899 / ;
2888   
2889  Sets
2890    scarcityAreaIslandMap(sarea,ild)                    'Mapping of scarcity area to island'
2891    unsolvedPeriod(tp)                                  'Set of periods that are not solved yet'
2892  * Unmmaped bus defificit temporary sets
2893    unmappedDeficitBus(dt,b)                            'List of buses that have deficit generation (price) and are not mapped to any pnode'
2894    changedDeficitBus(dt,b)                             'List of buses that have deficit generation added from unmapped deficit bus'
2895  * TN - Replacing invalid prices after SOS1
2896    vSPD_SOS1_Solve(tp)                                 'Flag period that is resolved using SOS1'
2897    ;
2898   
2899  Parameters
2900  * Flag to apply corresponding vSPD model
2901    VSPDModel(tp)                                       '0=VSPD, 1=VSPD_MIP, 2=vSPD_BranchFlowMIP, 3=vSPD_MixedConstraintMIP, 4=VSPD (last solve)'
2902  * Main iteration counter
2903    iterationCount                                      'Iteration counter for the solve'
2904  * MIP logic
2905    circularBranchFlowExist(tp,br)                      'Flag to indicate if circulating branch flows exist on each branch: 1 = Yes'
2906  * Introduce flag to detect circular branch flows on each HVDC pole
2907    poleCircularBranchFlowExist(tp,pole)                'Flag to indicate if circulating branch flows exist on each an HVDC pole: 1 = Yes'
2908    northHVDC(tp)                                       'HVDC MW sent from from SI to NI'
2909    southHVDC(tp)                                       'HVDC MW sent from from NI to SI'
2910    nonPhysicalLossExist(tp,br)                         'Flag to indicate if non-physical losses exist on branch: 1 = Yes'
2911    manualBranchSegmentMWFlow(tp,br,los,fd)             'Manual calculation of the branch loss segment MW flow'
2912    manualLossCalculation(tp,br)                        'MW losses calculated manually from the solution for each loss branch'
2913    HVDChalfPoleSouthFlow(tp)                           'Flag to indicate if south flow on HVDC halfpoles'
2914    type1MixedConstraintLimit2Violation(tp, t1MixCstr)  'Type 1 mixed constraint MW violaton of the alternate limit value'
2915  * Parameters to calculate circular branch flow on each HVDC pole
2916    TotalHVDCpoleFlow(tp,pole)                          'Total flow on an HVDC pole'
2917    MaxHVDCpoleFlow(tp,pole)                            'Maximum flow on an HVDC pole'
2918  * Disconnected bus post-processing
2919    busGeneration(tp,b)                                 'MW generation at each bus for the study trade periods'
2920    busLoad(tp,b)                                       'MW load at each bus for the study trade periods'
2921    busPrice(tp,b)                                      '$/MW price at each bus for the study trade periods'
2922    busDisconnected(tp,b)                               'Indication if bus is disconnected or not (1 = Yes) for the study trade periods'
2923  * Scarcity pricing processing parameters
2924    scarcitySituation(tp,sarea)                         'Flag to indicate that a scarcity situation exists (1 = Yes)'
2925    GWAPFloor(tp,sarea)                                 'Floor price for the scarcity situation in scarcity area'
2926    GWAPCeiling(tp,sarea)                               'Ceiling price for the scarcity situation in scarcity area'
2927    GWAPPastDaysAvg(tp,ild)                             'Average GWAP over past days - number of periods in GWAP count'
2928    GWAPCountForAvg(tp,ild)                             'Number of periods used for the i_gwapPastDaysAvg'
2929    GWAPThreshold(tp,ild)                               'Threshold on previous 336 trading period GWAP - cumulative price threshold'
2930    islandGWAP(tp,ild)                                  'Island GWAP calculation used to update GWAPPastDaysAvg'
2931    scarcityAreaGWAP(tp,sarea)                          'Scarcity area GWAP used to calculate the scaling factor'
2932    pastGWAPsumforCPT(tp,ild)
2933    pastTPcntforCPT(tp,ild)
2934    currentDayGWAPsumforCPT(ild)
2935    currentDayTPsumforCPT(ild)
2936    avgPriorGWAP(tp,ild)
2937    cptIslandPassed(tp,sarea)
2938    cptPassed(tp,sarea)
2939    cptIslandReq(sarea)
2940    scarcityScalingFactor(tp,sarea)
2941    scaledbusPrice(tp,b)
2942    scalednodePrice(tp,n)
2943    scaledFIRprice(tp,ild)
2944    scaledSIRprice(tp,ild)
2945    scaledislandGWAP(tp,ild)
2946    scaledscarcityAreaGWAP(tp,sarea)
2947  * Unmmaped bus defificit temporary parameters
2948    temp_busDeficit_TP(dt,b) 'Bus deficit violation for each trade period'
2949  * TN - Replacing invalid prices after SOS1
2950    busSOSinvalid(tp,b)                                 'Buses with invalid bus prices after SOS1 solve'
2951    numberofbusSOSinvalid(tp)                           'Number of buses with invalid bus prices after SOS1 solve --> used to check if invalid prices can be improved (numberofbusSOSinvalid reduces after each iteration) '
2952  * TN - Flag to apply branch reverse ratings
2953    reverseRatingsApplied(tp)
2954    ;
2955   
2956  Sets
2957  * Dispatch results reporting
2958    o_fromDateTime(dt)                                  'Start period for summary reports'
2959    o_dateTime(dt)                                      'Date and time for reporting'
2960    o_bus(dt,b)                                         'Set of buses for output report'
2961    o_offer(dt,o)                                       'Set of offers for output report'
2962    o_bid(dt,bd)                                        'Set of bids for output report'
2963    o_island(dt,ild)                                    'Island definition for trade period reserve output report'
2964    o_offerTrader(o,trdr)                               'Mapping of offers to traders for offer summary reports'
2965    o_trader(trdr)                                      'Set of traders for trader summary output report'
2966    o_node(dt,n)                                        'Set of nodes for output report'
2967    o_branch(dt,br)                                     'Set of branches for output report'
2968    o_HVDClink(dt,br)                                   'HVDC links (branches) defined for the current trading period'
2969    o_branchFromBus_TP(dt,br,frB)                       'From bus for set of branches for output report'
2970    o_branchToBus_TP(dt,br,toB)                         'To bus for set of branches for output report'
2971    o_brConstraint_TP(dt,brCstr)                        'Set of branch constraints for output report'
2972    o_MnodeConstraint_TP(dt,MnodeCstr)                  'Set of Mnode constraints for output report'
2973  * Audit - extra output declaration
2974    o_busIsland_TP(dt,b,ild)                                      'Audit - Bus island mapping'
2975    o_marketNodeIsland_TP(dt,o,ild)                               'Audit - Generation offer island mapping'
2976    ;
2977   
2978  Parameters
2979  * Dispatch results for reporting - Trade period level - Island output
2980    o_islandGen_TP(dt,ild)                              'Island MW generation for the different time periods'
2981    o_islandLoad_TP(dt,ild)                             'Island MW fixed load for the different time periods'
2982    o_islandClrBid_TP(dt,ild)                           'Island cleared MW bid for the different time periods'
2983    o_systemViolation_TP(dt,ild)                        'Island MW violation for the different time periods'
2984    o_islandEnergyRevenue_TP(dt,ild)                    'Island energy revenue ($) for the different time periods'
2985    o_islandReserveRevenue_TP(dt,ild)                   'Island reserve revenue ($) for the different time periods'
2986    o_islandLoadCost_TP(dt,ild)                         'Island load cost ($) for the different time periods'
2987    o_islandLoadRevenue_TP(dt,ild)                      'Island load revenue ($) for the different time periods'
2988    o_islandBranchLoss_TP(dt,ild)                       'Intra-island branch losses for the different time periods (MW)'
2989    o_islandRefPrice_TP(dt,ild)                         'Reference prices in each island ($/MWh)'
2990    o_HVDCflow_TP(dt,ild)                               'HVDC flow from each island (MW)'
2991    o_HVDCloss_TP(dt,ild)                               'HVDC losses (MW)'
2992    o_HVDChalfPoleLoss_TP(dt,ild)                       'Losses on HVDC half poles (MW)'
2993    o_HVDCpoleFixedLoss_TP(dt,ild)                      'Fixed loss on inter-island HVDC (MW)'
2994    o_busGeneration_TP(dt,b)                            'Output MW generation at each bus for the different time periods'
2995    o_busLoad_TP(dt,b)                                  'Output MW load at each bus for the different time periods'
2996    o_busPrice_TP(dt,b)                                 'Output $/MW price at each bus for the different time periods'
2997    o_busDisconnected_TP(dt,b)                          'Output disconnected bus flag (1 = Yes) for the different time periods'
2998    o_busRevenue_TP(dt,b)                               'Generation revenue ($) at each bus for the different time periods'
2999    o_busCost_TP(dt,b)                                  'Load cost ($) at each bus for the different time periods'
3000    o_busDeficit_TP(dt,b)                               'Bus deficit violation for each trade period'
3001    o_busSurplus_TP(dt,b)                               'Bus surplus violation for each trade period'
3002    o_branchFromBusPrice_TP(dt,br)                      'Output from bus price ($/MW) for branch reporting'
3003    o_branchToBusPrice_TP(dt,br)                        'Output to bus price ($/MW) for branch reporting'
3004    o_branchMarginalPrice_TP(dt,br)                     'Output marginal branch constraint price ($/MW) for branch reporting'
3005    o_branchFlow_TP(dt,br)                              'Output MW flow on each branch for the different time periods'
3006    o_branchDynamicLoss_TP(dt,br)                       'Output MW dynamic loss on each branch for the different time periods'
3007    o_branchTotalLoss_TP(dt,br)                         'Output MW total loss on each branch for the different time periods'
3008    o_branchFixedLoss_TP(dt,br)                         'Output MW fixed loss on each branch for the different time periods'
3009    o_branchTotalRentals_TP(dt,br)                      'Output $ rentals on transmission branches using total (dynamic + fixed) for the different time periods'
3010    o_branchCapacity_TP(dt,br)                          'Output MW branch capacity for branch reporting'
3011    o_ACbranchTotalRentals(dt)                          'Total AC rental by trading period for reporting'
3012    o_ACbranchLossMW(dt,br,los)                         'MW element of the loss segment curve in MW'
3013    o_ACbranchLossFactor(dt,br,los)                     'Loss factor element of the loss segment curve'
3014    o_offerEnergy_TP(dt,o)                              'Output MW cleared for each energy offer for each trade period'
3015    o_offerFIR_TP(dt,o)                                 'Output MW cleared for FIR for each trade period'
3016    o_offerSIR_TP(dt,o)                                 'Output MW cleared for SIR for each trade period'
3017    o_bidEnergy_TP(dt,bd)                               'Output MW cleared for each energy bid for each trade period'
3018    o_offerEnergyBlock_TP(dt,o,trdBlk)                  'Output MW cleared for each energy offer for each trade period'
3019    o_offerFIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for FIR for each trade period'
3020    o_offerSIRBlock_TP(dt,o,trdBlk,resT)                'Output MW cleared for SIR for each trade period'
3021    o_bidTotalMW_TP(dt,bd)                              'Output total MW bidded for each energy bid for each trade period'
3022    o_bidFIR_TP(dt,bd)                                  'Output MW cleared for FIR for each trade period'
3023    o_bidSIR_TP(dt,bd)                                  'Output MW cleared for SIR for each trade period'
3024    o_ReserveReqd_TP(dt,ild,resC)                       'Output MW required for each reserve class in each trade period'
3025    o_FIRreqd_TP(dt,ild)                                'Output MW required FIR for each trade period'
3026    o_SIRreqd_TP(dt,ild)                                'Output MW required SIR for each trade period'
3027    o_ResCleared_TP(dt,ild,resC)                        'Reserve cleared from an island for each trade period'
3028    o_FIRcleared_TP(dt,ild)                             'Output - total FIR cleared by island'
3029    o_SIRcleared_TP(dt,ild)                             'Output - total SIR cleared by island'
3030    o_ResPrice_TP(dt,ild,resC)                          'Output $/MW price for each reserve classes for each trade period'
3031    o_FIRprice_TP(dt,ild)                               'Output $/MW price for FIR reserve classes for each trade period'
3032    o_SIRprice_TP(dt,ild)                               'Output $/MW price for SIR reserve classes for each trade period'
3033    o_ResViolation_TP(dt,ild,resC)                      'Violation MW for each reserve classes for each trade period'
3034    o_FIRviolation_TP(dt,ild)                           'Violation MW for FIR reserve classes for each trade period'
3035    o_SIRviolation_TP(dt,ild)                           'Violation MW for SIR reserve classes for each trade period'
3036    o_nodeGeneration_TP(dt,n)                           'Ouput MW generation at each node for the different time periods'
3037    o_nodeLoad_TP(dt,n)                                 'Ouput MW load at each node for the different time periods'
3038    o_nodePrice_TP(dt,n)                                'Output $/MW price at each node for the different time periods'
3039    o_nodeRevenue_TP(dt,n)                              'Output $ revenue at each node for the different time periods'
3040    o_nodeCost_TP(dt,n)                                 'Output $ cost at each node for the different time periods'
3041    o_nodeDeficit_TP(dt,n)                              'Output node deficit violation for each trade period'
3042    o_nodeSurplus_TP(dt,n)                              'Output node surplus violation for each trade period'
3043  * Security constraint data
3044    o_brConstraintSense_TP(dt,brCstr)                   'Branch constraint sense for each output report'
3045    o_brConstraintLHS_TP(dt,brCstr)                     'Branch constraint LHS for each output report'
3046    o_brConstraintRHS_TP(dt,brCstr)                     'Branch constraint RHS for each output report'
3047    o_brConstraintPrice_TP(dt,brCstr)                   'Branch constraint price for each output report'
3048  * Mnode constraint data
3049    o_MnodeConstraintSense_TP(dt,MnodeCstr)             'Market node constraint sense for each output report'
3050    o_MnodeConstraintLHS_TP(dt,MnodeCstr)               'Market node constraint LHS for each output report'
3051    o_MnodeConstraintRHS_TP(dt,MnodeCstr)               'Market node constraint RHS for each output report'
3052    o_MnodeConstraintPrice_TP(dt,MnodeCstr)             'Market node constraint price for each output report'
3053  * TradePeriod summary report
3054    o_solveOK_TP(dt)                                    'Solve status for summary report (1=OK)'
3055    o_systemCost_TP(dt)                                 'System cost for summary report'
3056    o_systemBenefit_TP(dt)                              'System benefit of cleared bids for summary report'
3057    o_ofv_TP(dt)                                        'Objective function value for summary report'
3058    o_penaltyCost_TP(dt)                                'Penalty cost for summary report'
3059    o_defGenViolation_TP(dt)                            'Deficit generation violation for summary report'
3060    o_surpGenViolation_TP(dt)                           'Surplus generaiton violation for summary report'
3061    o_surpBranchFlow_TP(dt)                             'Surplus branch flow violation for summary report'
3062    o_defRampRate_TP(dt)                                'Deficit ramp rate violation for summary report'
3063    o_surpRampRate_TP(dt)                               'Surplus ramp rate violation for summary report'
3064    o_surpBranchGroupConst_TP(dt)                       'Surplus branch group constraint violation for summary report'
3065    o_defBranchGroupConst_TP(dt)                        'Deficit branch group constraint violation for summary report'
3066    o_defMnodeConst_TP(dt)                              'Deficit market node constraint violation for summary report'
3067    o_surpMnodeConst_TP(dt)                             'Surplus market node constraint violation for summary report'
3068    o_defACnodeConst_TP(dt)                             'Deficit AC node constraint violation for summary report'
3069    o_surpACnodeConst_TP(dt)                            'Surplus AC node constraint violation for summary report'
3070    o_defT1MixedConst_TP(dt)                            'Deficit Type1 mixed constraint violation for sumamry report'
3071    o_surpT1MixedConst_TP(dt)                           'Surplus Type1 mixed constraint violation for summary report'
3072    o_defGenericConst_TP(dt)                            'Deficit generic constraint violation for summary report'
3073    o_surpGenericConst_TP(dt)                           'Surplus generic constraint violation for summary report'
3074    o_defResv_TP(dt)                                    'Deficit reserve violation for summary report'
3075    o_totalViolation_TP(dt)                             'Total violation for datawarehouse summary report'
3076  * System level
3077    o_numTradePeriods                                   'Output number of trade periods in summary'
3078    o_systemOFV                                         'System objective function value'
3079    o_systemGen                                         'Output system MWh generation'
3080    o_systemLoad                                        'Output system MWh load'
3081    o_systemLoss                                        'Output system MWh loss'
3082    o_systemViolation                                   'Output system MWh violation'
3083    o_systemFIR                                         'Output system FIR MWh reserve'
3084    o_systemSIR                                         'Output system SIR MWh reserve'
3085    o_systemEnergyRevenue                               'Output offer energy revenue $'
3086    o_systemReserveRevenue                              'Output reserve revenue $'
3087    o_systemLoadCost                                    'Output system load cost $'
3088    o_systemLoadRevenue                                 'Output system load revenue $'
3089    o_systemSurplus                                     'Output system surplus $'
3090  * Offer level
3091    o_offerGen(o)                                       'Output offer generation (MWh)'
3092    o_offerFIR(o)                                       'Output offer FIR (MWh)'
3093    o_offerSIR(o)                                       'Output offer SIR (MWh)'
3094    o_offerGenRevenue(o)                                'Output offer energy revenue ($)'
3095    o_offerFIRrevenue(o)                                'Output offer FIR revenue ($)'
3096    o_offerSIRrevenue(o)                                'Output offer SIR revenue ($)'
3097  * Trader level
3098    o_traderGen(trdr)                                   'Output trader generation (MWh)'
3099    o_traderFIR(trdr)                                   'Output trader FIR (MWh)'
3100    o_traderSIR(trdr)                                   'Output trader SIR (MWh)'
3101    o_traderGenRevenue(trdr)                            'Output trader energy revenue ($)'
3102    o_traderFIRrevenue(trdr)                            'Output trader FIR revenue ($)'
3103    o_traderSIRrevenue(trdr)                            'Output trader SIR revenue ($)'
3104  * Factor to prorate the deficit and surplus at the nodal level
3105    totalBusAllocation(dt,b)                            'Total allocation of nodes to bus'
3106    busNodeAllocationFactor(dt,b,n)                     'Bus to node allocation factor'
3107  * Introduce i_useBusNetworkModel to account for MSP change-over date.
3108    i_useBusNetworkModel(tp)                            'Indicates if the post-MSP bus network model is used in vSPD (1 = Yes)'
3109  * Virtual reserve output
3110    o_vrResMW_TP(dt,ild,resC)                           'MW scheduled from virtual reserve resource'
3111    o_FIRvrMW_TP(dt,ild)                                'MW scheduled from virtual FIR resource'
3112    o_SIRvrMW_TP(dt,ild)                                'MW scheduled from virtual SIR resource'
3113  * Scarcity pricing output
3114    o_scarcityExists_TP(dt,ild)
3115    o_cptPassed_TP(dt,ild)
3116    o_avgPriorGWAP_TP(dt,ild)
3117    o_islandGWAPbefore_TP(dt,ild)
3118    o_islandGWAPafter_TP(dt,ild)
3119    o_scarcityGWAPbefore_TP(dt,ild)
3120    o_scarcityGWAPafter_TP(dt,ild)
3121    o_scarcityScalingFactor_TP(dt,ild)
3122    o_GWAPthreshold_TP(dt,ild)
3123    o_GWAPfloor_TP(dt,ild)
3124    o_GWAPceiling_TP(dt,ild)
3125  * Audit - extra output declaration
3126    o_lossSegmentBreakPoint(dt,br,los)                            'Audit - loss segment MW'
3127    o_lossSegmentFactor(dt,br,los)                                'Audit - loss factor of each loss segment'
3128    o_ACbusAngle(dt,b)                                            'Audit - bus voltage angle'
3129    o_nonPhysicalLoss(dt,br)                                      'Audit - non physical loss'
3130    o_ILRO_FIR_TP(dt,o)                                           'Audit - ILRO FIR offer cleared (MWh)'
3131    o_ILRO_SIR_TP(dt,o)                                           'Audit - ILRO SIR offer cleared (MWh)'
3132    o_ILbus_FIR_TP(dt,b)                                          'Audit - ILRO FIR cleared at bus (MWh)'
3133    o_ILbus_SIR_TP(dt,b)                                          'Audit - ILRO SIR cleared at bus (MWh)'
3134    o_PLRO_FIR_TP(dt,o)                                           'Audit - PLRO FIR offer cleared (MWh)'
3135    o_PLRO_SIR_TP(dt,o)                                           'Audit - PLRO SIR offer cleared (MWh)'
3136    o_TWRO_FIR_TP(dt,o)                                           'Audit - TWRO FIR offer cleared (MWh)'
3137    o_TWRO_SIR_TP(dt,o)                                           'Audit - TWRO SIR offer cleared (MWh)'
3138    o_generationRiskLevel(dt,ild,o,resC,riskC)                    'Audit - generation risk'
3139    o_generationRiskPrice(dt,ild,o,resC,riskC)                    'Audit - generation risk shadow price'
3140    o_HVDCriskLevel(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk'
3141    o_HVDCriskPrice(dt,ild,resC,riskC)                            'Audit - DCCE and DCECE risk shadow price'
3142    o_manuRiskLevel(dt,ild,resC,riskC)                            'Audit - manual risk'
3143    o_manuRiskPrice(dt,ild,resC,riskC)                            'Audit - manual risk shadow price'
3144    o_genHVDCriskLevel(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk'
3145    o_genHVDCriskPrice(dt,ild,o,resC,riskC)                       'Audit - generation + HVDC secondary risk shadow price'
3146    o_manuHVDCriskLevel(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary'
3147    o_manuHVDCriskPrice(dt,ild,resC,riskC)                        'Audit - manual + HVDC secondary shadow price'
3148    o_generationRiskGroupLevel(dt,ild,rg,resC,riskC)                 'Audit - generation group risk'
3149    o_generationRiskGroupPrice(dt,ild,rg,resC,riskC)                 'Audit - generation group risk shadow price'
3150  * TN - output parameters added for NMIR project --------------------------------
3151    o_FirSent_TP(dt,ild)                        'FIR export from an island for each trade period'
3152    o_SirSent_TP(dt,ild)                        'SIR export from an island for each trade period'
3153    o_FirReceived_TP(dt,ild)                    'FIR received at an island for each trade period'
3154    o_SirReceived_TP(dt,ild)                    'SIR received at an island for each trade period'
3155    o_FirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3156    o_SirEffReport_TP(dt,ild)                   'Effective FIR share for reporting to an island for each trade period'
3157    o_EffectiveRes_TP(dt,ild,resC,riskC)        'Effective reserve share to an island for each trade period'
3158    o_FirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3159    o_SirEffective_TP(dt,ild,riskC)             'Effective FIR share to an island for each trade period'
3160  * TN - output parameters added for NMIR project end ----------------------------
3161    ;
3162   
3163  Scalars
3164    modelSolved                   'Flag to indicate if the model solved successfully (1 = Yes)'                                           / 0 /
3165    LPmodelSolved                 'Flag to indicate if the final LP model (when MIP fails) is solved successfully (1 = Yes)'              / 0 /
3166  * Flag to use the extended set of risk classes which include the GENRISK_ECE and Manual_ECE
3167    useExtendedRiskClass          'Use the extended set of risk classes (1 = Yes)'                                                        / 0 /
3168  * Scarcity pricing
3169    scarcityExists                'Flag to indicate that a scarcity situation exists for at least 1 trading period in the solve'
3170    exitLoop                      'Flag to exit solve loop'                                                                               / 0 /
3171    ;
3172   
3173   
3174   
3175  *=====================================================================================
3176  * 2. Load data from GDX file
3177  *=====================================================================================
3178   
3179  * If input file does not exist then go to the next input file
3181   
3182  * Load trading period to be solved
3183  * If scarcity pricing situation exists --> load and solve all trading periods
GDXIN   C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
--- LOAD  i_tradePeriod = 1:i_TradePeriod
--- LOAD  i_dateTime = 2:i_DateTime
3189   
3190   
3191  * Call the GDX routine and load the input data:
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
3193  * Sets
--- LOAD  i_offer = 84:i_Offer
--- LOAD  i_trader = 83:i_Trader
--- LOAD  i_bid = 101:i_bid
--- LOAD  i_node = 15:i_node
--- LOAD  i_bus = 16:i_bus
--- LOAD  i_branch = 32:i_branch
--- LOAD  i_branchConstraint = 42:i_branchConstraint
--- LOAD  i_ACnodeConstraint = 45:i_ACnodeConstraint
--- LOAD  i_MnodeConstraint = 48:i_MnodeConstraint
--- LOAD  i_genericConstraint = 54:i_genericConstraint
--- LOAD  i_type1MixedConstraint = 63:i_type1MixedConstraint
--- LOAD  i_type2MixedConstraint = 78:i_type2MixedConstraint
--- LOAD  i_dateTimeTradePeriodMap = 7:i_dateTimeTradePeriodMap
--- LOAD  i_tradePeriodOfferTrader = 90:i_tradePeriodOfferTrader
--- LOAD  i_tradePeriodOfferNode = 91:i_tradePeriodOfferNode
--- LOAD  i_tradePeriodBidTrader = 104:i_tradePeriodBidTrader
--- LOAD  i_tradePeriodBidNode = 105:i_tradePeriodBidNode
--- LOAD  i_tradePeriodNode = 17:i_tradePeriodNode
--- LOAD  i_tradePeriodBusIsland = 19:i_tradePeriodBusIsland
--- LOAD  i_tradePeriodBus = 18:i_tradePeriodBus
--- LOAD  i_tradePeriodNodeBus = 20:i_tradePeriodNodeBus
--- LOAD  i_tradePeriodBranchDefn = 33:i_tradePeriodBranchDefn
--- LOAD  i_tradePeriodRiskGenerator = 115:i_tradePeriodRiskGenerator
--- LOAD  i_type1MixedConstraintReserveMap = 64:i_type1MixedConstraintReserveMap
--- LOAD  i_tradePeriodType1MixedConstraint = 65:i_tradePeriodType1MixedConstraint
--- LOAD  i_tradePeriodType2MixedConstraint = 79:i_tradePeriodType2MixedConstraint
--- LOAD  i_type1MixedConstraintBranchCondition = 66:i_type1MixedConstraintBranchCondition
--- LOAD  i_tradePeriodGenericConstraint = 55:i_tradePeriodGenericConstraint
3200  * Parameters
--- LOAD  i_day = 2:i_day
--- LOAD  i_month = 3:i_month
--- LOAD  i_year = 4:i_year
--- LOAD  i_tradingPeriodLength = 10:i_tradingPeriodLength
--- LOAD  i_AClineUnit = 9:i_AClineUnit
--- MERGE i_branchReceivingEndLossProportion = 11:i_branchReceivingEndLossProportion
--- LOAD  i_StudyTradePeriod = 8:i_studyTradePeriod
--- LOAD  i_CVPvalues = 13:i_CVPvalues
--- LOAD  i_tradePeriodOfferParameter = 92:i_tradePeriodOfferParameter
--- LOAD  i_tradePeriodEnergyOffer = 93:i_tradePeriodEnergyOffer
--- LOAD  i_tradePeriodSustainedPLSRoffer = 94:i_tradePeriodSustainedPLSRoffer
--- LOAD  i_tradePeriodFastPLSRoffer = 95:i_tradePeriodFastPLSRoffer
--- LOAD  i_tradePeriodSustainedTWDRoffer = 96:i_tradePeriodSustainedTWDRoffer
--- LOAD  i_tradePeriodFastTWDRoffer = 97:i_tradePeriodFastTWDRoffer
--- LOAD  i_tradePeriodSustainedILRoffer = 98:i_tradePeriodSustainedILRoffer
--- LOAD  i_tradePeriodFastILRoffer = 99:i_tradePeriodFastILRoffer
--- LOAD  i_tradePeriodEnergyBid = 106:i_tradePeriodEnergyBid
--- LOAD  i_tradePeriodSustainedILRbid = 107:i_tradePeriodSustainedILRbid
--- LOAD  i_tradePeriodFastILRbid = 108:i_tradePeriodFastILRbid
--- LOAD  i_tradePeriodHVDCNode = 23:i_tradePeriodHVDCNode
--- LOAD  i_tradePeriodReferenceNode = 24:i_tradePeriodReferenceNode
--- LOAD  i_tradePeriodHVDCBranch = 34:i_tradePeriodHVDCBranch
--- LOAD  i_tradePeriodBranchParameter = 35:i_tradePeriodBranchParameter
--- LOAD  i_tradePeriodBranchCapacity = 36:i_tradePeriodBranchCapacity
--- LOAD  i_tradePeriodBranchOpenStatus = 38:i_tradePeriodBranchOpenStatus
--- LOAD  i_noLossBranch = 27:i_noLossBranch
--- LOAD  i_AClossBranch = 28:i_ACLossBranch
--- LOAD  i_HVDClossBranch = 29:i_HVDCLossBranch
--- LOAD  i_tradePeriodNodeBusAllocationFactor = 21:i_tradePeriodNodeBusAllocationFactor
--- LOAD  i_tradePeriodBusElectricalIsland = 22:i_tradePeriodBusElectricalIsland
--- LOAD  i_tradePeriodRiskParameter = 116:i_tradePeriodRiskParameter
--- LOAD  i_tradePeriodManualRisk = 117:i_tradePeriodManualRisk
--- LOAD  i_tradePeriodBranchConstraintFactors = 43:i_tradePeriodBranchConstraintFactors
--- LOAD  i_tradePeriodBranchConstraintRHS = 44:i_tradePeriodBranchConstraintRHS
--- LOAD  i_tradePeriodACnodeConstraintFactors = 46:i_tradePeriodACnodeConstraintFactors
--- LOAD  i_tradePeriodACnodeConstraintRHS = 47:i_tradePeriodACnodeConstraintRHS
--- LOAD  i_tradePeriodMNodeEnergyOfferConstraintFactors = 49:i_tradePeriodMNodeEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeReserveOfferConstraintFactors = 50:i_tradePeriodMNodeReserveOfferConstraintFactors
--- LOAD  i_tradePeriodMNodeEnergyBidConstraintFactors = 51:i_tradePeriodMNodeEnergyBidConstraintFactors
--- LOAD  i_tradePeriodMNodeILReserveBidConstraintFactors = 52:i_tradePeriodMNodeILReserveBidConstraintFactors
--- LOAD  i_tradePeriodMNodeConstraintRHS = 53:i_tradePeriodMNodeConstraintRHS
--- LOAD  i_type1MixedConstraintVarWeight = 67:i_type1MixedConstraintVarWeight
--- LOAD  i_type1MixedConstraintGenWeight = 69:i_type1MixedConstraintGenWeight
--- LOAD  i_type1MixedConstraintResWeight = 70:i_type1MixedConstraintResWeight
--- LOAD  i_type1MixedConstraintHVDClineWeight = 71:i_type1MixedConstraintHVDClineWeight
--- LOAD  i_tradePeriodType1MixedConstraintRHSParameters = 72:i_tradePeriodType1MixedConstraintRHSParameters
--- LOAD  i_type2MixedConstraintLHSParameters = 80:i_type2MixedConstraintLHSParameters
--- LOAD  i_tradePeriodType2MixedConstraintRHSParameters = 81:i_tradePeriodType2MixedConstraintRHSParameters
--- LOAD  i_tradePeriodGenericEnergyOfferConstraintFactors = 56:i_tradePeriodGenericEnergyOfferConstraintFactors
--- LOAD  i_tradePeriodGenericReserveOfferConstraintFactors = 57:i_tradePeriodGenericReserveOfferConstraintFactors
--- LOAD  i_tradePeriodGenericEnergyBidConstraintFactors = 58:i_tradePeriodGenericEnergyBidConstraintFactors
--- LOAD  i_tradePeriodGenericILReserveBidConstraintFactors = 59:i_tradePeriodGenericILReserveBidConstraintFactors
--- LOAD  i_tradePeriodGenericBranchConstraintFactors = 60:i_tradePeriodGenericBranchConstraintFactors
--- LOAD  i_tradePeriodGenericConstraintRHS = 61:i_tradePeriodGenericConstraintRHS
3214   
3215  * New risk group sets
GDXIN   C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
--- LOAD  i_riskGroup = 147:i_riskGroup
--- LOAD  riskGroupOffer = 145:i_tradePeriodRiskGroup
3221   
3222   
3223  *=====================================================================================
3224  * 3. Manage model and data compatability
3225  *=====================================================================================
3226   
3227  * This section manages the changes to model flags to ensure backward compatibility
3228  * given changes in the SPD model formulation over time:
3229  * - some data loading from GDX file is conditioned on inclusion date of symbol in question
3230  * - data symbols below are loaded at execution time whereas the main load above is at compile time.
3231   
3232  * Gregorian date of when symbols have been included into the GDX files and therefore conditionally loaded
3233  Scalars inputGDXGDate                     'Gregorian date of input GDX file' ;
3234   
3235  * Calculate the Gregorian date of the input data
3236  inputGDXGDate = jdate(i_year,i_month,i_day) ;
3237   
3238  * Introduce i_useBusNetworkModel to account for MSP change-over date when for
3239  * half of the day the old market node model and the other half the bus network
3240  * model was used. The old model does not have the i_tradePeriodBusElectrical
3241  * island paramter specified since it uses the market node network model.
3242  * This flag is introduced to allow the i_tradePeriodBusElectricalIsland parameter
3243  * to be used in the post-MSP solves to indentify 'dead' electrical buses.
3244  * MSP change over from mid-day on 21 Jul 2009
3245  i_useBusNetworkModel(tp) = 1 $ { ( inputGDXGDate >= jdate(2009,7,21) ) and
3246                                   sum[ b, i_tradePeriodBusElectricalIsland(tp,b) ]
3247                                 } ;
3248   
3249  * Switch off the mixed constraint based risk offset calculation after 17 October 2011
3250  useMixedConstraintRiskOffset = 1 $ { inputGDXGDate < jdate(2011,10,17) } ;
3251   
3252  * Switch off mixed constraint formulation if no data coming through
3253  * or mixed constraint is suppressed manually in vSPDsetting.inc
3254  useMixedConstraint(tp)
3255      = 1 $ { sum[t1MixCstr$i_tradePeriodType1MixedConstraint(tp,t1MixCstr), 1]
3256          and (suppressMixedConstraint = 0) } ;
3257   
3258  put_utility temp 'gdxin' / 'C:\vSPD\GitHub\Programs\..\Input\\RTD_20211202_RTP.gdx' ;
3259   
3260  * Primary secondary offer in use from 01 May 2012'
3261  if(inputGDXGDate >= jdate(2012,05,01),
3262      execute_load i_tradePeriodPrimarySecondaryOffer ;
3263  else
3264      i_tradePeriodPrimarySecondaryOffer(tp,o,o1) = no ;
3265  ) ;
3266   
3267  * Change to demand bid on 28 Jun 2012
3268  useDSBFDemandBidModel = 1 $ { inputGDXGDate >= jdate(2012,6,28) } ;
3269   
3270  * Manual ECE risk parameters in use from 20 Sep 2012
3271  if(inputGDXGDate >= jdate(2012,9,20),
3272      execute_load i_tradePeriodManualRisk_ECE ;
3273  else
3274      i_tradePeriodManualRisk_ECE(tp,ild,resC) = 0 ;
3275  ) ;
3276   
3277  * HVDC secondary risk parameters in use from 20 Sep 2012
3278  if(inputGDXGDate >= jdate(2012,9,20),
3279      execute_load i_tradePeriodHVDCsecRiskEnabled
3280                   i_tradePeriodHVDCsecRiskSubtractor ;
3281  else
3282      i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC) = 0 ;
3283      i_tradePeriodHVDCsecRiskSubtractor(tp,ild) = 0 ;
3284  ) ;
3285   
3286  * Do not use the extended risk class if no data coming through
3287  useExtendedRiskClass
3288      = 1 $ { sum[ (tp,ild,resC,riskC,riskPar) $ (ord(riskC) > 4)
3289                 , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] };
3290   
3291  * HVDC round power mode in use from 20 Sep 2012
3292  if(inputGDXGDate >= jdate(2012,9,20),
3293      execute_load i_tradePeriodAllowHVDCroundpower ;
3294  else
3295      i_tradePeriodAllowHVDCroundpower(tp) = 0 ;
3296  ) ;
3297   
3298  * Additional mixed constraint parameters exist from 24 Feb 2013
3299   
3300  if(inputGDXGDate >= jdate(2013,2,24),
3301      execute_load i_type1MixedConstraintAClineWeight
3302                   i_type1MixedConstraintAClineLossWeight
3303                   i_type1MixedConstraintAClineFixedLossWeight
3304                   i_type1MixedConstraintHVDClineLossWeight
3305                   i_type1MixedConstraintHVDClineFixedLossWeight
3306                   i_type1MixedConstraintPurWeight ;
3307  else
3308      i_type1MixedConstraintAClineWeight(t1MixCstr,br) = 0 ;
3309      i_type1MixedConstraintAClineLossWeight(t1MixCstr,br) = 0 ;
3310      i_type1MixedConstraintAClineFixedLossWeight(t1MixCstr,br) = 0 ;
3311      i_type1MixedConstraintHVDClineLossWeight(t1MixCstr,br) = 0 ;
3312      i_type1MixedConstraintHVDClineFixedLossWeight(t1MixCstr,br) = 0 ;
3313      i_type1MixedConstraintPurWeight(t1MixCstr,bd) = 0 ;
3314  ) ;
3315   
3316  *  Reserve class generation parameter in use from 24 Feb 2013
3317  if(inputGDXGDate >= jdate(2013,2,24),
3318      execute_load i_tradePeriodReserveClassGenerationMaximum ;
3319  else
3320      i_tradePeriodReserveClassGenerationMaximum(tp,o,resC) = 0 ;
3321  ) ;
3322   
3323  * Primary secondary risk model in use from 24 Feb 2013
3324  usePrimSecGenRiskModel = 1 $ { inputGDXGDate >= jdate(2013,2,24) } ;
3325   
3326  * Dispatchable Demand effective date 20 May 2014
3327  if(inputGDXGDate >= jdate(2014,5,20),
3328      execute_load i_tradePeriodDispatchableBid;
3329  else
3330      i_tradePeriodDispatchableBid(tp,bd) =  Yes $ useDSBFDemandBidModel ;
3331  ) ;
3332  * MODD modification end
3333   
3334  * Scarcity pricing scheme for reserve available from 27 May 2014
3335  if(inputGDXGDate >= jdate(2014,5,27),
3336      execute_load i_tradePeriodVROfferMax, i_tradePeriodVROfferPrice ;
3337  else
3338      i_tradePeriodVROfferMax(tp,ild,resC) = 0 ;
3339      i_tradePeriodVROfferPrice(tp,ild,resC) = 0 ;
3340  ) ;
3341   
3342   
3343  * National market for IR effective date 20 Oct 2016
3344  if (inputGDXGDate >= jdate(2016,10,20),
3345      execute_load
3346      reserveRoundPower     = i_tradePeriodReserveRoundPower
3347      reserveShareEnabled   = i_tradePeriodReserveSharing
3348      modulationRiskClass   = i_tradePeriodModulationRisk
3349      roundPower2MonoLevel  = i_tradePeriodRoundPower2Mono
3350      bipole2MonoLevel      = i_tradePeriodBipole2Mono
3351      monopoleMinimum       = i_tradePeriodReserveSharingPoleMin
3352      HVDCControlBand       = i_tradePeriodHVDCcontrolBand
3353      HVDClossScalingFactor = i_tradePeriodHVDClossScalingFactor
3354      sharedNFRfactor       = i_tradePeriodSharedNFRfactor
3355      sharedNFRLoadOffset   = i_tradePeriodSharedNFRLoadOffset
3356      effectiveFactor       = i_tradePeriodReserveEffectiveFactor
3357      RMTreserveLimitTo     = i_tradePeriodRMTreserveLimit
3358      rampingConstraint     = i_tradePeriodRampingConstraint
3359    ;
3360  else
3361      reserveRoundPower(tp,resC)         = 0    ;
3362      reserveShareEnabled(tp,resC)       = 0    ;
3363      modulationRiskClass(tp,riskC)      = 0    ;
3364      roundPower2MonoLevel(tp)           = 0    ;
3365      bipole2MonoLevel(tp)               = 0    ;
3366      MonopoleMinimum(tp)                = 0    ;
3367      HVDCControlBand(tp,fd)             = 0    ;
3368      HVDClossScalingFactor(tp)          = 0    ;
3369      sharedNFRfactor(tp)                = 0    ;
3370      sharedNFRloadOffset(tp,ild)        = 0    ;
3371      effectiveFactor(tp,ild,resC,riskC) = 0    ;
3372      RMTreserveLimitTo(tp,ild,resC)     = 0    ;
3373      rampingConstraint(tp,brCstr)       = no   ;
3374  ) ;
3375   
3376  UseShareReserve = 1 $ sum[ (tp,resC), reserveShareEnabled(tp,resC)] ;
3377   
3378  * Branch Reverse Ratings planned to go-live on 03/Feb/2021 (this will be flagged in GDX using i_tradePeriodReverseRatingsApplied)
3379  * From 11 Dec 2020, GDX file will have i_tradePeriodBranchCapacityDirected and i_tradePeriodReverseRatingsApplied symbols
3380  if (inputGDXGDate >= jdate(2020,12,11),
3381      execute_load i_tradePeriodBranchCapacityDirected;
3382      execute_load reverseRatingsApplied = i_tradePeriodReverseRatingsApplied;
3383   
3384      i_tradePeriodBranchCapacityDirected(tp,br,'backward') $ (reverseRatingsApplied(tp)=0)
3385          = i_tradePeriodBranchCapacityDirected(tp,br,'forward');
3386   
3387  else
3388      i_tradePeriodBranchCapacityDirected(tp,br,fd)
3389          = i_tradePeriodBranchCapacity(tp,br) ;
3390  ) ;
3391   
3392   
3393  * Real Time Pricing phase 2 planned to go live on 22 March 2022
3394  * From 1 March 2022, GDX file will have following symbols
3395  inputGDXGDate =  jdate(2022,4,1);
3396  if (inputGDXGDate >= jdate(2022,3,1),
3397      execute_load
3398      studyMode                   = i_studyMode
3399      useGenInitialMW             = i_useGenInitialMW
3400      runEnrgShortfallTransfer    = i_runEnrgShortfallTransfer
3401      runPriceTransfer            = i_runPriceTransfer
3402      InputInitialLoad            = i_tradePeriodInputInitialLoad
3403      LoadIsOverride              = i_tradePeriodLoadIsOverride
3404      LoadIsBad                   = i_tradePeriodLoadIsBad
3405      LoadIsNCL                   = i_tradePeriodLoadIsNCL
3406      ConformingFactor            = i_tradePeriodConformingFactor
3407      NonConformingLoad           = i_tradePeriodNonConformingLoad
3408      MaxLoad                     = i_tradePeriodMaxLoad
3409   
3410      useActualLoad               = i_useActualLoad
3411      dontScaleNegativeLoad       = i_dontScaleNegativeLoad
3412   
3413      islandMWIPS                 = i_tradePeriodIslandMWIPS
3414      islandPDS                   = i_tradePeriodIslandPDS
3415      islandLosses                = i_tradePeriodIslandLosses
3416   
3417      energyScarcityEnabled       = i_energyScarcityEnabled
3418      reserveScarcityEnabled      = i_reserveScarcityEnabled
3419      scarcityEnrgNationalFactor  = i_tradePeriodScarcityEnrgNationalFactor
3420      scarcityEnrgNationalPrice   = i_tradePeriodScarcityEnrgNationalPrice
3421      scarcityEnrgNodeFactor      = i_tradePeriodScarcityEnrgNodeFactor
3422      scarcityEnrgNodeFactorPrice = i_tradePeriodScarcityEnrgNodeFactorPrice
3423      scarcityEnrgNodeLimit       = i_tradePeriodScarcityEnrgNodeLimit
3424      scarcityEnrgNodeLimitPrice  = i_tradePeriodScarcityEnrgNodeLimitPrice
3425      scarcityResrvIslandLimit    = i_tradePeriodScarcityResrvIslandLimit
3426      scarcityResrvIslandPrice    = i_tradePeriodScarcityResrvIslandPrice
3427      ;
3428   
3429      i_tradePeriodNodeDemand(tp,n) = InputInitialLoad(tp,n);
3430      i_tradePeriodNodeDemand(tp,n) $ LoadIsBad(tp,n) = ConformingFactor(tp,n);
3431  else
3432      studyMode                                  = 111 ;
3433   
3434      islandMWIPS(tp,ild)                          = 0 ;
3435      islandPDS(tp,ild)                            = 0 ;
3436      islandLosses(tp,ild)                         = 0 ;
3437      dontScaleNegativeLoad(tp)                    = 0 ;
3438      energyScarcityEnabled(tp)                    = 0 ;
3439      reserveScarcityEnabled(tp)                   = 0 ;
3440      scarcityEnrgNationalFactor(tp,trdBlk)        = 0 ;
3441      scarcityEnrgNationalPrice(tp,trdBlk)         = 0 ;
3442      scarcityEnrgNodeFactor(tp,n,trdBlk)          = 0 ;
3443      scarcityEnrgNodeFactorPrice(tp,n,trdBlk)     = 0 ;
3444      scarcityEnrgNodeLimit(tp,n,trdBlk)           = 0 ;
3445      scarcityEnrgNodeLimitPrice(tp,n,trdBlk)      = 0 ;
3446      scarcityResrvIslandLimit(tp,ild,resC,trdBlk) = 0 ;
3447      scarcityResrvIslandPrice(tp,ild,resC,trdBlk) = 0 ;
3448  ) ;
3449   
3450   
3451   
3452  *=====================================================================================
3453  * 4. Input data overrides - declare and apply (include vSPDoverrides.gms)
3454  *=====================================================================================
3455   
       - At this point, vSPDoverrides.gms is included into vSPDsolve.gms if an override
         file defined by the $setglobal vSPDinputOvrdData in vSPDSetting.inc exists.
       - All override data symbols have the characters 'Ovrd' appended to the original
         symbol name. After declaring the override symbols, the override data is
         installed and the original symbols are overwritten.
       - Note that the Excel interface permits a limited number of input data symbols
         to be overridden. The EMI interface will create a GDX file of override values
         for all data inputs to be overridden. If operating in standalone mode,
         overrides can be installed by any means the user prefers - GDX file, $include
         file, hard-coding, etc. But it probably makes sense to mimic the GDX file as
         used by EMI.
3469   
3471   
3472   
3473  *=====================================================================================
3474  * 5. Initialise constraint violation penalties (CVPs)
3475  *=====================================================================================
3476   
3477  Scalar CVPchangeGDate 'Gregorian date of CE and ECE CVP change' ;
3478  * Calculate the Gregorian date of the CE and ECE change
3479  * Based on CAN from www.systemoperator.co.nz this was on 24th June 2010
3480  CVPchangeGDate = jdate(2010,06,24) ;
3481   
3482  * Set the flag for the application of the different CVPs for CE and ECE
3483  * If the user selects No (0), this default value of the diffCeECeCVP flag will be used.
3484  diffCeECeCVP = 0 ;
3485  * If the user selects Auto (-1), set the diffCeECeCVP flag if the input date is greater than or equal to this date
3486  diffCeECeCVP $ { (inputGDXGDate >= CVPchangeGDate) and (-1 = -1) } = 1 ;
3487  * If the user selects Yes (1), set the diffCeECeCVP flag
3488  diffCeECeCVP $ (-1 = 1) = 1 ;
3489   
3490  deficitBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 1), i_CVPvalues(i_CVP)) ;
3491  surplusBusGenerationPenalty                       = sum(i_CVP$(ord(i_CVP) = 2), i_CVPvalues(i_CVP)) ;
3492  deficitReservePenalty(resC) $ (ord(resC) = 1)     = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3493  deficitReservePenalty(resC) $ (ord(resC) = 2)     = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3494  deficitBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 5), i_CVPvalues(i_CVP)) ;
3495  surplusBrCstrPenalty                              = sum(i_CVP$(ord(i_CVP) = 6), i_CVPvalues(i_CVP)) ;
3496  deficitGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 7), i_CVPvalues(i_CVP)) ;
3497  surplusGnrcCstrPenalty                            = sum(i_CVP$(ord(i_CVP) = 8), i_CVPvalues(i_CVP)) ;
3498  deficitRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 9), i_CVPvalues(i_CVP)) ;
3499  surplusRampRatePenalty                            = sum(i_CVP$(ord(i_CVP) = 10), i_CVPvalues(i_CVP)) ;
3500  deficitACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 11), i_CVPvalues(i_CVP)) ;
3501  surplusACnodeCstrPenalty                          = sum(i_CVP$(ord(i_CVP) = 12), i_CVPvalues(i_CVP)) ;
3502  deficitBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 13), i_CVPvalues(i_CVP)) ;
3503  surplusBranchFlowPenalty                          = sum(i_CVP$(ord(i_CVP) = 14), i_CVPvalues(i_CVP)) ;
3504  deficitMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 15), i_CVPvalues(i_CVP)) ;
3505  surplusMnodeCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 16), i_CVPvalues(i_CVP)) ;
3506  deficitT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 17), i_CVPvalues(i_CVP)) ;
3507  surplusT1MixCstrPenalty                           = sum(i_CVP$(ord(i_CVP) = 18), i_CVPvalues(i_CVP)) ;
3508  * Different CVPs defined for CE and ECE
3509  deficitReservePenalty_CE(resC) $ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 3), i_CVPvalues(i_CVP)) ;
3510  deficitReservePenalty_CE(resC) $ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 4), i_CVPvalues(i_CVP)) ;
3511  deficitReservePenalty_ECE(resC)$ (ord(resC) = 1)  = sum(i_CVP$(ord(i_CVP) = 19), i_CVPvalues(i_CVP)) ;
3512  deficitReservePenalty_ECE(resC)$ (ord(resC) = 2)  = sum(i_CVP$(ord(i_CVP) = 20), i_CVPvalues(i_CVP)) ;
3513   
3514  *=====================================================================================
3515  * 6. Initialise model mapping and inputs
3516  *=====================================================================================
3517   
3518  * Pre-dispatch schedule is solved sequentially
3519  sequentialSolve
3520      $ ( sum[ (tp,o,offerPar) $ {(ord(tp) = 2) and (ord(offerPar) = 1)}
3521                               , i_tradePeriodOfferParameter(tp,o,offerPar) ] = 0
3522        ) = 1 ;
3523   
3524  sequentialSolve $ UseShareReserve = 1;
3525   
3526  * Initialise bus, node, offer, bid for the current trade period start
3527  bus(tp,b)  $ i_tradePeriodBus(tp,b)  = yes  ;
3528  node(tp,n) $ i_tradePeriodNode(tp,n) = yes  ;
3529   
3530  * Initialise network sets for the current trade period start
3531  nodeBus(node,b)     $ i_tradePeriodNodeBus(node,b)        = yes ;
3532  HVDCnode(node)      $ i_tradePeriodHVDCnode(node)         = yes ;
3533  ACnode(node)        $ ( not HVDCnode(node))               = yes ;
3534  referenceNode(node) $ i_tradePeriodReferenceNode(node)    = yes ;
3535  DCbus(tp,b)         $ sum[ nodeBus(HVDCnode(tp,n),b), 1 ] = yes ;
3536  ACbus(tp,b)         $ ( not DCbus(tp,b) )                 = yes ;
3537   
3538  * Bus live island status
3539  busElectricalIsland(bus) = i_tradePeriodBusElectricalIsland(bus) ;
3540   
3541  * Offer initialisation - offer must be mapped to a node that is mapped to a
3542  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3543  offer(tp,o) $ sum[ (n,b) $ { i_tradePeriodOfferNode(tp,o,n) and
3544                               nodeBus(tp,n,b) and
3545                               ( (not i_useBusNetworkModel(tp)) or
3546                                 busElectricalIsland(tp,b))
3547                             }, 1 ] = yes ;
3548   
3549  * IL offer mapped to a node that is mapped to a bus always valid
3550  * (updated on 23 July 2015 based on an email from SO Bennet Tucker on 21 July 2015))
3551  offer(tp,o)
3552      $ sum[ (n,b)
3553           $ { i_tradePeriodOfferNode(tp,o,n) and nodeBus(tp,n,b)
3554           and sum[ (trdBlk,ILofrCmpnt)
3555                  , i_tradePeriodFastILRoffer(tp,o,trdBlk,ILofrCmpnt)
3556                  + i_tradePeriodSustainedILRoffer(tp,o,trdBlk,ILofrCmpnt) ]
3557             }, 1 ] = yes ;
3558   
3559  * Bid initialisation - bid must be mapped to a node that is mapped to a bus
3560  * bus that is not in electrical island = 0 if i_useBusNetworkModel flag is 1
3561  bid(tp,bd) $ sum[ (n,b) $ { i_tradePeriodBidNode(tp,bd,n) and
3562                              nodeBus(tp,n,b) and
3563                              ( (not i_useBusNetworkModel(tp)) or
3564                                busElectricalIsland(tp,b) )
3565                            }, 1 ] = yes ;
3566   
3567  * Initialise Risk/Reserve data for the current trading period
3568  RiskGenerator(offer) $ i_tradePeriodRiskGenerator(offer) = yes ;
3569   
3570  * Mapping bus, node, offer, bid and island start for the current trade period
3571  offerNode(offer,n)   $ i_tradePeriodOfferNode(offer,n)                 = yes ;
3572  bidNode(bid,n)       $ i_tradePeriodBidNode(bid,n)                     = yes ;
3573  busIsland(bus,ild)   $ i_tradePeriodBusIsland(bus,ild)                 = yes ;
3574  nodeIsland(tp,n,ild) $ sum[ b $ { bus(tp,b) and node(tp,n)
3575                                and nodeBus(tp,n,b)
3576                                and busIsland(tp,b,ild) }, 1 ]           = yes ;
3577  offerIsland(offer(tp,o),ild)
3578      $ sum[ n $ { offerNode(tp,o,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3579  bidIsland(bid(tp,bd),ild)
3580      $ sum[ n $ { bidNode(tp,bd,n) and nodeIsland(tp,n,ild) }, 1 ] = yes ;
3581   
3582  IslandRiskGenerator(tp,ild,o)
3583      $ { offerIsland(tp,o,ild) and RiskGenerator(tp,o) } = yes ;
3584   
3585  * Set the primary-secondary offer combinations
3586  primarySecondaryOffer(offer,o1) = i_tradePeriodPrimarySecondaryOffer(offer,o1) ;
3587   
3588  * Identification of primary and secondary units
3589  hasSecondaryOffer(tp,o) = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o,o1), 1 ] ;
3590  hasPrimaryOffer(tp,o)   = 1 $ sum[ o1 $ primarySecondaryOffer(tp,o1,o), 1 ];
3591   
3592  * Initialise offer parameters for the current trade period start
3593  generationStart(offer(tp,o))
3594      = sum[ offerPar $ ( ord(offerPar) = 1 )
3595                      , i_tradePeriodOfferParameter(tp,o,offerPar)
3596                      + sum[ o1 $ primarySecondaryOffer(tp,o,o1)
3597                                ,i_tradePeriodOfferParameter(tp,o1,offerPar) ]
3598           ];
3599   
3600  rampRateUp(offer)
3601      = sum[ offerPar $ ( ord(offerPar) = 2 )
3602                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3603  rampRateDown(offer)
3604      = sum[ offerPar $ ( ord(offerPar) = 3 )
3605                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3606  reserveGenerationMaximum(offer)
3607      = sum[ offerPar $ ( ord(offerPar) = 4 )
3608                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3609  windOffer(offer)
3610      = sum[ offerPar $ ( ord(offerPar) = 5 )
3611                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3612  FKband(offer)
3613      = sum[ offerPar $ ( ord(offerPar) = 6 )
3614                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3615   
3616  priceResponsive(offer)
3617      = sum[ offerPar $ ( ord(offerPar) = 7 )
3618                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3619   
3620  potentialMW(offer)
3621      = sum[ offerPar $ ( ord(offerPar) = 8 )
3622                      , i_tradePeriodOfferParameter(offer,offerPar) ] ;
3623   
3624   
3625  * Initialise energy offer data for the current trade period start
3626  generationOfferMW(offer,trdBlk)
3627      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 1 )
3628                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3629  generationOfferPrice(offer,trdBlk)
3630      = sum[ NRGofrCmpnt $ ( ord(NRGofrCmpnt) = 2 )
3631                         , i_tradePeriodEnergyOffer(offer,trdBlk,NRGofrCmpnt) ] ;
3632   
3633  * Valid generation offer blocks are defined as those with a positive block limit
3634  validGenerationOfferBlock(offer,trdBlk)
3635      $ ( generationOfferMW(offer,trdBlk) > 0 ) = yes ;
3636   
3637  * Define set of positive energy offers
3638  positiveEnergyOffer(offer)
3639      $ sum[ trdBlk $ validGenerationOfferBlock(offer,trdBlk), 1 ] = yes ;
3640   
3641  * Initialise reserve offer data for the current trade period start
3642  PLSRReserveType(resT) $ (ord(resT) = 1) = yes ;
3643  TWDRReserveType(resT) $ (ord(resT) = 2) = yes ;
3644  ILReserveType(resT)   $ (ord(resT) = 3) = yes ;
3645   
3646  reserveOfferProportion(offer,trdBlk,resC)
3647      $ ( ord(resC) = 1 )
3648      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3649           , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3650   
3651  reserveOfferProportion(offer,trdBlk,resC)
3652      $ ( ord(resC) = 2 )
3653      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 1 )
3654           , i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt) / 100 ] ;
3655   
3656  reserveOfferMaximum(offer(tp,o),trdBlk,resC,PLSRReserveType)
3657      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 2 )
3658      , i_tradePeriodFastPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3659      + i_tradePeriodSustainedPLSRoffer(tp,o,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3660   
3661  reserveOfferMaximum(offer(tp,o),trdBlk,resC,TWDRReserveType)
3662      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 1 )
3663      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3664      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3665   
3666  reserveOfferMaximum(offer,trdBlk,resC,ILReserveType)
3667      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 1 )
3668      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3669      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ];
3670   
3671  reserveOfferPrice(offer,trdBlk,resC,PLSRReserveType)
3672      = sum[ PLSofrCmpnt $ ( ord(PLSofrCmpnt) = 3 )
3673      , i_tradePeriodFastPLSRoffer(offer,trdBlk,PLSofrCmpnt)     $(ord(resC)=1)
3674      + i_tradePeriodSustainedPLSRoffer(offer,trdBlk,PLSofrCmpnt)$(ord(resC)=2) ];
3675   
3676   
3677  reserveOfferPrice(offer,trdBlk,resC,TWDRReserveType)
3678      = sum[ TWDofrCmpnt $ ( ord(TWDofrCmpnt) = 2 )
3679      , i_tradePeriodFastTWDRoffer(offer,trdBlk,TWDofrCmpnt)     $(ord(resC)=1)
3680      + i_tradePeriodSustainedTWDRoffer(offer,trdBlk,TWDofrCmpnt)$(ord(resC)=2) ];
3681   
3682  reserveOfferPrice(offer,trdBlk,resC,ILReserveType)
3683      = sum[ ILofrCmpnt $ ( ord(ILofrCmpnt) = 2 )
3684      , i_tradePeriodFastILRoffer(offer,trdBlk,ILofrCmpnt)     $(ord(resC)=1)
3685      + i_tradePeriodSustainedILRoffer(offer,trdBlk,ILofrCmpnt)$(ord(resC)=2) ] ;
3686   
3687  * Only reserve offer block with a positive block limit is valid
3688  validReserveOfferBlock(offer,trdBlk,resC,resT)
3689      $ (reserveOfferMaximum(offer,trdBlk,resC,resT) > 0) = yes ;
3690   
3691  * Bid energy data
3692  purchaseBidMW(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3693      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 1 )
3694           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3695   
3696  purchaseBidPrice(bid,trdBlk) $ i_tradePeriodDispatchableBid(bid)
3697      = sum[ NRGbidCmpnt $ ( ord(NRGbidCmpnt) = 2 )
3698           , i_tradePeriodEnergyBid(bid,trdBlk,NRGbidCmpnt) ] ;
3699   
3700  validPurchaseBidBlock(bid,trdBlk)
3701      $ { ( purchaseBidMW(bid,trdBlk) > 0 ) or
3702          ( useDSBFDemandBidModel * purchaseBidMW(bid,trdBlk) <> 0) } = yes ;
3703   
3704  * Bid IL data
3705  purchaseBidILRMW(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3706      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt ) = 1)
3707           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3708           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3709   
3710  purchaseBidILRPrice(bid,trdBlk,resC) $ i_tradePeriodDispatchableBid(bid)
3711      = sum[ ILbidCmpnt $ ( ord(ILbidCmpnt) = 2 )
3712           , i_tradePeriodFastILRbid(bid,trdBlk,ILbidCmpnt)     $(ord(resC)=1)
3713           + i_tradePeriodSustainedILRbid(bid,trdBlk,ILbidCmpnt)$(ord(resC)=2) ] ;
3714   
3715  validPurchaseBidILRBlock(bid,trdBlk,resC)
3716      $ ( purchaseBidILRMW(bid,trdBlk,resC) > 0 ) = yes ;
3717   
3718   
3719  * Initialise demand/bid data for the current trade period start
3720  nodeDemand(node) = i_tradePeriodNodeDemand(node) ;
3721   
3722  * If a bid is valid --> ignore the demand at the node connected to the bid
3723  * (PA suggested during v1.4 Audit)
3724  nodeDemand(node(tp,n))
3725      $ { useDSBFDemandBidModel and
3726          Sum[ bd $ { bidNode(tp,bd,n) and i_tradePeriodDispatchableBid(tp,bd) }
3727             , 1 ]
3728        } = 0;
3729   
3730  * Branch is defined if there is a defined terminal bus, it has a non-zero
3731  * capacity and is closed for that trade period
3732  * Update the pre-processing code that removes branches which have a limit of zero
3733  * so that it removes a branch if either direction has a limit of zero.
3734  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3735                    (not i_tradePeriodHVDCBranch(tp,br)) and
3736                    sum[ fd $ (ord(fd)=1), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3737                    sum[ fd $ (ord(fd)=2), i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3738                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3739                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3740                  } = yes ;
3741   
3742  branch(tp,br) $ { (not i_tradePeriodBranchOpenStatus(tp,br)) and
3743                    (i_tradePeriodHVDCBranch(tp,br)) and
3744                    sum[ fd, i_tradePeriodBranchCapacityDirected(tp,br,fd)] and
3745                    sum[ (b,b1) $ { bus(tp,b) and bus(tp,b1) and
3746                                    i_tradePeriodBranchDefn(tp,br,b,b1) }, 1 ]
3747                  } = yes ;
3748   
3749   
3750  branchBusDefn(branch,b,b1) $ i_tradePeriodBranchDefn(branch,b,b1)    = yes ;
3751  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b,b1), 1] = yes ;
3752  branchBusConnect(branch,b) $ sum[b1 $ branchBusDefn(branch,b1,b), 1] = yes ;
3753   
3754  * HVDC link and AC branch definition
3755  HVDClink(branch)      $ i_tradePeriodHVDCBranch(branch)         = yes ;
3756  HVDCpoles(branch)     $ ( i_tradePeriodHVDCBranch(branch) = 1 ) = yes ;
3757  HVDChalfPoles(branch) $ ( i_tradePeriodHVDCBranch(branch) = 2 ) = yes ;
3758  ACbranch(branch)      $ ( not HVDClink(branch) )                = yes ;
3759   
3760  * Determine sending and receiving bus sets
3761  loop((frB,toB),
3762      ACbranchSendingBus(ACbranch,frB,fd)
3763          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3764   
3765      ACbranchReceivingBus(ACbranch,toB,fd)
3766          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 1) } = yes ;
3767   
3768      ACbranchSendingBus(ACbranch,toB,fd)
3769          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3770   
3771      ACbranchReceivingBus(ACbranch,frB,fd)
3772          $ { branchBusDefn(ACbranch,frB,toB) and (ord(fd) = 2) } = yes ;
3773  );
3774   
3775  HVDClinkSendingBus(HVDClink,frB)
3776      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3777   
3778  HVDClinkReceivingBus(HVDClink,toB)
3779      $ sum[ branchBusDefn(HVDClink,frB,toB), 1 ] = yes ;
3780   
3781  HVDClinkBus(HVDClink,b) $ HVDClinkSendingBus(HVDClink,b)   = yes ;
3782  HVDClinkBus(HVDClink,b) $ HVDClinkReceivingBus(HVDClink,b) = yes ;
3783   
3784  * Determine the HVDC inter-island pole in the northward and southward direction
3785   
3786  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 1) and HVDClink(tp,br) }
3787      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 2)
3788                                         and nodeIsland(tp,n,ild)
3789                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3790   
3791  HVDCpoleDirection(tp,br,fd) $ { (ord(fd) = 2) and HVDClink(tp,br) }
3792      = yes $ sum[ (ild,NodeBus(tp,n,b)) $ { (ord(ild) = 1)
3793                                         and nodeIsland(tp,n,ild)
3794                                         and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
3795   
3796  * Mapping HVDC branch to pole to account for name changes to Pole 3
3797  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY1.1'), 1] = yes ;
3798  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN1.1'), 1] = yes ;
3799  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'BEN_HAY3.1'), 1] = yes ;
3800  HVDCpoleBranchMap('Pole1',br) $ sum[ sameas(br,'HAY_BEN3.1'), 1] = yes ;
3801  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'BEN_HAY2.1'), 1] = yes ;
3802  HVDCpoleBranchMap('Pole2',br) $ sum[ sameas(br,'HAY_BEN2.1'), 1] = yes ;
3803   
3804  * Initialise network data for the current trade period start
3805  * Node-bus allocation factor
3806  nodeBusAllocationFactor(tp,n,b) $ { node(tp,n) and bus(tp,b) }
3807      = i_tradePeriodNodeBusAllocationFactor(tp,n,b) ;
3808   
3809  * Flag to allow roundpower on the HVDC link
3810  allowHVDCroundpower(tp) = i_tradePeriodAllowHVDCroundpower(tp) ;
3811   
3812  * Allocate the input branch parameters to the defined branchCapacity
3813  branchCapacity(branch,fd)
3814      = i_tradePeriodBranchCapacityDirected(branch,fd) ;
3815  * HVDC Links do not have reverse capacity
3816  branchCapacity(HVDClink,fd) $ ( ord(fd) = 2 ) = 0 ;
3817   
3818  * Allocate the input branch parameters to the defined branchResistance
3819  branchResistance(branch)
3820      = sum[ i_branchParameter $ (ord(i_branchParameter) = 1)
3821           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3822   
3823  * Convert susceptance from -Bpu to B% for data post-MSP
3824  branchSusceptance(ACbranch(tp,br))
3825      = sum[ i_branchParameter $ (ord(i_branchParameter) = 2)
3826           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter) ]
3827      * [ 100$(not i_useBusNetworkModel(tp)) - 100$i_useBusNetworkModel(tp) ];
3828   
3829  branchLossBlocks(branch)
3830      = sum[ i_branchParameter $ (ord(i_branchParameter) = 4)
3831           , i_tradePeriodBranchParameter(branch,i_branchParameter) ] ;
3832   
3833  * Ensure fixed losses for no loss AC branches are not included
3834  branchFixedLoss(ACbranch)
3835      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3836           , i_tradePeriodBranchParameter(ACbranch,i_branchParameter)
3837           ] $ (branchLossBlocks(ACbranch) > 1) ;
3838   
3839  branchFixedLoss(HVDClink)
3840      = sum[ i_branchParameter $ (ord(i_branchParameter) = 3)
3841           , i_tradePeriodBranchParameter(HVDClink,i_branchParameter) ] ;
3842   
3843  * Set resistance and fixed loss to zero if do not want to use the loss model
3844  branchResistance(ACbranch) $ (not useAClossModel) = 0 ;
3845  branchFixedLoss(ACbranch)  $ (not useAClossModel) = 0 ;
3846   
3847  branchResistance(HVDClink) $ (not useHVDClossModel) = 0 ;
3848  branchFixedLoss(HVDClink)  $ (not useHVDClossModel) = 0 ;
3849   
3850  * Initialise loss tranches data for the current trade period start
3851  * The loss factor coefficients assume that the branch capacity is in MW
3852  * and the resistance is in p.u.
3853   
3854  * Loss branches with 0 loss blocks
3855  lossSegmentMW(branch,los,fd)
3856      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3857      = branchCapacity(branch,fd) ;
3858   
3859  LossSegmentFactor(branch,los,fd)
3860      $ { (branchLossBlocks(branch) = 0) and (ord(los) = 1) }
3861      = 0 ;
3862   
3863  * Loss branches with 1 loss blocks
3864  LossSegmentMW(branch,los,fd)
3865      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3866      = maxFlowSegment ;
3867   
3868  LossSegmentFactor(branch,los,fd)
3869      $ { (branchLossBlocks(branch) = 1) and (ord(los) = 1) }
3870      = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
3871   
3872  * Loss branches with 3 loss blocks
3873  loop( branch $ (branchLossBlocks(branch) = 3),
3874  *   Segment 1
3875      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3876          = lossCoeff_A * branchCapacity(branch,fd) ;
3877   
3878      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3879          = 0.01 * 0.75 * lossCoeff_A
3880          * branchResistance(branch) * branchCapacity(branch,fd) ;
3881   
3882  *   Segment 2
3883      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
3884          = (1-lossCoeff_A) * branchCapacity(branch,fd) ;
3885   
3886      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
3887          = 0.01 * branchResistance(branch) * branchCapacity(branch,fd) ;
3888   
3889  *   Segment 3
3890      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
3891          = maxFlowSegment ;
3892   
3893      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
3894          = 0.01 * (2 - (0.75*lossCoeff_A))
3895          * branchResistance(branch) * branchCapacity(branch,fd) ;
3896  );
3897   
3898  * Loss branches with 6 loss blocks
3899  loop( branch $ (branchLossBlocks(branch) = 6),
3900  *   Segment 1
3901      LossSegmentMW(branch,los,fd) $ (ord(los) = 1)
3902          = lossCoeff_C  * branchCapacity(branch,fd) ;
3903   
3904      LossSegmentFactor(branch,los,fd) $ (ord(los) = 1)
3905          = 0.01 * 0.75 * lossCoeff_C
3906          * branchResistance(branch) * branchCapacity(branch,fd) ;
3907   
3908  *   Segment 2
3909      LossSegmentMW(branch,los,fd) $ (ord(los) = 2)
3910          = lossCoeff_D * branchCapacity(branch,fd) ;
3911   
3912      LossSegmentFactor(branch,los,fd) $ (ord(los) = 2)
3913          = 0.01 * lossCoeff_E
3914          * branchResistance(branch) * branchCapacity(branch,fd) ;
3915   
3916  *   Segment 3
3917      LossSegmentMW(branch,los,fd) $ (ord(los) = 3)
3918          = 0.5 * branchCapacity(branch,fd) ;
3919   
3920      LossSegmentFactor(branch,los,fd) $ (ord(los) = 3)
3921          = 0.01 * lossCoeff_F
3922          * branchResistance(branch) * branchCapacity(branch,fd) ;
3923   
3924  *   Segment 4
3925      LossSegmentMW(branch,los,fd) $ (ord(los) = 4)
3926          = (1 - lossCoeff_D) * branchCapacity(branch,fd) ;
3927   
3928      LossSegmentFactor(branch,los,fd) $ (ord(los) = 4)
3929          = 0.01 * (2 - lossCoeff_F)
3930          * branchResistance(branch) * branchCapacity(branch,fd) ;
3931   
3932  *   Segment 5
3933      LossSegmentMW(branch,los,fd) $ (ord(los) = 5)
3934          = (1 - lossCoeff_C) * branchCapacity(branch,fd) ;
3935   
3936      LossSegmentFactor(branch,los,fd) $ (ord(los) = 5)
3937          = 0.01 * (2 - lossCoeff_E)
3938          * branchResistance(branch) * branchCapacity(branch,fd) ;
3939   
3940  *   Segment 6
3941      LossSegmentMW(branch,los,fd) $ (ord(los) = 6)
3942          = maxFlowSegment ;
3943   
3944      LossSegmentFactor(branch,los,fd) $ (ord(los) = 6)
3945          = 0.01 * (2 - (0.75*lossCoeff_C))
3946          * branchResistance(branch) * branchCapacity(branch,fd) ;
3947  ) ;
3948   
3949  * HVDC does not have backward flow --> No loss segment for backward flow
3950  LossSegmentMW(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
3951  LossSegmentFactor(HVDClink,los,fd) $ (ord(fd) = 2) = 0;
3952   
3953   
3954  * Valid loss segment for a branch is defined as a loss segment that
3955  * has a non-zero LossSegmentMW or a non-zero LossSegmentFactor.
3956  validLossSegment(branch,los,fd) = yes $ { (ord(los) = 1) or
3957                                            LossSegmentMW(branch,los,fd) or
3958                                            LossSegmentFactor(branch,los,fd) } ;
3959   
3960  * HVDC loss model requires at least two loss segments and
3961  * an additional loss block due to cumulative loss formulation
3962  validLossSegment(HVDClink,los,fd)
3963      $ { (branchLossBlocks(HVDClink) <= 1) and (ord(los) = 2) } = yes ;
3964   
3965  validLossSegment(HVDClink,los,fd)
3966      $ { (branchLossBlocks(HVDClink) > 1) and
3967          (ord(los) = (branchLossBlocks(HVDClink) + 1)) and
3968          (sum[ los1, LossSegmentMW(HVDClink,los1,fd)
3969                    + LossSegmentFactor(HVDClink,los1,fd) ] > 0)
3970        } = yes ;
3971   
3972  * branches that have non-zero loss factors
3973  LossBranch(branch) $ sum[ (los,fd), LossSegmentFactor(branch,los,fd) ] = yes ;
3974   
3975  * Create AC branch loss segments
3976  ACbranchLossMW(ACbranch,los,fd)
3977      $ { validLossSegment(ACbranch,los,fd) and (ord(los) = 1) }
3978      = LossSegmentMW(ACbranch,los,fd) ;
3979   
3980  ACbranchLossMW(ACbranch,los,fd)
3981      $ { validLossSegment(ACbranch,los,fd) and (ord(los) > 1) }
3982      = LossSegmentMW(ACbranch,los,fd) - LossSegmentMW(ACbranch,los-1,fd) ;
3983   
3984  ACbranchLossFactor(ACbranch,los,fd)
3985      $ validLossSegment(ACbranch,los,fd) = LossSegmentFactor(ACbranch,los,fd) ;
3986   
3987  * Create HVDC loss break points
3988  HVDCBreakPointMWFlow(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
3989  HVDCBreakPointMWLoss(HVDClink,bp,fd) $ (ord(bp) = 1) = 0 ;
3990   
3991  HVDCBreakPointMWFlow(HVDClink,bp,fd)
3992      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) > 1) }
3993      = LossSegmentMW(HVDClink,bp-1,fd) ;
3994   
3995  HVDCBreakPointMWLoss(HVDClink,bp,fd)
3996      $ { validLossSegment(HVDClink,bp,fd) and (ord(bp) = 2) }
3997      =  LossSegmentMW(HVDClink,bp-1,fd) * LossSegmentFactor(HVDClink,bp-1,fd) ;
3998   
3999  loop( (HVDClink(branch),bp) $ (ord(bp) > 2),
4000      HVDCBreakPointMWLoss(branch,bp,fd) $ validLossSegment(branch,bp,fd)
4001          = LossSegmentFactor(branch,bp-1,fd)
4002          * [ LossSegmentMW(branch,bp-1,fd) - LossSegmentMW(branch,bp-2,fd) ]
4003          + HVDCBreakPointMWLoss(branch,bp-1,fd) ;
4004  ) ;
4005   
4006  * Initialise branch constraint data for the current trading period
4007  branchConstraint(tp,brCstr)
4008      $ sum[ branch(tp,br)
4009           $ i_tradePeriodBranchConstraintFactors(tp,brCstr,br), 1 ] = yes ;
4010   
4011  branchConstraintFactors(branchConstraint,br)
4012      = i_tradePeriodBranchConstraintFactors(branchConstraint,br) ;
4013   
4014  branchConstraintSense(branchConstraint)
4015      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4016           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4017   
4018  branchConstraintLimit(branchConstraint)
4019      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4020           i_tradePeriodBranchConstraintRHS(branchConstraint,CstrRHS) ] ;
4021   
4022  * Calculate parameters for NMIR project ----------------------------------------
4023  islandRiskGroup(tp,ild,rg,riskC)
4024      = yes $ sum[ o $ { offerIsland(tp,o,ild)
4025                     and riskGroupOffer(tp,rg,o,riskC) }, 1 ] ;
4026   
4027  modulationRisk(tp) = smax[ riskC, modulationRiskClass(tp,RiskC) ];
4028   
4029  reserveShareEnabledOverall(tp) = smax[ resC, reserveShareEnabled(tp,resC) ];
4030   
4031  roPwrZoneExit(tp,resC)
4032      = [ roundPower2MonoLevel(tp) - modulationRisk(tp) ]$(ord(resC)=1)
4033      + bipole2MonoLevel(tp)$(ord(resC)=2) ;
4034   
4035  * National market refinement - effective date 28 Mar 2019 12:00
         SPD pre-processing is changed so that the roundpower settings for FIR are now the same as for SIR. Specifically:
         -  The RoundPowerZoneExit for FIR will be set at BipoleToMonopoleTransition by SPD pre-processing (same as for SIR),
            a change from the existing where the RoundPowerZoneExit for FIR is set at RoundPowerToMonopoleTransition by SPD pre-processing.
         -  Provided that roundpower is not disabled by the MDB, the InNoReverseZone for FIR will be removed by SPD pre-processing (same as for SIR),
            a change from the existing where the InNoReverseZone for FIR is never removed by SPD pre-processing.
4043   
4044  if (inputGDXGDate >= jdate(2019,03,28),
4045      roPwrZoneExit(tp,resC) = bipole2MonoLevel(tp) ;
4046  ) ;
4047   
4048  * National market refinement end
4049   
4050   
4051  * Pre-processing: Shared Net Free Reserve (NFR) calculation - NMIR (5.2.1.2)
4052  sharedNFRLoad(tp,ild)
4053      = sum[ nodeIsland(tp,n,ild), nodeDemand(tp,n)]
4054      + sum[ (bd,trdBlk) $ bidIsland(tp,bd,ild), purchaseBidMW(tp,bd,trdBlk) ]
4055      - sharedNFRLoadOffset(tp,ild) ;
4056   
4057  sharedNFRMax(tp,ild) = Min{ RMTReserveLimitTo(tp,ild,'FIR'),
4058                              sharedNFRFactor(tp)*sharedNFRLoad(tp,ild) } ;
4059   
4060  * Calculate HVDC constraint sets and HVDC Max Flow - NMIR (4.1.8 - NMIR06)
4061  * TN on 22 May 2017: Usually a branch group constraint that limits the HVDC flow only involves
4062  * the HVDC branch(s) in the same direction. However, during TP6 to TP9 of 18 May 2017, the
4063  * constraint HAY_BEN_High_Frequency_limit involved all four branches in the form:
4064  *   HAY_BEN1.1 + HAY_BEN2.1 - BEN_HAY1.1 - BEN_HAY2.1 <= 530 MW
4065  * This method of formulating the constraint prevented the previous formulation of monopoleConstraint
4066  * and bipoleConstraintfrom working properly. Those constraints have been reformulated (see below)
4067  * in order to cope with the formulation observed on 18 May 2017.
4068  monopoleConstraint(tp,ild,brCstr,br)
4069      $ { HVDCpoles(tp,br)
4070      and ( not rampingConstraint(tp,brCstr) )
4071      and ( branchConstraintSense(tp,brCstr) = -1 )
4072      and (Sum[ (br1,b) $ {HVDClinkSendingBus(tp,br1,b) and busIsland(tp,b,ild)}
4073                        , branchConstraintFactors(tp,brCstr,br1)    ] = 1)
4074      and (Sum[ b $ {HVDClinkSendingBus(tp,br,b) and busIsland(tp,b,ild)}
4075                   , branchConstraintFactors(tp,brCstr,br)      ] = 1)
4076         } = yes ;
4077   
4078  bipoleConstraint(tp,ild,brCstr)
4079      $ { ( not rampingConstraint(tp,brCstr) )
4080      and ( branchConstraintSense(tp,brCstr) = -1 )
4081      and (Sum[ (br,b) $ { HVDCpoles(tp,br)
4082                       and HVDClinkSendingBus(tp,br,b)
4083                       and busIsland(tp,b,ild) }
4084                      , branchConstraintFactors(tp,brCstr,br)  ] = 2)
4085                         } = yes ;
4086   
4087  monoPoleCapacity(tp,ild,br)
4088      = Sum[ (b,fd) $ { BusIsland(tp,b,ild)
4089                    and HVDCPoles(tp,br)
4090                    and HVDClinkSendingBus(tp,br,b)
4091                    and ( ord(fd) = 1 )
4092                      }, branchCapacity(tp,br,fd) ] ;
4093   
4094  monoPoleCapacity(tp,ild,br)
4095      $ Sum[ brCstr $ monopoleConstraint(tp,ild,brCstr,br), 1]
4096      = Smin[ brCstr $ monopoleConstraint(tp,ild,brCstr,br)
4097            , branchConstraintLimit(tp,brCstr) ];
4098   
4099  monoPoleCapacity(tp,ild,br)
4100      = Min( monoPoleCapacity(tp,ild,br),
4101             sum[ fd $ ( ord(fd) = 1 ), branchCapacity(tp,br,fd) ] );
4102   
4103  biPoleCapacity(tp,ild)
4104      $ Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1]
4105      = Smin[ brCstr $ bipoleConstraint(tp,ild,brCstr)
4106            , branchConstraintLimit(tp,brCstr) ];
4107   
4108  biPoleCapacity(tp,ild)
4109      $ { Sum[ brCstr $ bipoleConstraint(tp,ild,brCstr), 1] = 0 }
4110      = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4111                       and HVDClinkSendingBus(tp,br,b)
4112                       and ( ord(fd) = 1 )
4113                         }, branchCapacity(tp,br,fd) ] ;
4114   
4115  HVDCMax(tp,ild)
4116      = Min( biPoleCapacity(tp,ild), Sum[ br, monoPoleCapacity(tp,ild,br) ] ) ;
4117   
4118  * Calculate HVDC HVDC Loss segment applied for NMIR
4119   
      * Note: When NMIR started on 20/10/2016, the SOdecided to incorrectly calculate the HVDC loss
      * curve for reserve sharing based on the HVDC capacity only (i.e. not based on in-service HVDC poles)
      * Tuong Nguyen @ EA discovered this bug and the SO has fixed it as of 22/11/2016.
4125  if (inputGDXGDate >= jdate(2016,11,22),
4126        HVDCCapacity(tp,ild)
4127            = Sum[ (b,br,fd) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4128                             and HVDClinkSendingBus(tp,br,b)
4129                             and ( ord(fd) = 1 )
4130                               }, branchCapacity(tp,br,fd) ] ;
4131   
4132        numberOfPoles(tp,ild)
4133            = Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4134                          and HVDClinkSendingBus(tp,br,b) }, 1 ] ;
4135   
4136        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4137            = Prod[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4138                           and HVDClinkSendingBus(tp,br,b)
4139                             }, branchResistance(tp,br) ]
4140            / Sum[ (b,br) $ { BusIsland(tp,b,ild) and HVDCPoles(tp,br)
4141                          and HVDClinkSendingBus(tp,br,b)
4142                            }, branchResistance(tp,br) ] ;
4143   
4144        HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 1)
4145            = Sum[ br $ monoPoleCapacity(tp,ild,br), branchResistance(tp,br) ] ;
4146  else
4147      HVDCCapacity(tp,ild)
4148          = Sum[ (br,b,b1,fd) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4149                              and i_tradePeriodBusIsland(tp,b,ild)
4150                              and i_tradePeriodBranchDefn(tp,br,b,b1)
4151                              and ( ord(fd) = 1 )
4152                                }, i_tradePeriodBranchCapacityDirected(tp,br,fd) ] ;
4153   
4154      numberOfPoles(tp,ild)
4155          =Sum[ (br,b,b1) $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4156                        and i_tradePeriodBusIsland(tp,b,ild)
4157                        and i_tradePeriodBranchDefn(tp,br,b,b1)
4158                        and sum[ fd $ ( ord(fd) = 1 )
4159                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4160                          }, 1 ] ;
4161   
4162      HVDCResistance(tp,ild)
4163          =  Sum[ (br,b,b1,i_branchParameter)
4164                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4165                and i_tradePeriodBusIsland(tp,b,ild)
4166                and i_tradePeriodBranchDefn(tp,br,b,b1)
4167                and (ord(i_branchParameter) = 1)
4168                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter) ] ;
4169   
4170      HVDCResistance(tp,ild) $ (numberOfPoles(tp,ild) = 2)
4171          = Prod[ (br,b,b1,i_branchParameter)
4172                $ { (i_tradePeriodHVDCBranch(tp,br) = 1)
4173                and i_tradePeriodBusIsland(tp,b,ild)
4174                and i_tradePeriodBranchDefn(tp,br,b,b1)
4175                and sum[ fd $ ( ord(fd) = 1 )
4176                               , i_tradePeriodBranchCapacityDirected(tp,br,fd) ]
4177                and (ord(i_branchParameter) = 1)
4178                  }, i_tradePeriodBranchParameter(tp,br,i_branchParameter)
4179                ] / HVDCResistance(tp,ild) ;
4180  ) ;
4181   
4182  * Segment 1
4183  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 1)
4184      = HVDCCapacity(tp,ild) * lossCoeff_C ;
4185   
4186  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 1)
4187      = 0.01 * 0.75 * lossCoeff_C
4188      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4189   
4190  * Segment 2
4191  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 2)
4192      = HVDCCapacity(tp,ild) * lossCoeff_D ;
4193   
4194  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 2)
4195      = 0.01 * lossCoeff_E
4196      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4197   
4198  * Segment 3
4199  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 3)
4200      = HVDCCapacity(tp,ild) * 0.5 ;
4201   
4202  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 3)
4203      = 0.01 * lossCoeff_F
4204      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4205   
4206  * Segment 4
4207  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 4)
4208      = HVDCCapacity(tp,ild) * (1 - lossCoeff_D) ;
4209   
4210  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 4)
4211      = 0.01 * (2 - lossCoeff_F)
4212      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4213   
4214  * Segment 5
4215  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 5)
4216      = HVDCCapacity(tp,ild) * (1 - lossCoeff_C) ;
4217   
4218  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 5)
4219      = 0.01 * (2 - lossCoeff_E)
4220      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4221   
4222  * Segment 6
4223  HVDCLossSegmentMW(tp,ild,los) $ (ord(los) = 6)
4224      = HVDCCapacity(tp,ild) ;
4225   
4226  HVDCLossSegmentFactor(tp,ild,los) $ (ord(los) = 6)
4227      = 0.01 * (2 - (0.75*lossCoeff_C))
4228      * HVDCResistance(tp,ild) * HVDCCapacity(tp,ild) ;
4229   
4230  * Parameter for energy lambda loss model
4231  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4232  HVDCSentBreakPointMWLoss(tp,ild,bp) $ (ord(bp) = 1) = 0 ;
4233   
4234  HVDCSentBreakPointMWFlow(tp,ild,bp) $ (ord(bp) > 1)
4235      = HVDCLossSegmentMW(tp,ild,bp-1) ;
4236   
4237  loop( (tp,ild,bp) $ {(ord(bp) > 1) and (ord(bp) <= 7)},
4238      HVDCSentBreakPointMWLoss(tp,ild,bp)
4239          = HVDClossScalingFactor(tp)
4240          * HVDCLossSegmentFactor(tp,ild,bp-1)
4241          * [ HVDCLossSegmentMW(tp,ild,bp-1)
4242            - HVDCSentBreakPointMWFlow(tp,ild,bp-1) ]
4243          + HVDCSentBreakPointMWLoss(tp,ild,bp-1) ;
4244  ) ;
4245   
4246  * Parameter for energy+reserve lambda loss model
4247   
4248  * Ideally SO should use asymmetric loss curve
4249  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4250      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4251                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4252           , -HVDCSentBreakPointMWFlow(tp,ild1,rsbp1) ];
4253   
4254  * SO decide to use symmetric loss curve instead
4255  HVDCReserveBreakPointMWFlow(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4256      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4257           , -HVDCSentBreakPointMWFlow(tp,ild,rsbp1) ];
4258   
4259  HVDCReserveBreakPointMWFlow(tp,ild,rsbp)
4260      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4261      = HVDCSentBreakPointMWFlow(tp,ild,rsbp-6) ;
4262   
4263   
4264  * Ideally SO should use asymmetric loss curve
4265  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4266      = Sum[ (ild1,rsbp1) $ { ( not sameas(ild1,ild) )
4267                          and ( ord(rsbp) + ord(rsbp1) = 8)}
4268           , HVDCSentBreakPointMWLoss(tp,ild1,rsbp1) ];
4269   
4270  * SO decide to use symmetric loss curve instead
4271  HVDCReserveBreakPointMWLoss(tp,ild,rsbp) $ (ord(rsbp) <= 7)
4272      = Sum[ rsbp1 $ { ord(rsbp) + ord(rsbp1) = 8}
4273           , HVDCSentBreakPointMWLoss(tp,ild,rsbp1) ];
4274   
4275  HVDCReserveBreakPointMWLoss(tp,ild,rsbp)
4276      $ { (ord(rsbp) > 7) and (ord(rsbp) <= 13) }
4277      = HVDCSentBreakPointMWLoss(tp,ild,rsbp-6);
4278   
4279  * Parameter for lambda loss model  end
4280   
4281  * Initialze parameters for NMIR project end ----------------------------------
4282   
4283   
4284  * Initialise risk/reserve data for the current trade period start
4285   
4286  GenRisk(riskC)     $ (ord(riskC) = 1) = yes ;
4287  HVDCrisk(riskC)    $ (ord(riskC) = 2) = yes ;
4288  HVDCrisk(riskC)    $ (ord(riskC) = 3) = yes ;
4289  ManualRisk(riskC)  $ (ord(riskC) = 4) = yes ;
4290  GenRisk(riskC)     $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4291  ManualRisk(riskC)  $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4292  HVDCsecRisk(riskC) $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4293  HVDCsecRisk(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4294   
4295  * Define the CE and ECE risk class set to support the different CE and ECE CVP
4296  ContingentEvents(riskC)        $ (ord(riskC) = 1) = yes ;
4297  ContingentEvents(riskC)        $ (ord(riskC) = 2) = yes ;
4298  ExtendedContingentEvent(riskC) $ (ord(riskC) = 3) = yes ;
4299  ContingentEvents(riskC)        $ (ord(riskC) = 4) = yes ;
4300  ExtendedContingentEvent(riskC) $ (ord(riskC) = 5) = yes $ useExtendedRiskClass ;
4301  ExtendedContingentEvent(riskC) $ (ord(riskC) = 6) = yes $ useExtendedRiskClass ;
4302  ContingentEvents(riskC)        $ (ord(riskC) = 7) = yes $ useExtendedRiskClass ;
4303  ExtendedContingentEvent(riskC) $ (ord(riskC) = 8) = yes $ useExtendedRiskClass ;
4304   
4305  * Risk parameters
4306  FreeReserve(tp,ild,resC,riskC)
4307      = sum[ riskPar $ (ord(riskPar) = 1)
4308                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ]
4309  * NMIR - Subtract shareNFRMax from current NFR -(5.2.1.4) - SPD version 11
4310      - sum[ ild1 $ (not sameas(ild,ild1)),sharedNFRMax(tp,ild1)
4311           ] $ { (ord(resC)=1) and ( (GenRisk(riskC)) or (ManualRisk(riskC)) )
4312             and (inputGDXGDate >= jdate(2016,10,20)) }
4313      ;
4314   
4315  IslandRiskAdjustmentFactor(tp,ild,resC,riskC) $ useReserveModel
4316      = sum[ riskPar $ (ord(riskPar) = 2)
4317                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4318   
4319  * HVDC rampup max - (3.4.1.3) - SPD version 11
4320  HVDCpoleRampUp(tp,ild,resC,riskC)
4321      = sum[ riskPar $ (ord(riskPar) = 3)
4322                     , i_tradePeriodRiskParameter(tp,ild,resC,riskC,riskPar) ] ;
4323   
4324  * Index IslandMinimumRisk to cater for CE and ECE minimum risk
4325  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 4)
4326      = i_tradePeriodManualRisk(tp,ild,resC) ;
4327   
4328  IslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 6)
4329      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4330   
4331  * HVDC secondary risk parameters
4332  HVDCsecRiskEnabled(tp,ild,riskC)= i_tradePeriodHVDCsecRiskEnabled(tp,ild,riskC);
4333  HVDCsecRiskSubtractor(tp,ild)   = i_tradePeriodHVDCsecRiskSubtractor(tp,ild) ;
4334   
4335  * Min risks for the HVDC secondary risk are the same as the island min risk
4336  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 7)
4337      = i_tradePeriodManualRisk(tp,ild,resC) ;
4338   
4339  HVDCsecIslandMinimumRisk(tp,ild,resC,riskC) $ (ord(riskC) = 8)
4340      = i_tradePeriodManualRisk_ECE(tp,ild,resC) ;
4341   
4342  * The MW combined maximum capability for generation and reserve of class.
4343  reserveClassGenerationMaximum(offer,resC) = ReserveGenerationMaximum(offer) ;
4344   
4345  reserveClassGenerationMaximum(offer,resC)
4346      $ i_tradePeriodReserveClassGenerationMaximum(offer,resC)
4347      = i_tradePeriodReserveClassGenerationMaximum(offer,resC) ;
4348   
4349  * Calculation of reserve maximum factor - 5.2.1.1
4350  ReserveMaximumFactor(offer,resC) = 1 ;
4351  ReserveMaximumFactor(offer,resC)
4352      $ (ReserveClassGenerationMaximum(offer,resC)>0)
4353      = ReserveGenerationMaximum(offer)
4354      / reserveClassGenerationMaximum(offer,resC) ;
4355   
4356  * Virtual reserve
4357  virtualReserveMax(tp,ild,resC) = i_tradePeriodVROfferMax(tp,ild,resC) ;
4358  virtualReservePrice(tp,ild,resC) = i_tradePeriodVROfferPrice(tp,ild,resC) ;
4359   
4360  * Initialise AC node constraint data for the current trading period
4361  ACnodeConstraint(tp,ACnodeCstr)
4362      $ sum[ ACnode(tp,n)
4363           $ i_tradePeriodACnodeConstraintFactors(tp,ACnodeCstr,n), 1 ] = yes ;
4364   
4365  ACnodeConstraintFactors(ACnodeConstraint,n)
4366      = i_tradePeriodACnodeConstraintFactors(ACnodeConstraint,n) ;
4367   
4368  ACnodeConstraintSense(ACnodeConstraint)
4369      = sum[ CstrRHS $ (ord(CstrRHS) = 1),
4370           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4371   
4372  ACnodeConstraintLimit(ACnodeConstraint)
4373      = sum[ CstrRHS $ (ord(CstrRHS) = 2),
4374           i_tradePeriodACnodeConstraintRHS(ACnodeConstraint,CstrRHS) ] ;
4375   
4376  * Initialise market node constraint data for the current trading period
4377  MnodeConstraint(tp,MnodeCstr)
4378      $ { sum[ (offer(tp,o),resT,resC)
4379             $ { i_tradePeriodMnodeEnergyOfferConstraintFactors(tp,MnodeCstr,o) or
4380                 i_tradePeriodMnodeReserveOfferConstraintFactors(tp,MnodeCstr,o,resC,resT)
4381               }, 1
4382             ]
4383        or
4384          sum[ (bid(tp,bd),resC)
4385             $ { i_tradePeriodMnodeEnergyBidConstraintFactors(tp,MnodeCstr,bd) or
4386                 i_tradePeriodMnodeILReserveBidConstraintFactors(tp,MnodeCstr,bd,resC)
4387               }, 1
4388             ]
4389        } = yes ;
4390   
4391  MnodeEnergyOfferConstraintFactors(MnodeConstraint,o)
4392      = i_tradePeriodMnodeEnergyOfferConstraintFactors(MnodeConstraint,o) ;
4393   
4394  MnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT)
4395      = i_tradePeriodMnodeReserveOfferConstraintFactors(MnodeConstraint,o,resC,resT) ;
4396   
4397  MnodeEnergyBidConstraintFactors(MnodeConstraint,bd)
4398      = i_tradePeriodMnodeEnergyBidConstraintFactors(MnodeConstraint,bd) ;
4399   
4400  MnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC)
4401      = i_tradePeriodMnodeILReserveBidConstraintFactors(MnodeConstraint,bd,resC) ;
4402   
4403  MnodeConstraintSense(MnodeConstraint)
4404      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4405           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4406   
4407  MnodeConstraintLimit(MnodeConstraint)
4408      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4409           , i_tradePeriodMnodeConstraintRHS(MnodeConstraint,CstrRHS) ] ;
4410   
4411  * Initialise mixed constraint data for the current trading period
4412  Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC)
4413      = i_type1MixedConstraintReserveMap(t1MixCstr,ild,resC,riskC) ;
4414   
4415  Type1MixedConstraint(tp,t1MixCstr)
4416      = i_tradePeriodType1MixedConstraint(tp,t1MixCstr) ;
4417   
4418  Type2MixedConstraint(tp,t2MixCstr)
4419      = i_tradePeriodType2MixedConstraint(tp,t2MixCstr) ;
4420   
4421  Type1MixedConstraintSense(tp,t1MixCstr)
4422      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 1)
4423           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4424   
4425  Type1MixedConstraintLimit1(tp,t1MixCstr)
4426      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 2)
4427           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4428   
4429  Type1MixedConstraintLimit2(tp,t1MixCstr)
4430      = sum[ t1MixCstrRHS $ (ord(t1MixCstrRHS) = 3)
4431           , i_tradePeriodType1MixedConstraintRHSParameters(tp,t1MixCstr,t1MixCstrRHS) ] ;
4432   
4433  Type2MixedConstraintSense(tp,t2MixCstr)
4434      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4435           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4436   
4437  Type2MixedConstraintLimit(tp,t2MixCstr)
4438      = sum[ CstrRHS$(ord(CstrRHS) = 2)
4439           , i_tradePeriodType2MixedConstraintRHSParameters(tp,t2MixCstr,CstrRHS) ] ;
4440   
4441  Type1MixedConstraintCondition(tp,t1MixCstr)
4442      $ sum[ br $ { HVDChalfPoles(tp,br) and
4443                    i_type1MixedConstraintBranchCondition(t1MixCstr,br)
4444                  }, 1
4445           ] = yes ;
4446   
4447  * Initialise generic constraint data for the current trading period
4448  GenericConstraint(tp,gnrcCstr) = i_tradePeriodGenericConstraint(tp,gnrcCstr) ;
4449   
4450  GenericEnergyOfferConstraintFactors(GenericConstraint,o)
4451      = i_tradePeriodGenericEnergyOfferConstraintFactors(GenericConstraint,o) ;
4452   
4453  GenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT)
4454      = i_tradePeriodGenericReserveOfferConstraintFactors(GenericConstraint,o,resC,resT) ;
4455   
4456  GenericEnergyBidConstraintFactors(GenericConstraint,bd)
4457      = i_tradePeriodGenericEnergyBidConstraintFactors(GenericConstraint,bd) ;
4458   
4459  GenericILReserveBidConstraintFactors(GenericConstraint,bd,resC)
4460      = i_tradePeriodGenericILReserveBidConstraintFactors(GenericConstraint,bd,resC) ;
4461   
4462  GenericBranchConstraintFactors(GenericConstraint,br)
4463      = i_tradePeriodGenericBranchConstraintFactors(GenericConstraint,br) ;
4464   
4465  GenericConstraintSense(GenericConstraint)
4466      = sum[ CstrRHS $ (ord(CstrRHS) = 1)
4467           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4468   
4469  GenericConstraintLimit(GenericConstraint)
4470      = sum[ CstrRHS $ (ord(CstrRHS) = 2)
4471           , i_tradePeriodGenericConstraintRHS(GenericConstraint,CstrRHS) ] ;
4472   
4473   
4474  * Additional pre-processing on parameters --------------------------------------
4475   
4476  * Calculation of generation upper limits due to ramp rate limits
4477   
4478  * Only primary offers are considered (5.3.1.1)
4479  generationMaximum(tp,o) $ (not hasPrimaryOffer(tp,o))
4480      = sum[ validGenerationOfferBlock(tp,o,trdBlk)
4481           , generationOfferMW(tp,o,trdBlk) ]
4482      + sum[ (o1,trdBlk) $ { primarySecondaryOffer(tp,o,o1) and
4483                             validGenerationOfferBlock(tp,o1,trdBlk) }
4484           , generationOfferMW(tp,o1,trdBlk)
4485           ] ;
4486   
4487  * Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4488  * initial MW and ramp rate is used - Reference: Transpower Market Services
4489  rampTimeUp(offer) $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4490      = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4491                                     - generationStart(offer)
4492                                     ) / rampRateUp(offer)
4493           ] ;
4494   
4495  * Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4496  * initial MW and ramp rate is used - Reference: Transpower Market Services
4497  generationEndUp(offer) $ (not hasPrimaryOffer(offer))
4498      = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4499   
4500   
4501  * Calculation of generation lower limits due to ramp rate limits
4502   
4503  * Only primary offers are considered (5.3.2.1)
4504  * Negative prices for generation offers are not allowed? (5.3.2.1)
4505  generationMinimum(offer) = 0;
4506   
4507  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4508  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4509  rampTimeDown(offer) $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4510      = Min[ i_tradingPeriodLength, ( generationStart(offer)
4511                                    - generationMinimum(offer)
4512                                    ) / rampRateDown(offer)
4513           ] ;
4514   
4515  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4516  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4517  generationEndDown(offer) $ (not hasPrimaryOffer(offer))
4518      = Max[ 0, generationStart(offer) - rampRateDown(offer)*rampTimeDown(offer) ] ;
4519   
4520  o_offerEnergy_TP(dt,o) = 0;
4521  *   Additional pre-processing on parameters end
4522   
4523   
4524   
4525  * TN - Pivot or demand analysis begin
4528  * TN - Pivot or demand analysis begin end
4529   
4530  *=====================================================================================
4531  * 7. The vSPD solve loop
4532  *=====================================================================================
4533   
4534  unsolvedPeriod(tp) = yes;
4535  VSPDModel(tp) = 0 ;
4536  option clear = useBranchFlowMIP ;
4537  option clear = useMixedConstraintMIP ;
4538   
4539  While ( Sum[ tp $ unsolvedPeriod(tp), 1 ],
4540    exitLoop = 0;
4541    loop[ tp $ {unsolvedPeriod(tp) and (exitLoop = 0)},
4542   
4543  *   7a. Reset all sets, parameters and variables -------------------------------
4544      option clear = currTP ;
4545  *   Generation variables
4546      option clear = GENERATION ;
4547      option clear = GENERATIONBLOCK ;
4548  *   Purchase variables
4549      option clear = PURCHASE ;
4550      option clear = PURCHASEBLOCK ;
4551      option clear = PURCHASEILR ;
4552      option clear = PURCHASEILRBLOCK ;
4553  *   Network variables
4554      option clear = ACNODENETINJECTION ;
4555      option clear = ACNODEANGLE ;
4556      option clear = ACBRANCHFLOW ;
4557      option clear = ACBRANCHFLOWDIRECTED ;
4558      option clear = ACBRANCHLOSSESDIRECTED ;
4559      option clear = ACBRANCHFLOWBLOCKDIRECTED ;
4560      option clear = ACBRANCHLOSSESBLOCKDIRECTED ;
4561      option clear = ACBRANCHFLOWDIRECTED_INTEGER ;
4562      option clear = HVDCLINKFLOW ;
4563      option clear = HVDCLINKLOSSES ;
4564      option clear = LAMBDA ;
4565      option clear = LAMBDAINTEGER ;
4566      option clear = HVDCLINKFLOWDIRECTION_INTEGER ;
4567      option clear = HVDCPOLEFLOW_INTEGER ;
4568  *   Risk/Reserve variables
4569      option clear = RISKOFFSET ;
4570      option clear = HVDCREC ;
4571      option clear = ISLANDRISK ;
4572      option clear = RESERVEBLOCK ;
4573      option clear = RESERVE ;
4574      option clear = ISLANDRESERVE;
4575  *   NMIR variables
4576      option clear = SHAREDNFR ;
4577      option clear = SHAREDRESERVE ;
4578      option clear = HVDCSENT ;
4579      option clear = RESERVESHAREEFFECTIVE ;
4580      option clear = RESERVESHARERECEIVED ;
4581      option clear = RESERVESHARESENT ;
4582      option clear = HVDCSENDING ;
4583      option clear = INZONE ;
4584      option clear = HVDCSENTINSEGMENT ;
4585      option clear = HVDCRESERVESENT ;
4586      option clear = HVDCSENTLOSS ;
4587      option clear = HVDCRESERVELOSS ;
4588      option clear = LAMBDAHVDCENERGY ;
4589      option clear = LAMBDAHVDCRESERVE ;
4590      option clear = RESERVESHAREPENALTY ;
4591  *   Mixed constraint variables
4592      option clear = MIXEDCONSTRAINTVARIABLE ;
4593      option clear = MIXEDCONSTRAINTLIMIT2SELECT ;
4594  *   Objective
4595      option clear = NETBENEFIT ;
4596  *   Violation variables
4597      option clear = TOTALPENALTYCOST ;
4598      option clear = DEFICITBUSGENERATION ;
4599      option clear = SURPLUSBUSGENERATION ;
4600      option clear = DEFICITRESERVE ;
4601      option clear = DEFICITRESERVE_CE ;
4602      option clear = DEFICITRESERVE_ECE ;
4603      option clear = DEFICITBRANCHSECURITYCONSTRAINT ;
4604      option clear = SURPLUSBRANCHSECURITYCONSTRAINT ;
4605      option clear = DEFICITRAMPRATE ;
4606      option clear = SURPLUSRAMPRATE ;
4607      option clear = DEFICITACnodeCONSTRAINT ;
4608      option clear = SURPLUSACnodeCONSTRAINT ;
4609      option clear = DEFICITBRANCHFLOW ;
4610      option clear = SURPLUSBRANCHFLOW ;
4611      option clear = DEFICITMNODECONSTRAINT ;
4612      option clear = SURPLUSMNODECONSTRAINT ;
4613      option clear = DEFICITTYPE1MIXEDCONSTRAINT ;
4614      option clear = SURPLUSTYPE1MIXEDCONSTRAINT ;
4615      option clear = DEFICITGENERICCONSTRAINT ;
4616      option clear = SURPLUSGENERICCONSTRAINT ;
4617   
4618  *   Clear the pole circular branch flow flag
4619      option clear = circularBranchFlowExist ;
4620      option clear = poleCircularBranchFlowExist ;
4621      option clear = northHVDC ;
4622      option clear = southHVDC ;
4623      option clear = manualBranchSegmentMWFlow ;
4624      option clear = manualLossCalculation ;
4625      option clear = nonPhysicalLossExist ;
4626      option clear = modelSolved ;
4627      option clear = LPmodelSolved ;
4628  *   Disconnected bus post-processing
4629      option clear = busGeneration ;
4630      option clear = busLoad ;
4631      option clear = busDisconnected ;
4632      option clear = busPrice ;
4633   
4634   
4635  *   End reset
4636   
4637   
4638  *   7b. Initialise current trade period and model data -------------------------
4639      currTP(tp)  $ sequentialSolve       = yes;
4640      currTP(tp1) $ (not sequentialSolve) = yes;
4641   
4642  *   Update initial MW if run NRSS, PRSS, NRSL, PRSL
4643      generationStart(offer(currTP(tp),o))
4644          $ (sum[ o1, generationStart(currTP,o1)] = 0)
4645          = sum[ dt $ (ord(dt) = ord(tp)-1), o_offerEnergy_TP(dt,o) ] ;
4646  *   Calculation of generation upper limits due to ramp rate limits
4647  *   Calculation 5.3.1.2. - For primary-secondary offers, only primary offer
4648  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4649      rampTimeUp(offer(currTP(tp),o))
4650          $ { (not hasPrimaryOffer(offer)) and rampRateUp(offer) }
4651          = Min[ i_tradingPeriodLength , ( generationMaximum(offer)
4652                                         - generationStart(offer)
4653                                         ) / rampRateUp(offer)
4654               ] ;
4655   
4656  *   Calculation 5.3.1.3. - For primary-secondary offers, only primary offer
4657  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4658      generationEndUp(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4659          = generationStart(offer) + rampRateUp(offer)*rampTimeUp(offer) ;
4660   
4661   
4662  *   Calculation of generation lower limits due to ramp rate limits
4663   
4664  *   Calculation 5.3.2.2. - For primary-secondary offers, only primary offer
4665  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4666      rampTimeDown(offer(currTP(tp),o))
4667          $ { (not hasPrimaryOffer(offer)) and rampRateDown(offer) }
4668          = Min[ i_tradingPeriodLength, ( generationStart(offer)
4669                                        - generationMinimum(offer)
4670                                        ) / rampRateDown(offer)
4671               ] ;
4672   
4673  *   Calculation 5.3.2.3. - For primary-secondary offers, only primary offer
4674  *   initial MW and ramp rate is used - Reference: Transpower Market Services
4675      generationEndDown(offer(currTP(tp),o)) $ (not hasPrimaryOffer(offer))
4676          = Max[ 0, generationStart(offer)
4677                  - rampRateDown(offer)*rampTimeDown(offer) ] ;
4678   
4679  *   Additional pre-processing on parameters end
4680   
4681   
4682  *   7c. Updating the variable bounds before model solve ------------------------
4683   
4684  * TN - Pivot or Demand Analysis - revise input data
4687  * TN - Pivot or Demand Analysis - revise input data end
4688   
4689  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS ========================
4690   
4691  *   Offer blocks - Constraint 3.1.1.1
4692      GENERATIONBLOCK.up(validGenerationOfferBlock(currTP,o,trdBlk))
4693          = generationOfferMW(validGenerationOfferBlock) ;
4694   
4695      GENERATIONBLOCK.fx(currTP,o,trdBlk)
4696          $ (not validGenerationOfferBlock(currTP,o,trdBlk)) = 0 ;
4697   
4698  *   Constraint 3.1.1.2 - Fix the generation variable for generators
4699  *   that are not connected or do not have a non-zero energy offer
4700      GENERATION.fx(offer(currTP,o)) $ (not PositiveEnergyOffer(offer)) = 0 ;
4701   
4702  *   Constraint 5.1.1.3 - Set Upper Bound for Wind Offer - Tuong
4703      GENERATION.up(offer(currTP,o))
4704          $ { windOffer(offer) and priceResponsive(offer) }
4705          = min[ potentialMW(offer), ReserveGenerationMaximum(offer) ] ;
4706   
4707  *   Change to demand bid - Constraint 3.1.1.3 and 3.1.1.4
4708      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4709          $ (not UseDSBFDemandBidModel)
4710          = purchaseBidMW(validPurchaseBidBlock) ;
4711   
4712      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4713          $ (not UseDSBFDemandBidModel)
4714          = 0 ;
4715   
4716      PURCHASEBLOCK.up(validPurchaseBidBlock(currTP,bd,trdBlk))
4717          $ UseDSBFDemandBidModel
4718          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)>0];
4719   
4720      PURCHASEBLOCK.lo(validPurchaseBidBlock(currTP,bd,trdBlk))
4721          $ UseDSBFDemandBidModel
4722          = purchaseBidMW(currTP,bd,trdBlk) $ [purchaseBidMW(currTP,bd,trdBlk)<0];
4723   
4724      PURCHASEBLOCK.fx(currTP,bd,trdBlk)
4725          $ (not validPurchaseBidBlock(currTP,bd,trdBlk))
4726          = 0 ;
4727   
4728  *   Fix the purchase variable for purchasers that are not connected
4729  *   or do not have a non-zero purchase bid
4730      PURCHASE.fx(currTP,bd)
4731          $ (sum[trdBlk $ validPurchaseBidBlock(currTP,bd,trdBlk), 1] = 0) = 0 ;
4732   
4733  *======= GENERATION, DEMAND AND LOAD FORECAST EQUATIONS END ====================
4734   
4735   
4736  *======= HVDC TRANSMISSION EQUATIONS ===========================================
4737   
4738  *   Ensure that variables used to specify flow and losses on HVDC link are
4739  *   zero for AC branches and for open HVDC links.
4740      HVDCLINKFLOW.fx(currTP,br)   $ (not HVDClink(currTP,br)) = 0 ;
4741      HVDCLINKLOSSES.fx(currTP,br) $ (not HVDClink(currTP,br)) = 0 ;
4742   
4743  *   Apply an upper bound on the weighting parameter based on its definition
4744      LAMBDA.up(branch,bp) = 1 ;
4745   
4746  *   Ensure that the weighting factor value is zero for AC branches and for
4747  *   invalid loss segments on HVDC links
4748      LAMBDA.fx(HVDClink,bp)
4749          $ ( sum[fd $ validLossSegment(HVDClink,bp,fd),1] = 0 ) = 0 ;
4750      LAMBDA.fx(currTP,br,bp) $ (not HVDClink(currTP,br)) = 0 ;
4751   
4752  *======= HVDC TRANSMISSION EQUATIONS END =======================================
4753   
4754   
4755  *======= AC TRANSMISSION EQUATIONS =============================================
4756   
4757  *   Ensure that variables used to specify flow and losses on AC branches are
4758  *   zero for HVDC links branches and for open AC branches
4759      ACBRANCHFLOW.fx(currTP,br)              $ (not ACbranch(currTP,br)) = 0 ;
4760      ACBRANCHFLOWDIRECTED.fx(currTP,br,fd)   $ (not ACbranch(currTP,br)) = 0 ;
4761      ACBRANCHLOSSESDIRECTED.fx(currTP,br,fd) $ (not ACbranch(currTP,br)) = 0 ;
4762   
4763  *   Ensure directed block flow and loss block variables are zero for
4764  *   non-AC branches and invalid loss segments on AC branches
4765     ACBRANCHFLOWBLOCKDIRECTED.fx(currTP,br,los,fd)
4766         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4767   
4768     ACBRANCHLOSSESBLOCKDIRECTED.fx(currTP,br,los,fd)
4769         $ { not(ACbranch(currTP,br) and validLossSegment(currTP,br,los,fd)) } = 0 ;
4770   
4771   
4772  *   Constraint 3.3.1.10 - Ensure that the bus voltage angle for the buses
4773  *   corresponding to the reference nodes and the HVDC nodes are set to zero
4774      ACNODEANGLE.fx(currTP,b)
4775         $ sum[ n $ { NodeBus(currTP,n,b) and
4776                      (ReferenceNode(currTP,n) or HVDCnode(currTP,n)) }, 1 ] = 0 ;
4777   
4778  *======= AC TRANSMISSION EQUATIONS END =========================================
4779   
4780   
4781  *======= RISK & RESERVE EQUATIONS ==============================================
4782   
4783  *   Ensure that all the invalid reserve blocks are set to zero for offers and purchasers
4784      RESERVEBLOCK.fx(offer(currTP,o),trdBlk,resC,resT)
4785          $ (not validReserveOfferBlock(offer,trdBlk,resC,resT)) = 0 ;
4786   
4787      PURCHASEILRBLOCK.fx(bid(currTP,bd),trdBlk,resC)
4788          $ (not validPurchaseBidILRBlock(bid,trdBlk,resC)) = 0 ;
4789   
4790  *   Reserve block maximum for offers and purchasers - Constraint 3.4.3.2.
4791      RESERVEBLOCK.up(validReserveOfferBlock(currTP,o,trdBlk,resC,resT))
4792          = reserveOfferMaximum(validReserveOfferBlock) ;
4793   
4794      PURCHASEILRBLOCK.up(validPurchaseBidILRBlock(currTP,bd,trdBlk,resC))
4795          = purchaseBidILRMW(validPurchaseBidILRBlock) ;
4796   
4797  *   Fix the reserve variable for invalid reserve offers. These are offers that
4798  *   are either not connected to the grid or have no reserve quantity offered.
4799      RESERVE.fx(currTP,o,resC,resT)
4800          $ (not sum[ trdBlk $ validReserveOfferBlock(currTP,o,trdBlk,resC,resT), 1 ] ) = 0 ;
4801   
4802  *   Fix the purchase ILR variable for invalid purchase reserve offers. These are
4803  *   offers that are either not connected to the grid or have no reserve quantity offered.
4804      PURCHASEILR.fx(currTP,bd,resC)
4805          $ (not sum[ trdBlk $ validPurchaseBidILRBlock(currTP,bd,trdBlk,resC), 1 ] ) = 0 ;
4806   
4807  *   Risk offset fixed to zero for those not mapped to corresponding mixed constraint variable
4808      RISKOFFSET.fx(currTP,ild,resC,riskC)
4809          $ { useMixedConstraintRiskOffset and useMixedConstraint(currTP) and
4810              (not sum[ t1MixCstr $ Type1MixCstrReserveMap(t1MixCstr,ild,resC,riskC),1])
4811            } = 0 ;
4812   
4813  *   Fix the appropriate deficit variable to zero depending on
4814  *   whether the different CE and ECE CVP flag is set
4815      DEFICITRESERVE.fx(currTP,ild,resC) $ diffCeECeCVP = 0 ;
4816      DEFICITRESERVE_CE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4817      DEFICITRESERVE_ECE.fx(currTP,ild,resC) $ (not diffCeECeCVP) = 0 ;
4818   
4819  *   Virtual reserve
4820      VIRTUALRESERVE.up(currTP,ild,resC) = virtualReserveMax(currTP,ild,resC) ;
4821   
4822  * TN - The code below is used to set bus deficit generation <= total bus load (positive)
          DEFICITBUSGENERATION.up(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] > 0 )
              = sum[ NodeBus(currTP,n,b)
                   , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                   ]  ;
          DEFICITBUSGENERATION.fx(currTP,b)
              $ ( sum[ NodeBus(currTP,n,b)
                     , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
                     ] <= 0 )
              = 0 ;
4837  *   NMIR project variables
4838      HVDCSENT.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4839      HVDCSENTLOSS.fx(currTP,ild) $ (HVDCCapacity(currTP,ild) = 0) = 0 ;
4840   
4841  *   (3.4.2.3) - SPD version 11.0
4842      SHAREDNFR.up(currTP,ild) = Max[0,sharedNFRMax(currTP,ild)] ;
4843   
4844  *   No forward reserve sharing if HVDC capacity is zero
4845      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4846          $ { (HVDCCapacity(currTP,ild) = 0) and (ord(rd) = 1) } = 0 ;
4847   
4848  *   No forward reserve sharing if reserve sharing is disabled
4849      RESERVESHARESENT.fx(currTP,ild,resC,rd)
4850          $ (reserveShareEnabled(currTP,resC)=0) = 0;
4851   
4852  *   No reserve sharing to cover HVDC risk
4853      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCrisk) = 0;
4854      RESERVESHAREEFFECTIVE.fx(currTP,ild,resC,HVDCsecRisk) = 0;
4855   
4856  *   (3.4.2.16) - SPD version 11 - no RP zone if reserve round power disabled
4857      INZONE.fx(currTP,ild,resC,z)
4858          $ {(ord(z) = 1) and (not reserveRoundPower(currTP,resC))} = 0;
4859   
4860  *   (3.4.2.17) - SPD version 11 - no no-reserve zone for SIR zone if reserve RP enabled
4861      INZONE.fx(currTP,ild,resC,z)
4862          $ {(ord(resC)=2) and (ord(z)=2) and reserveRoundPower(currTP,resC)} = 0;
4863   
4864  *   Fixing Lambda integer variable for energy sent
4865      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ { (HVDCCapacity(currTP,ild) = 0)
4866                                          and (ord(bp) = 1) } = 1 ;
4867   
4868      LAMBDAHVDCENERGY.fx(currTP,ild,bp) $ (ord(bp) > 7) = 0 ;
4869   
4870  * To be reviewed NMIR
4871      LAMBDAHVDCRESERVE.fx(currTP,ild,resC,rd,rsbp)
4872          $ { (HVDCCapacity(currTP,ild) = 0)
4873          and (ord(rsbp) = 7) and (ord(rd) = 1) } = 1 ;
4874   
4875      LAMBDAHVDCRESERVE.fx(currTP,ild1,resC,rd,rsbp)
4876          $ { (sum[ ild $ (not sameas(ild,ild1)), HVDCCapacity(currTP,ild) ] = 0)
4877          and (ord(rsbp) < 7) and (ord(rd) = 2) } = 0 ;
4878  ;
4879   
4880   
4881  *======= RISK & RESERVE EQUATIONS END ==========================================
4882   
4883   
4884  *======= MIXED CONSTRAINTS =====================================================
4885   
4886  *   Mixed constraint
4887      MIXEDCONSTRAINTVARIABLE.fx(currTP,t1MixCstr)
4888          $ (not i_type1MixedConstraintVarWeight(t1MixCstr)) = 0 ;
4889   
4890  *======= MIXED CONSTRAINTS END =================================================
4891   
4892  *   Updating the variable bounds before model solve end
4893   
4894   
4895  *   7d. Solve Models
4896   
4897  *   Solve the LP model ---------------------------------------------------------
4898      if( (Sum[currTP, VSPDModel(currTP)] = 0),
4899   
4900          if( UseShareReserve,
4901              option bratio = 1 ;
4902              vSPD_NMIR.Optfile = 1 ;
4903              vSPD_NMIR.optcr = MIPOptimality ;
4904              vSPD_NMIR.reslim = MIPTimeLimit ;
4905              vSPD_NMIR.iterlim = MIPIterationLimit ;
4906              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
4907  *           Set the model solve status
4908              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
4909                                 or (vSPD_NMIR.modelstat = 8) )
4910                              and ( vSPD_NMIR.solvestat = 1 ) } ;
4911          else
4912              option bratio = 1 ;
4913              vSPD.reslim = LPTimeLimit ;
4914              vSPD.iterlim = LPIterationLimit ;
4915              solve vSPD using lp maximizing NETBENEFIT ;
4916  *           Set the model solve status
4917              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
4918          )
4919   
4920  *       Post a progress message to the console and for use by EMI.
4921          if((ModelSolved = 1) and (sequentialSolve = 0),
4922              putclose runlog 'The case: RTD_20211202_RTP '
4923                              'is solved successfully.'/
4924                              'Objective function value: '
4925                              NETBENEFIT.l:<12:1 /
4926                              'Violation Cost          : '
4927                              TOTALPENALTYCOST.l:<12:1 /
4928          elseif((ModelSolved = 0) and (sequentialSolve = 0)),
4929              putclose runlog 'The case: RTD_20211202_RTP '
4930                              'is solved unsuccessfully.'/
4931          ) ;
4932   
4933          if((ModelSolved = 1) and (sequentialSolve = 1),
4934              loop(currTP,
4935                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
4936                                  'is solved successfully.'/
4937                                  'Objective function value: '
4938                                  NETBENEFIT.l:<12:1 /
4939                                  'Violations cost         : '
4940                                  TOTALPENALTYCOST.l:<12:1 /
4941              ) ;
4942          elseif((ModelSolved = 0) and (sequentialSolve = 1)),
4943              loop(currTP,
4944                  unsolvedPeriod(currTP) = no;
4945                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
4946                                  'is solved unsuccessfully.'/
4947              ) ;
4948   
4949          ) ;
4950  *   Solve the LP model end -----------------------------------------------------
4951   
4952   
4953  *   Solve the VSPD_MIP model ---------------------------------------------------
4954      elseif (Sum[currTP, VSPDModel(currTP)] = 1),
4955  *       Fix the values of the integer variables that are not needed
4956          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
4957              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
4958   
4959  *       Fix the integer AC branch flow variable to zero for invalid branches
4960          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
4961              $ (not branch(currTP,br)) = 0 ;
4962   
4963  *       Apply an upper bound on the integer weighting parameter
4964          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
4965   
4966  *       Ensure that the weighting factor value is zero for AC branches
4967  *       and for invalid loss segments on HVDC links
4968          LAMBDAINTEGER.fx(branch(currTP,br),bp)
4969              $ { ACbranch(branch)
4970              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
4971                } = 0 ;
4972   
4973  *       Fix the lambda integer variable to zero for invalid branches
4974          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
4975   
4976  *       Fix the value of some binary variables used in the mixed constraints
4977  *       that have no alternate limit
4978          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
4979              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
4980   
4981          option bratio = 1 ;
4982          vSPD_MIP.Optfile = 1 ;
4983          vSPD_MIP.optcr = MIPOptimality ;
4984          vSPD_MIP.reslim = MIPTimeLimit ;
4985          vSPD_MIP.iterlim = MIPIterationLimit ;
4986          solve vSPD_MIP using mip maximizing NETBENEFIT ;
4987  *       Set the model solve status
4988          ModelSolved = 1 $ { [ (vSPD_MIP.modelstat = 1) or
4989                                (vSPD_MIP.modelstat = 8)
4990                              ]
4991                              and
4992                              [ vSPD_MIP.solvestat = 1 ]
4993                            } ;
4994   
4995  *       Post a progress message for use by EMI.
4996          if(ModelSolved = 1,
4997              loop(currTP,
4998                  unsolvedPeriod(currTP) = no;
4999                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5000                                  'is solved successfully for FULL integer.'/
5001                                  'Objective function value: '
5002                                  NETBENEFIT.l:<12:1 /
5003                                  'Violations              : '
5004                                  TOTALPENALTYCOST.l:<12:1 /
5005              ) ;
5006          else
5007              loop(currTP,
5008                  unsolvedPeriod(currTP) = yes;
5009                  VSPDModel(currTP) = 4;
5010                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5011                                  'is solved unsuccessfully for FULL integer.'/
5012              ) ;
5013          ) ;
5014  *   Solve the vSPD_MIP model end -----------------------------------------------
5015   
5016   
5017  *   Solve the vSPD_BranchFlowMIP -----------------------------------------------
5018      elseif (Sum[currTP, VSPDModel(currTP)] = 2),
5019  *       Fix the values of these integer variables that are not needed
5020          ACBRANCHFLOWDIRECTED_INTEGER.fx(branch(currTP,br),fd)
5021              $ { (not ACbranch(currTP,br)) or (not LossBranch(branch)) } = 0 ;
5022   
5023  *       Fix the integer AC branch flow variable to zero for invalid branches
5024          ACBRANCHFLOWDIRECTED_INTEGER.fx(currTP,br,fd)
5025              $ (not branch(currTP,br)) = 0 ;
5026   
5027  *       Apply an upper bound on the integer weighting parameter
5028          LAMBDAINTEGER.up(branch(currTP,br),bp) = 1 ;
5029   
5030  *       Ensure that the weighting factor value is zero for AC branches
5031  *       and for invalid loss segments on HVDC links
5032          LAMBDAINTEGER.fx(branch(currTP,br),bp)
5033              $ { ACbranch(branch)
5034              or ( sum[fd $ validLossSegment(branch,bp,fd),1 ] = 0 )
5035                } = 0 ;
5036   
5037  *       Fix the lambda integer variable to zero for invalid branches
5038          LAMBDAINTEGER.fx(currTP,br,bp) $ (not branch(currTP,br)) = 0 ;
5039   
5040          option bratio = 1 ;
5041          vSPD_BranchFlowMIP.Optfile = 1 ;
5042          vSPD_BranchFlowMIP.optcr = MIPOptimality ;
5043          vSPD_BranchFlowMIP.reslim = MIPTimeLimit ;
5044          vSPD_BranchFlowMIP.iterlim = MIPIterationLimit ;
5045          solve vSPD_BranchFlowMIP using mip maximizing NETBENEFIT ;
5046  *       Set the model solve status
5047          ModelSolved = 1 $ { [ ( vSPD_BranchFlowMIP.modelstat = 1) or
5048                                (vSPD_BranchFlowMIP.modelstat = 8)
5049                              ]
5050                              and
5051                              [ vSPD_BranchFlowMIP.solvestat = 1 ]
5052                            } ;
5053   
5054  *       Post a progress message for use by EMI.
5055          if(ModelSolved = 1,
5056   
5057  *           TN - Replacing invalid prices after SOS1 - Flag to show the period that required SOS1 solve
5058              vSPD_SOS1_Solve(currTP)  = yes;
5059   
5060              loop(currTP,
5061                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5062                                  'is solved successfully for branch integer.'/
5063                                  'Objective function value: '
5064                                  NETBENEFIT.l:<12:1 /
5065                                  'Violations cost         : '
5066                                  TOTALPENALTYCOST.l:<12:1 /
5067              ) ;
5068          else
5069              loop(currTP,
5070                  unsolvedPeriod(currTP) = yes;
5071                  VSPDModel(currTP) = 4;
5072                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5073                                  'is solved unsuccessfully for branch integer.'/
5074              ) ;
5075          ) ;
5076  *   Solve the vSPD_BranchFlowMIP model end -------------------------------------
5077   
5078   
5079  *   Solve the vSPD_MixedConstraintMIP model ------------------------------------
5080      elseif (Sum[currTP, VSPDModel(currTP)] = 3),
5081  *       Fix the value of some binary variables used in the mixed constraints
5082  *       that have no alternate limit
5083          MIXEDCONSTRAINTLIMIT2SELECT.fx(Type1MixedConstraint(currTP,t1MixCstr))
5084              $ (not Type1MixedConstraintCondition(Type1MixedConstraint)) = 0 ;
5085   
5086  *       Use the advanced basis here
5087          option bratio = 0.25 ;
5088          vSPD_MixedConstraintMIP.Optfile = 1 ;
5089  *       Set the optimality criteria for the MIP
5090          vSPD_MixedConstraintMIP.optcr = MIPOptimality ;
5091          vSPD_MixedConstraintMIP.reslim = MIPTimeLimit ;
5092          vSPD_MixedConstraintMIP.iterlim = MIPIterationLimit ;
5093  *       Solve the model
5094          solve vSPD_MixedConstraintMIP using mip maximizing NETBENEFIT ;
5095  *       Set the model solve status
5096          ModelSolved = 1 $ { [ (vSPD_MixedConstraintMIP.modelstat = 1) or
5097                                (vSPD_MixedConstraintMIP.modelstat = 8)
5098                              ]
5099                              and
5100                              [ vSPD_MixedConstraintMIP.solvestat = 1 ]
5101                            } ;
5102   
5103  *       Post a progress message for use by EMI.
5104          if(ModelSolved = 1,
5105              loop(currTP,
5106                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5107                                  'is solved successfully for '
5108                                  'mixed constraint integer.'/
5109                                  'Objective function value: '
5110                                  NETBENEFIT.l:<12:1 /
5111                                  'Violations cost         : '
5112                                  TOTALPENALTYCOST.l:<12:1 /
5113              ) ;
5114          else
5115              loop(currTP,
5116                  unsolvedPeriod(currTP) = yes;
5117                  VSPDModel(currTP) = 1;
5118                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ') '
5119                                  'is solved unsuccessfully for '
5120                                  'mixed constraint integer.'/
5121              ) ;
5122          ) ;
5123  *   Solve the vSPD_MixedConstraintMIP model end --------------------------------
5124   
5125   
5126  *   Solve the LP model and stop ------------------------------------------------
5127      elseif (Sum[currTP, VSPDModel(currTP)] = 4),
5128   
5129          if( UseShareReserve,
5130              option bratio = 1 ;
5131              vSPD_NMIR.Optfile = 1 ;
5132              vSPD_NMIR.optcr = MIPOptimality ;
5133              vSPD_NMIR.reslim = MIPTimeLimit ;
5134              vSPD_NMIR.iterlim = MIPIterationLimit ;
5135              solve vSPD_NMIR using mip maximizing NETBENEFIT ;
5136  *           Set the model solve status
5137              ModelSolved = 1 $ { ( (vSPD_NMIR.modelstat = 1)
5138                                 or (vSPD_NMIR.modelstat = 8) )
5139                              and ( vSPD_NMIR.solvestat = 1 ) } ;
5140          else
5141              option bratio = 1 ;
5142              vSPD.reslim = LPTimeLimit ;
5143              vSPD.iterlim = LPIterationLimit ;
5144              solve vSPD using lp maximizing NETBENEFIT ;
5145  *           Set the model solve status
5146              ModelSolved = 1 $ { (vSPD.modelstat = 1) and (vSPD.solvestat = 1) };
5147          )
5148   
5149  *       Post a progress message for use by EMI.
5150          if( ModelSolved = 1,
5151              loop(currTP,
5152                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl ')'
5153                                  ' integer resolve was unsuccessful.' /
5154                                  'Reverting back to linear solve and '
5155                                  'solve successfully. ' /
5156                                  'Objective function value: '
5157                                  NETBENEFIT.l:<12:1 /
5158                                  'Violations cost         : '
5159                                  TOTALPENALTYCOST.l:<12:1 /
5160                                  'Solution may have circulating flows '
5161                                  'and/or non-physical losses.' /
5162              ) ;
5163          else
5164              loop(currTP,
5165                  putclose runlog 'The case: RTD_20211202_RTP (' currTP.tl
5166                                  ') integer solve was unsuccessful. '
5167                                  'Reverting back to linear solve. '
5168                                  'Linear solve unsuccessful.' /
5169              ) ;
5170          ) ;
5171   
5172          unsolvedPeriod(currTP) = no;
5173   
5174  *   Solve the LP model and stop end --------------------------------------------
5175   
5176      ) ;
5177  *   Solve the models end
5178   
5179   
5180   
5181  *   6e. Check if the LP results are valid --------------------------------------
5182      if((ModelSolved = 1),
5183          useBranchFlowMIP(currTP) = 0 ;
5184          useMixedConstraintMIP(currTP) = 0 ;
5185  *       Check if there is no branch circular flow and non-physical losses
5186          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=3) } ,
5187   
5188  *           Check if there are circulating branch flows on loss AC branches
5189              circularBranchFlowExist(ACbranch(currTP,br))
5190                  $ { LossBranch(ACbranch) and
5191                      [ ( sum[ fd, ACBRANCHFLOWDIRECTED.l(ACbranch,fd) ]
5192                        - abs(ACBRANCHFLOW.l(ACbranch))
5193                        ) > circularBranchFlowTolerance
5194                      ]
5195                    } = 1 ;
5196   
5197  *           Determine the circular branch flow flag on each HVDC pole
5198              TotalHVDCpoleFlow(currTP,pole)
5199                  = sum[ br $ HVDCpoleBranchMap(pole,br)
5200                       , HVDCLINKFLOW.l(currTP,br) ] ;
5201   
5202              MaxHVDCpoleFlow(currTP,pole)
5203                  = smax[ br $ HVDCpoleBranchMap(pole,br)
5204                        , HVDCLINKFLOW.l(currTP,br) ] ;
5205   
5206              poleCircularBranchFlowExist(currTP,pole)
5207                  $ { ( TotalHVDCpoleFlow(currTP,pole)
5208                      - MaxHVDCpoleFlow(currTP,pole)
5209                      ) > circularBranchFlowTolerance
5210                    } = 1 ;
5211   
5212  *           Check if there are circulating branch flows on HVDC
5213              NorthHVDC(currTP)
5214                  = sum[ (ild,b,br) $ { (ord(ild) = 2) and
5215                                        i_tradePeriodBusIsland(currTP,b,ild) and
5216                                        HVDClinkSendingBus(currTP,br,b) and
5217                                        HVDCpoles(currTP,br)
5218                                      }, HVDCLINKFLOW.l(currTP,br)
5219                       ] ;
5220   
5221              SouthHVDC(currTP)
5222                  = sum[ (ild,b,br) $ { (ord(ild) = 1) and
5223                                        i_tradePeriodBusIsland(currTP,b,ild) and
5224                                        HVDClinkSendingBus(currTP,br,b) and
5225                                        HVDCpoles(currTP,br)
5226                                      }, HVDCLINKFLOW.l(currTP,br)
5227                       ] ;
5228   
5229              circularBranchFlowExist(currTP,br)
5230                  $ { HVDCpoles(currTP,br) and LossBranch(currTP,br) and
5231                     (NorthHVDC(currTP) > circularBranchFlowTolerance) and
5232                     (SouthHVDC(currTP) > circularBranchFlowTolerance)
5233                    } = 1 ;
5234   
5235  *           Check if there are non-physical losses on HVDC links
5236              ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
5237                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5238                  and validLossSegment(currTP,br,los,fd) }
5239                  = Min[ Max( 0,
5240                              [ abs(HVDCLINKFLOW.l(HVDClink))
5241                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5242                              ]
5243                            ),
5244                         ( LossSegmentMW(HVDClink,los,fd)
5245                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5246                         )
5247                       ] ;
5248   
5249              ManualLossCalculation(LossBranch(HVDClink(currTP,br)))
5250                  = sum[ (los,fd) $ validLossSegment(currTP,br,los,fd)
5251                                  , LossSegmentFactor(HVDClink,los,fd)
5252                                  * ManualBranchSegmentMWFlow(HVDClink,los,fd)
5253                       ] ;
5254   
5255              NonPhysicalLossExist(LossBranch(HVDClink(currTP,br)))
5256                  $ { abs( HVDCLINKLOSSES.l(HVDClink)
5257                         - ManualLossCalculation(HVDClink)
5258                         ) > NonPhysicalLossTolerance
5259                    } = 1 ;
5260   
5261  *           Set UseBranchFlowMIP = 1 if the number of circular branch flow
5262  *           and non-physical loss branches exceeds the specified tolerance
5263              useBranchFlowMIP(currTP)
5264                  $ { ( sum[ br $ { ACbranch(currTP,br) and LossBranch(currTP,br) }
5265                                , resolveCircularBranchFlows
5266                                * circularBranchFlowExist(currTP,br)
5267                           ]
5268                      + sum[ br $ { HVDClink(currTP,br) and LossBranch(currTP,br) }
5269                                , (1 - AllowHVDCroundpower(currTP))
5270                                * resolveCircularBranchFlows
5271                                * circularBranchFlowExist(currTP,br)
5272                                + resolveHVDCnonPhysicalLosses
5273                                * NonPhysicalLossExist(currTP,br)
5274                           ]
5275                      + sum[ pole, resolveCircularBranchFlows
5276                                 * poleCircularBranchFlowExist(currTP,pole)
5277                           ]
5278                       ) > UseBranchFlowMIPTolerance
5279                                         } = 1 ;
5280   
5281  *       Check if there is no branch circular flow and non-physical losses end
5282          );
5283   
5284   
5285  *       Check if there is mixed constraint integer is required
5286          Loop( currTP $ { (VSPDModel(currTP)=0) or (VSPDModel(currTP)=2) } ,
5287   
5288  *           Check if integer variables are needed for mixed constraint
5289              if( useMixedConstraintRiskOffset,
5290                  HVDChalfPoleSouthFlow(currTP)
5291                      $ { sum[ i_type1MixedConstraintBranchCondition(t1MixCstr,br)
5292                               $ HVDChalfPoles(currTP,br), HVDCLINKFLOW.l(currTP,br)
5293                             ] > MixedMIPTolerance
5294                        } = 1 ;
5295   
5296  *               Only calculate violation if the constraint limit is non-zero
5297                  Type1MixedConstraintLimit2Violation(Type1MixedConstraintCondition)
5298                      $ (Type1MixedConstraintLimit2(Type1MixedConstraintCondition) > 0)
5299                      = [ Type1MixedConstraintLE.l(Type1MixedConstraintCondition)
5300                        - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5301                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = -1)
5302                      + [ Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5303                        - Type1MixedConstraintGE.l(Type1MixedConstraintCondition)
5304                        ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 1)
5305                      + abs[ Type1MixedConstraintEQ.l(Type1MixedConstraintCondition)
5306                           - Type1MixedConstraintLimit2(Type1MixedConstraintCondition)
5307                           ] $ (Type1MixedConstraintSense(Type1MixedConstraintCondition) = 0) ;
5308   
5309  *               Integer constraints are needed if southward flow on half-poles AND
5310  *               constraint level exceeds the mixed constraint limit2 value
5311                  useMixedConstraintMIP(currTP)
5312                      $ { HVDChalfPoleSouthFlow(currTP) and
5313                          sum[ t1MixCstr
5314                               $ { Type1MixedConstraintLimit2Violation(currTP,t1MixCstr)
5315                                 > MixedMIPTolerance }, 1
5316                             ]
5317                        } = 1 ;
5318              ) ;
5319   
5320  *       Check if there is mixed constraint integer is required end
5321          );
5322   
5323  *       A period is unsolved if MILP model is required
5324          unsolvedPeriod(currTP) = yes $ [ UseBranchFlowMIP(currTP)
5325                                         + UseMixedConstraintMIP(currTP)
5326                                         ] ;
5327   
5328  *       Post a progress message for use by EMI. Reverting to the sequential mode for integer resolves.
5329          loop( unsolvedPeriod(currTP),
5330              if( UseBranchFlowMIP(currTP)*UseMixedConstraintMIP(currTP) >= 1,
5331                  VSPDModel(currTP) = 1;
5332                  putclose runlog 'The case: RTD_20211202_RTP requires a'
5333                                  'VSPD_MIP resolve for period ' currTP.tl
5334                                  '. Switching Vectorisation OFF.' /
5335   
5336              elseif UseBranchFlowMIP(currTP) >= 1,
5337                  if( VSPDModel(currTP) = 0,
5338                      VSPDModel(currTP) = 2;
5339                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5340                                      'vSPD_BranchFlowMIP resolve for period '
5341                                      currTP.tl '. Switching Vectorisation OFF.'/
5342                  elseif VSPDModel(currTP) = 3,
5343                      VSPDModel(currTP) = 1;
5344                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5345                                      'VSPD_MIP resolve for period ' currTP.tl
5346                                      '. Switching Vectorisation OFF.' /
5347                  );
5348   
5349              elseif UseMixedConstraintMIP(currTP) >= 1,
5350                  if( VSPDModel(currTP) = 0,
5351                      VSPDModel(currTP) = 3;
5352                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5353                                      'vSPD_MixedConstraintMIP resolve for period '
5354                                      currTP.tl '. Switching Vectorisation OFF.' /
5355                  elseif VSPDModel(currTP) = 2,
5356                      VSPDModel(currTP) = 1;
5357                      putclose runlog 'The case: RTD_20211202_RTP requires a '
5358                                      'VSPD_MIP resolve for period ' currTP.tl
5359                                      '. Switching Vectorisation OFF.' /
5360                  );
5361   
5362              ) ;
5363   
5364          ) ;
5365   
5366          sequentialSolve $ Sum[ unsolvedPeriod(currTP), 1 ] = 1 ;
5367          exitLoop = 1 $ Sum[ unsolvedPeriod(currTP), 1 ];
5368   
5369  *   Check if the LP results are valid end
5370      ) ;
5371   
5372   
5373   
5374  *   6f. Check for disconnected nodes and adjust prices accordingly -------------
5375   
5376  *   See Rule Change Proposal August 2008 - Disconnected nodes available at
5377  *   www.systemoperator.co.nz/reports-papers
          Disconnected nodes are defined as follows:
          Pre-MSP: Have no generation or load, are disconnected from the network
                   and has a price = CVP.
          Post-MSP: Indication to SPD whether a bus is dead or not.
                    Dead buses are not processed by the SPD solved
          Disconnected nodes' prices set by the post-process with the following rules:
          Scenario A/B/D: Price for buses in live electrical island determined
                          by the solved
          Scenario C/F/G/H/I: Buses in the dead electrical island with:
              a. Null/zero load: Marked as disconnected with $0 price.
              b. Positive load: Price = CVP for deficit generation
              c. Negative load: Price = -CVP for surplus generation
          Scenario E: Price for bus in live electrical island with zero load needs to
                      be adjusted since actually is disconnected.
       
          The Post-MSP implementation imply a mapping of a bus to an electrical island
          and an indication of whether this electrical island is live of dead.
          The correction of the prices is performed by SPD.
       
          Update the disconnected nodes logic to use the time-stamped
          i_useBusNetworkModel flag. This allows disconnected nodes logic to work
          with both pre and post-MSP data structure in the same gdx file
5402   
5403      busGeneration(bus(currTP,b))
5404          = sum[ (o,n) $ { offerNode(currTP,o,n) and NodeBus(currTP,n,b) }
5405               , NodeBusAllocationFactor(currTP,n,b) * GENERATION.l(currTP,o)
5406               ] ;
5407   
5408      busLoad(bus(currTP,b))
5409          = sum[ NodeBus(currTP,n,b)
5410               , NodeBusAllocationFactor(currTP,n,b) * NodeDemand(currTP,n)
5411               ] ;
5412   
5413      busPrice(bus(currTP,b)) $ { not sum[ NodeBus(HVDCnode(currTP,n),b), 1 ] }
5414          = ACnodeNetInjectionDefinition2.m(currTP,b) ;
5415   
5416      busPrice(bus(currTP,b)) $ sum[ NodeBus(HVDCnode(currTP,n),b), 1 ]
5417          = DCNodeNetInjection.m(currTP,b) ;
5418   
5419      if((disconnectedNodePriceCorrection = 1),
5420  *       Pre-MSP case
5421          busDisconnected(bus(currTP,b)) $ (i_useBusNetworkModel(currTP) = 0)
5422              = 1 $ { (busGeneration(bus) = 0) and  (busLoad(bus) = 0) and
5423                      ( not sum[ br $ { branchBusConnect(currTP,br,b) and
5424                                        branch(currTP,br)
5425                                      }, 1 ]
5426                      )
5427                    } ;
5428   
5429  *       Post-MSP cases
5430  *       Scenario C/F/G/H/I:
5431          busDisconnected(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1)
5432                                         and (busLoad(bus) = 0)
5433                                         and (busElectricalIsland(bus) = 0)
5434                                           } = 1 ;
5435  *       Scenario E:
5436          busDisconnected(bus(currTP,b))
5437              $ { ( sum[ b1 $ { busElectricalIsland(currTP,b1)
5438                              = busElectricalIsland(bus) }
5439                       , busLoad(currTP,b1) ] = 0
5440                  ) and
5441                  ( busElectricalIsland(bus) > 0 ) and
5442                  ( i_useBusNetworkModel(currTP) = 1 )
5443                } = 1 ;
5444  *       Set prices at dead buses with non-zero load
5445          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5446                                      (busLoad(bus) > 0) and
5447                                      (busElectricalIsland(bus)= 0)
5448                                    } = DeficitBusGenerationPenalty ;
5449   
5450          busPrice(bus(currTP,b)) $ { (i_useBusNetworkModel(currTP) = 1) and
5451                                      (busLoad(bus) < 0) and
5452                                      (busElectricalIsland(bus)= 0)
5453                                    } = -SurplusBusGenerationPenalty ;
5454   
5455  *       Set price at identified disconnected buses to 0
5456          busPrice(bus)$busDisconnected(bus) = 0 ;
5457      ) ;
5458   
5459  * End Check for disconnected nodes and adjust prices accordingly
5460   
5461  * TN - Replacing invalid prices after SOS1
5462  *   6f0. Replacing invalid prices after SOS1 (6.1.3)----------------------------
5463      if ( vSPD_SOS1_Solve(tp),
5464           busSOSinvalid(tp,b)
5465             = 1 $ { [ ( busPrice(tp,b) = 0 )
5466                      or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5467                      or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
5468                       ]
5469                   and bus(tp,b)
5470                   and [ not busDisconnected(tp,b) ]
5471  *                 and [ busLoad(tp,b) = 0 ]
5472  *                 and [ busGeneration(tp,b) = 0 ]
5473                   and [ busLoad(tp,b) = busGeneration(tp,b) ]
5474                   and [ sum[(br,fd)
5475                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5476                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5477                            ] = 0
5478                       ]
5479                   and [ sum[ br
5480                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5481                            , 1
5482                            ] > 0
5483                       ]
5484                     };
5485          numberofbusSOSinvalid(tp) = 2*sum[b, busSOSinvalid(tp,b)];
5486          While ( sum[b, busSOSinvalid(tp,b)] < numberofbusSOSinvalid(tp) ,
5487              numberofbusSOSinvalid(tp) = sum[b, busSOSinvalid(tp,b)];
5488              busPrice(tp,b)
5489                $ { busSOSinvalid(tp,b)
5490                and ( sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5491                              and sum[ br $ { branch(tp,br)
5492                                          and BranchBusConnect(tp,br,b)
5493                                          and BranchBusConnect(tp,br,b1)
5494                                            }, 1
5495                                     ]
5496                               }, 1
5497                         ] > 0
5498                    )
5499                  }
5500                = sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5501                          and sum[ br $ { branch(tp,br)
5502                                      and BranchBusConnect(tp,br,b)
5503                                      and BranchBusConnect(tp,br,b1)
5504                                        }, 1 ]
5505                            }, busPrice(tp,b1)
5506                     ]
5507                / sum[ b1 $ { [ not busSOSinvalid(tp,b1) ]
5508                          and sum[ br $ { branch(tp,br)
5509                                      and BranchBusConnect(tp,br,b)
5510                                      and BranchBusConnect(tp,br,b1)
5511                                        }, 1 ]
5512                            }, 1
5513                     ];
5514   
5515              busSOSinvalid(tp,b)
5516                = 1 $ { [ ( busPrice(tp,b) = 0 )
5517                       or ( busPrice(tp,b) > 0.9 * deficitBusGenerationPenalty )
5518                       or ( busPrice(tp,b) < -0.9 * surplusBusGenerationPenalty )
5519                        ]
5520                    and bus(tp,b)
5521                    and [ not busDisconnected(tp,b) ]
5522  *                  and [ busLoad(tp,b) = 0 ]
5523  *                  and [ busGeneration(tp,b) = 0 ]
5524                    and [ busLoad(tp,b) = busGeneration(tp,b) ]
5525                    and [ sum[(br,fd)
5526                            $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5527                            , ACBRANCHFLOWDIRECTED.l(tp,br,fd)
5528                             ] = 0
5529                        ]
5530                    and [ sum[ br
5531                             $ { BranchBusConnect(tp,br,b) and branch(tp,br) }
5532                             , 1
5533                             ] > 0
5534                        ]
5535                      };
5536           );
5537      );
5538  *   End Replacing invalid prices after SOS1 (6.1.3) ----------------------------
5539   
5540   
5541  *   6g. Collect and store results of solved periods into output parameters -----
5542  * Note: all the price relating outputs such as costs and revenues are calculated in section 7.b
5543   
5545  *   Normal vSPD run post processing for reporting
5547      Loop i_dateTimeTradePeriodMap(dt,currTP) $ (not unsolvedPeriod(currTP)) do
5548  *   Reporting at trading period start
5549  *       Node level output
5550          o_node(dt,n) $ {Node(currTP,n) and (not HVDCnode(currTP,n))} = yes ;
5551   
5552          o_nodeGeneration_TP(dt,n) $ Node(currTP,n)
5553              = sum[ o $ offerNode(currTP,o,n), GENERATION.l(currTP,o) ] ;
5554   
5555          o_nodeLoad_TP(dt,n) $ Node(currTP,n)
5556             = NodeDemand(currTP,n)
5557             + Sum[ bd $ bidNode(currTP,bd,n), PURCHASE.l(currTP,bd) ];
5558   
5559          o_nodePrice_TP(dt,n) $ Node(currTP,n)
5560              = sum[ b $ NodeBus(currTP,n,b)
5561                   , NodeBusAllocationFactor(currTP,n,b) * busPrice(currTP,b)
5562                    ] ;
5563   
5564  *       Offer output
5565          o_offer(dt,o) $ offer(currTP,o) = yes ;
5566   
5567          o_offerEnergy_TP(dt,o) $ offer(currTP,o) = GENERATION.l(currTP,o) ;
5568   
5569          o_offerFIR_TP(dt,o) $ offer(currTP,o)
5570              = sum[ (resC,resT)$(ord(resC) = 1)
5571                   , RESERVE.l(currTP,o,resC,resT) ] ;
5572   
5573          o_offerSIR_TP(dt,o) $ offer(currTP,o)
5574              = sum[ (resC,resT)$(ord(resC) = 2)
5575                   , RESERVE.l(currTP,o,resC,resT) ] ;
5576   
5577  *       Bus level output
5578          o_bus(dt,b) $ { bus(currTP,b) and (not DCBus(currTP,b)) } = yes ;
5579   
5580          o_busGeneration_TP(dt,b) $ bus(currTP,b) = busGeneration(currTP,b) ;
5581   
5582          o_busLoad_TP(dt,b) $ bus(currTP,b)
5583              = busLoad(currTP,b)
5584              + Sum[ (bd,n) $ { bidNode(currTP,bd,n) and NodeBus(currTP,n,b) }
5585                   , PURCHASE.l(currTP,bd) ];
5586   
5587          o_busPrice_TP(dt,b) $ bus(currTP,b) = busPrice(currTP,b) ;
5588   
5589          o_busDeficit_TP(dt,b)$bus(currTP,b) = DEFICITBUSGENERATION.l(currTP,b) ;
5590   
5591          o_busSurplus_TP(dt,b)$bus(currTP,b) = SURPLUSBUSGENERATION.l(currTP,b) ;
5592   
5593  *       Node level output
5594   
5595          totalBusAllocation(dt,b) $ bus(currTP,b)
5596              = sum[ n $ Node(currTP,n), NodeBusAllocationFactor(currTP,n,b)];
5597   
5598          busNodeAllocationFactor(dt,b,n) $ (totalBusAllocation(dt,b) > 0)
5599              = NodeBusAllocationFactor(currTP,n,b) / totalBusAllocation(dt,b) ;
5600   
5601  * TN - post processing unmapped generation deficit buses start
      The following code is added post-process generation deficit bus that is not
      mapped to a pnode (BusNodeAllocationFactor  = 0). In post-processing, when a
      deficit is detected at a bus that does not map directly to a pnode, SPD creates
      a ZBR mapping by following zero impendence branches (ZBRs) until it reaches a
      pnode. The price at the deficit bus is assigned directly to the pnode,
      overwriting any weighted price that post-processing originally calculated for
      the pnode. This is based on email from Nic Deller <Nic.Deller@transpower.co.nz>
      on 25 Feb 2015.
      The code is modified again on 16 Feb 2016 to avoid infinite loop when there are
      many generation deficit buses.
      This code is used to post-process generation deficit bus that is not mapped to
5615          unmappedDeficitBus(dt,b) $ o_busDeficit_TP(dt,b)
5616              = yes $ (Sum[ n, busNodeAllocationFactor(dt,b,n)] = 0);
5617   
5618          changedDeficitBus(dt,b) = no;
5619   
5620          If Sum[b $ unmappedDeficitBus(dt,b), 1] then
5621   
5622              temp_busDeficit_TP(dt,b) = o_busDeficit_TP(dt,b);
5623   
5624              Loop b $ unmappedDeficitBus(dt,b) do
5625                  o_busDeficit_TP(dt,b1)
5626                    $ { Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5627                                and ( branchBusDefn(tp,br,b1,b)
5628                                   or branchBusDefn(tp,br,b,b1) )
5629                                  }, 1 ]
5630                      } = o_busDeficit_TP(dt,b1) + o_busDeficit_TP(dt,b) ;
5631   
5632                  changedDeficitBus(dt,b1)
5633                    $ Sum[ br $ { ( branchLossBlocks(tp,br)=0 )
5634                              and ( branchBusDefn(tp,br,b1,b)
5635                                 or branchBusDefn(tp,br,b,b1) )
5636                                }, 1 ] = yes;
5637   
5638                  unmappedDeficitBus(dt,b) = no;
5639                  changedDeficitBus(dt,b) = no;
5640                  o_busDeficit_TP(dt,b) = 0;
5641              EndLoop;
5642   
5643              Loop n $ sum[ b $ changedDeficitBus(dt,b)
5644                          , busNodeAllocationFactor(dt,b,n)] do
5645                  o_nodePrice_TP(dt,n) = deficitBusGenerationPenalty ;
5646                  o_nodeDeficit_TP(dt,n) = sum[ b $ busNodeAllocationFactor(dt,b,n),
5647                                                    busNodeAllocationFactor(dt,b,n)
5648                                                  * o_busDeficit_TP(dt,b) ] ;
5649              EndLoop;
5650   
5651              o_busDeficit_TP(dt,b) = temp_busDeficit_TP(dt,b);
5652          Endif;
5653  * TN - post processing unmapped generation deficit buses end
5654   
5655          o_nodeDeficit_TP(dt,n) $ Node(currTP,n)
5656              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5657                                            * DEFICITBUSGENERATION.l(currTP,b) ] ;
5658   
5659          o_nodeSurplus_TP(dt,n) $ Node(currTP,n)
5660              = sum[ b $ NodeBus(currTP,n,b), busNodeAllocationFactor(dt,b,n)
5661                                            * SURPLUSBUSGENERATION.l(currTP,b) ] ;
5662   
5663  *       branch output
5664          o_branch(dt,br) $ branch(currTP,br) = yes ;
5665   
5666          o_branchFlow_TP(dt,br) $ ACbranch(currTP,br) = ACBRANCHFLOW.l(currTP,br);
5667   
5668          o_branchFlow_TP(dt,br) $ HVDClink(currTP,br) = HVDCLINKFLOW.l(currTP,br);
5669   
5670          o_branchDynamicLoss_TP(dt,br) $  ACbranch(currTP,br)
5671              = sum[ fd, ACBRANCHLOSSESDIRECTED.l(currTP,br,fd) ] ;
5672   
5673          o_branchDynamicLoss_TP(dt,br) $ HVDClink(currTP,br)
5674              = HVDCLINKLOSSES.l(currTP,br) ;
5675   
5676          o_branchFixedLoss_TP(dt,br) $ branch(currTP,br)
5677              = branchFixedLoss(currTP,br) ;
5678   
5679          o_branchTotalLoss_TP(dt,br) $ branch(currTP,br)
5680              = o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br) ;
5681   
5682          o_branchFromBus_TP(dt,br,frB)
5683              $ { branch(currTP,br) and
5684                  sum[ toB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5685                } = yes ;
5686   
5687          o_branchToBus_TP(dt,br,toB)
5688              $ { branch(currTP,br) and
5689                  sum[ frB $ branchBusDefn(currTP,br,frB,toB), 1 ]
5690                } = yes ;
5691   
5692          o_branchMarginalPrice_TP(dt,br) $ ACbranch(currTP,br)
5693              = sum[ fd, ACbranchMaximumFlow.m(currTP,br,fd) ] ;
5694   
5695          o_branchMarginalPrice_TP(dt,br) $ HVDClink(currTP,br)
5696              = HVDClinkMaximumFlow.m(currTP,br) ;
5697   
5698          o_branchCapacity_TP(dt,br) $ branch(currTP,br)
5699              = sum[ fd $ ( ord(fd) = 1 )
5700                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
5701                   ] $  { o_branchFlow_TP(dt,br) >= 0 }
5702              + sum[ fd $ ( ord(fd) = 2 )
5703                        , i_tradePeriodBranchCapacityDirected(currTP,br,fd)
5704                   ] $  { o_branchFlow_TP(dt,br) < 0 } ;
5705   
5706   
5707  *       Offer output
5708          o_offerEnergyBlock_TP(dt,o,trdBlk)
5709              = GENERATIONBLOCK.l(currTP,o,trdBlk);
5710   
5711          o_offerFIRBlock_TP(dt,o,trdBlk,resT)
5712              = sum[ resC $ (ord(resC) = 1)
5713              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5714   
5715          o_offerSIRBlock_TP(dt,o,trdBlk,resT)
5716              = sum[ resC $ (ord(resC) = 2)
5717              , RESERVEBLOCK.l(currTP,o,trdBlk,resC,resT)];
5718   
5719  *       bid output
5720          o_bid(dt,bd) $ bid(currTP,bd) = yes ;
5721   
5722          o_bidEnergy_TP(dt,bd) $ bid(currTP,bd) = PURCHASE.l(currTP,bd) ;
5723   
5724          o_bidFIR_TP(dt,bd) $ bid(currTP,bd)
5725              = sum[ resC $ (ord(resC) = 1)
5726                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5727   
5728          o_bidSIR_TP(dt,bd) $ bid(currTP,bd)
5729              = sum[ resC $ (ord(resC) = 2)
5730                   , PURCHASEILR.l(currTP,bd,resC) ] ;
5731   
5732          o_bidTotalMW_TP(dt,bd) $ bid(currTP,bd)
5733              = sum[ trdBlk, purchaseBidMW(currTP,bd,trdBlk) ] ;
5734   
5735  *       Violation reporting based on the CE and ECE
5736          o_ResViolation_TP(dt,ild,resC)
5737              = DEFICITRESERVE.l(currTP,ild,resC)     $ (not diffCeECeCVP)
5738              + DEFICITRESERVE_CE.l(currTP,ild,resC)  $ (diffCeECeCVP)
5739              + DEFICITRESERVE_ECE.l(currTP,ild,resC) $ (diffCeECeCVP) ;
5740   
5741          o_FIRviolation_TP(dt,ild)
5742              = sum[ resC $ (ord(resC) = 1), o_ResViolation_TP(dt,ild,resC) ] ;
5743   
5744          o_SIRviolation_TP(dt,ild)
5745              = sum[ resC $ (ord(resC) = 2), o_ResViolation_TP(dt,ild,resC) ] ;
5746   
5747  *       Security constraint data
5748          o_brConstraint_TP(dt,brCstr) $ branchConstraint(currTP,brCstr) = yes ;
5749   
5750          o_brConstraintSense_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5751              = branchConstraintSense(currTP,brCstr) ;
5752   
5753          o_brConstraintLHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5754              = [ branchSecurityConstraintLE.l(currTP,brCstr)
5755                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5756              + [ branchSecurityConstraintGE.l(currTP,brCstr)
5757                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5758              + [ branchSecurityConstraintEQ.l(currTP,brCstr)
5759                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5760   
5761          o_brConstraintRHS_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5762              = branchConstraintLimit(currTP,brCstr) ;
5763   
5764          o_brConstraintPrice_TP(dt,brCstr) $ branchConstraint(currTP,brCstr)
5765              = [ branchSecurityConstraintLE.m(currTP,brCstr)
5766                $ (branchConstraintSense(currTP,brCstr) = -1) ]
5767              + [ branchSecurityConstraintGE.m(currTP,brCstr)
5768                $ (branchConstraintSense(currTP,brCstr) = 1)  ]
5769              + [ branchSecurityConstraintEQ.m(currTP,brCstr)
5770                $ (branchConstraintSense(currTP,brCstr) = 0)  ] ;
5771   
5772  *       Mnode constraint data
5773          o_MnodeConstraint_TP(dt,MnodeCstr)
5774              $ MnodeConstraint(currTP,MnodeCstr) = yes ;
5775   
5776          o_MnodeConstraintSense_TP(dt,MnodeCstr)
5777              $ MnodeConstraint(currTP,MnodeCstr)
5778              = MnodeConstraintSense(currTP,MnodeCstr) ;
5779   
5780          o_MnodeConstraintLHS_TP(dt,MnodeCstr)
5781              $ MnodeConstraint(currTP,MnodeCstr)
5782              = [ MnodeSecurityConstraintLE.l(currTP,MnodeCstr)
5783                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5784              + [ MnodeSecurityConstraintGE.l(currTP,MnodeCstr)
5785                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5786              + [ MnodeSecurityConstraintEQ.l(currTP,MnodeCstr)
5787                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5788   
5789          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
5790              $ MnodeConstraint(currTP,MnodeCstr)
5791              = MnodeConstraintLimit(currTP,MnodeCstr) ;
5792   
5793          o_MnodeConstraintPrice_TP(dt,MnodeCstr)
5794              $ MnodeConstraint(currTP,MnodeCstr)
5795              = [ MnodeSecurityConstraintLE.m(currTP,MnodeCstr)
5796                $ (MnodeConstraintSense(currTP,MnodeCstr) = -1) ]
5797              + [ MnodeSecurityConstraintGE.m(currTP,MnodeCstr)
5798                $ (MnodeConstraintSense(currTP,MnodeCstr) = 1)  ]
5799              + [ MnodeSecurityConstraintEQ.m(currTP,MnodeCstr)
5800                $ (MnodeConstraintSense(currTP,MnodeCstr) = 0)  ] ;
5801   
5802  *       Island output
5803          o_island(dt,ild) = yes ;
5804   
5805          o_ResPrice_TP(dt,ild,resC)= IslandReserveCalculation.m(currTP,ild,resC);
5806   
5807          o_FIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
5808                                            , o_ResPrice_TP(dt,ild,resC) ];
5809   
5810          o_SIRprice_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
5811                                            , o_ResPrice_TP(dt,ild,resC) ];
5812   
5813          o_islandGen_TP(dt,ild)
5814              = sum[ b $ busIsland(currTP,b,ild), busGeneration(currTP,b) ] ;
5815   
5816          o_islandClrBid_TP(dt,ild)
5817              = sum[ bd $ bidIsland(currTP,bd,ild), PURCHASE.l(currTP,bd) ] ;
5818   
5819          o_islandLoad_TP(dt,ild)
5820              = sum[ b $ busIsland(currTP,b,ild), busLoad(currTP,b) ]
5821              + o_islandClrBid_TP(dt,ild) ;
5822   
5823          o_ResCleared_TP(dt,ild,resC) = ISLANDRESERVE.l(currTP,ild,resC);
5824   
5825          o_FirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 1)
5826                                              , o_ResCleared_TP(dt,ild,resC) ];
5827   
5828          o_SirCleared_TP(dt,ild) = Sum[ resC $ (ord(resC) = 2)
5829                                              , o_ResCleared_TP(dt,ild,resC) ];
5830   
5831          o_islandBranchLoss_TP(dt,ild)
5832              = sum[ (br,frB,toB)
5833                   $ { ACbranch(currTP,br) and busIsland(currTP,toB,ild)
5834                   and branchBusDefn(currTP,br,frB,toB)
5835                     }, o_branchTotalLoss_TP(dt,br) ] ;
5836   
5837          o_HVDCflow_TP(dt,ild)
5838              = sum[ (br,frB,toB)
5839                   $ { HVDCpoles(currTP,br) and busIsland(currTP,frB,ild)
5840                   and branchBusDefn(currTP,br,frB,toB)
5841                     }, o_branchFlow_TP(dt,br) ] ;
5842   
5843          o_HVDChalfPoleLoss_TP(dt,ild)
5844              = sum[ (br,frB,toB) $ { HVDChalfPoles(currTP,br) and
5845                                      branchBusDefn(currTP,br,frB,toB) and
5846                                      busIsland(currTP,toB,ild) and
5847                                      busIsland(currTP,frB,ild)
5848                                        }, o_branchTotalLoss_TP(dt,br)
5849                   ] ;
5850   
5851          o_HVDCpoleFixedLoss_TP(dt,ild)
5852              = sum[ (br,frB,toB) $ { HVDCpoles(currTP,br) and
5853                                      branchBusDefn(currTP,br,frB,toB) and
5854                                      ( busIsland(currTP,toB,ild) or
5855                                        busIsland(currTP,frB,ild)
5856                                      )
5857                                    }, 0.5 * o_branchFixedLoss_TP(dt,br)
5858                   ] ;
5859   
5860          o_HVDCloss_TP(dt,ild)
5861              = o_HVDChalfPoleLoss_TP(dt,ild)
5862              + o_HVDCpoleFixedLoss_TP(dt,ild)
5863              + sum[ (br,frB,toB) $ { HVDClink(currTP,br) and
5864                                      branchBusDefn(currTP,br,frB,toB) and
5865                                      busIsland(currTP,toB,ild) and
5866                                      (not (busIsland(currTP,frB,ild)))
5867                                    }, o_branchDynamicLoss_TP(dt,br)
5868                   ] ;
5869   
5870  * TN - The code below is added for NMIR project ================================
5871          o_EffectiveRes_TP(dt,ild,resC,riskC) $ reserveShareEnabled(currTP,resC)
5872              = RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ;
5873   
5874          If Sum[ resC $ (ord(resC) = 1), reserveShareEnabled(currTP,resC)] then
5875   
5876              o_FirSent_TP(dt,ild)
5877                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5878                       , RESERVESHARESENT.l(currTP,ild,resC,rd)];
5879   
5880              o_FirReceived_TP(dt,ild)
5881                  = Sum[ (rd,resC) $ (ord(resC) = 1)
5882                       , RESERVESHARERECEIVED.l(currTP,ild,resC,rd) ];
5883   
5884              o_FirEffective_TP(dt,ild,riskC)
5885                  = Sum[ resC $ (ord(resC) = 1),
5886                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5887   
5888              o_FirEffReport_TP(dt,ild)
5889                  = Smax[ (resC,riskC) $ (ord(resC)=1)
5890                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5891   
5892          Endif;
5893   
5894          If Sum[ resC $ (ord(resC) = 2), reserveShareEnabled(currTP,resC)] then
5895   
5896              o_SirSent_TP(dt,ild)
5897                  = Sum[ (rd,resC) $ (ord(resC) = 2),
5898                         RESERVESHARESENT.l(currTP,ild,resC,rd) ];
5899   
5900              o_SirReceived_TP(dt,ild)
5901                  = Sum[ (fd,resC) $ (ord(resC) = 2),
5902                         RESERVESHARERECEIVED.l(currTP,ild,resC,fd) ];
5903   
5904              o_SirEffective_TP(dt,ild,riskC)
5905                  = Sum[ resC $ (ord(resC) = 2),
5906                         RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5907   
5908              o_SirEffReport_TP(dt,ild)
5909                  = Smax[ (resC,riskC) $ (ord(resC)=2)
5910                       , RESERVESHAREEFFECTIVE.l(currTP,ild,resC,riskC) ];
5911          Endif;
5912   
5913   
5914  * TN - The code for NMIR project end ===========================================
5915   
5916  *       Additional output for audit reporting
5917          o_ACbusAngle(dt,b) = ACNODEANGLE.l(currTP,b) ;
5918   
5919  *       Check if there are non-physical losses on AC branches
5920          ManualBranchSegmentMWFlow(LossBranch(ACbranch(currTP,br)),los,fd)
5921                  $ { ( ord(los) <= branchLossBlocks(ACbranch) )
5922                  and validLossSegment(ACbranch,los,fd)
5923                  and ( ACBRANCHFLOWDIRECTED.l(ACbranch,fd) > 0 )
5924                    }
5925                  = Min[ Max( 0,
5926                              [ abs(o_branchFlow_TP(dt,br))
5927                              - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
5928                              ]
5929                            ),
5930                         ( LossSegmentMW(ACbranch,los,fd)
5931                         - [LossSegmentMW(ACbranch,los-1,fd) $ (ord(los) > 1)]
5932                         )
5933                       ] ;
5934   
5935          ManualBranchSegmentMWFlow(LossBranch(HVDClink(currTP,br)),los,fd)
5936                  $ { ( ord(los) <= branchLossBlocks(HVDClink) )
5937                  and validLossSegment(HVDClink,los,fd) and ( ord(fd) = 1 )
5938                    }
5939                  = Min[ Max( 0,
5940                              [ abs(o_branchFlow_TP(dt,br))
5941                              - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5942                              ]
5943                            ),
5944                         ( LossSegmentMW(HVDClink,los,fd)
5945                         - [LossSegmentMW(HVDClink,los-1,fd) $ (ord(los) > 1)]
5946                         )
5947                       ] ;
5948   
5949          ManualLossCalculation(LossBranch(branch(currTP,br)))
5950              = sum[ (los,fd), LossSegmentFactor(branch,los,fd)
5951                             * ManualBranchSegmentMWFlow(branch,los,fd) ] ;
5952   
5953          o_nonPhysicalLoss(dt,br) = o_branchDynamicLoss_TP(dt,br)
5954                                   - ManualLossCalculation(currTP,br) ;
5955   
5956          o_lossSegmentBreakPoint(dt,br,los)
5957              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
5958                         and (ord(fd) = 1)
5959                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
5960              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
5961                         and (ord(fd) = 2)
5962                           }, LossSegmentMW(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
5963          ;
5964   
5965          o_lossSegmentFactor(dt,br,los)
5966              = sum [ fd $ { validLossSegment(currTP,br,los,fd)
5967                         and (ord(fd) = 1)
5968                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) >= 0 }
5969              + sum [ fd $ { validLossSegment(currTP,br,los,fd)
5970                         and (ord(fd) = 2)
5971                           }, LossSegmentFactor(currTP,br,los,fd) ] $ { o_branchFlow_TP(dt,br) < 0 }
5972          ;
5973   
5974          o_busIsland_TP(dt,b,ild) $ busIsland(currTP,b,ild) = yes ;
5975   
5976          o_PLRO_FIR_TP(dt,o) $ offer(currTP,o)
5977              = sum[(resC,PLSRReserveType) $ (ord(resC)=1)
5978                   , RESERVE.l(currTP,o,resC,PLSRReserveType) ] ;
5979   
5980          o_PLRO_SIR_TP(dt,o) $ offer(currTP,o)
5981              = sum[(resC,PLSRReserveType) $ (ord(resC)=2)
5982                   , RESERVE.l(currTP,o,resC,PLSRReserveType)] ;
5983   
5984          o_TWRO_FIR_TP(dt,o) $ offer(currTP,o)
5985              = sum[(resC,TWDRReserveType) $ (ord(resC)=1)
5986                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
5987   
5988          o_TWRO_SIR_TP(dt,o) $ offer(currTP,o)
5989              = sum[(resC,TWDRReserveType) $ (ord(resC)=2)
5990                   , RESERVE.l(currTP,o,resC,TWDRReserveType)] ;
5991   
5992          o_ILRO_FIR_TP(dt,o) $ offer(currTP,o)
5993              = sum[ (resC,ILReserveType) $ (ord(resC)=1)
5994                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
5995   
5996          o_ILRO_SIR_TP(dt,o) $ offer(currTP,o)
5997              = sum[ (resC,ILReserveType) $ (ord(resC)=2)
5998                   , RESERVE.l(currTP,o,resC,ILReserveType)] ;
5999   
6000          o_ILbus_FIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6001                                                offerNode(currTP,o,n)
6002                                              }, o_ILRO_FIR_TP(dt,o) ] ;
6003   
6004          o_ILbus_SIR_TP(dt,b) = sum[ (o,n) $ { NodeBus(currTP,n,b) and
6005                                                offerNode(currTP,o,n)
6006                                              }, o_ILRO_SIR_TP(dt,o) ] ;
6007   
6008          o_marketNodeIsland_TP(dt,o,ild)
6009              $ sum[ n $ { offerIsland(currTP,o,ild) and
6010                           offerNode(currTP,o,n) and
6011                           (o_nodeLoad_TP(dt,n)  = 0)
6012                         },1
6013                   ] = yes ;
6014   
6015          o_generationRiskLevel(dt,ild,o,resC,GenRisk)
6016              = GENISLANDRISK.l(currTP,ild,o,resC,GenRisk)
6017              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6018              ;
6019   
6020          o_generationRiskPrice(dt,ild,o,resC,GenRisk)
6021              = GenIslandRiskCalculation_1.m(currTP,ild,o,resC,GenRisk) ;
6022   
6023          o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6024              = ISLANDRISK.l(currTP,ild,resC,HVDCrisk) ;
6025   
6026          o_HVDCriskPrice(dt,ild,resC,HVDCrisk)
6027              = HVDCIslandRiskCalculation.m(currTP,ild,resC,HVDCrisk) ;
6028   
6029          o_manuRiskLevel(dt,ild,resC,ManualRisk)
6030              = ISLANDRISK.l(currTP,ild,resC,ManualRisk)
6031              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,ManualRisk)
6032              ;
6033   
6034          o_manuRiskPrice(dt,ild,resC,ManualRisk)
6035              = ManualIslandRiskCalculation.m(currTP,ild,resC,ManualRisk) ;
6036   
6037          o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk)
6038              = HVDCGENISLANDRISK.l(currTP,ild,o,resC,HVDCsecRisk) ;
6039   
6040          o_genHVDCriskPrice(dt,ild,o,resC,HVDCsecRisk(riskC))
6041              = HVDCIslandSecRiskCalculation_GEN_1.m(currTP,ild,o,resC,riskC) ;
6042   
6043          o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)
6044              = HVDCMANISLANDRISK.l(currTP,ild,resC,HVDCsecRisk);
6045   
6046          o_manuHVDCriskPrice(dt,ild,resC,HVDCsecRisk(riskC))
6047              = HVDCIslandSecRiskCalculation_Manu_1.m(currTP,ild,resC,riskC) ;
6048   
6049          o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)
6050              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6051              = GENISLANDRISKGROUP.l(currTP,ild,rg,resC,GenRisk)
6052              + RESERVESHAREEFFECTIVE.l(currTP,ild,resC,GenRisk)
6053              ;
6054   
6055          o_generationRiskGroupPrice(dt,ild,rg,resC,GenRisk)
6056              $ islandRiskGroup(currTP,ild,rg,GenRisk)
6057              = GenIslandRiskGroupCalculation_1.m(currTP,ild,rg,resC,GenRisk) ;
6058   
6059  *       FIR and SIR required based on calculations of the island risk to
6060  *       overcome reporting issues of the risk setter under degenerate
6061  *       conditions when reserve price = 0 - See below
6062   
6063          o_ReserveReqd_TP(dt,ild,resC)
6064              = Max[ 0,
6065                     smax[(o,GenRisk)     , o_generationRiskLevel(dt,ild,o,resC,GenRisk)],
6066                     smax[ HVDCrisk       , o_HVDCriskLevel(dt,ild,resC,HVDCrisk) ] ,
6067                     smax[ ManualRisk     , o_manuRiskLevel(dt,ild,resC,ManualRisk) ] ,
6068                     smax[ (o,HVDCsecRisk), o_genHVDCriskLevel(dt,ild,o,resC,HVDCsecRisk) ] ,
6069                     smax[ HVDCsecRisk    , o_manuHVDCriskLevel(dt,ild,resC,HVDCsecRisk)  ] ,
6070                     smax[ (rg,GenRisk)   , o_generationRiskGroupLevel(dt,ild,rg,resC,GenRisk)  ]
6071                   ] ;
6072   
6073          o_FIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=1), o_ReserveReqd_TP(dt,ild,resC) ] ;
6074          o_SIRreqd_TP(dt,ild) = sum[ resC $ (ord(resC)=2), o_ReserveReqd_TP(dt,ild,resC) ] ;
6075   
6076  *       Summary reporting by trading period
6077          o_solveOK_TP(dt) = ModelSolved ;
6078   
6079          o_systemCost_TP(dt) = SYSTEMCOST.l(currTP) ;
6080   
6081          o_systemBenefit_TP(dt) = SYSTEMBENEFIT.l(currTP) ;
6082   
6083          o_penaltyCost_TP(dt) = SYSTEMPENALTYCOST.l(currTP) ;
6084   
6085          o_ofv_TP(dt) = o_systemBenefit_TP(dt)
6086                       - o_systemCost_TP(dt)
6087                       - o_penaltyCost_TP(dt);
6088   
6089   
6090  *       Separete violation reporting at trade period level
6091          o_defGenViolation_TP(dt) = sum[ b, o_busDeficit_TP(dt,b) ] ;
6092   
6093          o_surpGenViolation_TP(dt) = sum[ b, o_busSurplus_TP(dt,b) ] ;
6094   
6095          o_surpBranchFlow_TP(dt)
6096              = sum[ br$branch(currTP,br), SURPLUSBRANCHFLOW.l(currTP,br) ] ;
6097   
6098          o_defRampRate_TP(dt)
6099              = sum[ o $ offer(currTP,o), DEFICITRAMPRATE.l(currTP,o) ] ;
6100   
6101          o_surpRampRate_TP(dt)
6102              = sum[ o $ offer(currTP,o), SURPLUSRAMPRATE.l(currTP,o) ] ;
6103   
6104          o_surpBranchGroupConst_TP(dt)
6105              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6106                   , SURPLUSBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6107   
6108          o_defBranchGroupConst_TP(dt)
6109              = sum[ brCstr $ branchConstraint(currTP,brCstr)
6110                   , DEFICITBRANCHSECURITYCONSTRAINT.l(currTP,brCstr) ] ;
6111   
6112          o_defMnodeConst_TP(dt)
6113              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6114                   , DEFICITMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6115   
6116          o_surpMnodeConst_TP(dt)
6117              = sum[ MnodeCstr $ MnodeConstraint(currTP,MnodeCstr)
6118                   , SURPLUSMnodeCONSTRAINT.l(currTP,MnodeCstr) ] ;
6119   
6120          o_defACnodeConst_TP(dt)
6121              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6122                   , DEFICITACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6123   
6124          o_surpACnodeConst_TP(dt)
6125              = sum[ ACnodeCstr $ ACnodeConstraint(currTP,ACnodeCstr)
6126                   , SURPLUSACnodeCONSTRAINT.l(currTP,ACnodeCstr) ] ;
6127   
6128          o_defT1MixedConst_TP(dt)
6129              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6130                   , DEFICITTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6131   
6132          o_surpT1MixedConst_TP(dt)
6133              = sum[ t1MixCstr $ Type1MixedConstraint(currTP,t1MixCstr)
6134                   , SURPLUSTYPE1MIXEDCONSTRAINT.l(currTP,t1MixCstr) ] ;
6135   
6136          o_defGenericConst_TP(dt)
6137              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6138                   , DEFICITGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6139   
6140          o_surpGenericConst_TP(dt)
6141              = sum[ gnrcCstr $ GenericConstraint(currTP,gnrcCstr)
6142                   , SURPLUSGENERICCONSTRAINT.l(currTP,gnrcCstr) ] ;
6143   
6144          o_defResv_TP(dt)
6145              = sum[ (ild,resC) , o_ResViolation_TP(dt,ild,resC) ] ;
6146   
6147          o_totalViolation_TP(dt)
6148              = o_defGenViolation_TP(dt) + o_surpGenViolation_TP(dt)
6149              + o_defRampRate_TP(dt) + o_surpRampRate_TP(dt)
6150              + o_defBranchGroupConst_TP(dt) + o_surpBranchGroupConst_TP(dt)
6151              + o_defMnodeConst_TP(dt) + o_surpMnodeConst_TP(dt)
6152              + o_defACnodeConst_TP(dt) + o_surpACnodeConst_TP(dt)
6153              + o_defT1MixedConst_TP(dt) + o_surpT1MixedConst_TP(dt)
6154              + o_defGenericConst_TP(dt) + o_surpGenericConst_TP(dt)
6155              + o_defResv_TP(dt) + o_surpBranchFlow_TP(dt) ;
6156   
6157  *       Virtual reserve
6158          o_vrResMW_TP(dt,ild,resC) = VIRTUALRESERVE.l(currTP,ild,resC) ;
6159   
6160          o_FIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 1)
6161                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6162   
6163          o_SIRvrMW_TP(dt,ild) = sum[ resC $ (ord(resC) = 2)
6164                                    , o_vrResMW_TP(dt,ild,resC) ] ;
6165   
6166  *   Reporting at trading period end
6167      EndLoop;
6169   
6171   
6172  * End of the solve vSPD loop
6173    ] ;
6174  * End of the While loop
6175  );
6176   
6177   
6178  *   Summary reports - only applied for normal and audit vSPD run.
6180   
6181  *   System level
6182      o_numTradePeriods = card(tp) ;
6183   
6184      o_systemOFV = sum[ dt, o_ofv_TP(dt) ] ;
6185   
6186      o_systemGen = sum[ (dt,ild), o_islandGen_TP(dt,ild) ] ;
6187   
6188      o_systemLoad = sum[ (dt,ild), o_islandLoad_TP(dt,ild)
6189                                  - o_islandClrBid_TP(dt,ild) ] ;
6190   
6191      o_systemLoss = sum[ (dt,ild), o_islandBranchLoss_TP(dt,ild)
6192                                  + o_HVDCloss_TP(dt,ild) ] ;
6193   
6194      o_systemViolation = sum[ dt, o_totalViolation_TP(dt) ] ;
6195   
6196      o_systemFIR = sum[ (dt,ild), o_FIRcleared_TP(dt,ild) ] ;
6197   
6198      o_systemSIR = sum[ (dt,ild), o_SIRcleared_TP(dt,ild) ] ;
6199   
6200   
6201  *   Offer level - This does not include revenue from wind generators for
6202  *   final pricing because the wind generation is netted off against load
6203  *   at the particular bus for the final pricing solves
6204   
6205      o_offerTrader(o,trdr)
6206          $ sum[ tp $ i_tradePeriodOfferTrader(tp,o,trdr), 1 ] = yes ;
6207   
6208      o_offerGen(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerEnergy_TP(dt,o)] ;
6209   
6210      o_offerFIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerFIR_TP(dt,o)] ;
6211   
6212      o_offerSIR(o) = (i_tradingPeriodLength/60)*sum[dt, o_offerSIR_TP(dt,o)] ;
6213   
6215   
6216   
6217  *=====================================================================================
6218  * 8. vSPD scarcity pricing post-processing
6219  *=====================================================================================
6221   
6222  * Mapping scarcity area to islands
6223  scarcityAreaIslandMap(sarea,ild)      = no ;
6224  scarcityAreaIslandMap('NI','NI')      = yes ;
6225  scarcityAreaIslandMap('SI','SI')      = yes ;
6226  scarcityAreaIslandMap('National',ild) = yes ;
6227   
6229   
6230   
6231  * 8b. Calculating price-relating outputs --------------------------------------
6232   
6234  loop(i_dateTimeTradePeriodMap(dt,tp),
6235   
6236  *   bus output update
6237      o_busRevenue_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6238                                        * o_busGeneration_TP(dt,b)
6239                                        * o_busPrice_TP(dt,b) ;
6240   
6241      o_busCost_TP(dt,b) $ bus(tp,b) = (i_tradingPeriodLength / 60)
6242                                     * o_busLoad_TP(dt,b)
6243                                     * o_busPrice_TP(dt,b);
6244   
6245  *   node output update
6246      o_nodeRevenue_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6247                                          * o_nodeGeneration_TP(dt,n)
6248                                          * o_nodePrice_TP(dt,n) ;
6249   
6250      o_nodeCost_TP(dt,n) $ node(tp,n) = (i_tradingPeriodLength / 60)
6251                                       * o_nodeLoad_TP(dt,n)
6252                                       * o_nodePrice_TP(dt,n) ;
6253   
6254  *   branch output update
6255      o_branchFromBusPrice_TP(dt,br) $ branch(tp,br)
6256          = sum[ b $ o_branchFromBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6257   
6258      o_branchToBusPrice_TP(dt,br) $ branch(tp,br)
6259          = sum[ b $ o_branchToBus_TP(dt,br,b), o_busPrice_TP(dt,b) ] ;
6260   
6261      o_branchTotalRentals_TP(dt,br)
6262          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) >= 0) }
6263          = (i_tradingPeriodLength/60)
6264          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6265            - o_branchToBusPrice_TP(dt,br)   * o_branchTotalLoss_TP(dt,br)
6266            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6267            ] ;
6268   
6269      o_branchTotalRentals_TP(dt,br)
6270          $ { branch(tp,br) and (o_branchFlow_TP(dt,br) < 0) }
6271          = (i_tradingPeriodLength/60)
6272          * [ o_branchToBusPrice_TP(dt,br)   * o_branchFlow_TP(dt,br)
6273            - o_branchFromBusPrice_TP(dt,br) * o_branchFlow_TP(dt,br)
6274            - o_branchFromBusPrice_TP(dt,br) * o_branchTotalLoss_TP(dt,br)
6275            ] ;
6276   
6277  *   Island output
6278      o_islandRefPrice_TP(dt,ild)
6279          = sum[ n $ { referenceNode(tp,n)
6280                   and nodeIsland(tp,n,ild) } , o_nodePrice_TP(dt,n) ] ;
6281   
6282      o_islandEnergyRevenue_TP(dt,ild)
6283          = sum[ n $ nodeIsland(tp,n,ild), o_nodeRevenue_TP(dt,n)] ;
6284   
6285      o_islandReserveRevenue_TP(dt,ild) = sum[ resC, o_ResCleared_TP(dt,ild,resC)
6286                                                   * o_ResPrice_TP(dt,ild,resC)
6287                                                   * i_tradingPeriodLength/60 ];
6288   
6289      o_islandLoadCost_TP(dt,ild)
6290          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) >= 0) }
6291               , o_nodeCost_TP(dt,n) ] ;
6292   
6293      o_islandLoadRevenue_TP(dt,ild)
6294          = sum[ n $ { nodeIsland(tp,n,ild) and (o_nodeLoad_TP(dt,n) < 0) }
6295               , - o_nodeCost_TP(dt,n) ] ;
6296   
6298  ) ;
6299   
6300  * System level
6301  o_systemEnergyRevenue  = sum[ (dt,ild), o_islandEnergyRevenue_TP(dt,ild) ] ;
6302   
6303  o_systemReserveRevenue = sum[ (dt,ild), o_islandReserveRevenue_TP(dt,ild) ];
6304   
6305  o_systemLoadCost       = sum[ (dt,ild), o_islandLoadCost_TP(dt,ild) ];
6306   
6307  o_systemLoadRevenue    = sum[ (dt,ild), o_islandLoadRevenue_TP(dt,ild) ];
6308   
6309  * Offer level
6310  o_offerGenRevenue(o)
6311      = sum[ (dt,tp,n) $ { i_dateTimeTradePeriodMap(dt,tp) and offerNode(tp,o,n) }
6312           , (i_tradingPeriodLength/60)
6313           * o_offerEnergy_TP(dt,o) * o_nodePrice_TP(dt,n) ] ;
6314   
6315  o_offerFIRrevenue(o)
6316      = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6317                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6318           , (i_tradingPeriodLength/60)
6319           * o_offerFIR_TP(dt,o) * o_FIRprice_TP(dt,ild) ] ;
6320   
6321  o_offerSIRrevenue(o)
6322     = sum[ (dt,tp,n,ild) $ { i_dateTimeTradePeriodMap(dt,tp) and
6323                               offerNode(tp,o,n) and nodeIsland(tp,n,ild)}
6324           , (i_tradingPeriodLength/60)
6325           * o_offerSIR_TP(dt,o) * o_SIRprice_TP(dt,ild) ] ;
6326   
6328  *   Calculating price-relating outputs end -------------------------------------
6329   
6330   
6332   
6333  *=====================================================================================
6334  * 9. Write results to CSV report files and GDX files
6335  *=====================================================================================
6336  * TN - Pivot analysis end
INCLUDE    C:\vSPD\GitHub\Programs\vSPDreport.gms
6338  *=====================================================================================
6339  * Name:                 vSPDreport.gms
6340  * Function:             Creates the detailed reports for normal SPD mode
6341  * Developed by:         Tuong Nguyen - Electricity Authority, New Zealand
6342  * Source:               https://github.com/ElectricityAuthority/vSPD
6343  *                       https://www.emi.ea.govt.nz/Tools/vSPD
6344  * Contact:              Forum: https://www.emi.ea.govt.nz/forum/
6345  *                       Email: emi@ea.govt.nz
6346  * Last modified on:     1 Oct 2019
6347  *
6348  *=====================================================================================
6349   
6350  * Normal vSPD run output
6351  o_FromDateTime(dt)$( ord(dt) = 1 ) = yes ;
6352   
6353  * System surplus needs to be calculated outside the main loop
6354  o_systemSurplus = o_systemLoadCost-o_systemLoadRevenue-o_systemEnergyRevenue ;
6355   
6356  * Trader level - Currently this does not include revenue from wind generators
6357  * since wind generation in FP is represented as negative load
6358  o_trader(trdr) = yes ;
6359  o_traderGen(trdr) = sum(o_offerTrader(o,trdr), o_offerGen(o)) ;
6360  o_traderFIR(trdr) = sum(o_offerTrader(o,trdr), o_offerFIR(o)) ;
6361  o_traderSIR(trdr) = sum(o_offerTrader(o,trdr), o_offerSIR(o)) ;
6362  o_traderGenRevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerGenRevenue(o));
6363  o_traderFIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerFIRrevenue(o));
6364  o_traderSIRrevenue(trdr) = sum(o_offerTrader(o,trdr), o_offerSIRrevenue(o));
6365   
6366   
6367  *=====================================================================================
6368  * Writing data in to CSV result files
6369  *=====================================================================================
6370   
6371  * System level summary
6372  File SystemResults    / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_SystemResults.csv" / ;
6373  SystemResults.pc = 5 ;     SystemResults.lw = 0 ;
6374  SystemResults.pw = 9999 ;  SystemResults.ap = 1 ;
6375  put SystemResults ;
6376  loop( dt $ o_FromDateTime(dt),
6377      put dt.tl, o_NumTradePeriods, o_systemOFV, o_systemGen, o_systemLoad
6378          o_systemLoss, o_systemViolation, o_systemFIR, o_systemSIR
6379          o_systemEnergyRevenue, o_systemLoadCost, o_systemLoadRevenue
6380          o_systemSurplus / ;
6381  ) ;
6382   
6383  * Offer level summary
6384  File  OfferResults     / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults.csv" / ;
6385  OfferResults.pc = 5 ;      OfferResults.lw = 0 ;
6386  OfferResults.pw = 9999 ;   OfferResults.ap = 1 ;
6387  put OfferResults ;
6388  loop( (dt,o,trdr)
6389      $ { o_FromDateTime(dt) and o_offerTrader(o,trdr) and
6390          [ o_offerGen(o) or o_offerFIR(o) or o_offerSIR(o) ]
6391        },
6392      put dt.tl, o_NumTradePeriods, o.tl, trdr.tl
6393          o_offerGen(o), o_offerFIR(o), o_offerSIR(o) / ;
6394  ) ;
6395   
6396  * Trader level summary
6397  File  TraderResults   / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_TraderResults.csv" / ;
6398  TraderResults.pc = 5 ;     TraderResults.lw = 0 ;
6399  TraderResults.pw = 9999 ;  TraderResults.ap = 1 ;
6400  put TraderResults ;
6401  loop( (dt,trdr)
6402      $ { o_FromDateTime(dt) and o_trader(trdr) and
6403          [ o_traderGen(trdr) or o_traderFIR(trdr) or o_traderSIR(trdr) ]
6404        },
6405      put dt.tl, o_NumTradePeriods, trdr.tl
6406          o_traderGen(trdr), o_traderFIR(trdr), o_traderSIR(trdr) / ;
6407  ) ;
6408   
6409   
6410  * Trading period level report
6412   
6413  * Trading period summary result
6414  File
6415  SummaryResults_TP / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_SummaryResults_TP.csv" / ;
6416  SummaryResults_TP.pc = 5 ;    SummaryResults_TP.lw = 0 ;
6417  SummaryResults_TP.pw = 9999 ; SummaryResults_TP.ap = 1 ;
6418  SummaryResults_TP.nd = 5 ;
6419  put SummaryResults_TP ;
6420  loop( dt,
6421      put dt.tl, o_solveOK_TP(dt), o_ofv_TP(dt)
6422          o_systemCost_TP(dt), o_systemBenefit_TP(dt)
6423          o_penaltyCost_TP(dt), o_DefGenViolation_TP(dt)
6424          o_SurpGenViolation_TP(dt),o_DefResv_TP(dt),o_SurpBranchFlow_TP(dt)
6425          o_DefRampRate_TP(dt), o_SurpRampRate_TP(dt)
6426          o_DefBranchGroupConst_TP(dt), o_SurpBranchGroupConst_TP(dt)
6427          o_DefMnodeConst_TP(dt), o_SurpMnodeConst_TP(dt)
6428          o_DefACNodeConst_TP(dt), o_SurpACNodeConst_TP(dt)
6429          o_DefT1MixedConst_TP(dt), o_SurpT1MixedConst_TP(dt)
6430          o_DefGenericConst_TP(dt), o_SurpGenericConst_TP(dt) / ;
6431  ) ;
6432   
6433  * Trading period island result
6434  File IslandResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_IslandResults_TP.csv"/;
6435  IslandResults_TP.pc = 5 ;     IslandResults_TP.lw = 0 ;
6436  IslandResults_TP.pw = 9999 ;  IslandResults_TP.ap = 1 ;
6437  IslandResults_TP.nd = 5 ;
6438  put IslandResults_TP ;
6439  loop( (dt,ild) $ o_island(dt,ild),
6440      put dt.tl, ild.tl, o_islandGen_TP(dt,ild), o_islandLoad_TP(dt,ild)
6441          o_islandClrBid_TP(dt,ild), o_islandBranchLoss_TP(dt,ild)
6442          o_HVDCFlow_TP(dt,ild), o_HVDCLoss_TP(dt,ild)
6443          o_islandRefPrice_TP(dt,ild), o_FIRReqd_TP(dt,ild)
6444          o_SIRReqd_TP(dt,ild), o_FIRPrice_TP(dt,ild)
6445          o_SIRPrice_TP(dt,ild), o_islandEnergyRevenue_TP(dt,ild)
6446          o_islandLoadCost_TP(dt,ild), o_islandLoadRevenue_TP(dt,ild)
6447  * NIRM output
6448      o_FirCleared_TP(dt,ild), o_SirCleared_TP(dt,ild)
6449      o_FirSent_TP(dt,ild), o_SirSent_TP(dt,ild)
6450      o_FirReceived_TP(dt,ild), o_SirReceived_TP(dt,ild)
6451      o_FirEffReport_TP(dt,ild), o_SirEffReport_TP(dt,ild)
6452  *NIRM output end
6453      / ;
6454  ) ;
6455   
6457   
6458  * Trading period bus result
6459  File BusResults_TP   / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv" / ;
6460  BusResults_TP.pc = 5 ;
6461  BusResults_TP.lw = 0 ;
6462  BusResults_TP.pw = 9999 ;
6463  BusResults_TP.ap = 1 ;
6464  BusResults_TP.nd = 3
6465  put BusResults_TP ;
6466  loop( o_bus(dt,b),
6467      put dt.tl, b.tl, o_busGeneration_TP(dt,b), o_busLoad_TP(dt,b)
6468          o_busPrice_TP(dt,b), o_busRevenue_TP(dt,b), o_busCost_TP(dt,b)
6469          o_busDeficit_TP(dt,b), o_busSurplus_TP(dt,b) / ;
6470  ) ;
6471   
6472  * Trading period node result
6473  File NodeResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_NodeResults_TP.csv" / ;
6474  NodeResults_TP.pc = 5 ;
6475  NodeResults_TP.lw = 0 ;
6476  NodeResults_TP.pw = 9999 ;
6477  NodeResults_TP.ap = 1 ;
6478  NodeResults_TP.nd = 3 ;
6479  put NodeResults_TP ;
6480  loop( (dt,n) $ o_node(dt,n),
6481      put dt.tl, n.tl, o_nodeGeneration_TP(dt,n), o_nodeLoad_TP(dt,n)
6482          o_nodePrice_TP(dt,n), o_nodeRevenue_TP(dt,n), o_nodeCost_TP(dt,n)
6483          o_nodeDeficit_TP(dt,n), o_nodeSurplus_TP(dt,n) / ;
6484  ) ;
6485   
6486  * Trading period offer result
6487  File OfferResults_TP  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults_TP.csv"/ ;
6488  OfferResults_TP.pc = 5 ;      OfferResults_TP.lw = 0 ;
6489  OfferResults_TP.pw = 9999 ;   OfferResults_TP.ap = 1 ;
6490  OfferResults_TP.nd = 3 ;
6491  put OfferResults_TP ;
6492  loop( (dt,o) $ o_offer(dt,o),
6493      put dt.tl, o.tl, o_offerEnergy_TP(dt,o)
6494          o_offerFIR_TP(dt,o), o_offerSIR_TP(dt,o) / ;
6495  ) ;
6496   
6497  * Trading period bid result
6498  File BidResults_TP    / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BidResults_TP.csv" / ;
6499  BidResults_TP.pc = 5 ;     BidResults_TP.lw = 0 ;
6500  BidResults_TP.pw = 9999 ;  BidResults_TP.ap = 1 ;
6501  BidResults_TP.nd = 3 ;
6502  put BidResults_TP ;
6503  loop( (dt,bd) $ o_bid(dt,bd),
6504      put dt.tl, bd.tl, o_bidTotalMW_TP(dt,bd), o_bidEnergy_TP(dt,bd)
6505      o_bidFIR_TP(dt,bd), o_bidSIR_TP(dt,bd) / ;
6506  ) ;
6507   
6508  * Trading period reserve result
6509  File
6510  ReserveResults_TP /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_ReserveResults_TP.csv" / ;
6511  ReserveResults_TP.pc = 5 ;    ReserveResults_TP.lw = 0 ;
6512  ReserveResults_TP.pw = 9999 ; ReserveResults_TP.ap = 1 ;
6513  ReserveResults_TP.nd = 3 ;
6514  put ReserveResults_TP ;
6515  loop( (dt,ild) $ o_island(dt,ild),
6516      put dt.tl, ild.tl, o_FIRReqd_TP(dt,ild), o_SIRReqd_TP(dt,ild)
6517          o_FIRPrice_TP(dt,ild), o_SIRPrice_TP(dt,ild)
6518          o_FIRViolation_TP(dt,ild), o_SIRViolation_TP(dt,ild)
6519          o_FIRvrMW_TP(dt,ild), o_SIRvrMW_TP(dt,ild) / ;
6520  ) ;
6521   
6522  * Trading period branch result
6523  File
6524  BranchResults_TP  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BranchResults_TP.csv" / ;
6525  BranchResults_TP.pc = 5 ;     BranchResults_TP.lw = 0 ;
6526  BranchResults_TP.pw = 9999 ;  BranchResults_TP.ap = 1 ;
6527  BranchResults_TP.nd = 5 ;
6528  put BranchResults_TP ;
6529  loop( (dt,br,frB,toB)
6530      $ { o_branchToBus_TP(dt,br,toB) and
6531          o_branchFromBus_TP(dt,br,frB) and o_branch(dt,br)
6532        },
6533      put dt.tl, br.tl, frB.tl, toB.tl, o_branchFlow_TP(dt,br)
6534          o_branchCapacity_TP(dt,br), o_branchDynamicLoss_TP(dt,br)
6535          o_branchFixedLoss_TP(dt,br), o_branchFromBusPrice_TP(dt,br)
6536          o_branchToBusPrice_TP(dt,br), o_branchMarginalPrice_TP(dt,br)
6537          o_branchTotalRentals_TP(dt,br) / ;
6538  ) ;
6539   
6540  * Trading period branch constraint result
6541  File BrCstrResults_TP
6542  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_BrConstraintResults_TP.csv" / ;
6543  BrCstrResults_TP.pc = 5 ;
6544  BrCstrResults_TP.lw = 0 ;
6545  BrCstrResults_TP.pw = 9999 ;
6546  BrCstrResults_TP.ap = 1 ;
6547  BrCstrResults_TP.nd = 5 ;
6548  put BrCstrResults_TP ;
6549  loop( (dt,brCstr) $ o_brConstraint_TP(dt,brCstr),
6550      put dt.tl, brCstr.tl, o_brConstraintLHS_TP(dt,brCstr)
6551          o_brConstraintSense_TP(dt,brCstr), o_brConstraintRHS_TP(dt,brCstr)
6552          o_brConstraintPrice_TP(dt,brCstr) / ;
6553  ) ;
6554   
6555  * Trading period market node constraint result
6556  File MnodeCstrResults_TP
6557  / "C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_MnodeConstraintResults_TP.csv" / ;
6558  MnodeCstrResults_TP.pc = 5 ;
6559  MnodeCstrResults_TP.lw = 0 ;
6560  MnodeCstrResults_TP.pw = 9999 ;
6561  MnodeCstrResults_TP.ap = 1 ;
6562  MnodeCstrResults_TP.nd = 5 ;
6563  put MnodeCstrResults_TP ;
6564  loop( (dt,MnodeCstr) $ o_MnodeConstraint_TP(dt,MnodeCstr),
6565      put dt.tl, MnodeCstr.tl, o_MnodeConstraintLHS_TP(dt,MnodeCstr)
6566          o_MnodeConstraintSense_TP(dt,MnodeCstr)
6567          o_MnodeConstraintRHS_TP(dt,MnodeCstr)
6568          o_MnodeConstraintPrice_TP(dt,MnodeCstr) / ;
6569  ) ;
6570   
6572  *===============================================================================
6573   
6574   
6575   
6576  *===============================================================================
6577  * Audit mode reporting process
6578  *===============================================================================
6580   
6581  * Introduce zero tolerance to detect risk setter due to rounding issues
6582  Scalar zeroTolerance / 0.000001 / ;
6583   
6584   
6585  * Audit - branch loss result
6586  File branchLoss_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchLoss.csv"/;
6587  branchLoss_Audit.pc = 5 ;
6588  branchLoss_Audit.lw = 0 ;
6589  branchLoss_Audit.pw = 9999 ;
6590  BranchLoss_Audit.ap = 1 ;
6591  BranchLoss_Audit.nd = 9 ;
6592  put BranchLoss_Audit ;
6593  loop( (dt,br) $ o_branch(dt,br),
6594      put dt.tl, br.tl ;
6595      loop(los $ o_LossSegmentBreakPoint(dt,br,los),
6596          put o_LossSegmentBreakPoint(dt,br,los)
6597              o_LossSegmentFactor(dt,br,los) ;
6598      )
6599      put / ;
6600  ) ;
6601   
6602  * Audit - bus result
6603  File busResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BusResults.csv"/;
6604  busResults_Audit.pc = 5 ;
6605  busResults_Audit.lw = 0 ;
6606  busResults_Audit.pw = 9999 ;
6607  BusResults_Audit.ap = 1 ;
6608  BusResults_Audit.nd = 5 ;
6609  put BusResults_Audit ;
6610  loop( (dt,b,ild) $ { o_bus(dt,b) and o_busIsland_TP(dt,b,ild) },
6611      put dt.tl, ild.tl, b.tl, o_ACBusAngle(dt,b)
6612          o_busPrice_TP(dt,b), o_busLoad_TP(dt,b)
6613          o_ILBus_FIR_TP(dt,b), o_ILBus_SIR_TP(dt,b) / ;
6614  ) ;
6615   
6616  * Audit - market node result
6617  File
6618  MNodeResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_MNodeResults.csv"/;
6619  MNodeResults_Audit.pc = 5 ;
6620  MNodeResults_Audit.lw = 0 ;
6621  MNodeResults_Audit.pw = 9999 ;
6622  MNodeResults_Audit.ap = 1 ;
6623  MNodeResults_Audit.nd = 5 ;
6624  put MNodeResults_Audit ;
6625  loop( (dt,o,ild) $ {o_offer(dt,o) and o_MarketNodeIsland_TP(dt,o,ild) },
6626      put dt.tl, ild.tl, o.tl, o_offerEnergy_TP(dt,o)
6627          o_PLRO_FIR_TP(dt,o), o_PLRO_SIR_TP(dt,o)
6628          o_TWRO_FIR_TP(dt,o), o_TWRO_SIR_TP(dt,o) / ;
6629  ) ;
6630   
6631  * Audit - branch result
6632  File
6633  brchResults_Audit  /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchResults.csv"/;
6634  brchResults_Audit.pc = 5 ;
6635  brchResults_Audit.lw = 0 ;
6636  brchResults_Audit.pw = 9999 ;
6637  brchResults_Audit.ap = 1 ;
6638  brchResults_Audit.nd = 9 ;
6639  put brchResults_Audit ;
6640  loop( (dt,br) $ o_branch(dt,br),
6641      put dt.tl, br.tl, o_branchFlow_TP(dt,br)
6642          o_branchDynamicLoss_TP(dt,br), o_branchFixedLoss_TP(dt,br)
6643          [o_branchDynamicLoss_TP(dt,br) + o_branchFixedLoss_TP(dt,br)] ;
6644      if ( o_branchMarginalPrice_TP(dt,br) <> 0,  put 'Y' ;
6645      else                                        put 'N' ;
6646      ) ;
6647   
6648      put o_branchMarginalPrice_TP(dt,br) ;
6649   
6650      if( o_NonPhysicalLoss(dt,br) > NonPhysicalLossTolerance, put 'Y' / ;
6651      else                                                     put 'N' / ;
6652      ) ;
6653  ) ;
6654   
6655  * Audit - risk result
6656  File
6657  riskResults_Audit    /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_RiskResults.csv"/;
6658  riskResults_Audit.pc = 5 ;
6659  riskResults_Audit.lw = 0 ;
6660  riskResults_Audit.pw = 9999 ;
6661  RiskResults_Audit.ap = 1 ;
6662  RiskResults_Audit.nd = 5 ;
6663  put RiskResults_Audit ;
6664  loop( (dt,ild,resC) $ o_island(dt,ild),
6665      loop( (o,GenRisk) $ { ( o_generationRiskLevel(dt,ild,o,resC,GenRisk) > 0 )
6666                        and ( abs[ o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
6667                                 - o_ReserveReqd_TP(dt,ild,resC)
6668                                 ] <= ZeroTolerance )
6669                           },
6670          put dt.tl, ild.tl, resC.tl, o.tl, GenRisk.tl
6671              o_GenerationRiskLevel(dt,ild,o,resC,GenRisk)
6672              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,GenRisk)
6673              o_ResViolation_TP(dt,ild,resC)
6674              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6675   
6676      ) ;
6677   
6678      loop( HVDCrisk $ { (o_HVDCriskLevel(dt,ild,resC,HVDCrisk) > 0)
6679                     and ( abs[  o_HVDCriskLevel(dt,ild,resC,HVDCrisk)
6680                               - o_ReserveReqd_TP(dt,ild,resC)
6681                              ] <= ZeroTolerance )
6682                       },
6683          put dt.tl, ild.tl, resC.tl, 'HVDC', HVDCrisk.tl
6684              o_HVDCriskLevel(dt,ild,resC,HVDCrisk), o_ResCleared_TP(dt,ild,resC)
6685              o_EffectiveRes_TP(dt,ild,resC,HVDCRisk)
6686              o_ResViolation_TP(dt,ild,resC)
6687              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6688      ) ;
6689   
6690      loop( manualRisk $ { ( o_manuRiskLevel(dt,ild,resC,ManualRisk) > 0 )
6691                       and ( abs[ o_manuRiskLevel(dt,ild,resC,manualRisk)
6692                                - o_ReserveReqd_TP(dt,ild,resC)
6693                                ] <= ZeroTolerance )
6694                         },
6695          put dt.tl, ild.tl, resC.tl, 'Manual', manualRisk.tl
6696              o_manuRiskLevel(dt,ild,resC,manualRisk),o_ResCleared_TP(dt,ild,resC)
6697              o_EffectiveRes_TP(dt,ild,resC,manualRisk)
6698              o_ResViolation_TP(dt,ild,resC)
6699              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6700      ) ;
6701   
6702      loop( (o,riskC) $ { HVDCsecRisk(riskC)
6703                      and ( o_genHVDCriskLevel(dt,ild,o,resC,riskC) > 0 )
6704                      and ( abs[ o_genHVDCriskLevel(dt,ild,o,resC,riskC)
6705                               - o_ReserveReqd_TP(dt,ild,resC)
6706                               ] <= ZeroTolerance )
6707                        },
6708          put dt.tl, ild.tl, resC.tl, o.tl, riskC.tl
6709              o_GenHVDCRiskLevel(dt,ild,o, resC,riskC)
6710              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
6711              o_ResViolation_TP(dt,ild,resC)
6712              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6713      ) ;
6714   
6715      loop( (o,riskC) $ { HVDCsecRisk(riskC)
6716                      and ( o_manuHVDCriskLevel(dt,ild,resC,riskC) > 0 )
6717                      and ( abs[ o_manuHVDCriskLevel(dt,ild,resC,riskC)
6718                               - o_ReserveReqd_TP(dt,ild,resC)
6719                               ] <= ZeroTolerance )
6720                        },
6721          put dt.tl, ild.tl, resC.tl, 'Manual', riskC.tl
6722              o_manuHVDCriskLevel(dt,ild,resC,riskC)
6723              o_ResCleared_TP(dt,ild,resC), o_EffectiveRes_TP(dt,ild,resC,riskC)
6724              o_ResViolation_TP(dt,ild,resC)
6725              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6726          ) ;
6727   
6728  *   Ensure still reporting for conditions with zero FIR and/or SIR required
6729      if( (o_ReserveReqd_TP(dt,ild,resC) = 0) ,
6730          put dt.tl, ild.tl, resC.tl, ' ', ' ', ' '
6731              o_ResCleared_TP(dt,ild,resC), o_ResViolation_TP(dt,ild,resC)
6732              o_ResPrice_TP(dt,ild,resC), o_vrResMW_TP(dt,ild,resC) / ;
6733      ) ;
6734  ) ;
6735   
6736  * Audit - objective result
6737  File objResults_Audit /"C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_Audit_ObjResults.csv"/;
6738  objResults_Audit.pc = 5 ;
6739  objResults_Audit.lw = 0 ;
6740  objResults_Audit.pw = 9999 ;
6741  objResults_Audit.ap = 1 ;
6742  objResults_Audit.nd = 5 ;
6743  objResults_Audit.nw = 20 ;
6744  put objResults_Audit
6745  loop( dt,
6746      put dt.tl, o_ofv_TP(dt) /
6747  ) ;
6748   
6749   
6750  execute_unload 'C:\vSPD\GitHub\Programs\..\Output\\RTD_20211202_RTP\RTD_20211202_RTP_AllData.gdx' ;
6752  *===============================================================================
6753  *execute_unload '%outputPath%\%runName%\%vSPDinputData%_AllData.gdx' ;
6754   
6755   
6756   
6757   
6759   
6760   
6761  * Post a progress message for use by EMI.
6762  putclose runlog 'Case: RTD_20211202_RTP is complete in ',timeExec,'(secs)'/ ;
6763  putclose runlog 'Case: RTD_20211202_RTP is finished in ',timeElapsed,'(secs)'/ ;
6764   
6765  * Go to the next input file
6767   
6768  * Post a progress message for use by EMI.
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/13/22 18:06:25 Page 4
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\vSPD\GitHub\Programs\vSPDsolve.gms
     2     2728 INCLUDE        1      64  .C:\vSPD\GitHub\Programs\vSPDsettings.inc
     3     2783 INCLUDE        1      65  .C:\vSPD\GitHub\Programs\vSPDcase.inc
     4     3180 IF EXIST       1     459  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     5     3186 GDXIN          1     465  C:\vSPD\GitHub\Programs\vSPDPeriod.gdx
     6     3192 GDXIN          1     471  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     7     3216 GDXIN          1     495  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx
     8     3470 IF EXIST       1     749  C:\vSPD\GitHub\Override\.gdx
     9     6337 INCLUDE        1    3828  .C:\vSPD\GitHub\Programs\vSPDreport.gms
    10     6411 IF EXIST       9      74  .C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv
    11     6769 IF EXIST       1    3840  C:\vSPD\GitHub\Input\RTD_20211202_RTP.gdx


COMPILATION TIME     =        0.031 SECONDS      4 MB  36.2.0 r433180e WEX-WEI
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/13/22 18:06:25 Page 5
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Model Statistics    SOLVE vSPD_NMIR Using MIP From line 4906


LOOPS                            FOR/WHILE   1
                                        tp   02-DEC-2021 13:25


MODEL STATISTICS

BLOCKS OF EQUATIONS          91     SINGLE EQUATIONS       31,844
BLOCKS OF VARIABLES          67     SINGLE VARIABLES       43,141
NON ZERO ELEMENTS        93,793     DISCRETE VARIABLES         14


GENERATION TIME      =        0.078 SECONDS     24 MB  36.2.0 r433180e WEX-WEI
               L O O P S          FOR/WHILE 1
                                         tp 02-DEC-2021 13:25

GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/13/22 18:06:25 Page 6
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Solution Report     SOLVE vSPD_NMIR Using MIP From line 4906


               S O L V E      S U M M A R Y

     MODEL   vSPD_NMIR           OBJECTIVE  NETBENEFIT
     TYPE    MIP                 DIRECTION  MAXIMIZE
     SOLVER  CPLEX               FROM LINE  4906

**** SOLVER STATUS     1 Normal Completion
**** MODEL STATUS      1 Optimal
**** OBJECTIVE VALUE            -8240.6224

 RESOURCE USAGE, LIMIT          1.047      3600.000
 ITERATION COUNT, LIMIT      7170    2000000000
--- GAMS/Cplex Link licensed for continuous and discrete problems.

Reading parameter(s) from "C:\vSPD\GitHub\Programs\cplex.opt"
>>  epint = 1e-9
Finished reading from "C:\vSPD\GitHub\Programs\cplex.opt"

--- GMO setup time: 0.00s
--- Space for names approximately 5.25 Mb
--- Use option 'names no' to turn use of names off
--- GMO memory 13.12 Mb (peak 13.45 Mb)
--- Dictionary memory 0.00 Mb
--- Cplex 20.1.0.1 link memory 1.19 Mb (peak 8.40 Mb)
--- Starting Cplex


--- MIP status (101): integer optimal solution.
--- Cplex Time: 0.70sec (det. 834.70 ticks)

--- Fixing integer variables and solving final LP...


--- Fixed MIP status (1): optimal.
--- Cplex Time: 0.25sec (det. 274.99 ticks)


Proven optimal solution
MIP Solution:        -8240.622360    (7170 iterations, 6 nodes)
Final Solve:         -8240.622360    (3350 iterations)

Best possible:       -8240.622360
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
                             1  PROJECTED
GAMS 36.2.0  r433180e Released Sep  3, 2021 WEX-WEI x86 64bit/MS Windows - 01/13/22 18:06:25 Page 7
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
E x e c u t i o n


**** REPORT FILE SUMMARY

runlog C:\vSPD\GitHub\Programs\ProgressReport.txt
temp C:\vSPD\GitHub\Programs\temp.put
SystemResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_SystemResults.csv
OfferResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults.csv
TraderResults C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_TraderResults.csv
SummaryResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_SummaryResults_TP.csv
IslandResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_IslandResults_TP.csv
BusResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BusResults_TP.csv
NodeResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_NodeResults_TP.csv
OfferResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_OfferResults_TP.csv
ReserveResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_ReserveResults_TP.csv
BranchResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BranchResults_TP.csv
BrCstrResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_BrConstraintResults_TP.csv
MnodeCstrResults_TP C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_MnodeConstraintResults_TP.csv
branchLoss_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchLoss.csv
busResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BusResults.csv
MNodeResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_MNodeResults.csv
brchResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_BranchResults.csv
riskResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_RiskResults.csv
objResults_Audit C:\vSPD\GitHub\Output\RTD_20211202_RTP\RTD_20211202_RTP_Audit_ObjResults.csv


EXECUTION TIME       =        2.031 SECONDS     30 MB  36.2.0 r433180e WEX-WEI


USER: Single User License, Phil Bishop               G200929/0001CS-WIN
      Electricity Authority - Te Mana Hiko                    DC5643-S1


**** FILE SUMMARY

Restart    C:\vSPD\GitHub\Programs\vSPDmodel.g00
Input      C:\vSPD\GitHub\Programs\vSPDsolve.gms
Output     C:\vSPD\GitHub\Programs\vSPDsolve.lst
